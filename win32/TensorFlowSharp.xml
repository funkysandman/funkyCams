<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TensorFlowSharp</name>
    </assembly>
    <members>
        <member name="T:TensorFlow.MonoPInvokeCallbackAttribute">
            <summary>
            This attribute can be applied to callback functions that will be invoked
            from unmanaged code to managed code.
            </summary>
            <remarks>
            <code>
            [TensorFlow.MonoPInvokeCallback (typeof (BufferReleaseFunc))]
            internal static void MyFreeFunc (IntPtr data, IntPtr length){..}
            </code>
            </remarks>
        </member>
        <member name="M:TensorFlow.MonoPInvokeCallbackAttribute.#ctor(System.Type)">
            <summary>
            Use this constructor to annotate the type of the callback function that 
            will be invoked from unmanaged code.
            </summary>
            <param name="t">T.</param>
        </member>
        <member name="T:TensorFlow.TFBuffer">
            <summary>
            Holds a block of data, suitable to pass, or retrieve from TensorFlow.
            </summary>
            <remarks>
            <para>
            Use the TFBuffer to blobs of data into TensorFlow, or to retrieve blocks
            of data out of TensorFlow.
            </para>
            <para>
            There are two constructors to wrap existing data, one to wrap blocks that are 
            pointed to by an IntPtr and one that takes a byte array that we want to wrap.
            </para>
            <para>
            The empty constructor can be used to create a new TFBuffer that can be populated
            by the TensorFlow library and returned to user code.
            </para>
            <para>
            Typically, the data consists of a serialized protocol buffer, but other data
            may also be held in a buffer.
            </para>
            </remarks>
        </member>
        <member name="M:TensorFlow.TFBuffer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TensorFlow.TFBuffer"/> class.
            </summary>
        </member>
        <member name="T:TensorFlow.TFBuffer.BufferReleaseFunc">
            <summary>
            Signature of the method that is invoked to release the data.  
            </summary>
            <remarks>
            Methods of this signature are invoked with the data pointer and the
            lenght pointer when then TFBuffer no longer needs to hold on to the
            data.  If you are using this on platforms with static compilation
            like iOS, you need to annotate your callback with the MonoPInvokeCallbackAttribute,
            like this:
            
            <code>
            [TensorFlow.MonoPInvokeCallback (typeof (BufferReleaseFunc))]
            internal static void MyFreeFunc (IntPtr data, IntPtr length){..}
            </code>
            </remarks>
        </member>
        <member name="M:TensorFlow.TFBuffer.#ctor(System.IntPtr,System.Int64,TensorFlow.TFBuffer.BufferReleaseFunc)">
            <summary>
            Initializes a new instance of the <see cref="T:TensorFlow.TFBuffer"/> by wrapping the unmanaged resource pointed by the buffer.
            </summary>
            <param name="buffer">Pointer to the data that will be wrapped.</param>
            <param name="size">The size of the buffer to wrap.</param>
            <param name="release">Optional, if not null, this method will be invoked to release the block.</param>
            <remarks>
            This constructor wraps the buffer as a the data to be held by the <see cref="T:TensorFlow.TFBuffer"/>,
            if the release parameter is null, then you must ensure that the data is not released before the TFBuffer
            is no longer in use.   If the value is not null, the provided method will be invoked to release
            the data when the TFBuffer is disposed, or the contents of the buffer replaced.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFBuffer.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:TensorFlow.TFBuffer"/> by making a copy of the provided byte array.
            </summary>
            <param name="buffer">Buffer of data that will be wrapped.</param>
            <remarks>
            This constructor makes a copy of the data into an unmanaged buffer, 
            so the byte array is not pinned.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFBuffer.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:TensorFlow.TFBuffer"/> by making a copy of the provided byte array.
            </summary>
            <param name="buffer">Buffer of data that will be wrapped.</param>
            <param name="start">Starting offset into the buffer to wrap.</param>
            <param name="count">Number of bytes from the buffer to keep.</param>
            <remarks>
            This constructor makes a copy of the data into an unmanaged buffer, 
            so the byte array is not pinned.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFBuffer.ToArray">
            <summary>
            Returns a byte array representing the data wrapped by this buffer.
            </summary>
            <returns>The array.</returns>
        </member>
        <member name="T:TensorFlow.TFGraph">
            <summary>
            Represents a computation graph.  Graphs may be shared between sessions and are thread safe.
            </summary>
            <remarks>
            <para>
            Graphs consist of operations (represented by TFOperation objects), these can be named, or 
            the runtime will automatically assign a name.
            </para> 
            <para>
            For debugging purposes, you might want to group operations together, for this, call the
            WithScope method with your new scope, which will create a new namespace for your object names.
            </para>
            <para>
            For example, if you call WithScope ("demo"), and add an operation named "add" inside the
            scope, the full name of the operation will be "demo/add", if you create a new scope inside, say
            "hot", and add a "sub" operation there the result will be "demo/hot/sub".
            </para>
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Abort(System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
              Raise a exception to abort the process when called.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Abort'.
            </param>
            <param name="error_msg">
              Optional argument
              A string which is the message associated with the exception.
            </param>
            <param name="exit_without_error">
              Optional argument
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              If exit_without_error is true, the process will exit normally,
              otherwise it will exit with a SIGABORT signal.
              
              Returns nothing but an exception.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Abs(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the absolute value of a tensor.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Abs'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a tensor `x`, this operation returns a tensor containing the absolute
              value of each element in `x`. For example, if x is an input element and y is
              an output element, this operation computes \\(y = |x|\\).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AccumulateNV2(TensorFlow.TFOutput[],TensorFlow.TFShape,System.String)">
            <summary>
              Returns the element-wise sum of a list of tensors.
            </summary>
            <param name="inputs">
              A list of `Tensor` objects, each with same shape and type.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulateNV2'.
            </param>
            <param name="shape">
              Shape of elements of `inputs`.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `tf.accumulate_n_v2` performs the same operation as `tf.add_n`, but does not
              wait for all of its inputs to be ready before beginning to sum. This can
              save memory if inputs are ready at different times, since minimum temporary
              storage is proportional to the output size rather than the inputs size.
              
              Unlike the original `accumulate_n`, `accumulate_n_v2` is differentiable.
              
              Returns a `Tensor` of same shape and type as the elements of `inputs`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AccumulatorApplyGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Applies a gradient to a given accumulator.
            </summary>
            <param name="handle">
              The handle to a accumulator.
            </param>
            <param name="local_step">
              The local_step value at which the gradient was computed.
            </param>
            <param name="gradient">
              A tensor of the gradient to be accumulated.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorApplyGradient'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              Does not add if local_step is lesser than the accumulator's global_step.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AccumulatorNumAccumulated(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the number of gradients aggregated in the given accumulators.
            </summary>
            <param name="handle">
              The handle to an accumulator.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorNumAccumulated'.
            </param>
            <returns>
              The number of gradients aggregated in the given accumulator.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.AccumulatorSetGlobalStep(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Updates the accumulator with a new value for global_step.
            </summary>
            <param name="handle">
              The handle to an accumulator.
            </param>
            <param name="new_global_step">
              The new global_step value to set.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorSetGlobalStep'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              Logs warning if the accumulator's value is already higher than
              new_global_step.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AccumulatorTakeGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Extracts the average gradient in the given ConditionalAccumulator.
            </summary>
            <param name="handle">
              The handle to an accumulator.
            </param>
            <param name="num_required">
              Number of gradients required before we return an aggregate.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorTakeGradient'.
            </param>
            <param name="dtype">
              The data type of accumulated gradients. Needs to correspond to the type
              of the accumulator.
            </param>
            <returns>
              The average of the accumulated gradients.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The op blocks until sufficient (i.e., more than num_required)
              gradients have been accumulated.  If the accumulator has already
              aggregated more than num_required gradients, it returns the average of
              the accumulated gradients.  Also automatically increments the recorded
              global_step in the accumulator by 1, and resets the aggregate to 0.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Acos(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes acos of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Acos'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Acosh(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes inverse hyperbolic cosine of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Acosh'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Add(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns x + y element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Add'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `Add` supports broadcasting. `AddN` does not. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AddManySparseToTensorsMap(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)">
            <summary>
              Add an `N`-minibatch `SparseTensor` to a `SparseTensorsMap`, return `N` handles.
            </summary>
            <param name="sparse_indices">
              2-D.  The `indices` of the minibatch `SparseTensor`.
              `sparse_indices[:, 0]` must be ordered values in `[0, N)`.
            </param>
            <param name="sparse_values">
              1-D.  The `values` of the minibatch `SparseTensor`.
            </param>
            <param name="sparse_shape">
              1-D.  The `shape` of the minibatch `SparseTensor`.
              The minibatch size `N == sparse_shape[0]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AddManySparseToTensorsMap'.
            </param>
            <param name="container">
              Optional argument
              The container name for the `SparseTensorsMap` created by this op.
            </param>
            <param name="shared_name">
              Optional argument
              The shared name for the `SparseTensorsMap` created by this op.
              If blank, the new Operation's unique name is used.
            </param>
            <returns>
              1-D.  The handles of the `SparseTensor` now stored in the
              `SparseTensorsMap`.  Shape: `[N]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              A `SparseTensor` of rank `R` is represented by three tensors: `sparse_indices`,
              `sparse_values`, and `sparse_shape`, where
              
              ```sparse_indices.shape[1] == sparse_shape.shape[0] == R```
              
              An `N`-minibatch of `SparseTensor` objects is represented as a `SparseTensor`
              having a first `sparse_indices` column taking values between `[0, N)`, where
              the minibatch size `N == sparse_shape[0]`.
              
              The input `SparseTensor` must have rank `R` greater than 1, and the first
              dimension is treated as the minibatch dimension.  Elements of the `SparseTensor`
              must be sorted in increasing order of this first dimension.  The stored
              `SparseTensor` objects pointed to by each row of the output `sparse_handles`
              will have rank `R-1`.
              
              The `SparseTensor` values can then be read out as part of a minibatch by passing
              the given keys as vector elements to `TakeManySparseFromTensorsMap`.  To ensure
              the correct `SparseTensorsMap` is accessed, ensure that the same
              `container` and `shared_name` are passed to that Op.  If no `shared_name`
              is provided here, instead use the *name* of the Operation created by calling
              `AddManySparseToTensorsMap` as the `shared_name` passed to
              `TakeManySparseFromTensorsMap`.  Ensure the Operations are colocated.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AddN(TensorFlow.TFOutput[],System.String)">
            <summary>
              Add all input tensors element wise.
            </summary>
            <param name="inputs">
              Must all be the same size and shape.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AddN'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.AddSparseToTensorsMap(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)">
            <summary>
              Add a `SparseTensor` to a `SparseTensorsMap` return its handle.
            </summary>
            <param name="sparse_indices">
              2-D.  The `indices` of the `SparseTensor`.
            </param>
            <param name="sparse_values">
              1-D.  The `values` of the `SparseTensor`.
            </param>
            <param name="sparse_shape">
              1-D.  The `shape` of the `SparseTensor`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AddSparseToTensorsMap'.
            </param>
            <param name="container">
              Optional argument
              The container name for the `SparseTensorsMap` created by this op.
            </param>
            <param name="shared_name">
              Optional argument
              The shared name for the `SparseTensorsMap` created by this op.
              If blank, the new Operation's unique name is used.
            </param>
            <returns>
              0-D.  The handle of the `SparseTensor` now stored in the
              `SparseTensorsMap`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              A `SparseTensor` is represented by three tensors: `sparse_indices`,
              `sparse_values`, and `sparse_shape`.
              
              This operator takes the given `SparseTensor` and adds it to a container
              object (a `SparseTensorsMap`).  A unique key within this container is generated
              in the form of an `int64`, and this is the value that is returned.
              
              The `SparseTensor` can then be read out as part of a minibatch by passing
              the key as a vector element to `TakeManySparseFromTensorsMap`.  To ensure
              the correct `SparseTensorsMap` is accessed, ensure that the same
              `container` and `shared_name` are passed to that Op.  If no `shared_name`
              is provided here, instead use the *name* of the Operation created by calling
              `AddSparseToTensorsMap` as the `shared_name` passed to
              `TakeManySparseFromTensorsMap`.  Ensure the Operations are colocated.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AddV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns x + y element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AddV2'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `Add` supports broadcasting. `AddN` does not. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AdjustContrast(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Deprecated. Disallowed in GraphDef version &amp;gt;= 2.
            </summary>
            <param name="images">
            </param>
            <param name="contrast_factor">
            </param>
            <param name="min_value">
            </param>
            <param name="max_value">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustContrast'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.AdjustContrastv2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Adjust the contrast of one or more images.
            </summary>
            <param name="images">
              Images to adjust.  At least 3-D.
            </param>
            <param name="contrast_factor">
              A float multiplier for adjusting contrast.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustContrastv2'.
            </param>
            <returns>
              The contrast-adjusted image or images.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `images` is a tensor of at least 3 dimensions.  The last 3 dimensions are
              interpreted as `[height, width, channels]`.  The other dimensions only
              represent a collection of images, such as `[batch, height, width, channels].`
              
              Contrast is adjusted independently for each channel of each image.
              
              For each channel, the Op first computes the mean of the image pixels in the
              channel and then adjusts each component of each pixel to
              `(x - mean) * contrast_factor + mean`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AdjustHue(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Adjust the hue of one or more images.
            </summary>
            <param name="images">
              Images to adjust.  At least 3-D.
            </param>
            <param name="delta">
              A float delta to add to the hue.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustHue'.
            </param>
            <returns>
              The hue-adjusted image or images.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `images` is a tensor of at least 3 dimensions.  The last dimension is
              interpretted as channels, and must be three.
              
              The input image is considered in the RGB colorspace. Conceptually, the RGB
              colors are first mapped into HSV. A delta is then applied all the hue values,
              and then remapped back to RGB colorspace.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AdjustSaturation(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Adjust the saturation of one or more images.
            </summary>
            <param name="images">
              Images to adjust.  At least 3-D.
            </param>
            <param name="scale">
              A float scale to add to the saturation.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustSaturation'.
            </param>
            <returns>
              The hue-adjusted image or images.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `images` is a tensor of at least 3 dimensions.  The last dimension is
              interpretted as channels, and must be three.
              
              The input image is considered in the RGB colorspace. Conceptually, the RGB
              colors are first mapped into HSV. A scale is then applied all the saturation
              values, and then remapped back to RGB colorspace.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.All(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the "logical and" of elements across dimensions of a tensor.
            </summary>
            <param name="input">
              The tensor to reduce.
            </param>
            <param name="reduction_indices">
              The dimensions to reduce. Must be in the range
              `[-rank(input), rank(input))`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'All'.
            </param>
            <param name="keep_dims">
              Optional argument
              If true, retain reduced dimensions with length 1.
            </param>
            <returns>
              The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Reduces `input` along the dimensions given in `reduction_indices`. Unless
              `keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
              `reduction_indices`. If `keep_dims` is true, the reduced dimensions are
              retained with length 1.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AllCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Generates labels for candidate sampling with a learned unigram distribution.
            </summary>
            <param name="true_classes">
              A batch_size * num_true matrix, in which each row contains the
              IDs of the num_true target_classes in the corresponding original label.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AllCandidateSampler'.
            </param>
            <param name="seed">
              Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              An second seed to avoid seed collision.
            </param>
            <param name="num_true">
              Number of true labels per context.
            </param>
            <param name="num_sampled">
              Number of candidates to produce.
            </param>
            <param name="unique">
              If unique is true, we sample with rejection, so that all sampled
              candidates in a batch are unique. This requires some approximation to
              estimate the post-rejection sampling probabilities.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              sampled_candidates: A vector of length num_sampled, in which each element is
              the ID of a sampled candidate.
              true_expected_count: A batch_size * num_true matrix, representing
              the number of times each candidate is expected to occur in a batch
              of sampled candidates. If unique=true, then this is a probability.
              sampled_expected_count: A vector of length num_sampled, for each sampled
              candidate representing the number of times the candidate is expected
              to occur in a batch of sampled candidates.  If unique=true, then this is a
              probability.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              See explanations of candidate sampling and the data formats at
              go/candidate-sampling.
              
              For each batch, this op picks a single set of sampled candidate labels.
              
              The advantages of sampling candidates per-batch are simplicity and the
              possibility of efficient dense matrix multiplication. The disadvantage is that
              the sampled candidates must be chosen independently of the context and of the
              true labels.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Angle(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Returns the argument of a complex number.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Angle'.
            </param>
            <param name="Tout">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a tensor `input` of complex numbers, this operation returns a tensor of
              type `float` that is the argument of each element in `input`. All elements in
              `input` must be complex numbers of the form \\(a + bj\\), where *a*
              is the real part and *b* is the imaginary part.
              
              The argument returned by this operation is of the form \\(atan2(b, a)\\).
              
              For example:
              
              ```
              # tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]
              tf.angle(input) ==&amp;gt; [2.0132, 1.056]
              ```
              
              @compatibility(numpy)
              Equivalent to np.angle.
              @end_compatibility
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Any(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the "logical or" of elements across dimensions of a tensor.
            </summary>
            <param name="input">
              The tensor to reduce.
            </param>
            <param name="reduction_indices">
              The dimensions to reduce. Must be in the range
              `[-rank(input), rank(input))`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Any'.
            </param>
            <param name="keep_dims">
              Optional argument
              If true, retain reduced dimensions with length 1.
            </param>
            <returns>
              The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Reduces `input` along the dimensions given in `reduction_indices`. Unless
              `keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
              `reduction_indices`. If `keep_dims` is true, the reduced dimensions are
              retained with length 1.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the adadelta scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="accum_update">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="rho">
              Decay factor. Must be a scalar.
            </param>
            <param name="epsilon">
              Constant factor. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdadelta'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, updating of the var, accum and update_accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              accum = rho() * accum + (1 - rho()) * grad.square();
              update = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;
              update_accum = rho() * update_accum + (1 - rho()) * update.square();
              var -= update;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the adagrad scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdagrad'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              accum += grad * grad
              var -= lr * grad * (1 / sqrt(accum))
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the proximal adagrad scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="gradient_accumulator">
              Should be from a Variable().
            </param>
            <param name="gradient_squared_accumulator">
              Should be from a Variable().
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="global_step">
              Training step number. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdagradDA'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyAdam(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the Adam algorithm.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="m">
              Should be from a Variable().
            </param>
            <param name="v">
              Should be from a Variable().
            </param>
            <param name="beta1_power">
              Must be a scalar.
            </param>
            <param name="beta2_power">
              Must be a scalar.
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="beta1">
              Momentum factor. Must be a scalar.
            </param>
            <param name="beta2">
              Momentum factor. Must be a scalar.
            </param>
            <param name="epsilon">
              Ridge term. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdam'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var, m, and v tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <param name="use_nesterov">
              Optional argument
              If `True`, uses the nesterov update.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              lr_t &amp;lt;- learning_rate * sqrt(1 - beta2^t) / (1 - beta1^t)
              m_t &amp;lt;- beta1 * m_{t-1} + (1 - beta1) * g_t
              v_t &amp;lt;- beta2 * v_{t-1} + (1 - beta2) * g_t * g_t
              variable &amp;lt;- variable - lr_t * m_t / (sqrt(v_t) + epsilon)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyAddSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the AddSign update.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="m">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="alpha">
              Must be a scalar.
            </param>
            <param name="sign_decay">
              Must be a scalar.
            </param>
            <param name="beta">
              Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAddSign'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and m tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              m_t &amp;lt;- beta1 * m_{t-1} + (1 - beta1) * g
              update &amp;lt;- (alpha + sign_decay * sign(g) *sign(m)) * g
              variable &amp;lt;- variable - lr_t * update
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the centered RMSProp algorithm.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="mg">
              Should be from a Variable().
            </param>
            <param name="ms">
              Should be from a Variable().
            </param>
            <param name="mom">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="rho">
              Decay rate. Must be a scalar.
            </param>
            <param name="momentum">
            </param>
            <param name="epsilon">
              Ridge term. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyCenteredRMSProp'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var, mg, ms, and mom tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The centered RMSProp algorithm uses an estimate of the centered second moment
              (i.e., the variance) for normalization, as opposed to regular RMSProp, which
              uses the (uncentered) second moment. This often helps with training, but is
              slightly more expensive in terms of computation and memory.
              
              Note that in dense implementation of this algorithm, mg, ms, and mom will
              update even if the grad is zero, but in this sparse implementation, mg, ms,
              and mom will not update in iterations during which the grad is zero.
              
              mean_square = decay * mean_square + (1-decay) * gradient ** 2
              mean_grad = decay * mean_grad + (1-decay) * gradient
              
              Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)
              
              mg &amp;lt;- rho * mg_{t-1} + (1-rho) * grad
              ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
              mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)
              var &amp;lt;- var - mom
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="linear">
              Should be from a Variable().
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regulariation. Must be a scalar.
            </param>
            <param name="l2">
              L2 regulariation. Must be a scalar.
            </param>
            <param name="lr_power">
              Scaling factor. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyFtrl'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              accum_new = accum + grad * grad
              linear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
              accum = accum_new
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="linear">
              Should be from a Variable().
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regulariation. Must be a scalar.
            </param>
            <param name="l2">
              L2 shrinkage regulariation. Must be a scalar.
            </param>
            <param name="l2_shrinkage">
            </param>
            <param name="lr_power">
              Scaling factor. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyFtrlV2'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              grad_with_shrinkage = grad + 2 * l2_shrinkage * var
              accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
              linear += grad_with_shrinkage +
                  (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
              accum = accum_new
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' by subtracting 'alpha' * 'delta' from it.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="alpha">
              Scaling factor. Must be a scalar.
            </param>
            <param name="delta">
              The change.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyGradientDescent'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the momentum scheme. Set use_nesterov = True if you
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="momentum">
              Momentum. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyMomentum'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <param name="use_nesterov">
              Optional argument
              If `True`, the tensor passed to compute grad will be
              var - lr * momentum * accum, so in the end, the var you get is actually
              var - lr * momentum * accum.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              want to use Nesterov momentum.
              
              accum = accum * momentum + grad
              var -= lr * accum
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyPowerSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the AddSign update.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="m">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="logbase">
              Must be a scalar.
            </param>
            <param name="sign_decay">
              Must be a scalar.
            </param>
            <param name="beta">
              Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyPowerSign'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and m tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              m_t &amp;lt;- beta1 * m_{t-1} + (1 - beta1) * g
              update &amp;lt;- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g
              variable &amp;lt;- variable - lr_t * update
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyProximalAdagrad'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              accum += grad * grad
              prox_v = var - lr * grad * (1 / sqrt(accum))
              var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' as FOBOS algorithm with fixed learning rate.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="alpha">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="delta">
              The change.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyProximalGradientDescent'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              prox_v = var - alpha * delta
              var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the RMSProp algorithm.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="ms">
              Should be from a Variable().
            </param>
            <param name="mom">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="rho">
              Decay rate. Must be a scalar.
            </param>
            <param name="momentum">
            </param>
            <param name="epsilon">
              Ridge term. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyRMSProp'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var, ms, and mom tensors is protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Note that in dense implementation of this algorithm, ms and mom will
              update even if the grad is zero, but in this sparse implementation, ms
              and mom will not update in iterations during which the grad is zero.
              
              mean_square = decay * mean_square + (1-decay) * gradient ** 2
              Delta = learning_rate * gradient / sqrt(mean_square + epsilon)
              
              ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
              mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
              var &amp;lt;- var - mom
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ApproximateEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String)">
            <summary>
              Returns the truth value of abs(x-y) &amp;lt; tolerance element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ApproximateEqual'.
            </param>
            <param name="tolerance">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ArgMax(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Returns the index with the largest value across dimensions of a tensor.
            </summary>
            <param name="input">
            </param>
            <param name="dimension">
              int32 or int64, must be in the range `[-rank(input), rank(input))`.
              Describes which dimension of the input Tensor to reduce across. For vectors,
              use dimension = 0.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ArgMax'.
            </param>
            <param name="output_type">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Note that in case of ties the identity of the return value is not guaranteed.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ArgMin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Returns the index with the smallest value across dimensions of a tensor.
            </summary>
            <param name="input">
            </param>
            <param name="dimension">
              int32 or int64, must be in the range `[-rank(input), rank(input))`.
              Describes which dimension of the input Tensor to reduce across. For vectors,
              use dimension = 0.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ArgMin'.
            </param>
            <param name="output_type">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Note that in case of ties the identity of the return value is not guaranteed.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Asin(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes asin of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Asin'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Asinh(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes inverse hyperbolic sine of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Asinh'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Assert(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">
            <summary>
              Asserts that the given condition is true.
            </summary>
            <param name="condition">
              The condition to evaluate.
            </param>
            <param name="data">
              The tensors to print out when condition is false.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Assert'.
            </param>
            <param name="summarize">
              Optional argument
              Print this many entries of each tensor.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              If `condition` evaluates to false, print the list of tensors in `data`.
              `summarize` determines how many entries of the tensors to print.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Assign(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Update 'ref' by assigning 'value' to it.
            </summary>
            <param name="reference">
              Should be from a `Variable` node. May be uninitialized.
            </param>
            <param name="value">
              The value to be assigned to the variable.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Assign'.
            </param>
            <param name="validate_shape">
              Optional argument
              If true, the operation will validate that the shape
              of 'value' matches the shape of the Tensor being assigned to.  If false,
              'ref' will take on the shape of 'value'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, the assignment will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              = Same as "ref".  Returned as a convenience for operations that want
              to use the new value after the variable has been reset.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation outputs "ref" after the assignment is done.
              This makes it easier to chain operations that need to use the reset value.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AssignAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update 'ref' by adding 'value' to it.
            </summary>
            <param name="reference">
              Should be from a `Variable` node.
            </param>
            <param name="value">
              The value to be added to the variable.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignAdd'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, the addition will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              = Same as "ref".  Returned as a convenience for operations that want
              to use the new value after the variable has been updated.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation outputs "ref" after the update is done.
              This makes it easier to chain operations that need to use the reset value.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AssignAddVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Adds a value to the current value of a variable.
            </summary>
            <param name="resource">
              handle to the resource in which to store the variable.
            </param>
            <param name="value">
              the value by which the variable will be incremented.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignAddVariableOp'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              Any ReadVariableOp which depends directly or indirectly on this assign is
              guaranteed to see the incremented value or a subsequent newer one.
              
              Outputs the incremented value, which can be used to totally order the
              increments to this variable.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AssignSub(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update 'ref' by subtracting 'value' from it.
            </summary>
            <param name="reference">
              Should be from a `Variable` node.
            </param>
            <param name="value">
              The value to be subtracted to the variable.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignSub'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              = Same as "ref".  Returned as a convenience for operations that want
              to use the new value after the variable has been updated.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation outputs "ref" after the update is done.
              This makes it easier to chain operations that need to use the reset value.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AssignSubVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Subtracts a value from the current value of a variable.
            </summary>
            <param name="resource">
              handle to the resource in which to store the variable.
            </param>
            <param name="value">
              the value by which the variable will be incremented.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignSubVariableOp'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              Any ReadVariableOp which depends directly or indirectly on this assign is
              guaranteed to see the incremented value or a subsequent newer one.
              
              Outputs the incremented value, which can be used to totally order the
              increments to this variable.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AssignVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Assigns a new value to a variable.
            </summary>
            <param name="resource">
              handle to the resource in which to store the variable.
            </param>
            <param name="value">
              the value to set the new tensor to use.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignVariableOp'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              Any ReadVariableOp with a control dependency on this op is guaranteed to return
              this value or a subsequent newer value of the variable.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AsString(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String,System.String)">
            <summary>
              Converts each entry in the given tensor to strings.  Supports many numeric
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AsString'.
            </param>
            <param name="precision">
              Optional argument
              The post-decimal precision to use for floating point numbers.
              Only used if precision &amp;gt; -1.
            </param>
            <param name="scientific">
              Optional argument
              Use scientific notation for floating point numbers.
            </param>
            <param name="shortest">
              Optional argument
              Use shortest representation (either scientific or standard) for
              floating point numbers.
            </param>
            <param name="width">
              Optional argument
              Pad pre-decimal numbers to this width.
              Applies to both floating point and integer numbers.
              Only used if width &amp;gt; -1.
            </param>
            <param name="fill">
              Optional argument
              The value to pad if width &amp;gt; -1.  If empty, pads with spaces.
              Another typical value is '0'.  String cannot be longer than 1 character.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              types and boolean.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Atan(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes atan of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Atan'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Atan2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes arctangent of `y/x` element-wise, respecting signs of the arguments.
            </summary>
            <param name="y">
            </param>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Atan2'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This is the angle \( \theta \in [-\pi, \pi] \) such that
              \[ x = r \cos(\theta) \]
              and
              \[ y = r \sin(\theta) \]
              where \(r = \sqrt(x^2 + y^2) \).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Atanh(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes inverse hyperbolic tangent of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Atanh'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.AudioSpectrogram(TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)">
            <summary>
              Produces a visualization of audio data over time.
            </summary>
            <param name="input">
              Float representation of audio data.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AudioSpectrogram'.
            </param>
            <param name="magnitude_squared">
              Optional argument
              Whether to return the squared magnitude or just the
              magnitude. Using squared magnitude can avoid extra calculations.
            </param>
            <param name="window_size">
              How wide the input window is in samples. For the highest efficiency
              this should be a power of two, but other values are accepted.
            </param>
            <param name="stride">
              How widely apart the center of adjacent sample windows should be.
            </param>
            <returns>
              3D representation of the audio frequencies as an image.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Spectrograms are a standard way of representing audio information as a series of
              slices of frequency information, one slice for each window of time. By joining
              these together into a sequence, they form a distinctive fingerprint of the sound
              over time.
              
              This op expects to receive audio data as an input, stored as floats in the range
              -1 to 1, together with a window width in samples, and a stride specifying how
              far to move the window between slices. From this it generates a three
              dimensional output. The lowest dimension has an amplitude value for each
              frequency during that time slice. The next dimension is time, with successive
              frequency slices. The final dimension is for the channels in the input, so a
              stereo audio input would have two here for example.
              
              This means the layout when converted and saved as an image is rotated 90 degrees
              clockwise from a typical spectrogram. Time is descending down the Y axis, and
              the frequency decreases from left to right.
              
              Each value in the result represents the square root of the sum of the real and
              imaginary parts of an FFT on the current window of samples. In this way, the
              lowest dimension represents the power of each frequency in the current window,
              and adjacent windows are concatenated in the next dimension.
              
              To get a more intuitive and visual look at what this operation does, you can run
              tensorflow/examples/wav_to_spectrogram to read in an audio file and save out the
              resulting spectrogram as a PNG image.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AudioSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Nullable{System.Int64},System.String)">
            <summary>
              Outputs a `Summary` protocol buffer with audio.
            </summary>
            <param name="tag">
              Scalar. Used to build the `tag` attribute of the summary values.
            </param>
            <param name="tensor">
              2-D of shape `[batch_size, frames]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AudioSummary'.
            </param>
            <param name="max_outputs">
              Optional argument
              Max number of batch elements to generate audio for.
            </param>
            <param name="sample_rate">
              The sample rate of the signal in hertz.
            </param>
            <returns>
              Scalar. Serialized `Summary` protocol buffer.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The summary has up to `max_outputs` summary values containing audio. The
              audio is built from `tensor` which must be 3-D with shape `[batch_size,
              frames, channels]` or 2-D with shape `[batch_size, frames]`. The values are
              assumed to be in the range of `[-1.0, 1.0]` with a sample rate of `sample_rate`.
              
              The `tag` argument is a scalar `Tensor` of type `string`.  It is used to
              build the `tag` of the summary values:
              
              *  If `max_outputs` is 1, the summary value tag is '*tag*/audio'.
              *  If `max_outputs` is greater than 1, the summary value tags are
                 generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AudioSummaryV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)">
            <summary>
              Outputs a `Summary` protocol buffer with audio.
            </summary>
            <param name="tag">
              Scalar. Used to build the `tag` attribute of the summary values.
            </param>
            <param name="tensor">
              2-D of shape `[batch_size, frames]`.
            </param>
            <param name="sample_rate">
              The sample rate of the signal in hertz.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AudioSummaryV2'.
            </param>
            <param name="max_outputs">
              Optional argument
              Max number of batch elements to generate audio for.
            </param>
            <returns>
              Scalar. Serialized `Summary` protocol buffer.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The summary has up to `max_outputs` summary values containing audio. The
              audio is built from `tensor` which must be 3-D with shape `[batch_size,
              frames, channels]` or 2-D with shape `[batch_size, frames]`. The values are
              assumed to be in the range of `[-1.0, 1.0]` with a sample rate of `sample_rate`.
              
              The `tag` argument is a scalar `Tensor` of type `string`.  It is used to
              build the `tag` of the summary values:
              
              *  If `max_outputs` is 1, the summary value tag is '*tag*/audio'.
              *  If `max_outputs` is greater than 1, the summary value tags are
                 generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AvgPool(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
              Performs average pooling on the input.
            </summary>
            <param name="value">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPool'.
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, in_height, in_width, in_channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, in_channels, in_height, in_width].
            </param>
            <param name="ksize">
              The size of the sliding window for each dimension of `value`.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of `value`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The average pooled output tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Each entry in `output` is the mean of the corresponding size `ksize`
              window in `value`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AvgPool3D(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
              Performs 3D average pooling on the input.
            </summary>
            <param name="input">
              Shape `[batch, depth, rows, cols, channels]` tensor to pool over.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPool3D'.
            </param>
            <param name="data_format">
              Optional argument
              The data format of the input and output data. With the
              default format "NDHWC", the data is stored in the order of:
                  [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be "NCDHW", the data storage order is:
                  [batch, in_channels, in_depth, in_height, in_width].
            </param>
            <param name="ksize">
              1-D tensor of length 5. The size of the window for each dimension of
              the input tensor. Must have `ksize[0] = ksize[4] = 1`.
            </param>
            <param name="strides">
              1-D tensor of length 5. The stride of the sliding window for each
              dimension of `input`. Must have `strides[0] = strides[4] = 1`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The average pooled output tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.AvgPool3DGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
              Computes gradients of average pooling function.
            </summary>
            <param name="orig_input_shape">
              The original input dimensions.
            </param>
            <param name="grad">
              Output backprop of shape `[batch, depth, rows, cols, channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPool3DGrad'.
            </param>
            <param name="data_format">
              Optional argument
              The data format of the input and output data. With the
              default format "NDHWC", the data is stored in the order of:
                  [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be "NCDHW", the data storage order is:
                  [batch, in_channels, in_depth, in_height, in_width].
            </param>
            <param name="ksize">
              1-D tensor of length 5. The size of the window for each dimension of
              the input tensor. Must have `ksize[0] = ksize[4] = 1`.
            </param>
            <param name="strides">
              1-D tensor of length 5. The stride of the sliding window for each
              dimension of `input`. Must have `strides[0] = strides[4] = 1`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The backprop for input.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.AvgPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
              Computes gradients of the average pooling function.
            </summary>
            <param name="orig_input_shape">
              1-D.  Shape of the original input to `avg_pool`.
            </param>
            <param name="grad">
              4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t.
              the output of `avg_pool`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPoolGrad'.
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, in_height, in_width, in_channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, in_channels, in_height, in_width].
            </param>
            <param name="ksize">
              The size of the sliding window for each dimension of the input.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the input.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              4-D.  Gradients w.r.t. the input of `avg_pool`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Barrier(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Defines a barrier that persists across different graph executions.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Barrier'.
            </param>
            <param name="shapes">
              Optional argument
              The shape of each component in a value. Each shape must be 1 in the
              first dimension. The length of this attr must be the same as the length of
              component_types.
            </param>
            <param name="capacity">
              Optional argument
              The capacity of the barrier.  The default capacity is MAX_INT32,
              which is the largest capacity of the underlying queue.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this barrier is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this barrier will be shared under the given name
              across multiple sessions.
            </param>
            <param name="component_types">
              The type of each component in a value.
            </param>
            <returns>
              The handle to the barrier.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              A barrier represents a key-value map, where each key is a string, and
              each value is a tuple of tensors.
              
              At runtime, the barrier contains 'complete' and 'incomplete'
              elements. A complete element has defined tensors for all components of
              its value tuple, and may be accessed using BarrierTakeMany. An
              incomplete element has some undefined components in its value tuple,
              and may be updated using BarrierInsertMany.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BarrierClose(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Closes the given barrier.
            </summary>
            <param name="handle">
              The handle to a barrier.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierClose'.
            </param>
            <param name="cancel_pending_enqueues">
              Optional argument
              If true, all pending enqueue requests that are
              blocked on the barrier's queue will be canceled. InsertMany will fail, even
              if no new key is introduced.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              This operation signals that no more new elements will be inserted in the
              given barrier. Subsequent InsertMany that try to introduce a new key will fail.
              Subsequent InsertMany operations that just add missing components to already
              existing elements will continue to succeed. Subsequent TakeMany operations will
              continue to succeed if sufficient completed elements remain in the barrier.
              Subsequent TakeMany operations that would block will fail immediately.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BarrierIncompleteSize(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the number of incomplete elements in the given barrier.
            </summary>
            <param name="handle">
              The handle to a barrier.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierIncompleteSize'.
            </param>
            <returns>
              The number of incomplete elements (i.e. those with some of their value
              components not set) in the barrier.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.BarrierInsertMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">
            <summary>
              For each key, assigns the respective value to the specified component.
            </summary>
            <param name="handle">
              The handle to a barrier.
            </param>
            <param name="keys">
              A one-dimensional tensor of keys, with length n.
            </param>
            <param name="values">
              An any-dimensional tensor of values, which are associated with the
              respective keys. The 0th dimension must have length n.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierInsertMany'.
            </param>
            <param name="component_index">
              The component of the barrier elements that is being assigned.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              If a key is not found in the barrier, this operation will create a new
              incomplete element. If a key is found in the barrier, and the element
              already has a value at component_index, this operation will fail with
              INVALID_ARGUMENT, and leave the barrier in an undefined state.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BarrierReadySize(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the number of complete elements in the given barrier.
            </summary>
            <param name="handle">
              The handle to a barrier.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierReadySize'.
            </param>
            <returns>
              The number of complete elements (i.e. those with all of their value
              components set) in the barrier.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.BarrierTakeMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)">
            <summary>
              Takes the given number of completed elements from a barrier.
            </summary>
            <param name="handle">
              The handle to a barrier.
            </param>
            <param name="num_elements">
              A single-element tensor containing the number of elements to
              take.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierTakeMany'.
            </param>
            <param name="allow_small_batch">
              Optional argument
              Allow to return less than num_elements items if barrier is
              already closed.
            </param>
            <param name="wait_for_incomplete">
              Optional argument
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is empty, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <param name="component_types">
              The type of each component in a value.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              indices: A one-dimensional tensor of indices, with length num_elems.
              These indices refer to the batch in which the values were placed into the
              barrier (starting with MIN_LONG and increasing with each BarrierInsertMany).
              keys: A one-dimensional tensor of keys, with length num_elements.
              values: One any-dimensional tensor per component in a barrier element. All
              values have length num_elements in the 0th dimension.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              This operation concatenates completed-element component tensors along
              the 0th dimension to make a single component tensor.
              
              Elements come out of the barrier when they are complete, and in the order
              in which they were placed into the barrier.  The indices output provides
              information about the batch in which each element was originally inserted
              into the barrier.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BatchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that batches `batch_size` elements from `input_dataset`.
            </summary>
            <param name="input_dataset">
            </param>
            <param name="batch_size">
              A scalar representing the number of elements to accumulate in a
              batch.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.BatchMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Multiplies slices of two tensors in batches.
            </summary>
            <param name="x">
              2-D or higher with shape `[..., r_x, c_x]`.
            </param>
            <param name="y">
              2-D or higher with shape `[..., r_y, c_y]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatMul'.
            </param>
            <param name="adj_x">
              Optional argument
              If `True`, adjoint the slices of `x`. Defaults to `False`.
            </param>
            <param name="adj_y">
              Optional argument
              If `True`, adjoint the slices of `y`. Defaults to `False`.
            </param>
            <returns>
              3-D or higher with shape `[..., r_o, c_o]`
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Multiplies all slices of `Tensor` `x` and `y` (each slice can be
              viewed as an element of a batch), and arranges the individual results
              in a single output tensor of the same batch size. Each of the
              individual slices can optionally be adjointed (to adjoint a matrix
              means to transpose and conjugate it) before multiplication by setting
              the `adj_x` or `adj_y` flag to `True`, which are by default `False`.
              
              The input tensors `x` and `y` are 2-D or higher with shape `[..., r_x, c_x]`
              and `[..., r_y, c_y]`.
              
              The output tensor is 2-D or higher with shape `[..., r_o, c_o]`, where:
              
                  r_o = c_x if adj_x else r_x
                  c_o = r_y if adj_y else c_y
              
              It is computed as:
              
                  output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BatchNormWithGlobalNormalization(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Boolean,System.String)">
            <summary>
              Batch normalization.
            </summary>
            <param name="t">
              A 4D input Tensor.
            </param>
            <param name="m">
              A 1D mean Tensor with size matching the last dimension of t.
              This is the first output from tf.nn.moments,
              or a saved moving average thereof.
            </param>
            <param name="v">
              A 1D variance Tensor with size matching the last dimension of t.
              This is the second output from tf.nn.moments,
              or a saved moving average thereof.
            </param>
            <param name="beta">
              A 1D beta Tensor with size matching the last dimension of t.
              An offset to be added to the normalized tensor.
            </param>
            <param name="gamma">
              A 1D gamma Tensor with size matching the last dimension of t.
              If "scale_after_normalization" is true, this tensor will be multiplied
              with the normalized tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchNormWithGlobalNormalization'.
            </param>
            <param name="variance_epsilon">
              A small float number to avoid dividing by 0.
            </param>
            <param name="scale_after_normalization">
              A bool indicating whether the resulted tensor
              needs to be multiplied with gamma.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op is deprecated. Prefer `tf.nn.batch_normalization`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BatchNormWithGlobalNormalizationGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Boolean,System.String)">
            <summary>
              Gradients for batch normalization.
            </summary>
            <param name="t">
              A 4D input Tensor.
            </param>
            <param name="m">
              A 1D mean Tensor with size matching the last dimension of t.
              This is the first output from tf.nn.moments,
              or a saved moving average thereof.
            </param>
            <param name="v">
              A 1D variance Tensor with size matching the last dimension of t.
              This is the second output from tf.nn.moments,
              or a saved moving average thereof.
            </param>
            <param name="gamma">
              A 1D gamma Tensor with size matching the last dimension of t.
              If "scale_after_normalization" is true, this Tensor will be multiplied
              with the normalized Tensor.
            </param>
            <param name="backprop">
              4D backprop Tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchNormWithGlobalNormalizationGrad'.
            </param>
            <param name="variance_epsilon">
              A small float number to avoid dividing by 0.
            </param>
            <param name="scale_after_normalization">
              A bool indicating whether the resulted tensor
              needs to be multiplied with gamma.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              dx: 4D backprop tensor for input.
              dm: 1D backprop tensor for mean.
              dv: 1D backprop tensor for variance.
              db: 1D backprop tensor for beta.
              dg: 1D backprop tensor for gamma.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              This op is deprecated. See `tf.nn.batch_normalization`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BatchToSpace(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">
            <summary>
              BatchToSpace for 4-D tensors of type T.
            </summary>
            <param name="input">
              4-D tensor with shape
              `[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
                depth]`. Note that the batch size of the input tensor must be divisible by
              `block_size * block_size`.
            </param>
            <param name="crops">
              2-D tensor of non-negative integers with shape `[2, 2]`. It specifies
              how many elements to crop from the intermediate result across the spatial
              dimensions as follows:
              
                  crops = [[crop_top, crop_bottom], [crop_left, crop_right]]
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchToSpace'.
            </param>
            <param name="block_size">
            </param>
            <returns>
              4-D with shape `[batch, height, width, depth]`, where:
              
                    height = height_pad - crop_top - crop_bottom
                    width = width_pad - crop_left - crop_right
              
              The attr `block_size` must be greater than one. It indicates the block size.
              
              Some examples:
              
              (1) For the following input of shape `[4, 1, 1, 1]` and block_size of 2:
              
              ```
              [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
              ```
              
              The output tensor has shape `[1, 2, 2, 1]` and value:
              
              ```
              x = [[[[1], [2]], [[3], [4]]]]
              ```
              
              (2) For the following input of shape `[4, 1, 1, 3]` and block_size of 2:
              
              ```
              [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
              ```
              
              The output tensor has shape `[1, 2, 2, 3]` and value:
              
              ```
              x = [[[[1, 2, 3], [4, 5, 6]],
                    [[7, 8, 9], [10, 11, 12]]]]
              ```
              
              (3) For the following input of shape `[4, 2, 2, 1]` and block_size of 2:
              
              ```
              x = [[[[1], [3]], [[9], [11]]],
                   [[[2], [4]], [[10], [12]]],
                   [[[5], [7]], [[13], [15]]],
                   [[[6], [8]], [[14], [16]]]]
              ```
              
              The output tensor has shape `[1, 4, 4, 1]` and value:
              
              ```
              x = [[[1],   [2],  [3],  [4]],
                   [[5],   [6],  [7],  [8]],
                   [[9],  [10], [11],  [12]],
                   [[13], [14], [15],  [16]]]
              ```
              
              (4) For the following input of shape `[8, 1, 2, 1]` and block_size of 2:
              
              ```
              x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],
                   [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]
              ```
              
              The output tensor has shape `[2, 2, 4, 1]` and value:
              
              ```
              x = [[[[1], [3]], [[5], [7]]],
                   [[[2], [4]], [[10], [12]]],
                   [[[5], [7]], [[13], [15]]],
                   [[[6], [8]], [[14], [16]]]]
              ```
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This is a legacy version of the more general BatchToSpaceND.
              
              Rearranges (permutes) data from batch into blocks of spatial data, followed by
              cropping. This is the reverse transformation of SpaceToBatch. More specifically,
              this op outputs a copy of the input tensor where values from the `batch`
              dimension are moved in spatial blocks to the `height` and `width` dimensions,
              followed by cropping along the `height` and `width` dimensions.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BatchToSpaceND(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              BatchToSpace for N-D tensors of type T.
            </summary>
            <param name="input">
              N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`,
              where spatial_shape has M dimensions.
            </param>
            <param name="block_shape">
              1-D with shape `[M]`, all values must be &amp;gt;= 1.
            </param>
            <param name="crops">
              2-D with shape `[M, 2]`, all values must be &amp;gt;= 0.
                `crops[i] = [crop_start, crop_end]` specifies the amount to crop from input
                dimension `i + 1`, which corresponds to spatial dimension `i`.  It is
                required that
                `crop_start[i] + crop_end[i] &amp;lt;= block_shape[i] * input_shape[i + 1]`.
              
              This operation is equivalent to the following steps:
              
              1. Reshape `input` to `reshaped` of shape:
                   [block_shape[0], ..., block_shape[M-1],
                    batch / prod(block_shape),
                    input_shape[1], ..., input_shape[N-1]]
              
              2. Permute dimensions of `reshaped` to produce `permuted` of shape
                   [batch / prod(block_shape),
              
                    input_shape[1], block_shape[0],
                    ...,
                    input_shape[M], block_shape[M-1],
              
                    input_shape[M+1], ..., input_shape[N-1]]
              
              3. Reshape `permuted` to produce `reshaped_permuted` of shape
                   [batch / prod(block_shape),
              
                    input_shape[1] * block_shape[0],
                    ...,
                    input_shape[M] * block_shape[M-1],
              
                    input_shape[M+1],
                    ...,
                    input_shape[N-1]]
              
              4. Crop the start and end of dimensions `[1, ..., M]` of
                 `reshaped_permuted` according to `crops` to produce the output of shape:
                   [batch / prod(block_shape),
              
                    input_shape[1] * block_shape[0] - crops[0,0] - crops[0,1],
                    ...,
                    input_shape[M] * block_shape[M-1] - crops[M-1,0] - crops[M-1,1],
              
                    input_shape[M+1], ..., input_shape[N-1]]
              
              Some examples:
              
              (1) For the following input of shape `[4, 1, 1, 1]`, `block_shape = [2, 2]`, and
                  `crops = [[0, 0], [0, 0]]`:
              
              ```
              [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
              ```
              
              The output tensor has shape `[1, 2, 2, 1]` and value:
              
              ```
              x = [[[[1], [2]], [[3], [4]]]]
              ```
              
              (2) For the following input of shape `[4, 1, 1, 3]`, `block_shape = [2, 2]`, and
                  `crops = [[0, 0], [0, 0]]`:
              
              ```
              [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
              ```
              
              The output tensor has shape `[1, 2, 2, 3]` and value:
              
              ```
              x = [[[[1, 2, 3], [4, 5, 6]],
                    [[7, 8, 9], [10, 11, 12]]]]
              ```
              
              (3) For the following input of shape `[4, 2, 2, 1]`, `block_shape = [2, 2]`, and
                  `crops = [[0, 0], [0, 0]]`:
              
              ```
              x = [[[[1], [3]], [[9], [11]]],
                   [[[2], [4]], [[10], [12]]],
                   [[[5], [7]], [[13], [15]]],
                   [[[6], [8]], [[14], [16]]]]
              ```
              
              The output tensor has shape `[1, 4, 4, 1]` and value:
              
              ```
              x = [[[1],   [2],  [3],  [4]],
                   [[5],   [6],  [7],  [8]],
                   [[9],  [10], [11],  [12]],
                   [[13], [14], [15],  [16]]]
              ```
              
              (4) For the following input of shape `[8, 1, 3, 1]`, `block_shape = [2, 2]`, and
                  `crops = [[0, 0], [2, 0]]`:
              
              ```
              x = [[[[0], [1], [3]]], [[[0], [9], [11]]],
                   [[[0], [2], [4]]], [[[0], [10], [12]]],
                   [[[0], [5], [7]]], [[[0], [13], [15]]],
                   [[[0], [6], [8]]], [[[0], [14], [16]]]]
              ```
              
              The output tensor has shape `[2, 2, 4, 1]` and value:
              
              ```
              x = [[[[1],   [2],  [3],  [4]],
                    [[5],   [6],  [7],  [8]]],
                   [[[9],  [10], [11],  [12]],
                    [[13], [14], [15],  [16]]]]
              ```
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchToSpaceND'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation reshapes the "batch" dimension 0 into `M + 1` dimensions of shape
              `block_shape + [batch]`, interleaves these blocks back into the grid defined by
              the spatial dimensions `[1, ..., M]`, to obtain a result with the same rank as
              the input.  The spatial dimensions of this intermediate result are then
              optionally cropped according to `crops` to produce the output.  This is the
              reverse of SpaceToBatch.  See below for a precise description.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Betainc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Compute the regularized incomplete beta integral \\(I_x(a, b)\\).
            </summary>
            <param name="a">
            </param>
            <param name="b">
            </param>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Betainc'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The regularized incomplete beta integral is defined as:
              
              
              \\(I_x(a, b) = \frac{B(x; a, b)}{B(a, b)}\\)
              
              where
              
              
              \\(B(x; a, b) = \int_0^x t^{a-1} (1 - t)^{b-1} dt\\)
              
              
              is the incomplete beta function and \\(B(a, b)\\) is the *complete*
              beta function.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BiasAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">
            <summary>
              Adds `bias` to `value`.
            </summary>
            <param name="value">
              Any number of dimensions.
            </param>
            <param name="bias">
              1-D with size the last dimension of `value`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BiasAdd'.
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the bias tensor will be added to the last dimension
              of the value tensor.
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, in_channels, in_height, in_width].
              The tensor will be added to "in_channels", the third-to-the-last
                  dimension.
            </param>
            <returns>
              Broadcasted sum of `value` and `bias`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This is a special case of `tf.add` where `bias` is restricted to be 1-D.
              Broadcasting is supported, so `value` may have any number of dimensions.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BiasAddGrad(TensorFlow.TFOutput,System.String,System.String)">
            <summary>
              The backward operation for "BiasAdd" on the "bias" tensor.
            </summary>
            <param name="out_backprop">
              Any number of dimensions.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BiasAddGrad'.
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the bias tensor will be added to the last dimension
              of the value tensor.
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, in_channels, in_height, in_width].
              The tensor will be added to "in_channels", the third-to-the-last
                  dimension.
            </param>
            <returns>
              1-D with size the feature dimension of `out_backprop`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              It accumulates all the values from out_backprop into the feature dimension.
              For NHWC data format, the feature dimension is the last. For NCHW data format,
              the feature dimension is the third-to-last.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BiasAddV1(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Adds `bias` to `value`.
            </summary>
            <param name="value">
              Any number of dimensions.
            </param>
            <param name="bias">
              1-D with size the last dimension of `value`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BiasAddV1'.
            </param>
            <returns>
              Broadcasted sum of `value` and `bias`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This is a deprecated version of BiasAdd and will be soon removed.
              
              This is a special case of `tf.add` where `bias` is restricted to be 1-D.
              Broadcasting is supported, so `value` may have any number of dimensions.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Bincount(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Counts the number of occurrences of each value in an integer array.
            </summary>
            <param name="arr">
              int32 `Tensor`.
            </param>
            <param name="size">
              non-negative int32 scalar `Tensor`.
            </param>
            <param name="weights">
              is an int32, int64, float32, or float64 `Tensor` with the same
              shape as `arr`, or a length-0 `Tensor`, in which case it acts as all weights
              equal to 1.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Bincount'.
            </param>
            <returns>
              1D `Tensor` with length equal to `size`. The counts or summed weights for
              each value in the range [0, size).
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Outputs a vector with length `size` and the same dtype as `weights`. If
              `weights` are empty, then index `i` stores the number of times the value `i` is
              counted in `arr`. If `weights` are non-empty, then index `i` stores the sum of
              the value in `weights` at each index where the corresponding value in `arr` is
              `i`.
              
              Values in `arr` outside of the range [0, size) are ignored.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Bitcast(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Bitcasts a tensor from one type to another without copying data.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Bitcast'.
            </param>
            <param name="type">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a tensor `input`, this operation returns a tensor that has the same buffer
              data as `input` with datatype `type`.
              
              If the input datatype `T` is larger than the output datatype `type` then the
              shape changes from [...] to [..., sizeof(`T`)/sizeof(`type`)].
              
              If `T` is smaller than `type`, the operator requires that the rightmost
              dimension be equal to sizeof(`type`)/sizeof(`T`). The shape then goes from
              [..., sizeof(`type`)/sizeof(`T`)] to [...].
              
              *NOTE*: Bitcast is implemented as a low-level cast, so machines with different
              endian orderings will give different results.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BitwiseAnd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Elementwise computes the bitwise AND of `x` and `y`.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BitwiseAnd'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The result will have those bits set, that are set in both `x` and `y`. The
              computation is performed on the underlying representations of `x` and `y`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BitwiseOr(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Elementwise computes the bitwise OR of `x` and `y`.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BitwiseOr'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The result will have those bits set, that are set in `x`, `y` or both. The
              computation is performed on the underlying representations of `x` and `y`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BitwiseXor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Elementwise computes the bitwise XOR of `x` and `y`.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BitwiseXor'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The result will have those bits set, that are different in `x` and `y`. The
              computation is performed on the underlying representations of `x` and `y`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BroadcastArgs(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Return the shape of s0 op s1 with broadcast.
            </summary>
            <param name="s0">
            </param>
            <param name="s1">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BroadcastArgs'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given `s0` and `s1`, tensors that represent shapes, compute `r0`, the
              broadcasted shape. `s0`, `s1` and `r0` are all integer vectors.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BroadcastGradientArgs(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Return the reduction indices for computing gradients of s0 op s1 with broadcast.
            </summary>
            <param name="s0">
            </param>
            <param name="s1">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BroadcastGradientArgs'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              r0: 
              r1: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              This is typically used by gradient computations for a broadcasting operation.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Bucketize(TensorFlow.TFOutput,System.Single[],System.String)">
            <summary>
              Bucketizes 'input' based on 'boundaries'.
            </summary>
            <param name="input">
              Any shape of Tensor contains with int or float type.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Bucketize'.
            </param>
            <param name="boundaries">
              A sorted list of floats gives the boundary of the buckets.
            </param>
            <returns>
              Same shape with 'input', each value of input replaced with bucket index.
              
              @compatibility(numpy)
              Equivalent to np.digitize.
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              For example, if the inputs are
                  boundaries = [0, 10, 100]
                  input = [[-5, 10000]
                           [150,   10]
                           [5,    100]]
              
              then the output will be
                  output = [[0, 3]
                            [3, 2]
                            [1, 3]]
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.BytesProducedStatsDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Records the bytes size of each element of `input_dataset` in a StatsAggregator.
            </summary>
            <param name="input_dataset">
            </param>
            <param name="tag">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'BytesProducedStatsDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.CacheDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that caches elements from `input_dataset`.
            </summary>
            <param name="input_dataset">
            </param>
            <param name="filename">
              A path on the filesystem where we should cache the dataset. Note: this
              will be a directory.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CacheDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              A CacheDataset will iterate over the input_dataset, and store tensors. If the
              cache already exists, the cache will be used. If the cache is inappropriate
              (e.g. cannot be opened, contains tensors of the wrong shape / size), an error
              will the returned when used.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Cast(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Cast x of type SrcT to y of DstT.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Cast'.
            </param>
            <param name="DstT">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Ceil(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns element-wise smallest integer in not less than x.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Ceil'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.CheckNumerics(TensorFlow.TFOutput,System.String,System.String)">
            <summary>
              Checks a tensor for NaN and Inf values.
            </summary>
            <param name="tensor">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CheckNumerics'.
            </param>
            <param name="message">
              Prefix of the error message.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              When run, reports an `InvalidArgument` error if `tensor` has any values
              that are not a number (NaN) or infinity (Inf). Otherwise, passes `tensor` as-is.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Cholesky(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the Cholesky decomposition of one or more square matrices.
            </summary>
            <param name="input">
              Shape is `[..., M, M]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Cholesky'.
            </param>
            <returns>
              Shape is `[..., M, M]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions
              form square matrices.
              
              The input has to be symmetric and positive definite. Only the lower-triangular
              part of the input will be used for this operation. The upper-triangular part
              will not be read.
              
              The output is a tensor of the same shape as the input
              containing the Cholesky decompositions for all input submatrices `[..., :, :]`.
              
              **Note**: The gradient computation on GPU is faster for large matrices but
              not for large batch dimensions when the submatrices are small. In this
              case it might be faster to use the CPU.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.CholeskyGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the reverse mode backpropagated gradient of the Cholesky algorithm.
            </summary>
            <param name="l">
              Output of batch Cholesky algorithm l = cholesky(A). Shape is `[..., M, M]`.
              Algorithm depends only on lower triangular part of the innermost matrices of
              this tensor.
            </param>
            <param name="grad">
              df/dl where f is some scalar function. Shape is `[..., M, M]`.
              Algorithm depends only on lower triangular part of the innermost matrices of
              this tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CholeskyGrad'.
            </param>
            <returns>
              Symmetrized version of df/dA . Shape is `[..., M, M]`
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              For an explanation see "Differentiation of the Cholesky algorithm" by
              Iain Murray http://arxiv.org/abs/1602.07527.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.CloseSummaryWriter(TensorFlow.TFOutput,System.String)">
            <summary>
              Flushes and closes the summary writer.
            </summary>
            <param name="writer">
              A handle to the summary writer resource.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CloseSummaryWriter'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              Also removes it from the resource manager. To reopen, use another
              CreateSummaryFileWriter op.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.CompareAndBitpack(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Compare values of `input` to `threshold` and pack resulting bits into a `uint8`.
            </summary>
            <param name="input">
              Values to compare against `threshold` and bitpack.
            </param>
            <param name="threshold">
              Threshold to compare against.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CompareAndBitpack'.
            </param>
            <returns>
              The bitpacked comparisons.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Each comparison returns a boolean `true` (if `input_value &amp;gt; threshold`)
              or and `false` otherwise.
              
              This operation is useful for Locality-Sensitive-Hashing (LSH) and other
              algorithms that use hashing approximations of cosine and `L2` distances;
              codes can be generated from an input via:
              
              ```python
              codebook_size = 50
              codebook_bits = codebook_size * 32
              codebook = tf.get_variable('codebook', [x.shape[-1].value, codebook_bits],
                                         dtype=x.dtype,
                                         initializer=tf.orthogonal_initializer())
              codes = compare_and_threshold(tf.matmul(x, codebook), threshold=0.)
              codes = tf.bitcast(codes, tf.int32)  # go from uint8 to int32
              # now codes has shape x.shape[:-1] + [codebook_size]
              ```
              
              **NOTE**: Currently, the innermost dimension of the tensor must be divisible
              by 8.
              
              Given an `input` shaped `[s0, s1, ..., s_n]`, the output is
              a `uint8` tensor shaped `[s0, s1, ..., s_n / 8]`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Complex(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Converts two real numbers to a complex number.
            </summary>
            <param name="real">
            </param>
            <param name="imag">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Complex'.
            </param>
            <param name="Tout">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a tensor `real` representing the real part of a complex number, and a
              tensor `imag` representing the imaginary part of a complex number, this
              operation returns complex numbers elementwise of the form \\(a + bj\\), where
              *a* represents the `real` part and *b* represents the `imag` part.
              
              The input tensors `real` and `imag` must have the same shape.
              
              For example:
              
              ```
              # tensor 'real' is [2.25, 3.25]
              # tensor `imag` is [4.75, 5.75]
              tf.complex(real, imag) ==&amp;gt; [[2.25 + 4.75j], [3.25 + 5.75j]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ComplexAbs(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Computes the complex absolute value of a tensor.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ComplexAbs'.
            </param>
            <param name="Tout">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a tensor `x` of complex numbers, this operation returns a tensor of type
              `float` or `double` that is the absolute value of each element in `x`. All
              elements in `x` must be complex numbers of the form \\(a + bj\\). The absolute
              value is computed as \\( \sqrt{a^2 + b^2}\\).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ComputeAccidentalHits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Computes the ids of the positions in sampled_candidates that match true_labels.
            </summary>
            <param name="true_classes">
              The true_classes output of UnpackSparseLabels.
            </param>
            <param name="sampled_candidates">
              The sampled_candidates output of CandidateSampler.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ComputeAccidentalHits'.
            </param>
            <param name="seed">
              Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              An second seed to avoid seed collision.
            </param>
            <param name="num_true">
              Number of true labels per context.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              indices: A vector of indices corresponding to rows of true_candidates.
              ids: A vector of IDs of positions in sampled_candidates that match a true_label
              for the row with the corresponding index in indices.
              weights: A vector of the same length as indices and ids, in which each element
              is -FLOAT_MAX.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              When doing log-odds NCE, the result of this op should be passed through a
              SparseToDense op, then added to the logits of the sampled candidates. This has
              the effect of 'removing' the sampled labels that match the true labels by
              making the classifier sure that they are sampled labels.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Concat(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)">
            <summary>
              Concatenates tensors along one dimension.
            </summary>
            <param name="concat_dim">
              0-D.  The dimension along which to concatenate.  Must be in the
              range [0, rank(values)).
            </param>
            <param name="values">
              The `N` Tensors to concatenate. Their ranks and types must match,
              and their sizes must match in all dimensions except `concat_dim`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Concat'.
            </param>
            <returns>
              A `Tensor` with the concatenation of values stacked along the
              `concat_dim` dimension.  This tensor's shape matches that of `values` except
              in `concat_dim` where it has the sum of the sizes.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ConcatenateDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that concatenates `input_dataset` with `another_dataset`.
            </summary>
            <param name="input_dataset">
            </param>
            <param name="another_dataset">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ConcatenateDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ConcatOffset(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)">
            <summary>
              Computes offsets of concat inputs within its output.
            </summary>
            <param name="concat_dim">
              The dimension along which to concatenate.
            </param>
            <param name="shape">
              The `N` int32 vectors representing shape of tensors being concatenated.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ConcatOffset'.
            </param>
            <returns>
              The `N` int32 vectors representing the starting offset
              of input tensors within the concatenated output.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              For example:
              
              ```
              # 'x' is [2, 2, 7]
              # 'y' is [2, 3, 7]
              # 'z' is [2, 5, 7]
              concat_offset(2, [x, y, z]) =&amp;gt; [0, 0, 0], [0, 2, 0], [0, 5, 0]
              ```
              
              This is typically used by gradient computations for a concat operation.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ConcatV2(TensorFlow.TFOutput[],TensorFlow.TFOutput,System.String)">
            <summary>
              Concatenates tensors along one dimension.
            </summary>
            <param name="values">
              List of `N` Tensors to concatenate. Their ranks and types must match,
              and their sizes must match in all dimensions except `concat_dim`.
            </param>
            <param name="axis">
              0-D.  The dimension along which to concatenate.  Must be in the
              range [-rank(values), rank(values)).
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ConcatV2'.
            </param>
            <returns>
              A `Tensor` with the concatenation of values stacked along the
              `concat_dim` dimension.  This tensor's shape matches that of `values` except
              in `concat_dim` where it has the sum of the sizes.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ConditionalAccumulator(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String)">
            <summary>
              A conditional accumulator for aggregating gradients.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ConditionalAccumulator'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this accumulator is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this accumulator will be shared under the
              given name across multiple sessions.
            </param>
            <param name="dtype">
              The type of the value being accumulated.
            </param>
            <param name="shape">
              The shape of the values, can be [], in which case shape is unknown.
            </param>
            <returns>
              The handle to the accumulator.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The accumulator accepts gradients marked with local_step greater or
              equal to the most recent global_step known to the accumulator. The
              average can be extracted from the accumulator, provided sufficient
              gradients have been accumulated. Extracting the average automatically
              resets the aggregate to 0, and increments the global_step recorded by
              the accumulator.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Conj(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the complex conjugate of a complex number.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Conj'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a tensor `input` of complex numbers, this operation returns a tensor of
              complex numbers that are the complex conjugate of each element in `input`. The
              complex numbers in `input` must be of the form \\(a + bj\\), where *a* is the
              real part and *b* is the imaginary part.
              
              The complex conjugate returned by this operation is of the form \\(a - bj\\).
              
              For example:
              
              ```
              # tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]
              tf.conj(input) ==&amp;gt; [-2.25 - 4.75j, 3.25 - 5.75j]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ConjugateTranspose(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Shuffle dimensions of x according to a permutation and conjugate the result.
            </summary>
            <param name="x">
            </param>
            <param name="perm">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ConjugateTranspose'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:
                `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`
                `y[i,j,k,...,s,t,u] == conj(x[perm[i], perm[j], perm[k],...,perm[s], perm[t], perm[u]])`
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Const(TensorFlow.TFTensor,TensorFlow.TFDataType,System.String)">
            <summary>
              Returns a constant tensor.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Const'.
            </param>
            <param name="value">
              Attr `value` is the tensor to return.
            </param>
            <param name="dtype">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ControlTrigger(System.String)">
            <summary>
              Does nothing. Serves as a control trigger for scheduling.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ControlTrigger'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              Only useful as a placeholder for control edges.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Conv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)">
            <summary>
              Computes a 2-D convolution given 4-D `input` and `filter` tensors.
            </summary>
            <param name="input">
              A 4-D tensor. The dimension order is interpreted according to the value
              of `data_format`, see below for details.
            </param>
            <param name="filter">
              A 4-D tensor of shape
              `[filter_height, filter_width, in_channels, out_channels]`
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv2D'.
            </param>
            <param name="use_cudnn_on_gpu">
              Optional argument
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, height, width, channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, channels, height, width].
            </param>
            <param name="dilations">
              Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              `input`. If set to k &amp;gt; 1, there will be k-1 skipped cells between each
              filter element on that dimension. The dimension order is determined by the
              value of `data_format`, see above for details. Dilations in the batch and
              depth dimensions must be 1.
            </param>
            <param name="strides">
              1-D tensor of length 4.  The stride of the sliding window for each
              dimension of `input`. The dimension order is determined by the value of
              `data_format`, see below for details.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              A 4-D tensor. The dimension order is determined by the value of
              `data_format`, see below for details.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given an input tensor of shape `[batch, in_height, in_width, in_channels]`
              and a filter / kernel tensor of shape
              `[filter_height, filter_width, in_channels, out_channels]`, this op
              performs the following:
              
              1. Flattens the filter to a 2-D matrix with shape
                 `[filter_height * filter_width * in_channels, output_channels]`.
              2. Extracts image patches from the input tensor to form a *virtual*
                 tensor of shape `[batch, out_height, out_width,
                 filter_height * filter_width * in_channels]`.
              3. For each patch, right-multiplies the filter matrix and the image patch
                 vector.
              
              In detail, with the default NHWC format,
              
                  output[b, i, j, k] =
                      sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *
                                      filter[di, dj, q, k]
              
              Must have `strides[0] = strides[3] = 1`.  For the most common case of the same
              horizontal and vertices strides, `strides = [1, stride, stride, 1]`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Conv2DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)">
            <summary>
              Computes the gradients of convolution with respect to the filter.
            </summary>
            <param name="input">
              4-D with shape `[batch, in_height, in_width, in_channels]`.
            </param>
            <param name="filter_sizes">
              An integer vector representing the tensor shape of `filter`,
              where `filter` is a 4-D
              `[filter_height, filter_width, in_channels, out_channels]` tensor.
            </param>
            <param name="out_backprop">
              4-D with shape `[batch, out_height, out_width, out_channels]`.
              Gradients w.r.t. the output of the convolution.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv2DBackpropFilter'.
            </param>
            <param name="use_cudnn_on_gpu">
              Optional argument
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, in_height, in_width, in_channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, in_channels, in_height, in_width].
            </param>
            <param name="dilations">
              Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              `input`. If set to k &amp;gt; 1, there will be k-1 skipped cells between each filter
              element on that dimension. The dimension order is determined by the value of
              `data_format`, see above for details. Dilations in the batch and depth
              dimensions must be 1.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the input
              of the convolution. Must be in the same order as the dimension specified with
              format.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              4-D with shape
              `[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t.
              the `filter` input of the convolution.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Conv2DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)">
            <summary>
              Computes the gradients of convolution with respect to the input.
            </summary>
            <param name="input_sizes">
              An integer vector representing the shape of `input`,
              where `input` is a 4-D `[batch, height, width, channels]` tensor.
            </param>
            <param name="filter">
              4-D with shape
              `[filter_height, filter_width, in_channels, out_channels]`.
            </param>
            <param name="out_backprop">
              4-D with shape `[batch, out_height, out_width, out_channels]`.
              Gradients w.r.t. the output of the convolution.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv2DBackpropInput'.
            </param>
            <param name="use_cudnn_on_gpu">
              Optional argument
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, in_height, in_width, in_channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, in_channels, in_height, in_width].
            </param>
            <param name="dilations">
              Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              `input`. If set to k &amp;gt; 1, there will be k-1 skipped cells between each filter
              element on that dimension. The dimension order is determined by the value of
              `data_format`, see above for details. Dilations in the batch and depth
              dimensions must be 1.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the input
              of the convolution. Must be in the same order as the dimension specified with
              format.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              4-D with shape `[batch, in_height, in_width, in_channels]`.  Gradient
              w.r.t. the input of the convolution.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Conv3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)">
            <summary>
              Computes a 3-D convolution given 5-D `input` and `filter` tensors.
            </summary>
            <param name="input">
              Shape `[batch, in_depth, in_height, in_width, in_channels]`.
            </param>
            <param name="filter">
              Shape `[filter_depth, filter_height, filter_width, in_channels,
              out_channels]`. `in_channels` must match between `input` and `filter`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3D'.
            </param>
            <param name="data_format">
              Optional argument
              The data format of the input and output data. With the
              default format "NDHWC", the data is stored in the order of:
                  [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be "NCDHW", the data storage order is:
                  [batch, in_channels, in_depth, in_height, in_width].
            </param>
            <param name="dilations">
              Optional argument
              1-D tensor of length 5.  The dilation factor for each dimension of
              `input`. If set to k &amp;gt; 1, there will be k-1 skipped cells between each
              filter element on that dimension. The dimension order is determined by the
              value of `data_format`, see above for details. Dilations in the batch and
              depth dimensions must be 1.
            </param>
            <param name="strides">
              1-D tensor of length 5. The stride of the sliding window for each
              dimension of `input`. Must have `strides[0] = strides[4] = 1`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              In signal processing, cross-correlation is a measure of similarity of
              two waveforms as a function of a time-lag applied to one of them. This
              is also known as a sliding dot product or sliding inner-product.
              
              Our Conv3D implements a form of cross-correlation.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Conv3DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String)">
            <summary>
              Computes the gradients of 3-D convolution with respect to the filter.
            </summary>
            <param name="input">
              Shape `[batch, depth, rows, cols, in_channels]`.
            </param>
            <param name="filter">
              Shape `[depth, rows, cols, in_channels, out_channels]`.
              `in_channels` must match between `input` and `filter`.
            </param>
            <param name="out_backprop">
              Backprop signal of shape `[batch, out_depth, out_rows, out_cols,
              out_channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropFilter'.
            </param>
            <param name="strides">
              1-D tensor of length 5. The stride of the sliding window for each
              dimension of `input`. Must have `strides[0] = strides[4] = 1`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Conv3DBackpropFilterV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)">
            <summary>
              Computes the gradients of 3-D convolution with respect to the filter.
            </summary>
            <param name="input">
              Shape `[batch, depth, rows, cols, in_channels]`.
            </param>
            <param name="filter_sizes">
              An integer vector representing the tensor shape of `filter`,
              where `filter` is a 5-D
              `[filter_depth, filter_height, filter_width, in_channels, out_channels]`
              tensor.
            </param>
            <param name="out_backprop">
              Backprop signal of shape `[batch, out_depth, out_rows, out_cols,
              out_channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropFilterV2'.
            </param>
            <param name="data_format">
              Optional argument
              The data format of the input and output data. With the
              default format "NDHWC", the data is stored in the order of:
                  [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be "NCDHW", the data storage order is:
                  [batch, in_channels, in_depth, in_height, in_width].
            </param>
            <param name="dilations">
              Optional argument
              1-D tensor of length 5.  The dilation factor for each dimension of
              `input`. If set to k &amp;gt; 1, there will be k-1 skipped cells between each
              filter element on that dimension. The dimension order is determined by the
              value of `data_format`, see above for details. Dilations in the batch and
              depth dimensions must be 1.
            </param>
            <param name="strides">
              1-D tensor of length 5. The stride of the sliding window for each
              dimension of `input`. Must have `strides[0] = strides[4] = 1`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Conv3DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String)">
            <summary>
              Computes the gradients of 3-D convolution with respect to the input.
            </summary>
            <param name="input">
              Shape `[batch, depth, rows, cols, in_channels]`.
            </param>
            <param name="filter">
              Shape `[depth, rows, cols, in_channels, out_channels]`.
              `in_channels` must match between `input` and `filter`.
            </param>
            <param name="out_backprop">
              Backprop signal of shape `[batch, out_depth, out_rows, out_cols,
              out_channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropInput'.
            </param>
            <param name="strides">
              1-D tensor of length 5. The stride of the sliding window for each
              dimension of `input`. Must have `strides[0] = strides[4] = 1`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Conv3DBackpropInputV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)">
            <summary>
              Computes the gradients of 3-D convolution with respect to the input.
            </summary>
            <param name="input_sizes">
              An integer vector representing the tensor shape of `input`,
              where `input` is a 5-D
              `[batch, depth, rows, cols, in_channels]` tensor.
            </param>
            <param name="filter">
              Shape `[depth, rows, cols, in_channels, out_channels]`.
              `in_channels` must match between `input` and `filter`.
            </param>
            <param name="out_backprop">
              Backprop signal of shape `[batch, out_depth, out_rows, out_cols,
              out_channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropInputV2'.
            </param>
            <param name="data_format">
              Optional argument
              The data format of the input and output data. With the
              default format "NDHWC", the data is stored in the order of:
                  [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be "NCDHW", the data storage order is:
                  [batch, in_channels, in_depth, in_height, in_width].
            </param>
            <param name="dilations">
              Optional argument
              1-D tensor of length 5.  The dilation factor for each dimension of
              `input`. If set to k &amp;gt; 1, there will be k-1 skipped cells between each
              filter element on that dimension. The dimension order is determined by the
              value of `data_format`, see above for details. Dilations in the batch and
              depth dimensions must be 1.
            </param>
            <param name="strides">
              1-D tensor of length 5. The stride of the sliding window for each
              dimension of `input`. Must have `strides[0] = strides[4] = 1`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Cos(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes cos of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Cos'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Cosh(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes hyperbolic cosine of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Cosh'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.CountUpTo(TensorFlow.TFOutput,System.Int64,System.String)">
            <summary>
              Increments 'ref' until it reaches 'limit'.
            </summary>
            <param name="reference">
              Should be from a scalar `Variable` node.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CountUpTo'.
            </param>
            <param name="limit">
              If incrementing ref would bring it above limit, instead generates an
              'OutOfRange' error.
            </param>
            <returns>
              A copy of the input before increment. If nothing else modifies the
              input, the values produced will all be distinct.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.CreateSummaryDbWriter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Creates summary database writer accessible by given resource handle.
            </summary>
            <param name="writer">
              Handle to SummaryWriter resource to overwrite.
            </param>
            <param name="db_uri">
              For example "file:/tmp/foo.sqlite".
            </param>
            <param name="experiment_name">
              Can't contain ASCII control characters or &amp;lt;&amp;gt;. Case
              sensitive. If empty, then the Run will not be associated with any
              Experiment.
            </param>
            <param name="run_name">
              Can't contain ASCII control characters or &amp;lt;&amp;gt;. Case sensitive.
              If empty, then each Tag will not be associated with any Run.
            </param>
            <param name="user_name">
              Must be valid as both a DNS label and Linux username. If
              empty, then the Experiment will not be associated with any User.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CreateSummaryDbWriter'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              This can be used to write tensors from the execution graph directly
              to a database. Only SQLite is supported right now. This function
              will create the schema if it doesn't exist. Entries in the Users,
              Experiments, and Runs tables will be created automatically if they
              don't already exist.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.CreateSummaryFileWriter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Creates a summary file writer accessible by the given resource handle.
            </summary>
            <param name="writer">
              A handle to the summary writer resource
            </param>
            <param name="logdir">
              Directory where the event file will be written.
            </param>
            <param name="max_queue">
              Size of the queue of pending events and summaries.
            </param>
            <param name="flush_millis">
              How often, in milliseconds, to flush the pending events and
              summaries to disk.
            </param>
            <param name="filename_suffix">
              Every event file's name is suffixed with this suffix.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CreateSummaryFileWriter'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.CropAndResize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Single},System.String)">
            <summary>
              Extracts crops from the input image tensor and bilinearly resizes them (possibly
            </summary>
            <param name="image">
              A 4-D tensor of shape `[batch, image_height, image_width, depth]`.
              Both `image_height` and `image_width` need to be positive.
            </param>
            <param name="boxes">
              A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor
              specifies the coordinates of a box in the `box_ind[i]` image and is specified
              in normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of
              `y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the
              `[0, 1]` interval of normalized image height is mapped to
              `[0, image_height - 1]` in image height coordinates. We do allow `y1` &amp;gt; `y2`, in
              which case the sampled crop is an up-down flipped version of the original
              image. The width dimension is treated similarly. Normalized coordinates
              outside the `[0, 1]` range are allowed, in which case we use
              `extrapolation_value` to extrapolate the input image values.
            </param>
            <param name="box_ind">
              A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`.
              The value of `box_ind[i]` specifies the image that the `i`-th box refers to.
            </param>
            <param name="crop_size">
              A 1-D tensor of 2 elements, `size = [crop_height, crop_width]`. All
              cropped image patches are resized to this size. The aspect ratio of the image
              content is not preserved. Both `crop_height` and `crop_width` need to be
              positive.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CropAndResize'.
            </param>
            <param name="method">
              Optional argument
              A string specifying the interpolation method. Only 'bilinear' is
              supported for now.
            </param>
            <param name="extrapolation_value">
              Optional argument
              Value used for extrapolation, when applicable.
            </param>
            <returns>
              A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              with aspect ratio change) to a common output size specified by `crop_size`. This
              is more general than the `crop_to_bounding_box` op which extracts a fixed size
              slice from the input image and does not allow resizing or aspect ratio change.
              
              Returns a tensor with `crops` from the input `image` at positions defined at the
              bounding box locations in `boxes`. The cropped boxes are all resized (with
              bilinear interpolation) to a fixed `size = [crop_height, crop_width]`. The
              result is a 4-D tensor `[num_boxes, crop_height, crop_width, depth]`. The
              resizing is corner aligned. In particular, if `boxes = [[0, 0, 1, 1]]`, the
              method will give identical results to using `tf.image.resize_bilinear()`
              with `align_corners=True`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.CropAndResizeGradBoxes(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">
            <summary>
              Computes the gradient of the crop_and_resize op wrt the input boxes tensor.
            </summary>
            <param name="grads">
              A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.
            </param>
            <param name="image">
              A 4-D tensor of shape `[batch, image_height, image_width, depth]`.
              Both `image_height` and `image_width` need to be positive.
            </param>
            <param name="boxes">
              A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor
              specifies the coordinates of a box in the `box_ind[i]` image and is specified
              in normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of
              `y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the
              `[0, 1]` interval of normalized image height is mapped to
              `[0, image_height - 1] in image height coordinates. We do allow y1 &amp;gt; y2, in
              which case the sampled crop is an up-down flipped version of the original
              image. The width dimension is treated similarly. Normalized coordinates
              outside the `[0, 1]` range are allowed, in which case we use
              `extrapolation_value` to extrapolate the input image values.
            </param>
            <param name="box_ind">
              A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`.
              The value of `box_ind[i]` specifies the image that the `i`-th box refers to.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CropAndResizeGradBoxes'.
            </param>
            <param name="method">
              Optional argument
              A string specifying the interpolation method. Only 'bilinear' is
              supported for now.
            </param>
            <returns>
              A 2-D tensor of shape `[num_boxes, 4]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.CropAndResizeGradImage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String)">
            <summary>
              Computes the gradient of the crop_and_resize op wrt the input image tensor.
            </summary>
            <param name="grads">
              A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.
            </param>
            <param name="boxes">
              A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor
              specifies the coordinates of a box in the `box_ind[i]` image and is specified
              in normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of
              `y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the
              `[0, 1]` interval of normalized image height is mapped to
              `[0, image_height - 1] in image height coordinates. We do allow y1 &amp;gt; y2, in
              which case the sampled crop is an up-down flipped version of the original
              image. The width dimension is treated similarly. Normalized coordinates
              outside the `[0, 1]` range are allowed, in which case we use
              `extrapolation_value` to extrapolate the input image values.
            </param>
            <param name="box_ind">
              A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`.
              The value of `box_ind[i]` specifies the image that the `i`-th box refers to.
            </param>
            <param name="image_size">
              A 1-D tensor with value `[batch, image_height, image_width, depth]`
              containing the original image size. Both `image_height` and `image_width` need
              to be positive.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CropAndResizeGradImage'.
            </param>
            <param name="method">
              Optional argument
              A string specifying the interpolation method. Only 'bilinear' is
              supported for now.
            </param>
            <param name="T">
            </param>
            <returns>
              A 4-D tensor of shape `[batch, image_height, image_width, depth]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Cross(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Compute the pairwise cross product.
            </summary>
            <param name="a">
              A tensor containing 3-element vectors.
            </param>
            <param name="b">
              Another tensor, of same type and shape as `a`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Cross'.
            </param>
            <returns>
              Pairwise cross product of the vectors in `a` and `b`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `a` and `b` must be the same shape; they can either be simple 3-element vectors,
              or any shape where the innermost dimension is 3. In the latter case, each pair
              of corresponding 3-element vectors is cross-multiplied independently.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.CTCBeamSearchDecoder(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)">
            <summary>
              Performs beam search decoding on the logits given in input.
            </summary>
            <param name="inputs">
              3-D, shape: `(max_time x batch_size x num_classes)`, the logits.
            </param>
            <param name="sequence_length">
              A vector containing sequence lengths, size `(batch)`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CTCBeamSearchDecoder'.
            </param>
            <param name="merge_repeated">
              Optional argument
              If true, merge repeated classes in output.
            </param>
            <param name="beam_width">
              A scalar &amp;gt;= 0 (beam search beam width).
            </param>
            <param name="top_paths">
              A scalar &amp;gt;= 0, &amp;lt;= beam_width (controls output size).
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              decoded_indices: A list (length: top_paths) of indices matrices.  Matrix j,
              size `(total_decoded_outputs[j] x 2)`, has indices of a
              `SparseTensor&amp;lt;int64, 2&amp;gt;`.  The rows store: [batch, time].
              decoded_values: A list (length: top_paths) of values vectors.  Vector j,
              size `(length total_decoded_outputs[j])`, has the values of a
              `SparseTensor&amp;lt;int64, 2&amp;gt;`.  The vector stores the decoded classes for beam j.
              decoded_shape: A list (length: top_paths) of shape vector.  Vector j,
              size `(2)`, stores the shape of the decoded `SparseTensor[j]`.
              Its values are: `[batch_size, max_decoded_length[j]]`.
              log_probability: A matrix, shaped: `(batch_size x top_paths)`.  The
              sequence log-probabilities.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              A note about the attribute merge_repeated: For the beam search decoder,
              this means that if consecutive entries in a beam are the same, only
              the first of these is emitted.  That is, when the top path is "A B B B B",
              "A B" is returned if merge_repeated = True but "A B B B B" is
              returned if merge_repeated = False.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.CTCGreedyDecoder(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Performs greedy decoding on the logits given in inputs.
            </summary>
            <param name="inputs">
              3-D, shape: `(max_time x batch_size x num_classes)`, the logits.
            </param>
            <param name="sequence_length">
              A vector containing sequence lengths, size `(batch_size)`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CTCGreedyDecoder'.
            </param>
            <param name="merge_repeated">
              Optional argument
              If True, merge repeated classes in output.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              decoded_indices: Indices matrix, size `(total_decoded_outputs x 2)`,
              of a `SparseTensor&amp;lt;int64, 2&amp;gt;`.  The rows store: [batch, time].
              decoded_values: Values vector, size: `(total_decoded_outputs)`,
              of a `SparseTensor&amp;lt;int64, 2&amp;gt;`.  The vector stores the decoded classes.
              decoded_shape: Shape vector, size `(2)`, of the decoded SparseTensor.
              Values are: `[batch_size, max_decoded_length]`.
              log_probability: Matrix, size `(batch_size x 1)`, containing sequence
              log-probabilities.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              A note about the attribute merge_repeated: if enabled, when
              consecutive logits' maximum indices are the same, only the first of
              these is emitted.  Labeling the blank '*', the sequence "A B B * B B"
              becomes "A B B" if merge_repeated = True and "A B B B B" if
              merge_repeated = False.
              
              Regardless of the value of merge_repeated, if the maximum index of a given
              time and batch corresponds to the blank, index `(num_classes - 1)`, no new
              element is emitted.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.CTCLoss(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Calculates the CTC Loss (log probability) for each batch entry.  Also calculates
            </summary>
            <param name="inputs">
              3-D, shape: `(max_time x batch_size x num_classes)`, the logits.
            </param>
            <param name="labels_indices">
              The indices of a `SparseTensor&amp;lt;int32, 2&amp;gt;`.
              `labels_indices(i, :) == [b, t]` means `labels_values(i)` stores the id for
              `(batch b, time t)`.
            </param>
            <param name="labels_values">
              The values (labels) associated with the given batch and time.
            </param>
            <param name="sequence_length">
              A vector containing sequence lengths (batch).
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'CTCLoss'.
            </param>
            <param name="preprocess_collapse_repeated">
              Optional argument
              Scalar, if true then repeated labels are
              collapsed prior to the CTC calculation.
            </param>
            <param name="ctc_merge_repeated">
              Optional argument
              Scalar.  If set to false, *during* CTC calculation
              repeated non-blank labels will not be merged and are interpreted as
              individual labels.  This is a simplified version of CTC.
            </param>
            <param name="ignore_longer_outputs_than_inputs">
              Optional argument
              Scalar. If set to true, during CTC
              calculation, items that have longer output sequences than input sequences
              are skipped: they don't contribute to the loss term and have zero-gradient.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              loss: A vector (batch) containing log-probabilities.
              gradient: The gradient of `loss`.  3-D, shape:
              `(max_time x batch_size x num_classes)`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              the gradient.  This class performs the softmax operation for you, so inputs
              should be e.g. linear projections of outputs by an LSTM.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Cumprod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Compute the cumulative product of the tensor `x` along `axis`.
            </summary>
            <param name="x">
              A `Tensor`. Must be one of the following types: `float32`, `float64`,
              `int64`, `int32`, `uint8`, `uint16`, `int16`, `int8`, `complex64`,
              `complex128`, `qint8`, `quint8`, `qint32`, `half`.
            </param>
            <param name="axis">
              A `Tensor` of type `int32` (default: 0). Must be in the range
              `[-rank(x), rank(x))`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Cumprod'.
            </param>
            <param name="exclusive">
              Optional argument
              If `True`, perform exclusive cumprod.
            </param>
            <param name="reverse">
              Optional argument
              A `bool` (default: False).
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              By default, this op performs an inclusive cumprod, which means that the first
              element of the input is identical to the first element of the output:
              
              ```python
              tf.cumprod([a, b, c])  # =&amp;gt; [a, a * b, a * b * c]
              ```
              
              By setting the `exclusive` kwarg to `True`, an exclusive cumprod is
              performed instead:
              
              ```python
              tf.cumprod([a, b, c], exclusive=True)  # =&amp;gt; [1, a, a * b]
              ```
              
              By setting the `reverse` kwarg to `True`, the cumprod is performed in the
              opposite direction:
              
              ```python
              tf.cumprod([a, b, c], reverse=True)  # =&amp;gt; [a * b * c, b * c, c]
              ```
              
              This is more efficient than using separate `tf.reverse` ops.
              
              The `reverse` and `exclusive` kwargs can also be combined:
              
              ```python
              tf.cumprod([a, b, c], exclusive=True, reverse=True)  # =&amp;gt; [b * c, c, 1]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Cumsum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Compute the cumulative sum of the tensor `x` along `axis`.
            </summary>
            <param name="x">
              A `Tensor`. Must be one of the following types: `float32`, `float64`,
              `int64`, `int32`, `uint8`, `uint16`, `int16`, `int8`, `complex64`,
              `complex128`, `qint8`, `quint8`, `qint32`, `half`.
            </param>
            <param name="axis">
              A `Tensor` of type `int32` (default: 0). Must be in the range
              `[-rank(x), rank(x))`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Cumsum'.
            </param>
            <param name="exclusive">
              Optional argument
              If `True`, perform exclusive cumsum.
            </param>
            <param name="reverse">
              Optional argument
              A `bool` (default: False).
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              By default, this op performs an inclusive cumsum, which means that the first
              element of the input is identical to the first element of the output:
              
              ```python
              tf.cumsum([a, b, c])  # =&amp;gt; [a, a + b, a + b + c]
              ```
              
              By setting the `exclusive` kwarg to `True`, an exclusive cumsum is
              performed instead:
              
              ```python
              tf.cumsum([a, b, c], exclusive=True)  # =&amp;gt; [0, a, a + b]
              ```
              
              By setting the `reverse` kwarg to `True`, the cumsum is performed in the
              opposite direction:
              
              ```python
              tf.cumsum([a, b, c], reverse=True)  # =&amp;gt; [a + b + c, b + c, c]
              ```
              
              This is more efficient than using separate `tf.reverse` ops.
              
              The `reverse` and `exclusive` kwargs can also be combined:
              
              ```python
              tf.cumsum([a, b, c], exclusive=True, reverse=True)  # =&amp;gt; [b + c, c, 0]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DataFormatDimMap(TensorFlow.TFOutput,System.String,System.String,System.String)">
            <summary>
              Returns the dimension index in the destination data format given the one in
            </summary>
            <param name="x">
              Scalar. Dimension index in source data format. Must be in the range [-4, 4).
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DataFormatDimMap'.
            </param>
            <param name="src_format">
              Optional argument
              source data format.
            </param>
            <param name="dst_format">
              Optional argument
              destination data format.
            </param>
            <returns>
              Scalar. Dimension index in destination data format.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              the source data format.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DataFormatVecPermute(TensorFlow.TFOutput,System.String,System.String,System.String)">
            <summary>
              Returns the permuted vector in the destination data format given the one in
            </summary>
            <param name="x">
              Vector in source data format. Must be of size 4.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DataFormatVecPermute'.
            </param>
            <param name="src_format">
              Optional argument
              source data format.
            </param>
            <param name="dst_format">
              Optional argument
              destination data format.
            </param>
            <returns>
              Vector in destination data format. Must be of size 4.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              the source data format.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DatasetToSingleElement(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Outputs the single element from the given dataset.
            </summary>
            <param name="dataset">
              A handle to a dataset that contains a single element.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DatasetToSingleElement'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The components of the single element of `input`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.DebugGradientIdentity(TensorFlow.TFOutput,System.String)">
            <summary>
              Identity op for gradient debugging.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugGradientIdentity'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op is hidden from public in Python. It is used by TensorFlow Debugger to
              register gradient tensors for gradient debugging.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DecodeAndCropJpeg(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Single},System.String,System.String)">
            <summary>
              Decode and Crop a JPEG-encoded image to a uint8 tensor.
            </summary>
            <param name="contents">
              0-D.  The JPEG-encoded image.
            </param>
            <param name="crop_window">
              1-D.  The crop window: [crop_y, crop_x, crop_height, crop_width].
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeAndCropJpeg'.
            </param>
            <param name="channels">
              Optional argument
              Number of color channels for the decoded image.
            </param>
            <param name="ratio">
              Optional argument
              Downscaling ratio.
            </param>
            <param name="fancy_upscaling">
              Optional argument
              If true use a slower but nicer upscaling of the
              chroma planes (yuv420/422 only).
            </param>
            <param name="try_recover_truncated">
              Optional argument
              If true try to recover an image from truncated input.
            </param>
            <param name="acceptable_fraction">
              Optional argument
              The minimum required fraction of lines before a truncated
              input is accepted.
            </param>
            <param name="dct_method">
              Optional argument
              string specifying a hint about the algorithm used for
              decompression.  Defaults to "" which maps to a system-specific
              default.  Currently valid values are ["INTEGER_FAST",
              "INTEGER_ACCURATE"].  The hint may be ignored (e.g., the internal
              jpeg library changes to a version that does not have that specific
              option.)
            </param>
            <returns>
              3-D with shape `[height, width, channels]`..
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The attr `channels` indicates the desired number of color channels for the
              decoded image.
              
              Accepted values are:
              
              *   0: Use the number of channels in the JPEG-encoded image.
              *   1: output a grayscale image.
              *   3: output an RGB image.
              
              If needed, the JPEG-encoded image is transformed to match the requested number
              of color channels.
              
              The attr `ratio` allows downscaling the image by an integer factor during
              decoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than
              downscaling the image later.
              
              
              It is equivalent to a combination of decode and crop, but much faster by only
              decoding partial jpeg image.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DecodeBase64(TensorFlow.TFOutput,System.String)">
            <summary>
              Decode web-safe base64-encoded strings.
            </summary>
            <param name="input">
              Base64 strings to decode.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeBase64'.
            </param>
            <returns>
              Decoded strings.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Input may or may not have padding at the end. See EncodeBase64 for padding.
              Web-safe means that input must use - and _ instead of + and /.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DecodeBmp(TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)">
            <summary>
              Decode the first frame of a BMP-encoded image to a uint8 tensor.
            </summary>
            <param name="contents">
              0-D.  The BMP-encoded image.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeBmp'.
            </param>
            <param name="channels">
              Optional argument
            </param>
            <returns>
              3-D with shape `[height, width, channels]`. RGB order
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The attr `channels` indicates the desired number of color channels for the
              decoded image.
              
              Accepted values are:
              
              *   0: Use the number of channels in the BMP-encoded image.
              *   3: output an RGB image.
              *   4: output an RGBA image.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DecodeCSV(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String,System.Nullable{System.Boolean},System.String,System.String)">
            <summary>
              Convert CSV records to tensors. Each column maps to one tensor.
            </summary>
            <param name="records">
              Each string is a record/row in the csv and all records should have
              the same format.
            </param>
            <param name="record_defaults">
              One tensor per column of the input record, with either a
              scalar default value for that column or empty if the column is required.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeCSV'.
            </param>
            <param name="field_delim">
              Optional argument
              char delimiter to separate fields in a record.
            </param>
            <param name="use_quote_delim">
              Optional argument
              If false, treats double quotation marks as regular
              characters inside of the string fields (ignoring RFC 4180, Section 2,
              Bullet 5).
            </param>
            <param name="na_value">
              Optional argument
              Additional string to recognize as NA/NaN.
            </param>
            <returns>
              Each tensor will have the same shape as records.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              RFC 4180 format is expected for the CSV records.
              (https://tools.ietf.org/html/rfc4180)
              Note that we allow leading and trailing spaces with int or float field.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DecodeGif(TensorFlow.TFOutput,System.String)">
            <summary>
              Decode the first frame of a GIF-encoded image to a uint8 tensor.
            </summary>
            <param name="contents">
              0-D.  The GIF-encoded image.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeGif'.
            </param>
            <returns>
              4-D with shape `[num_frames, height, width, 3]`. RGB order
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              GIF with frame or transparency compression are not supported
              convert animated GIF from compressed to uncompressed by:
              
                  convert $src.gif -coalesce $dst.gif
              
              This op also supports decoding JPEGs and PNGs, though it is cleaner to use
              `tf.image.decode_image`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DecodeJpeg(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Single},System.String,System.String)">
            <summary>
              Decode a JPEG-encoded image to a uint8 tensor.
            </summary>
            <param name="contents">
              0-D.  The JPEG-encoded image.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeJpeg'.
            </param>
            <param name="channels">
              Optional argument
              Number of color channels for the decoded image.
            </param>
            <param name="ratio">
              Optional argument
              Downscaling ratio.
            </param>
            <param name="fancy_upscaling">
              Optional argument
              If true use a slower but nicer upscaling of the
              chroma planes (yuv420/422 only).
            </param>
            <param name="try_recover_truncated">
              Optional argument
              If true try to recover an image from truncated input.
            </param>
            <param name="acceptable_fraction">
              Optional argument
              The minimum required fraction of lines before a truncated
              input is accepted.
            </param>
            <param name="dct_method">
              Optional argument
              string specifying a hint about the algorithm used for
              decompression.  Defaults to "" which maps to a system-specific
              default.  Currently valid values are ["INTEGER_FAST",
              "INTEGER_ACCURATE"].  The hint may be ignored (e.g., the internal
              jpeg library changes to a version that does not have that specific
              option.)
            </param>
            <returns>
              3-D with shape `[height, width, channels]`..
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The attr `channels` indicates the desired number of color channels for the
              decoded image.
              
              Accepted values are:
              
              *   0: Use the number of channels in the JPEG-encoded image.
              *   1: output a grayscale image.
              *   3: output an RGB image.
              
              If needed, the JPEG-encoded image is transformed to match the requested number
              of color channels.
              
              The attr `ratio` allows downscaling the image by an integer factor during
              decoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than
              downscaling the image later.
              
              
              This op also supports decoding PNGs and non-animated GIFs since the interface is
              the same, though it is cleaner to use `tf.image.decode_image`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DecodeJSONExample(TensorFlow.TFOutput,System.String)">
            <summary>
              Convert JSON-encoded Example records to binary protocol buffer strings.
            </summary>
            <param name="json_examples">
              Each string is a JSON object serialized according to the JSON
              mapping of the Example proto.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeJSONExample'.
            </param>
            <returns>
              Each string is a binary Example protocol buffer corresponding
              to the respective element of `json_examples`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op translates a tensor containing Example records, encoded using
              the [standard JSON
              mapping](https://developers.google.com/protocol-buffers/docs/proto3#json),
              into a tensor containing the same records encoded as binary protocol
              buffers. The resulting tensor can then be fed to any of the other
              Example-parsing ops.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DecodePng(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Decode a PNG-encoded image to a uint8 or uint16 tensor.
            </summary>
            <param name="contents">
              0-D.  The PNG-encoded image.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodePng'.
            </param>
            <param name="channels">
              Optional argument
              Number of color channels for the decoded image.
            </param>
            <param name="dtype">
              Optional argument
            </param>
            <returns>
              3-D with shape `[height, width, channels]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The attr `channels` indicates the desired number of color channels for the
              decoded image.
              
              Accepted values are:
              
              *   0: Use the number of channels in the PNG-encoded image.
              *   1: output a grayscale image.
              *   3: output an RGB image.
              *   4: output an RGBA image.
              
              If needed, the PNG-encoded image is transformed to match the requested number
              of color channels.
              
              This op also supports decoding JPEGs and non-animated GIFs since the interface
              is the same, though it is cleaner to use `tf.image.decode_image`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DecodeRaw(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)">
            <summary>
              Reinterpret the bytes of a string as a vector of numbers.
            </summary>
            <param name="bytes">
              All the elements must have the same length.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeRaw'.
            </param>
            <param name="little_endian">
              Optional argument
              Whether the input `bytes` are in little-endian order.
              Ignored for `out_type` values that are stored in a single byte like
              `uint8`.
            </param>
            <param name="out_type">
            </param>
            <returns>
              A Tensor with one more dimension than the input `bytes`.  The
              added dimension will have size equal to the length of the elements
              of `bytes` divided by the number of bytes to represent `out_type`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.DecodeWav(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Decode a 16-bit PCM WAV file to a float tensor.
            </summary>
            <param name="contents">
              The WAV-encoded audio, usually from a file.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeWav'.
            </param>
            <param name="desired_channels">
              Optional argument
              Number of sample channels wanted.
            </param>
            <param name="desired_samples">
              Optional argument
              Length of audio requested.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              audio: 2-D with shape `[length, channels]`.
              sample_rate: Scalar holding the sample rate found in the WAV header.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              The -32768 to 32767 signed 16-bit values will be scaled to -1.0 to 1.0 in float.
              
              When desired_channels is set, if the input contains fewer channels than this
              then the last channel will be duplicated to give the requested number, else if
              the input has more channels than requested then the additional channels will be
              ignored.
              
              If desired_samples is set, then the audio will be cropped or padded with zeroes
              to the requested length.
              
              The first output contains a Tensor with the content of the audio samples. The
              lowest dimension will be the number of channels, and the second will be the
              number of samples. For example, a ten-sample-long stereo WAV file should give an
              output shape of [10, 2].
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DeleteSessionTensor(TensorFlow.TFOutput,System.String)">
            <summary>
              Delete the tensor specified by its handle in the session.
            </summary>
            <param name="handle">
              The handle for a tensor stored in the session state.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DeleteSessionTensor'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.DenseToDenseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
              Applies set operation along last dimension of 2 `Tensor` inputs.
            </summary>
            <param name="set1">
              `Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set2`.
              Dimension `n` contains values in a set, duplicates are allowed but ignored.
            </param>
            <param name="set2">
              `Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set1`.
              Dimension `n` contains values in a set, duplicates are allowed but ignored.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DenseToDenseSetOperation'.
            </param>
            <param name="validate_indices">
              Optional argument
            </param>
            <param name="set_operation">
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              result_indices: 2D indices of a `SparseTensor`.
              result_values: 1D values of a `SparseTensor`.
              result_shape: 1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is
              the same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]`
              is the max result set size across all `0...n-1` dimensions.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              See SetOperationOp::SetOperationFromContext for values of `set_operation`.
              
              Output `result` is a `SparseTensor` represented by `result_indices`,
              `result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this
              has rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`
              dimension contains the result of `set_operation` applied to the corresponding
              `[0...n-1]` dimension of `set`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DenseToSparseBatchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that yields a SparseTensor for each element of the input.
            </summary>
            <param name="input_dataset">
              A handle to an input dataset. Must have a single component.
            </param>
            <param name="batch_size">
              A scalar representing the number of elements to accumulate in a
              batch.
            </param>
            <param name="row_shape">
              A vector representing the dense shape of each row in the produced
              SparseTensor. The shape may be partially specified, using `-1` to indicate
              that a particular dimension should use the maximum size of all batch elements.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DenseToSparseBatchDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.DenseToSparseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
              Applies set operation along last dimension of `Tensor` and `SparseTensor`.
            </summary>
            <param name="set1">
              `Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set2`.
              Dimension `n` contains values in a set, duplicates are allowed but ignored.
            </param>
            <param name="set2_indices">
              2D `Tensor`, indices of a `SparseTensor`. Must be in row-major
              order.
            </param>
            <param name="set2_values">
              1D `Tensor`, values of a `SparseTensor`. Must be in row-major
              order.
            </param>
            <param name="set2_shape">
              1D `Tensor`, shape of a `SparseTensor`. `set2_shape[0...n-1]` must
              be the same as the 1st `n-1` dimensions of `set1`, `result_shape[n]` is the
              max set size across `n-1` dimensions.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DenseToSparseSetOperation'.
            </param>
            <param name="validate_indices">
              Optional argument
            </param>
            <param name="set_operation">
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              result_indices: 2D indices of a `SparseTensor`.
              result_values: 1D values of a `SparseTensor`.
              result_shape: 1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is
              the same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]`
              is the max result set size across all `0...n-1` dimensions.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              See SetOperationOp::SetOperationFromContext for values of `set_operation`.
              
              Input `set2` is a `SparseTensor` represented by `set2_indices`, `set2_values`,
              and `set2_shape`. For `set2` ranked `n`, 1st `n-1` dimensions must be the same
              as `set1`. Dimension `n` contains values in a set, duplicates are allowed but
              ignored.
              
              If `validate_indices` is `True`, this op validates the order and range of `set2`
              indices.
              
              Output `result` is a `SparseTensor` represented by `result_indices`,
              `result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this
              has rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`
              dimension contains the result of `set_operation` applied to the corresponding
              `[0...n-1]` dimension of `set`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DepthToSpace(TensorFlow.TFOutput,System.Int64,System.String,System.String)">
            <summary>
              DepthToSpace for tensors of type T.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthToSpace'.
            </param>
            <param name="data_format">
              Optional argument
            </param>
            <param name="block_size">
              The size of the spatial block, same as in Space2Depth.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Rearranges data from depth into blocks of spatial data.
              This is the reverse transformation of SpaceToDepth. More specifically,
              this op outputs a copy of the input tensor where values from the `depth`
              dimension are moved in spatial blocks to the `height` and `width` dimensions.
              The attr `block_size` indicates the input block size and how the data is moved.
              
                * Chunks of data of size `block_size * block_size` from depth are rearranged
                  into non-overlapping blocks of size `block_size x block_size`
                * The width the output tensor is `input_depth * block_size`, whereas the
                  height is `input_height * block_size`.
                * The Y, X coordinates within each block of the output image are determined
                  by the high order component of the input channel index.
                * The depth of the input tensor must be divisible by
                  `block_size * block_size`.
              
              The `data_format` attr specifies the layout of the input and output tensors
              with the following options:
                "NHWC": `[ batch, height, width, channels ]`
                "NCHW": `[ batch, channels, height, width ]`
                "NCHW_VECT_C":
                    `qint8 [ batch, channels / 4, height, width, 4 ]`
              
              It is useful to consider the operation as transforming a 6-D Tensor.
              e.g. for data_format = NHWC,
                   Each element in the input tensor can be specified via 6 coordinates,
                   ordered by decreasing memory layout significance as:
                   n,iY,iX,bY,bX,oC  (where n=batch index, iX, iY means X or Y coordinates
                                      within the input image, bX, bY means coordinates
                                      within the output block, oC means output channels).
                   The output would be the input transposed to the following layout:
                   n,iY,bY,iX,bX,oC
              
              This operation is useful for resizing the activations between convolutions
              (but keeping all data), e.g. instead of pooling. It is also useful for training
              purely convolutional models.
              
              For example, given an input of shape `[1, 1, 1, 4]`, data_format = "NHWC" and
              block_size = 2:
              
              ```
              x = [[[[1, 2, 3, 4]]]]
              
              ```
              
              This operation will output a tensor of shape `[1, 2, 2, 1]`:
              
              ```
                 [[[[1], [2]],
                   [[3], [4]]]]
              ```
              
              Here, the input has a batch of 1 and each batch element has shape `[1, 1, 4]`,
              the corresponding output will have 2x2 elements and will have a depth of
              1 channel (1 = `4 / (block_size * block_size)`).
              The output element shape is `[2, 2, 1]`.
              
              For an input tensor with larger depth, here of shape `[1, 1, 1, 12]`, e.g.
              
              ```
              x = [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]
              ```
              
              This operation, for block size of 2, will return the following tensor of shape
              `[1, 2, 2, 3]`
              
              ```
                 [[[[1, 2, 3], [4, 5, 6]],
                   [[7, 8, 9], [10, 11, 12]]]]
              
              ```
              
              Similarly, for the following input of shape `[1 2 2 4]`, and a block size of 2:
              
              ```
              x =  [[[[1, 2, 3, 4],
                     [5, 6, 7, 8]],
                    [[9, 10, 11, 12],
                     [13, 14, 15, 16]]]]
              ```
              
              the operator will return the following tensor of shape `[1 4 4 1]`:
              
              ```
              x = [[[ [1],   [2],  [5],  [6]],
                    [ [3],   [4],  [7],  [8]],
                    [ [9],  [10], [13],  [14]],
                    [ [11], [12], [15],  [16]]]]
              
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DepthwiseConv2dNative(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)">
            <summary>
              Computes a 2-D depthwise convolution given 4-D `input` and `filter` tensors.
            </summary>
            <param name="input">
            </param>
            <param name="filter">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthwiseConv2dNative'.
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, height, width, channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, channels, height, width].
            </param>
            <param name="dilations">
              Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              `input`. If set to k &amp;gt; 1, there will be k-1 skipped cells between each filter
              element on that dimension. The dimension order is determined by the value of
              `data_format`, see above for details. Dilations in the batch and depth
              dimensions must be 1.
            </param>
            <param name="strides">
              1-D of length 4.  The stride of the sliding window for each dimension
              of `input`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given an input tensor of shape `[batch, in_height, in_width, in_channels]`
              and a filter / kernel tensor of shape
              `[filter_height, filter_width, in_channels, channel_multiplier]`, containing
              `in_channels` convolutional filters of depth 1, `depthwise_conv2d` applies
              a different filter to each input channel (expanding from 1 channel to
              `channel_multiplier` channels for each), then concatenates the results
              together. Thus, the output has `in_channels * channel_multiplier` channels.
              
              ```
              for k in 0..in_channels-1
                for q in 0..channel_multiplier-1
                  output[b, i, j, k * channel_multiplier + q] =
                    sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
                                      filter[di, dj, k, q]
              ```
              
              Must have `strides[0] = strides[3] = 1`.  For the most common case of the same
              horizontal and vertices strides, `strides = [1, stride, stride, 1]`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)">
            <summary>
              Computes the gradients of depthwise convolution with respect to the filter.
            </summary>
            <param name="input">
              4-D with shape based on `data_format`.  For example, if
              `data_format` is 'NHWC' then `input` is a 4-D `[batch, in_height,
              in_width, in_channels]` tensor.
            </param>
            <param name="filter_sizes">
              An integer vector representing the tensor shape of `filter`,
              where `filter` is a 4-D
              `[filter_height, filter_width, in_channels, depthwise_multiplier]` tensor.
            </param>
            <param name="out_backprop">
              4-D with shape  based on `data_format`.
              For example, if `data_format` is 'NHWC' then
              out_backprop shape is `[batch, out_height, out_width, out_channels]`.
              Gradients w.r.t. the output of the convolution.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthwiseConv2dNativeBackpropFilter'.
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, height, width, channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, channels, height, width].
            </param>
            <param name="dilations">
              Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              `input`. If set to k &amp;gt; 1, there will be k-1 skipped cells between each filter
              element on that dimension. The dimension order is determined by the value of
              `data_format`, see above for details. Dilations in the batch and depth
              dimensions must be 1.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the input
              of the convolution.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              4-D with shape
              `[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t.
              the `filter` input of the convolution.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)">
            <summary>
              Computes the gradients of depthwise convolution with respect to the input.
            </summary>
            <param name="input_sizes">
              An integer vector representing the shape of `input`, based
              on `data_format`.  For example, if `data_format` is 'NHWC' then
               `input` is a 4-D `[batch, height, width, channels]` tensor.
            </param>
            <param name="filter">
              4-D with shape
              `[filter_height, filter_width, in_channels, depthwise_multiplier]`.
            </param>
            <param name="out_backprop">
              4-D with shape  based on `data_format`.
              For example, if `data_format` is 'NHWC' then
              out_backprop shape is `[batch, out_height, out_width, out_channels]`.
              Gradients w.r.t. the output of the convolution.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthwiseConv2dNativeBackpropInput'.
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, height, width, channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, channels, height, width].
            </param>
            <param name="dilations">
              Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              `input`. If set to k &amp;gt; 1, there will be k-1 skipped cells between each filter
              element on that dimension. The dimension order is determined by the value of
              `data_format`, see above for details. Dilations in the batch and depth
              dimensions must be 1.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the input
              of the convolution.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              4-D with shape according to `data_format`.  For example, if
              `data_format` is 'NHWC', output shape is `[batch, in_height,
              in_width, in_channels]`.  Gradient w.r.t. the input of the
              convolution.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Dequantize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">
            <summary>
              Dequantize the 'input' tensor into a float Tensor.
            </summary>
            <param name="input">
            </param>
            <param name="min_range">
              The minimum scalar value possibly produced for the input.
            </param>
            <param name="max_range">
              The maximum scalar value possibly produced for the input.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Dequantize'.
            </param>
            <param name="mode">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              [min_range, max_range] are scalar floats that specify the range for
              the 'input' data. The 'mode' attribute controls exactly which calculations are
              used to convert the float values to their quantized equivalents.
              
              In 'MIN_COMBINED' mode, each value of the tensor will undergo the following:
              
              ```
              if T == qint8, in[i] += (range(T) + 1)/ 2.0
              out[i] = min_range + (in[i]* (max_range - min_range) / range(T))
              ```
              here `range(T) = numeric_limits&amp;lt;T&amp;gt;::max() - numeric_limits&amp;lt;T&amp;gt;::min()`
              
              *MIN_COMBINED Mode Example*
              
              If the input comes from a QuantizedRelu6, the output type is
              quint8 (range of 0-255) but the possible range of QuantizedRelu6 is
              0-6.  The min_range and max_range values are therefore 0.0 and 6.0.
              Dequantize on quint8 will take each value, cast to float, and multiply
              by 6 / 255.
              Note that if quantizedtype is qint8, the operation will additionally add
              each value by 128 prior to casting.
              
              If the mode is 'MIN_FIRST', then this approach is used:
              
              ```c++
              num_discrete_values = 1 &amp;lt;&amp;lt; (# of bits in T)
              range_adjust = num_discrete_values / (num_discrete_values - 1)
              range = (range_max - range_min) * range_adjust
              range_scale = range / num_discrete_values
              const double offset_input = static_cast&amp;lt;double&amp;gt;(input) - lowest_quantized;
              result = range_min + ((input - numeric_limits&amp;lt;T&amp;gt;::min()) * range_scale)
              ```
              
              *SCALED mode Example*
              
              `SCALED` mode matches the quantization approach used in
              `QuantizeAndDequantize{V2|V3}`.
              
              If the mode is `SCALED`, we do not use the full range of the output type,
              choosing to elide the lowest possible value for symmetry (e.g., output range is
              -127 to 127, not -128 to 127 for signed 8 bit quantization), so that 0.0 maps to
              0.
              
              We first find the range of values in our tensor. The
              range we use is always centered on 0, so we find m such that
              ```c++
                m = max(abs(input_min), abs(input_max))
              ```
              
              Our input tensor range is then `[-m, m]`.
              
              Next, we choose our fixed-point quantization buckets, `[min_fixed, max_fixed]`.
              If T is signed, this is
              ```
                num_bits = sizeof(T) * 8
                [min_fixed, max_fixed] =
                    [-(1 &amp;lt;&amp;lt; (num_bits - 1) - 1), (1 &amp;lt;&amp;lt; (num_bits - 1)) - 1]
              ```
              
              Otherwise, if T is unsigned, the fixed-point range is
              ```
                [min_fixed, max_fixed] = [0, (1 &amp;lt;&amp;lt; num_bits) - 1]
              ```
              
              From this we compute our scaling factor, s:
              ```c++
                s = (2 * m) / (max_fixed - min_fixed)
              ```
              
              Now we can dequantize the elements of our tensor:
              ```c++
              result = input * s
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DeserializeIterator(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Converts the given variant tensor to an iterator and stores it in the given resource.
            </summary>
            <param name="resource_handle">
              A handle to an iterator resource.
            </param>
            <param name="serialized">
              A variant tensor storing the state of the iterator contained in the
              resource.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DeserializeIterator'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.DeserializeManySparse(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Deserialize and concatenate `SparseTensors` from a serialized minibatch.
            </summary>
            <param name="serialized_sparse">
              2-D, The `N` serialized `SparseTensor` objects.
              Must have 3 columns.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DeserializeManySparse'.
            </param>
            <param name="dtype">
              The `dtype` of the serialized `SparseTensor` objects.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              sparse_indices: 
              sparse_values: 
              sparse_shape: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              The input `serialized_sparse` must be a string matrix of shape `[N x 3]` where
              `N` is the minibatch size and the rows correspond to packed outputs of
              `SerializeSparse`.  The ranks of the original `SparseTensor` objects
              must all match.  When the final `SparseTensor` is created, it has rank one
              higher than the ranks of the incoming `SparseTensor` objects
              (they have been concatenated along a new row dimension).
              
              The output `SparseTensor` object's shape values for all dimensions but the
              first are the max across the input `SparseTensor` objects' shape values
              for the corresponding dimensions.  Its first shape value is `N`, the minibatch
              size.
              
              The input `SparseTensor` objects' indices are assumed ordered in
              standard lexicographic order.  If this is not the case, after this
              step run `SparseReorder` to restore index ordering.
              
              For example, if the serialized input is a `[2 x 3]` matrix representing two
              original `SparseTensor` objects:
              
                  index = [ 0]
                          [10]
                          [20]
                  values = [1, 2, 3]
                  shape = [50]
              
              and
              
                  index = [ 2]
                          [10]
                  values = [4, 5]
                  shape = [30]
              
              then the final deserialized `SparseTensor` will be:
              
                  index = [0  0]
                          [0 10]
                          [0 20]
                          [1  2]
                          [1 10]
                  values = [1, 2, 3, 4, 5]
                  shape = [2 50]
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DeserializeSparse(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Deserialize `SparseTensor` objects.
            </summary>
            <param name="serialized_sparse">
              The serialized `SparseTensor` objects. The last dimension
              must have 3 columns.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DeserializeSparse'.
            </param>
            <param name="dtype">
              The `dtype` of the serialized `SparseTensor` objects.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              sparse_indices: 
              sparse_values: 
              sparse_shape: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              The input `serialized_sparse` must have the shape `[?, ?, ..., ?, 3]` where
              the last dimension stores serialized `SparseTensor` objects and the other N
              dimensions (N &amp;gt;= 0) correspond to a batch. The ranks of the original
              `SparseTensor` objects must all match. When the final `SparseTensor` is
              created, its rank is the rank of the incoming `SparseTensor` objects plus N;
              the sparse tensors have been concatenated along new dimensions, one for each
              batch.
              
              The output `SparseTensor` object's shape values for the original dimensions
              are the max across the input `SparseTensor` objects' shape values for the
              corresponding dimensions. The new dimensions match the size of the batch.
              
              The input `SparseTensor` objects' indices are assumed ordered in
              standard lexicographic order.  If this is not the case, after this
              step run `SparseReorder` to restore index ordering.
              
              For example, if the serialized input is a `[2 x 3]` matrix representing two
              original `SparseTensor` objects:
              
                  index = [ 0]
                          [10]
                          [20]
                  values = [1, 2, 3]
                  shape = [50]
              
              and
              
                  index = [ 2]
                          [10]
                  values = [4, 5]
                  shape = [30]
              
              then the final deserialized `SparseTensor` will be:
              
                  index = [0  0]
                          [0 10]
                          [0 20]
                          [1  2]
                          [1 10]
                  values = [1, 2, 3, 4, 5]
                  shape = [2 50]
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DestroyResourceOp(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Deletes the resource specified by the handle.
            </summary>
            <param name="resource">
              handle to the resource to delete.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DestroyResourceOp'.
            </param>
            <param name="ignore_lookup_error">
              Optional argument
              whether to ignore the error when the resource
              doesn't exist.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              All subsequent operations using the resource will result in a NotFound
              error status.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DestroyTemporaryVariable(TensorFlow.TFOutput,System.String,System.String)">
            <summary>
              Destroys the temporary variable and returns its final value.
            </summary>
            <param name="reference">
              A reference to the temporary variable tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DestroyTemporaryVariable'.
            </param>
            <param name="var_name">
              Name of the temporary variable, usually the name of the matching
              'TemporaryVariable' op.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Sets output to the value of the Tensor pointed to by 'ref', then destroys
              the temporary variable called 'var_name'.
              All other uses of 'ref' *must* have executed before this op.
              This is typically achieved by chaining the ref through each assign op, or by
              using control dependencies.
              
              Outputs the final value of the tensor pointed to by 'ref'.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Diag(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns a diagonal tensor with a given diagonal values.
            </summary>
            <param name="diagonal">
              Rank k tensor where k is at most 1.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Diag'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a `diagonal`, this operation returns a tensor with the `diagonal` and
              everything else padded with zeros. The diagonal is computed as follows:
              
              Assume `diagonal` has dimensions [D1,..., Dk], then the output is a tensor of
              rank 2k with dimensions [D1,..., Dk, D1,..., Dk] where:
              
              `output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]` and 0 everywhere else.
              
              For example:
              
              ```
              # 'diagonal' is [1, 2, 3, 4]
              tf.diag(diagonal) ==&amp;gt; [[1, 0, 0, 0]
                                     [0, 2, 0, 0]
                                     [0, 0, 3, 0]
                                     [0, 0, 0, 4]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DiagPart(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the diagonal part of the tensor.
            </summary>
            <param name="input">
              Rank k tensor where k is even and not zero.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DiagPart'.
            </param>
            <returns>
              The extracted diagonal.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation returns a tensor with the `diagonal` part
              of the `input`. The `diagonal` part is computed as follows:
              
              Assume `input` has dimensions `[D1,..., Dk, D1,..., Dk]`, then the output is a
              tensor of rank `k` with dimensions `[D1,..., Dk]` where:
              
              `diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]`.
              
              For example:
              
              ```
              # 'input' is [[1, 0, 0, 0]
                            [0, 2, 0, 0]
                            [0, 0, 3, 0]
                            [0, 0, 0, 4]]
              
              tf.diag_part(input) ==&amp;gt; [1, 2, 3, 4]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Digamma(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes Psi, the derivative of Lgamma (the log of the absolute value of
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Digamma'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `Gamma(x)`), element-wise.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Dilation2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
              Computes the grayscale dilation of 4-D `input` and 3-D `filter` tensors.
            </summary>
            <param name="input">
              4-D with shape `[batch, in_height, in_width, depth]`.
            </param>
            <param name="filter">
              3-D with shape `[filter_height, filter_width, depth]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Dilation2D'.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the input
              tensor. Must be: `[1, stride_height, stride_width, 1]`.
            </param>
            <param name="rates">
              The input stride for atrous morphological dilation. Must be:
              `[1, rate_height, rate_width, 1]`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              4-D with shape `[batch, out_height, out_width, depth]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The `input` tensor has shape `[batch, in_height, in_width, depth]` and the
              `filter` tensor has shape `[filter_height, filter_width, depth]`, i.e., each
              input channel is processed independently of the others with its own structuring
              function. The `output` tensor has shape
              `[batch, out_height, out_width, depth]`. The spatial dimensions of the output
              tensor depend on the `padding` algorithm. We currently only support the default
              "NHWC" `data_format`.
              
              In detail, the grayscale morphological 2-D dilation is the max-sum correlation
              (for consistency with `conv2d`, we use unmirrored filters):
              
                  output[b, y, x, c] =
                     max_{dy, dx} input[b,
                                        strides[1] * y + rates[1] * dy,
                                        strides[2] * x + rates[2] * dx,
                                        c] +
                                  filter[dy, dx, c]
              
              Max-pooling is a special case when the filter has size equal to the pooling
              kernel size and contains all zeros.
              
              Note on duality: The dilation of `input` by the `filter` is equal to the
              negation of the erosion of `-input` by the reflected `filter`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Dilation2DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
              Computes the gradient of morphological 2-D dilation with respect to the filter.
            </summary>
            <param name="input">
              4-D with shape `[batch, in_height, in_width, depth]`.
            </param>
            <param name="filter">
              3-D with shape `[filter_height, filter_width, depth]`.
            </param>
            <param name="out_backprop">
              4-D with shape `[batch, out_height, out_width, depth]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Dilation2DBackpropFilter'.
            </param>
            <param name="strides">
              1-D of length 4. The stride of the sliding window for each dimension of
              the input tensor. Must be: `[1, stride_height, stride_width, 1]`.
            </param>
            <param name="rates">
              1-D of length 4. The input stride for atrous morphological dilation.
              Must be: `[1, rate_height, rate_width, 1]`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              3-D with shape `[filter_height, filter_width, depth]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Dilation2DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
              Computes the gradient of morphological 2-D dilation with respect to the input.
            </summary>
            <param name="input">
              4-D with shape `[batch, in_height, in_width, depth]`.
            </param>
            <param name="filter">
              3-D with shape `[filter_height, filter_width, depth]`.
            </param>
            <param name="out_backprop">
              4-D with shape `[batch, out_height, out_width, depth]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Dilation2DBackpropInput'.
            </param>
            <param name="strides">
              1-D of length 4. The stride of the sliding window for each dimension of
              the input tensor. Must be: `[1, stride_height, stride_width, 1]`.
            </param>
            <param name="rates">
              1-D of length 4. The input stride for atrous morphological dilation.
              Must be: `[1, rate_height, rate_width, 1]`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              4-D with shape `[batch, in_height, in_width, depth]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Div(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns x / y element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Div'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `Div` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DrawBoundingBoxes(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Draw bounding boxes on a batch of images.
            </summary>
            <param name="images">
              4-D with shape `[batch, height, width, depth]`. A batch of images.
            </param>
            <param name="boxes">
              3-D with shape `[batch, num_bounding_boxes, 4]` containing bounding
              boxes.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DrawBoundingBoxes'.
            </param>
            <returns>
              4-D with the same shape as `images`. The batch of input images with
              bounding boxes drawn on the images.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Outputs a copy of `images` but draws on top of the pixels zero or more bounding
              boxes specified by the locations in `boxes`. The coordinates of the each
              bounding box in `boxes` are encoded as `[y_min, x_min, y_max, x_max]`. The
              bounding box coordinates are floats in `[0.0, 1.0]` relative to the width and
              height of the underlying image.
              
              For example, if an image is 100 x 200 pixels (height x width) and the bounding
              box is `[0.1, 0.2, 0.5, 0.9]`, the upper-left and bottom-right coordinates of
              the bounding box will be `(40, 10)` to `(100, 50)` (in (x,y) coordinates).
              
              Parts of the bounding box may fall outside the image.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DynamicPartition(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">
            <summary>
              Partitions `data` into `num_partitions` tensors using indices from `partitions`.
            </summary>
            <param name="data">
            </param>
            <param name="partitions">
              Any shape.  Indices in the range `[0, num_partitions)`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DynamicPartition'.
            </param>
            <param name="num_partitions">
              The number of partitions to output.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              For each index tuple `js` of size `partitions.ndim`, the slice `data[js, ...]`
              becomes part of `outputs[partitions[js]]`.  The slices with `partitions[js] = i`
              are placed in `outputs[i]` in lexicographic order of `js`, and the first
              dimension of `outputs[i]` is the number of entries in `partitions` equal to `i`.
              In detail,
              
              ```python
                  outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]
              
                  outputs[i] = pack([data[js, ...] for js if partitions[js] == i])
              ```
              
              `data.shape` must start with `partitions.shape`.
              
              For example:
              
              ```python
                  # Scalar partitions.
                  partitions = 1
                  num_partitions = 2
                  data = [10, 20]
                  outputs[0] = []  # Empty with shape [0, 2]
                  outputs[1] = [[10, 20]]
              
                  # Vector partitions.
                  partitions = [0, 0, 1, 1, 0]
                  num_partitions = 2
                  data = [10, 20, 30, 40, 50]
                  outputs[0] = [10, 20, 50]
                  outputs[1] = [30, 40]
              ```
              
              See `dynamic_stitch` for an example on how to merge partitions back.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/DynamicPartition.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.DynamicStitch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)">
            <summary>
              Interleave the values from the `data` tensors into a single tensor.
            </summary>
            <param name="indices">
            </param>
            <param name="data">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'DynamicStitch'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Builds a merged tensor such that
              
              ```python
                  merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]
              ```
              
              For example, if each `indices[m]` is scalar or vector, we have
              
              ```python
                  # Scalar indices:
                  merged[indices[m], ...] = data[m][...]
              
                  # Vector indices:
                  merged[indices[m][i], ...] = data[m][i, ...]
              ```
              
              Each `data[i].shape` must start with the corresponding `indices[i].shape`,
              and the rest of `data[i].shape` must be constant w.r.t. `i`.  That is, we
              must have `data[i].shape = indices[i].shape + constant`.  In terms of this
              `constant`, the output shape is
              
                  merged.shape = [max(indices)] + constant
              
              Values are merged in order, so if an index appears in both `indices[m][i]` and
              `indices[n][j]` for `(m,i) &amp;lt; (n,j)` the slice `data[n][j]` will appear in the
              merged result. If you do not need this guarantee, ParallelDynamicStitch might
              perform better on some devices.
              
              For example:
              
              ```python
                  indices[0] = 6
                  indices[1] = [4, 1]
                  indices[2] = [[5, 2], [0, 3]]
                  data[0] = [61, 62]
                  data[1] = [[41, 42], [11, 12]]
                  data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]
                  merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],
                            [51, 52], [61, 62]]
              ```
              
              This method can be used to merge partitions created by `dynamic_partition`
              as illustrated on the following example:
              
              ```python
                  # Apply function (increments x_i) on elements for which a certain condition
                  # apply (x_i != -1 in this example).
                  x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])
                  condition_mask=tf.not_equal(x,tf.constant(-1.))
                  partitioned_data = tf.dynamic_partition(
                      x, tf.cast(condition_mask, tf.int32) , 2)
                  partitioned_data[1] = partitioned_data[1] + 1.0
                  condition_indices = tf.dynamic_partition(
                      tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)
                  x = tf.dynamic_stitch(condition_indices, partitioned_data)
                  # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain
                  # unchanged.
              ```
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/DynamicStitch.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.EditDistance(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the (possibly normalized) Levenshtein Edit Distance.
            </summary>
            <param name="hypothesis_indices">
              The indices of the hypothesis list SparseTensor.
              This is an N x R int64 matrix.
            </param>
            <param name="hypothesis_values">
              The values of the hypothesis list SparseTensor.
              This is an N-length vector.
            </param>
            <param name="hypothesis_shape">
              The shape of the hypothesis list SparseTensor.
              This is an R-length vector.
            </param>
            <param name="truth_indices">
              The indices of the truth list SparseTensor.
              This is an M x R int64 matrix.
            </param>
            <param name="truth_values">
              The values of the truth list SparseTensor.
              This is an M-length vector.
            </param>
            <param name="truth_shape">
              truth indices, vector.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'EditDistance'.
            </param>
            <param name="normalize">
              Optional argument
              boolean (if true, edit distances are normalized by length of truth).
              
              The output is:
            </param>
            <returns>
              A dense float tensor with rank R - 1.
              
              For the example input:
              
                  // hypothesis represents a 2x1 matrix with variable-length values:
                  //   (0,0) = ["a"]
                  //   (1,0) = ["b"]
                  hypothesis_indices = [[0, 0, 0],
                                        [1, 0, 0]]
                  hypothesis_values = ["a", "b"]
                  hypothesis_shape = [2, 1, 1]
              
                  // truth represents a 2x2 matrix with variable-length values:
                  //   (0,0) = []
                  //   (0,1) = ["a"]
                  //   (1,0) = ["b", "c"]
                  //   (1,1) = ["a"]
                  truth_indices = [[0, 1, 0],
                                   [1, 0, 0],
                                   [1, 0, 1],
                                   [1, 1, 0]]
                  truth_values = ["a", "b", "c", "a"]
                  truth_shape = [2, 2, 2]
                  normalize = true
              
              The output will be:
              
                  // output is a 2x2 matrix with edit distances normalized by truth lengths.
                  output = [[inf, 1.0],  // (0,0): no truth, (0,1): no hypothesis
                            [0.5, 1.0]]  // (1,0): addition, (1,1): no hypothesis
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The inputs are variable-length sequences provided by SparseTensors
                (hypothesis_indices, hypothesis_values, hypothesis_shape)
              and
                (truth_indices, truth_values, truth_shape).
              
              The inputs are:
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Elu(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes exponential linear: `exp(features) - 1` if &amp;lt; 0, `features` otherwise.
            </summary>
            <param name="features">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Elu'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              See [Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)
              ](http://arxiv.org/abs/1511.07289)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.EluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes gradients for the exponential linear (Elu) operation.
            </summary>
            <param name="gradients">
              The backpropagated gradients to the corresponding Elu operation.
            </param>
            <param name="outputs">
              The outputs of the corresponding Elu operation.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'EluGrad'.
            </param>
            <returns>
              The gradients: `gradients * (outputs + 1)` if outputs &amp;lt; 0,
              `gradients` otherwise.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.EncodeBase64(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Encode strings into web-safe base64 format.
            </summary>
            <param name="input">
              Strings to be encoded.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeBase64'.
            </param>
            <param name="pad">
              Optional argument
              Bool whether padding is applied at the ends.
            </param>
            <returns>
              Input strings encoded in base64.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Refer to the following article for more information on base64 format:
              en.wikipedia.org/wiki/Base64. Base64 strings may have padding with '=' at the
              end so that the encoded has length multiple of 4. See Padding section of the
              link above.
              
              Web-safe means that the encoder uses - and _ instead of + and /.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.EncodeJpeg(TensorFlow.TFOutput,System.String,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String)">
            <summary>
              JPEG-encode an image.
            </summary>
            <param name="image">
              3-D with shape `[height, width, channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeJpeg'.
            </param>
            <param name="format">
              Optional argument
              Per pixel image format.
            </param>
            <param name="quality">
              Optional argument
              Quality of the compression from 0 to 100 (higher is better and slower).
            </param>
            <param name="progressive">
              Optional argument
              If True, create a JPEG that loads progressively (coarse to fine).
            </param>
            <param name="optimize_size">
              Optional argument
              If True, spend CPU/RAM to reduce size with no quality change.
            </param>
            <param name="chroma_downsampling">
              Optional argument
              See http://en.wikipedia.org/wiki/Chroma_subsampling.
            </param>
            <param name="density_unit">
              Optional argument
              Unit used to specify `x_density` and `y_density`:
              pixels per inch (`'in'`) or centimeter (`'cm'`).
            </param>
            <param name="x_density">
              Optional argument
              Horizontal pixels per density unit.
            </param>
            <param name="y_density">
              Optional argument
              Vertical pixels per density unit.
            </param>
            <param name="xmp_metadata">
              Optional argument
              If not empty, embed this XMP metadata in the image header.
            </param>
            <returns>
              0-D. JPEG-encoded image.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `image` is a 3-D uint8 Tensor of shape `[height, width, channels]`.
              
              The attr `format` can be used to override the color format of the encoded
              output.  Values can be:
              
              *   `''`: Use a default format based on the number of channels in the image.
              *   `grayscale`: Output a grayscale JPEG image.  The `channels` dimension
                  of `image` must be 1.
              *   `rgb`: Output an RGB JPEG image. The `channels` dimension
                  of `image` must be 3.
              
              If `format` is not specified or is the empty string, a default format is picked
              in function of the number of channels in `image`:
              
              *   1: Output a grayscale image.
              *   3: Output an RGB image.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.EncodePng(TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)">
            <summary>
              PNG-encode an image.
            </summary>
            <param name="image">
              3-D with shape `[height, width, channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodePng'.
            </param>
            <param name="compression">
              Optional argument
              Compression level.
            </param>
            <returns>
              0-D. PNG-encoded image.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `image` is a 3-D uint8 or uint16 Tensor of shape `[height, width, channels]`
              where `channels` is:
              
              *   1: for grayscale.
              *   2: for grayscale + alpha.
              *   3: for RGB.
              *   4: for RGBA.
              
              The ZLIB compression level, `compression`, can be -1 for the PNG-encoder
              default or a value from 0 to 9.  9 is the highest compression level, generating
              the smallest output, but is slower.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.EncodeWav(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Encode audio data using the WAV file format.
            </summary>
            <param name="audio">
              2-D with shape `[length, channels]`.
            </param>
            <param name="sample_rate">
              Scalar containing the sample frequency.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeWav'.
            </param>
            <returns>
              0-D. WAV-encoded file contents.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation will generate a string suitable to be saved out to create a .wav
              audio file. It will be encoded in the 16-bit PCM format. It takes in float
              values in the range -1.0f to 1.0f, and any outside that value will be clamped to
              that range.
              
              `audio` is a 2-D float Tensor of shape `[length, channels]`.
              `sample_rate` is a scalar Tensor holding the rate to use (e.g. 44100).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Enter(TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)">
            <summary>
              Creates or finds a child frame, and makes `data` available to the child frame.
            </summary>
            <param name="data">
              The tensor to be made available to the child frame.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Enter'.
            </param>
            <param name="is_constant">
              Optional argument
              If true, the output is constant within the child frame.
            </param>
            <param name="parallel_iterations">
              Optional argument
              The number of iterations allowed to run in parallel.
            </param>
            <param name="frame_name">
              The name of the child frame.
            </param>
            <returns>
              The same tensor as `data`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op is used together with `Exit` to create loops in the graph.
              The unique `frame_name` is used by the `Executor` to identify frames. If
              `is_constant` is true, `output` is a constant in the child frame; otherwise
              it may be changed in the child frame. At most `parallel_iterations` iterations
              are run in parallel in the child frame.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Equal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the truth value of (x == y) element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Equal'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `Equal` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Erf(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the Gauss error function of `x` element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Erf'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Erfc(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the complementary error function of `x` element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Erfc'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Exit(TensorFlow.TFOutput,System.String)">
            <summary>
              Exits the current frame to its parent frame.
            </summary>
            <param name="data">
              The tensor to be made available to the parent frame.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Exit'.
            </param>
            <returns>
              The same tensor as `data`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Exit makes its input `data` available to the parent frame.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Exp(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes exponential of x element-wise.  \\(y = e^x\\).
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Exp'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ExpandDims(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Inserts a dimension of 1 into a tensor's shape.
            </summary>
            <param name="input">
            </param>
            <param name="dim">
              0-D (scalar). Specifies the dimension index at which to
              expand the shape of `input`. Must be in the range
              `[-rank(input) - 1, rank(input)]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ExpandDims'.
            </param>
            <returns>
              Contains the same data as `input`, but its shape has an additional
              dimension of size 1 added.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a tensor `input`, this operation inserts a dimension of 1 at the
              dimension index `dim` of `input`'s shape. The dimension index `dim` starts at
              zero; if you specify a negative number for `dim` it is counted backward from
              the end.
              
              This operation is useful if you want to add a batch dimension to a single
              element. For example, if you have a single image of shape `[height, width,
              channels]`, you can make it a batch of 1 image with `expand_dims(image, 0)`,
              which will make the shape `[1, height, width, channels]`.
              
              Other examples:
              
              ```
              # 't' is a tensor of shape [2]
              shape(expand_dims(t, 0)) ==&amp;gt; [1, 2]
              shape(expand_dims(t, 1)) ==&amp;gt; [2, 1]
              shape(expand_dims(t, -1)) ==&amp;gt; [2, 1]
              
              # 't2' is a tensor of shape [2, 3, 5]
              shape(expand_dims(t2, 0)) ==&amp;gt; [1, 2, 3, 5]
              shape(expand_dims(t2, 2)) ==&amp;gt; [2, 3, 1, 5]
              shape(expand_dims(t2, 3)) ==&amp;gt; [2, 3, 5, 1]
              ```
              
              This operation requires that:
              
              `-1-input.dims() &amp;lt;= dim &amp;lt;= input.dims()`
              
              This operation is related to `squeeze()`, which removes dimensions of
              size 1.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Expm1(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes exponential of x - 1 element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Expm1'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              I.e., \\(y = (\exp x) - 1\\).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ExtractGlimpse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Extracts a glimpse from the input tensor.
            </summary>
            <param name="input">
              A 4-D float tensor of shape `[batch_size, height, width, channels]`.
            </param>
            <param name="size">
              A 1-D tensor of 2 elements containing the size of the glimpses
              to extract.  The glimpse height must be specified first, following
              by the glimpse width.
            </param>
            <param name="offsets">
              A 2-D integer tensor of shape `[batch_size, 2]` containing
              the y, x locations of the center of each window.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractGlimpse'.
            </param>
            <param name="centered">
              Optional argument
              indicates if the offset coordinates are centered relative to
              the image, in which case the (0, 0) offset is relative to the center
              of the input images. If false, the (0,0) offset corresponds to the
              upper left corner of the input images.
            </param>
            <param name="normalized">
              Optional argument
              indicates if the offset coordinates are normalized.
            </param>
            <param name="uniform_noise">
              Optional argument
              indicates if the noise should be generated using a
              uniform distribution or a Gaussian distribution.
            </param>
            <returns>
              A tensor representing the glimpses `[batch_size,
              glimpse_height, glimpse_width, channels]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Returns a set of windows called glimpses extracted at location
              `offsets` from the input tensor. If the windows only partially
              overlaps the inputs, the non overlapping areas will be filled with
              random noise.
              
              The result is a 4-D tensor of shape `[batch_size, glimpse_height,
              glimpse_width, channels]`. The channels and batch dimensions are the
              same as that of the input tensor. The height and width of the output
              windows are specified in the `size` parameter.
              
              The argument `normalized` and `centered` controls how the windows are built:
              
              * If the coordinates are normalized but not centered, 0.0 and 1.0
                correspond to the minimum and maximum of each height and width
                dimension.
              * If the coordinates are both normalized and centered, they range from
                -1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to the upper
                left corner, the lower right corner is located at (1.0, 1.0) and the
                center is at (0, 0).
              * If the coordinates are not normalized they are interpreted as
                numbers of pixels.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ExtractImagePatches(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
              Extract `patches` from `images` and put them in the "depth" output dimension.
            </summary>
            <param name="images">
              4-D Tensor with shape `[batch, in_rows, in_cols, depth]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractImagePatches'.
            </param>
            <param name="ksizes">
              The size of the sliding window for each dimension of `images`.
            </param>
            <param name="strides">
              1-D of length 4. How far the centers of two consecutive patches are in
              the images. Must be: `[1, stride_rows, stride_cols, 1]`.
            </param>
            <param name="rates">
              1-D of length 4. Must be: `[1, rate_rows, rate_cols, 1]`. This is the
              input stride, specifying how far two consecutive patch samples are in the
              input. Equivalent to extracting patches with
              `patch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1)`, followed by
              subsampling them spatially by a factor of `rates`. This is equivalent to
              `rate` in dilated (a.k.a. Atrous) convolutions.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
              
              We specify the size-related attributes as:
              
              ```python
                    ksizes = [1, ksize_rows, ksize_cols, 1]
                    strides = [1, strides_rows, strides_cols, 1]
                    rates = [1, rates_rows, rates_cols, 1]
              ```
            </param>
            <returns>
              4-D Tensor with shape `[batch, out_rows, out_cols, ksize_rows *
              ksize_cols * depth]` containing image patches with size
              `ksize_rows x ksize_cols x depth` vectorized in the "depth" dimension. Note
              `out_rows` and `out_cols` are the dimensions of the output patches.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ExtractJpegShape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Extract the shape information of a JPEG-encoded image.
            </summary>
            <param name="contents">
              0-D. The JPEG-encoded image.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractJpegShape'.
            </param>
            <param name="output_type">
              Optional argument
              (Optional) The output type of the operation (int32 or int64).
              Defaults to int32.
            </param>
            <returns>
              1-D. The image shape with format [height, width, channels].
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op only parses the image header, so it is much faster than DecodeJpeg.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Fact(System.String)">
            <summary>
              Output a fact about factorials.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Fact'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.FakeQuantWithMinMaxArgs(TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">
            <summary>
              Fake-quantize the 'inputs' tensor, type float to 'outputs' tensor of same type.
            </summary>
            <param name="inputs">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxArgs'.
            </param>
            <param name="min">
              Optional argument
            </param>
            <param name="max">
              Optional argument
            </param>
            <param name="num_bits">
              Optional argument
            </param>
            <param name="narrow_range">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Attributes `[min; max]` define the clamping range for the `inputs` data.
              `inputs` values are quantized into the quantization range (`[0; 2^num_bits - 1]`
              when `narrow_range` is false and `[1; 2^num_bits - 1]` when it is true) and
              then de-quantized and output as floats in `[min; max]` interval.
              `num_bits` is the bitwidth of the quantization; between 2 and 8, inclusive.
              
              Quantization is called fake since the output is still in floating point.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FakeQuantWithMinMaxArgsGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">
            <summary>
              Compute gradients for a FakeQuantWithMinMaxArgs operation.
            </summary>
            <param name="gradients">
              Backpropagated gradients above the FakeQuantWithMinMaxArgs operation.
            </param>
            <param name="inputs">
              Values passed as inputs to the FakeQuantWithMinMaxArgs operation.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxArgsGradient'.
            </param>
            <param name="min">
              Optional argument
            </param>
            <param name="max">
              Optional argument
            </param>
            <param name="num_bits">
              Optional argument
            </param>
            <param name="narrow_range">
              Optional argument
            </param>
            <returns>
              Backpropagated gradients below the FakeQuantWithMinMaxArgs operation:
              `gradients * (inputs &amp;gt;= min &amp;&amp; inputs &amp;lt;= max)`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.FakeQuantWithMinMaxVars(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">
            <summary>
              Fake-quantize the 'inputs' tensor of type float via global float scalars `min`
            </summary>
            <param name="inputs">
            </param>
            <param name="min">
            </param>
            <param name="max">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVars'.
            </param>
            <param name="num_bits">
              Optional argument
            </param>
            <param name="narrow_range">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              and `max` to 'outputs' tensor of same shape as `inputs`.
              
              `[min; max]` define the clamping range for the `inputs` data.
              `inputs` values are quantized into the quantization range (`[0; 2^num_bits - 1]`
              when `narrow_range` is false and `[1; 2^num_bits - 1]` when it is true) and
              then de-quantized and output as floats in `[min; max]` interval.
              `num_bits` is the bitwidth of the quantization; between 2 and 8, inclusive.
              
              This operation has a gradient and thus allows for training `min` and `max`
              values.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FakeQuantWithMinMaxVarsGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">
            <summary>
              Compute gradients for a FakeQuantWithMinMaxVars operation.
            </summary>
            <param name="gradients">
              Backpropagated gradients above the FakeQuantWithMinMaxVars operation.
            </param>
            <param name="inputs">
              Values passed as inputs to the FakeQuantWithMinMaxVars operation.
              min, max: Quantization interval, scalar floats.
            </param>
            <param name="min">
            </param>
            <param name="max">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVarsGradient'.
            </param>
            <param name="num_bits">
              Optional argument
              The bitwidth of the quantization; between 2 and 8, inclusive.
            </param>
            <param name="narrow_range">
              Optional argument
              Whether to quantize into 2^num_bits - 1 distinct values.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              backprops_wrt_input: Backpropagated gradients w.r.t. inputs:
              `gradients * (inputs &amp;gt;= min &amp;&amp; inputs &amp;lt;= max)`.
              backprop_wrt_min: Backpropagated gradients w.r.t. min parameter:
              `sum(gradients * (inputs &amp;lt; min))`.
              backprop_wrt_max: Backpropagated gradients w.r.t. max parameter:
              `sum(gradients * (inputs &amp;gt; max))`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannel(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">
            <summary>
              Fake-quantize the 'inputs' tensor of type float and one of the shapes: `[d]`,
            </summary>
            <param name="inputs">
            </param>
            <param name="min">
            </param>
            <param name="max">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVarsPerChannel'.
            </param>
            <param name="num_bits">
              Optional argument
            </param>
            <param name="narrow_range">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `[b, d]` `[b, h, w, d]` via per-channel floats `min` and `max` of shape `[d]`
              to 'outputs' tensor of same shape as `inputs`.
              
              `[min; max]` define the clamping range for the `inputs` data.
              `inputs` values are quantized into the quantization range (`[0; 2^num_bits - 1]`
              when `narrow_range` is false and `[1; 2^num_bits - 1]` when it is true) and
              then de-quantized and output as floats in `[min; max]` interval.
              `num_bits` is the bitwidth of the quantization; between 2 and 8, inclusive.
              
              This operation has a gradient and thus allows for training `min` and `max`
              values.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">
            <summary>
              Compute gradients for a FakeQuantWithMinMaxVarsPerChannel operation.
            </summary>
            <param name="gradients">
              Backpropagated gradients above the FakeQuantWithMinMaxVars operation,
              shape one of: `[d]`, `[b, d]`,  `[b, h, w, d]`.
            </param>
            <param name="inputs">
              Values passed as inputs to the FakeQuantWithMinMaxVars operation, shape
                same as `gradients`.
              min, max: Quantization interval, floats of shape `[d]`.
            </param>
            <param name="min">
            </param>
            <param name="max">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVarsPerChannelGradient'.
            </param>
            <param name="num_bits">
              Optional argument
              The bitwidth of the quantization; between 2 and 8, inclusive.
            </param>
            <param name="narrow_range">
              Optional argument
              Whether to quantize into 2^num_bits - 1 distinct values.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              backprops_wrt_input: Backpropagated gradients w.r.t. inputs, shape same as
              `inputs`:
                `gradients * (inputs &amp;gt;= min &amp;&amp; inputs &amp;lt;= max)`.
              backprop_wrt_min: Backpropagated gradients w.r.t. min parameter, shape `[d]`:
              `sum_per_d(gradients * (inputs &amp;lt; min))`.
              backprop_wrt_max: Backpropagated gradients w.r.t. max parameter, shape `[d]`:
              `sum_per_d(gradients * (inputs &amp;gt; max))`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.FakeQueue(TensorFlow.TFOutput,System.String)">
            <summary>
              Deprecated. Do not use.
            </summary>
            <param name="resource">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQueue'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.FFT(TensorFlow.TFOutput,System.String)">
            <summary>
              Fast Fourier transform.
            </summary>
            <param name="input">
              A complex64 tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FFT'.
            </param>
            <returns>
              A complex64 tensor of the same shape as `input`. The inner-most
                dimension of `input` is replaced with its 1D Fourier transform.
              
              @compatibility(numpy)
              Equivalent to np.fft.fft
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes the 1-dimensional discrete Fourier transform over the inner-most
              dimension of `input`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FFT2D(TensorFlow.TFOutput,System.String)">
            <summary>
              2D fast Fourier transform.
            </summary>
            <param name="input">
              A complex64 tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FFT2D'.
            </param>
            <returns>
              A complex64 tensor of the same shape as `input`. The inner-most 2
                dimensions of `input` are replaced with their 2D Fourier transform.
              
              @compatibility(numpy)
              Equivalent to np.fft.fft2
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes the 2-dimensional discrete Fourier transform over the inner-most
              2 dimensions of `input`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FFT3D(TensorFlow.TFOutput,System.String)">
            <summary>
              3D fast Fourier transform.
            </summary>
            <param name="input">
              A complex64 tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FFT3D'.
            </param>
            <returns>
              A complex64 tensor of the same shape as `input`. The inner-most 3
                dimensions of `input` are replaced with their 3D Fourier transform.
              
              @compatibility(numpy)
              Equivalent to np.fft.fftn with 3 dimensions.
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes the 3-dimensional discrete Fourier transform over the inner-most 3
              dimensions of `input`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FIFOQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              A queue that produces elements in first-in first-out order.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FIFOQueue'.
            </param>
            <param name="shapes">
              Optional argument
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types. If the length of
              this attr is 0, the shapes of queue elements are not constrained, and
              only one element may be dequeued at a time.
            </param>
            <param name="capacity">
              Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.
            </param>
            <param name="component_types">
              The type of each component in a value.
            </param>
            <returns>
              The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.FIFOQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              A queue that produces elements in first-in first-out order.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FIFOQueueV2'.
            </param>
            <param name="shapes">
              Optional argument
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types. If the length of
              this attr is 0, the shapes of queue elements are not constrained, and
              only one element may be dequeued at a time.
            </param>
            <param name="capacity">
              Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.
            </param>
            <param name="component_types">
              The type of each component in a value.
            </param>
            <returns>
              The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Fill(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Creates a tensor filled with a scalar value.
            </summary>
            <param name="dims">
              1-D. Represents the shape of the output tensor.
            </param>
            <param name="value">
              0-D (scalar). Value to fill the returned tensor.
              
              @compatibility(numpy)
              Equivalent to np.full
              @end_compatibility
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Fill'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation creates a tensor of shape `dims` and fills it with `value`.
              
              For example:
              
              ```
              # Output tensor has shape [2, 3].
              fill([2, 3], 9) ==&amp;gt; [[9, 9, 9]
                                   [9, 9, 9]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FixedLengthRecordDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Creates a dataset that emits the records from one or more binary files.
            </summary>
            <param name="filenames">
              A scalar or a vector containing the name(s) of the file(s) to be
              read.
            </param>
            <param name="header_bytes">
              A scalar representing the number of bytes to skip at the
              beginning of a file.
            </param>
            <param name="record_bytes">
              A scalar representing the number of bytes in each record.
            </param>
            <param name="footer_bytes">
              A scalar representing the number of bytes to skip at the end
              of a file.
            </param>
            <param name="buffer_size">
              A scalar representing the number of bytes to buffer. Must be &amp;gt; 0.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordDataset'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.FixedLengthRecordReader(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              A Reader that outputs fixed-length records from a file.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordReader'.
            </param>
            <param name="header_bytes">
              Optional argument
              Number of bytes in the header, defaults to 0.
            </param>
            <param name="footer_bytes">
              Optional argument
              Number of bytes in the footer, defaults to 0.
            </param>
            <param name="hop_bytes">
              Optional argument
              Number of bytes to hop before each read. Default of 0 means using
              record_bytes.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.
            </param>
            <param name="record_bytes">
              Number of bytes in the record.
            </param>
            <returns>
              The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.FixedLengthRecordReaderV2(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String,System.String)">
            <summary>
              A Reader that outputs fixed-length records from a file.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordReaderV2'.
            </param>
            <param name="header_bytes">
              Optional argument
              Number of bytes in the header, defaults to 0.
            </param>
            <param name="footer_bytes">
              Optional argument
              Number of bytes in the footer, defaults to 0.
            </param>
            <param name="hop_bytes">
              Optional argument
              Number of bytes to hop before each read. Default of 0 means using
              record_bytes.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.
            </param>
            <param name="encoding">
              Optional argument
              The type of encoding for the file. Currently ZLIB and GZIP
              are supported. Defaults to none.
            </param>
            <param name="record_bytes">
              Number of bytes in the record.
            </param>
            <returns>
              The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.FixedUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Single[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Generates labels for candidate sampling with a learned unigram distribution.
            </summary>
            <param name="true_classes">
              A batch_size * num_true matrix, in which each row contains the
              IDs of the num_true target_classes in the corresponding original label.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedUnigramCandidateSampler'.
            </param>
            <param name="vocab_file">
              Optional argument
              Each valid line in this file (which should have a CSV-like format)
              corresponds to a valid word ID. IDs are in sequential order, starting from
              num_reserved_ids. The last entry in each line is expected to be a value
              corresponding to the count or relative probability. Exactly one of vocab_file
              and unigrams needs to be passed to this op.
            </param>
            <param name="distortion">
              Optional argument
              The distortion is used to skew the unigram probability distribution.
              Each weight is first raised to the distortion's power before adding to the
              internal unigram distribution. As a result, distortion = 1.0 gives regular
              unigram sampling (as defined by the vocab file), and distortion = 0.0 gives
              a uniform distribution.
            </param>
            <param name="num_reserved_ids">
              Optional argument
              Optionally some reserved IDs can be added in the range [0,
              ..., num_reserved_ids) by the users. One use case is that a special unknown
              word token is used as ID 0. These IDs will have a sampling probability of 0.
            </param>
            <param name="num_shards">
              Optional argument
              A sampler can be used to sample from a subset of the original range
              in order to speed up the whole computation through parallelism. This parameter
              (together with 'shard') indicates the number of partitions that are being
              used in the overall computation.
            </param>
            <param name="shard">
              Optional argument
              A sampler can be used to sample from a subset of the original range
              in order to speed up the whole computation through parallelism. This parameter
              (together with 'num_shards') indicates the particular partition number of a
              sampler op, when partitioning is being used.
            </param>
            <param name="unigrams">
              Optional argument
              A list of unigram counts or probabilities, one per ID in sequential
              order. Exactly one of vocab_file and unigrams should be passed to this op.
            </param>
            <param name="seed">
              Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              An second seed to avoid seed collision.
            </param>
            <param name="num_true">
              Number of true labels per context.
            </param>
            <param name="num_sampled">
              Number of candidates to randomly sample.
            </param>
            <param name="unique">
              If unique is true, we sample with rejection, so that all sampled
              candidates in a batch are unique. This requires some approximation to
              estimate the post-rejection sampling probabilities.
            </param>
            <param name="range_max">
              The sampler will sample integers from the interval [0, range_max).
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              sampled_candidates: A vector of length num_sampled, in which each element is
              the ID of a sampled candidate.
              true_expected_count: A batch_size * num_true matrix, representing
              the number of times each candidate is expected to occur in a batch
              of sampled candidates. If unique=true, then this is a probability.
              sampled_expected_count: A vector of length num_sampled, for each sampled
              candidate representing the number of times the candidate is expected
              to occur in a batch of sampled candidates.  If unique=true, then this is a
              probability.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              A unigram sampler could use a fixed unigram distribution read from a
              file or passed in as an in-memory array instead of building up the distribution
              from data on the fly. There is also an option to skew the distribution by
              applying a distortion power to the weights.
              
              The vocabulary file should be in CSV-like format, with the last field
              being the weight associated with the word.
              
              For each batch, this op picks a single set of sampled candidate labels.
              
              The advantages of sampling candidates per-batch are simplicity and the
              possibility of efficient dense matrix multiplication. The disadvantage is that
              the sampled candidates must be chosen independently of the context and of the
              true labels.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Floor(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns element-wise largest integer not greater than x.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Floor'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.FloorDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns x // y element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FloorDiv'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `FloorDiv` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FloorMod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns element-wise remainder of division. When `x &amp;lt; 0` xor `y &amp;lt; 0` is
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FloorMod'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              true, this follows Python semantics in that the result here is consistent
              with a flooring divide. E.g. `floor(x / y) * y + mod(x, y) = x`.
              
              *NOTE*: `FloorMod` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FlushSummaryWriter(TensorFlow.TFOutput,System.String)">
            <summary>
              Flushes the writer's unwritten events.
            </summary>
            <param name="writer">
              A handle to the summary writer resource.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FlushSummaryWriter'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.FractionalAvgPool(TensorFlow.TFOutput,System.Single[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Performs fractional average pooling on the input.
            </summary>
            <param name="value">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalAvgPool'.
            </param>
            <param name="pseudo_random">
              Optional argument
              When set to True, generates the pooling sequence in a
              pseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin
              Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for
              difference between pseudorandom and random.
            </param>
            <param name="overlapping">
              Optional argument
              When set to True, it means when pooling, the values at the boundary
              of adjacent pooling cells are used by both cells. For example:
              
              `index  0  1  2  3  4`
              
              `value  20 5  16 3  7`
              
              If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
              The result would be [41/3, 26/3] for fractional avg pooling.
            </param>
            <param name="deterministic">
              Optional argument
              When set to True, a fixed pooling region will be used when
              iterating over a FractionalAvgPool node in the computation graph. Mainly used
              in unit test to make FractionalAvgPool deterministic.
            </param>
            <param name="seed">
              Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              An second seed to avoid seed collision.
            </param>
            <param name="pooling_ratio">
              Pooling ratio for each dimension of `value`, currently only
              supports row and col dimension and should be &amp;gt;= 1.0. For example, a valid
              pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
              must be 1.0 because we don't allow pooling on batch and channels
              dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
              respectively.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: output tensor after fractional avg pooling.
              row_pooling_sequence: row pooling sequence, needed to calculate gradient.
              col_pooling_sequence: column pooling sequence, needed to calculate gradient.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Fractional average pooling is similar to Fractional max pooling in the pooling
              region generation step. The only difference is that after pooling regions are
              generated, a mean operation is performed instead of a max operation in each
              pooling region.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FractionalAvgPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes gradient of the FractionalAvgPool function.
            </summary>
            <param name="orig_input_tensor_shape">
              Original input tensor shape for `fractional_avg_pool`
            </param>
            <param name="out_backprop">
              4-D with shape `[batch, height, width, channels]`.  Gradients
              w.r.t. the output of `fractional_avg_pool`.
            </param>
            <param name="row_pooling_sequence">
              row pooling sequence, form pooling region with
              col_pooling_sequence.
            </param>
            <param name="col_pooling_sequence">
              column pooling sequence, form pooling region with
              row_pooling sequence.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalAvgPoolGrad'.
            </param>
            <param name="overlapping">
              Optional argument
              When set to True, it means when pooling, the values at the boundary
              of adjacent pooling cells are used by both cells. For example:
              
              `index  0  1  2  3  4`
              
              `value  20 5  16 3  7`
              
              If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
              The result would be [41/3, 26/3] for fractional avg pooling.
            </param>
            <returns>
              4-D.  Gradients w.r.t. the input of `fractional_avg_pool`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Unlike FractionalMaxPoolGrad, we don't need to find arg_max for
              FractionalAvgPoolGrad, we just need to evenly back-propagate each element of
              out_backprop to those indices that form the same pooling cell. Therefore, we
              just need to know the shape of original input tensor, instead of the whole
              tensor.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FractionalMaxPool(TensorFlow.TFOutput,System.Single[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Performs fractional max pooling on the input.
            </summary>
            <param name="value">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalMaxPool'.
            </param>
            <param name="pseudo_random">
              Optional argument
              When set to True, generates the pooling sequence in a
              pseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin
              Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for
              difference between pseudorandom and random.
            </param>
            <param name="overlapping">
              Optional argument
              When set to True, it means when pooling, the values at the boundary
              of adjacent pooling cells are used by both cells. For example:
              
              `index  0  1  2  3  4`
              
              `value  20 5  16 3  7`
              
              If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
              The result would be [20, 16] for fractional max pooling.
            </param>
            <param name="deterministic">
              Optional argument
              When set to True, a fixed pooling region will be used when
              iterating over a FractionalMaxPool node in the computation graph. Mainly used
              in unit test to make FractionalMaxPool deterministic.
            </param>
            <param name="seed">
              Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              An second seed to avoid seed collision.
            </param>
            <param name="pooling_ratio">
              Pooling ratio for each dimension of `value`, currently only
              supports row and col dimension and should be &amp;gt;= 1.0. For example, a valid
              pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
              must be 1.0 because we don't allow pooling on batch and channels
              dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
              respectively.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: output tensor after fractional max pooling.
              row_pooling_sequence: row pooling sequence, needed to calculate gradient.
              col_pooling_sequence: column pooling sequence, needed to calculate gradient.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Fractional max pooling is slightly different than regular max pooling.  In
              regular max pooling, you downsize an input set by taking the maximum value of
              smaller N x N subsections of the set (often 2x2), and try to reduce the set by
              a factor of N, where N is an integer.  Fractional max pooling, as you might
              expect from the word "fractional", means that the overall reduction ratio N
              does not have to be an integer.
              
              The sizes of the pooling regions are generated randomly but are fairly uniform.
              For example, let's look at the height dimension, and the constraints on the
              list of rows that will be pool boundaries.
              
              First we define the following:
              
              1.  input_row_length : the number of rows from the input set
              2.  output_row_length : which will be smaller than the input
              3.  alpha = input_row_length / output_row_length : our reduction ratio
              4.  K = floor(alpha)
              5.  row_pooling_sequence : this is the result list of pool boundary rows
              
              Then, row_pooling_sequence should satisfy:
              
              1.  a[0] = 0 : the first value of the sequence is 0
              2.  a[end] = input_row_length : the last value of the sequence is the size
              3.  K &amp;lt;= (a[i+1] - a[i]) &amp;lt;= K+1 : all intervals are K or K+1 size
              4.  length(row_pooling_sequence) = output_row_length+1
              
              For more details on fractional max pooling, see this paper:
              [Benjamin Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FractionalMaxPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes gradient of the FractionalMaxPool function.
            </summary>
            <param name="orig_input">
              Original input for `fractional_max_pool`
            </param>
            <param name="orig_output">
              Original output for `fractional_max_pool`
            </param>
            <param name="out_backprop">
              4-D with shape `[batch, height, width, channels]`.  Gradients
              w.r.t. the output of `fractional_max_pool`.
            </param>
            <param name="row_pooling_sequence">
              row pooling sequence, form pooling region with
              col_pooling_sequence.
            </param>
            <param name="col_pooling_sequence">
              column pooling sequence, form pooling region with
              row_pooling sequence.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalMaxPoolGrad'.
            </param>
            <param name="overlapping">
              Optional argument
              When set to True, it means when pooling, the values at the boundary
              of adjacent pooling cells are used by both cells. For example:
              
              `index  0  1  2  3  4`
              
              `value  20 5  16 3  7`
              
              If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
              The result would be [20, 16] for fractional max pooling.
            </param>
            <returns>
              4-D.  Gradients w.r.t. the input of `fractional_max_pool`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.FusedBatchNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
              Batch normalization.
            </summary>
            <param name="x">
              A 4D Tensor for input data.
            </param>
            <param name="scale">
              A 1D Tensor for scaling factor, to scale the normalized x.
            </param>
            <param name="offset">
              A 1D Tensor for offset, to shift to the normalized x.
            </param>
            <param name="mean">
              A 1D Tensor for population mean. Used for inference only;
              must be empty for training.
            </param>
            <param name="variance">
              A 1D Tensor for population variance. Used for inference only;
              must be empty for training.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNorm'.
            </param>
            <param name="epsilon">
              Optional argument
              A small float number added to the variance of x.
            </param>
            <param name="data_format">
              Optional argument
              The data format for x and y. Either "NHWC" (default) or "NCHW".
            </param>
            <param name="is_training">
              Optional argument
              A bool value to indicate the operation is for training (default)
              or inference.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              y: A 4D Tensor for output data.
              batch_mean: A 1D Tensor for the computed batch mean, to be used by TensorFlow
              to compute the running mean.
              batch_variance: A 1D Tensor for the computed batch variance, to be used by
              TensorFlow to compute the running variance.
              reserve_space_1: A 1D Tensor for the computed batch mean, to be reused
              in the gradient computation.
              reserve_space_2: A 1D Tensor for the computed batch variance (inverted variance
              in the cuDNN case), to be reused in the gradient computation.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
              The size of 1D Tensors matches the dimension C of the 4D Tensors.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FusedBatchNormGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
              Gradient for batch normalization.
            </summary>
            <param name="y_backprop">
              A 4D Tensor for the gradient with respect to y.
            </param>
            <param name="x">
              A 4D Tensor for input data.
            </param>
            <param name="scale">
              A 1D Tensor for scaling factor, to scale the normalized x.
            </param>
            <param name="reserve_space_1">
              When is_training is True, a 1D Tensor for the computed batch
              mean to be reused in gradient computation. When is_training is
              False, a 1D Tensor for the population mean to be reused in both
              1st and 2nd order gradient computation.
            </param>
            <param name="reserve_space_2">
              When is_training is True, a 1D Tensor for the computed batch
              variance (inverted variance in the cuDNN case) to be reused in
              gradient computation. When is_training is False, a 1D Tensor
              for the population variance to be reused in both 1st and 2nd
              order gradient computation.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormGrad'.
            </param>
            <param name="epsilon">
              Optional argument
              A small float number added to the variance of x.
            </param>
            <param name="data_format">
              Optional argument
              The data format for y_backprop, x, x_backprop.
              Either "NHWC" (default) or "NCHW".
            </param>
            <param name="is_training">
              Optional argument
              A bool value to indicate the operation is for training (default)
              or inference.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              x_backprop: A 4D Tensor for the gradient with respect to x.
              scale_backprop: A 1D Tensor for the gradient with respect to scale.
              offset_backprop: A 1D Tensor for the gradient with respect to offset.
              reserve_space_3: Unused placeholder to match the mean input in FusedBatchNorm.
              reserve_space_4: Unused placeholder to match the variance input
              in FusedBatchNorm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
              The size of 1D Tensors matches the dimension C of the 4D Tensors.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FusedBatchNormGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
              Gradient for batch normalization.
            </summary>
            <param name="y_backprop">
              A 4D Tensor for the gradient with respect to y.
            </param>
            <param name="x">
              A 4D Tensor for input data.
            </param>
            <param name="scale">
              A 1D Tensor for scaling factor, to scale the normalized x.
            </param>
            <param name="reserve_space_1">
              When is_training is True, a 1D Tensor for the computed batch
              mean to be reused in gradient computation. When is_training is
              False, a 1D Tensor for the population mean to be reused in both
              1st and 2nd order gradient computation.
            </param>
            <param name="reserve_space_2">
              When is_training is True, a 1D Tensor for the computed batch
              variance (inverted variance in the cuDNN case) to be reused in
              gradient computation. When is_training is False, a 1D Tensor
              for the population variance to be reused in both 1st and 2nd
              order gradient computation.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormGradV2'.
            </param>
            <param name="epsilon">
              Optional argument
              A small float number added to the variance of x.
            </param>
            <param name="data_format">
              Optional argument
              The data format for y_backprop, x, x_backprop.
              Either "NHWC" (default) or "NCHW".
            </param>
            <param name="is_training">
              Optional argument
              A bool value to indicate the operation is for training (default)
              or inference.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              x_backprop: A 4D Tensor for the gradient with respect to x.
              scale_backprop: A 1D Tensor for the gradient with respect to scale.
              offset_backprop: A 1D Tensor for the gradient with respect to offset.
              reserve_space_3: Unused placeholder to match the mean input in FusedBatchNorm.
              reserve_space_4: Unused placeholder to match the variance input
              in FusedBatchNorm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
              The size of 1D Tensors matches the dimension C of the 4D Tensors.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FusedBatchNormV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
              Batch normalization.
            </summary>
            <param name="x">
              A 4D Tensor for input data.
            </param>
            <param name="scale">
              A 1D Tensor for scaling factor, to scale the normalized x.
            </param>
            <param name="offset">
              A 1D Tensor for offset, to shift to the normalized x.
            </param>
            <param name="mean">
              A 1D Tensor for population mean. Used for inference only;
              must be empty for training.
            </param>
            <param name="variance">
              A 1D Tensor for population variance. Used for inference only;
              must be empty for training.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormV2'.
            </param>
            <param name="epsilon">
              Optional argument
              A small float number added to the variance of x.
            </param>
            <param name="data_format">
              Optional argument
              The data format for x and y. Either "NHWC" (default) or "NCHW".
            </param>
            <param name="is_training">
              Optional argument
              A bool value to indicate the operation is for training (default)
              or inference.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              y: A 4D Tensor for output data.
              batch_mean: A 1D Tensor for the computed batch mean, to be used by TensorFlow
              to compute the running mean.
              batch_variance: A 1D Tensor for the computed batch variance, to be used by
              TensorFlow to compute the running variance.
              reserve_space_1: A 1D Tensor for the computed batch mean, to be reused
              in the gradient computation.
              reserve_space_2: A 1D Tensor for the computed batch variance (inverted variance
              in the cuDNN case), to be reused in the gradient computation.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
              The size of 1D Tensors matches the dimension C of the 4D Tensors.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FusedPadConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Int64[],System.String,System.String)">
            <summary>
              Performs a padding as a preprocess during a convolution.
            </summary>
            <param name="input">
              4-D with shape `[batch, in_height, in_width, in_channels]`.
            </param>
            <param name="paddings">
              A two-column matrix specifying the padding sizes. The number of
              rows must be the same as the rank of `input`.
            </param>
            <param name="filter">
              4-D with shape
              `[filter_height, filter_width, in_channels, out_channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedPadConv2D'.
            </param>
            <param name="mode">
            </param>
            <param name="strides">
              1-D of length 4.  The stride of the sliding window for each dimension
              of `input`. Must be in the same order as the dimension specified with format.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Similar to FusedResizeAndPadConv2d, this op allows for an optimized
              implementation where the spatial padding transformation stage is fused with the
              im2col lookup, but in this case without the bilinear filtering required for
              resizing. Fusing the padding prevents the need to write out the intermediate
              results as whole tensors, reducing memory pressure, and we can get some latency
              gains by merging the transformation calculations.
              The data_format attribute for Conv2D isn't supported by this op, and 'NHWC'
              order is used instead.
              Internally this op uses a single per-graph scratch buffer, which means that it
              will block if multiple versions are being run in parallel. This is because this
              operator is primarily an optimization to minimize memory usage.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.FusedResizeAndPadConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Int64[],System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
              Performs a resize and padding as a preprocess during a convolution.
            </summary>
            <param name="input">
              4-D with shape `[batch, in_height, in_width, in_channels]`.
            </param>
            <param name="size">
              A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The
              new size for the images.
            </param>
            <param name="paddings">
              A two-column matrix specifying the padding sizes. The number of
              rows must be the same as the rank of `input`.
            </param>
            <param name="filter">
              4-D with shape
              `[filter_height, filter_width, in_channels, out_channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedResizeAndPadConv2D'.
            </param>
            <param name="resize_align_corners">
              Optional argument
              If true, rescale input by (new_height - 1) / (height - 1),
              which exactly aligns the 4 corners of images and resized images. If false, rescale
              by new_height / height. Treat similarly the width dimension.
            </param>
            <param name="mode">
            </param>
            <param name="strides">
              1-D of length 4.  The stride of the sliding window for each dimension
              of `input`. Must be in the same order as the dimension specified with format.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              It's often possible to do spatial transformations more efficiently as part of
              the packing stage of a convolution, so this op allows for an optimized
              implementation where these stages are fused together. This prevents the need to
              write out the intermediate results as whole tensors, reducing memory pressure,
              and we can get some latency gains by merging the transformation calculations.
              The data_format attribute for Conv2D isn't supported by this op, and defaults to
              'NHWC' order.
              Internally this op uses a single per-graph scratch buffer, which means that it
              will block if multiple versions are being run in parallel. This is because this
              operator is primarily an optimization to minimize memory usage.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Gather(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Gather slices from `params` according to `indices`.
            </summary>
            <param name="parameters">
            </param>
            <param name="indices">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Gather'.
            </param>
            <param name="validate_indices">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `indices` must be an integer tensor of any dimension (usually 0-D or 1-D).
              Produces an output tensor with shape `indices.shape + params.shape[1:]` where:
              
              ```python
                  # Scalar indices
                  output[:, ..., :] = params[indices, :, ... :]
              
                  # Vector indices
                  output[i, :, ..., :] = params[indices[i], :, ... :]
              
                  # Higher rank indices
                  output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]
              ```
              
              If `indices` is a permutation and `len(indices) == params.shape[0]` then
              this operation will permute `params` accordingly.
              
              `validate_indices`: DEPRECATED. If this operation is assigned to CPU, values in
              `indices` are always validated to be within range. If assigned to GPU,
              out-of-bound indices result in safe but unspecified behavior, which may include
              raising an error.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/Gather.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.GatherNd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Gather slices from `params` into a Tensor with shape specified by `indices`.
            </summary>
            <param name="parameters">
              The tensor from which to gather values.
            </param>
            <param name="indices">
              Index tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'GatherNd'.
            </param>
            <returns>
              Values from `params` gathered from indices given by `indices`, with
              shape `indices.shape[:-1] + params.shape[indices.shape[-1]:]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `indices` is an K-dimensional integer tensor, best thought of as a
              (K-1)-dimensional tensor of indices into `params`, where each element defines a
              slice of `params`:
              
                  output[i_0, ..., i_{K-2}] = params[indices[i0, ..., i_{K-2}]]
              
              Whereas in @{tf.gather} `indices` defines slices into the first
              dimension of `params`, in `tf.gather_nd`, `indices` defines slices into the
              first `N` dimensions of `params`, where `N = indices.shape[-1]`.
              
              The last dimension of `indices` can be at most the rank of
              `params`:
              
                  indices.shape[-1] &amp;lt;= params.rank
              
              The last dimension of `indices` corresponds to elements
              (if `indices.shape[-1] == params.rank`) or slices
              (if `indices.shape[-1] &amp;lt; params.rank`) along dimension `indices.shape[-1]`
              of `params`.  The output tensor has shape
              
                  indices.shape[:-1] + params.shape[indices.shape[-1]:]
              
              Some examples below.
              
              Simple indexing into a matrix:
              
              ```python
                  indices = [[0, 0], [1, 1]]
                  params = [['a', 'b'], ['c', 'd']]
                  output = ['a', 'd']
              ```
              
              Slice indexing into a matrix:
              
              ```python
                  indices = [[1], [0]]
                  params = [['a', 'b'], ['c', 'd']]
                  output = [['c', 'd'], ['a', 'b']]
              ```
              
              Indexing into a 3-tensor:
              
              ```python
                  indices = [[1]]
                  params = [[['a0', 'b0'], ['c0', 'd0']],
                            [['a1', 'b1'], ['c1', 'd1']]]
                  output = [[['a1', 'b1'], ['c1', 'd1']]]
              
              
                  indices = [[0, 1], [1, 0]]
                  params = [[['a0', 'b0'], ['c0', 'd0']],
                            [['a1', 'b1'], ['c1', 'd1']]]
                  output = [['c0', 'd0'], ['a1', 'b1']]
              
              
                  indices = [[0, 0, 1], [1, 0, 1]]
                  params = [[['a0', 'b0'], ['c0', 'd0']],
                            [['a1', 'b1'], ['c1', 'd1']]]
                  output = ['b0', 'b1']
              ```
              
              Batched indexing into a matrix:
              
              ```python
                  indices = [[[0, 0]], [[0, 1]]]
                  params = [['a', 'b'], ['c', 'd']]
                  output = [['a'], ['b']]
              ```
              
              Batched slice indexing into a matrix:
              
              ```python
                  indices = [[[1]], [[0]]]
                  params = [['a', 'b'], ['c', 'd']]
                  output = [[['c', 'd']], [['a', 'b']]]
              ```
              
              Batched indexing into a 3-tensor:
              
              ```python
                  indices = [[[1]], [[0]]]
                  params = [[['a0', 'b0'], ['c0', 'd0']],
                            [['a1', 'b1'], ['c1', 'd1']]]
                  output = [[[['a1', 'b1'], ['c1', 'd1']]],
                            [[['a0', 'b0'], ['c0', 'd0']]]]
              
                  indices = [[[0, 1], [1, 0]], [[0, 0], [1, 1]]]
                  params = [[['a0', 'b0'], ['c0', 'd0']],
                            [['a1', 'b1'], ['c1', 'd1']]]
                  output = [[['c0', 'd0'], ['a1', 'b1']],
                            [['a0', 'b0'], ['c1', 'd1']]]
              
              
                  indices = [[[0, 0, 1], [1, 0, 1]], [[0, 1, 1], [1, 1, 0]]]
                  params = [[['a0', 'b0'], ['c0', 'd0']],
                            [['a1', 'b1'], ['c1', 'd1']]]
                  output = [['b0', 'b1'], ['d0', 'c1']]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.GatherV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Gather slices from `params` axis `axis` according to `indices`.
            </summary>
            <param name="parameters">
              The tensor from which to gather values. Must be at least rank
              `axis + 1`.
            </param>
            <param name="indices">
              Index tensor. Must be in range `[0, params.shape[axis])`.
            </param>
            <param name="axis">
              The axis in `params` to gather `indices` from. Defaults to the first
              dimension. Supports negative indexes.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'GatherV2'.
            </param>
            <returns>
              Values from `params` gathered from indices given by `indices`, with
              shape `params.shape[:axis] + indices.shape + params.shape[axis + 1:]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `indices` must be an integer tensor of any dimension (usually 0-D or 1-D).
              Produces an output tensor with shape `params.shape[:axis] + indices.shape +
              params.shape[axis + 1:]` where:
              
              ```python
                  # Scalar indices (output is rank(params) - 1).
                  output[a_0, ..., a_n, b_0, ..., b_n] =
                    params[a_0, ..., a_n, indices, b_0, ..., b_n]
              
                  # Vector indices (output is rank(params)).
                  output[a_0, ..., a_n, i, b_0, ..., b_n] =
                    params[a_0, ..., a_n, indices[i], b_0, ..., b_n]
              
                  # Higher rank indices (output is rank(params) + rank(indices) - 1).
                  output[a_0, ..., a_n, i, ..., j, b_0, ... b_n] =
                    params[a_0, ..., a_n, indices[i, ..., j], b_0, ..., b_n]
              ```
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/Gather.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.GenerateVocabRemapping(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String)">
            <summary>
              Given a path to new and old vocabulary files, returns a remapping Tensor of
            </summary>
            <param name="new_vocab_file">
              Path to the new vocab file.
            </param>
            <param name="old_vocab_file">
              Path to the old vocab file.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'GenerateVocabRemapping'.
            </param>
            <param name="old_vocab_size">
              Optional argument
              Number of entries in the old vocab file to consider.  If -1,
              use the entire old vocabulary.
            </param>
            <param name="new_vocab_offset">
              How many entries into the new vocab file to start reading.
            </param>
            <param name="num_new_vocab">
              Number of entries in the new vocab file to remap.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              remapping: A Tensor of length num_new_vocab where the element at index i
              is equal to the old ID that maps to the new ID i.  This element is -1 for any
              new ID that is not found in the old vocabulary.
              num_present: Number of new vocab entries found in old vocab.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              length `num_new_vocab`, where `remapping[i]` contains the row number in the old
              vocabulary that corresponds to row `i` in the new vocabulary (starting at line
              `new_vocab_offset` and up to `num_new_vocab` entities), or `-1` if entry `i`
              in the new vocabulary is not in the old vocabulary.  The old vocabulary is
              constrained to the first `old_vocab_size` entries if `old_vocab_size` is not the
              default value of -1.
              
              `num_vocab_offset` enables
              use in the partitioned variable case, and should generally be set through
              examining partitioning info.  The format of the files should be a text file,
              with each line containing a single entity within the vocabulary.
              
              For example, with `new_vocab_file` a text file containing each of the following
              elements on a single line: `[f0, f1, f2, f3]`, old_vocab_file = [f1, f0, f3],
              `num_new_vocab = 3, new_vocab_offset = 1`, the returned remapping would be
              `[0, -1, 2]`.
              
              The op also returns a count of how many entries in the new vocabulary
              were present in the old vocabulary, which is used to calculate the number of
              values to initialize in a weight matrix remapping
              
              This functionality can be used to remap both row vocabularies (typically,
              features) and column vocabularies (typically, classes) from TensorFlow
              checkpoints.  Note that the partitioning logic relies on contiguous vocabularies
              corresponding to div-partitioned variables.  Moreover, the underlying remapping
              uses an IndexTable (as opposed to an inexact CuckooTable), so client code should
              use the corresponding index_table_from_file() as the FeatureColumn framework
              does (as opposed to tf.feature_to_id(), which uses a CuckooTable).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.GetSessionHandle(TensorFlow.TFOutput,System.String)">
            <summary>
              Store the input tensor in the state of the current session.
            </summary>
            <param name="value">
              The tensor to be stored.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'GetSessionHandle'.
            </param>
            <returns>
              The handle for the tensor stored in the session state, represented
              as a string.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.GetSessionHandleV2(TensorFlow.TFOutput,System.String)">
            <summary>
              Store the input tensor in the state of the current session.
            </summary>
            <param name="value">
              The tensor to be stored.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'GetSessionHandleV2'.
            </param>
            <returns>
              The handle for the tensor stored in the session state, represented
              as a ResourceHandle object.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.GetSessionTensor(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Get the value of the tensor specified by its handle.
            </summary>
            <param name="handle">
              The handle for a tensor stored in the session state.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'GetSessionTensor'.
            </param>
            <param name="dtype">
              The type of the output value.
            </param>
            <returns>
              The tensor for the given handle.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Greater(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the truth value of (x &amp;gt; y) element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Greater'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `Greater` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.GreaterEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the truth value of (x &amp;gt;= y) element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'GreaterEqual'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `GreaterEqual` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.GuaranteeConst(TensorFlow.TFOutput,System.String)">
            <summary>
              Gives a guarantee to the TF runtime that the input tensor is a constant.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'GuaranteeConst'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The runtime is then free to make optimizations based on this.
              
              Only accepts value typed tensors as inputs and rejects resource variable handles
              as input.
              
              Returns the input tensor without modification.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.HashTable(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
              Creates a non-initialized hash table.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'HashTable'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.
            </param>
            <param name="use_node_name_sharing">
              Optional argument
              If true and shared_name is empty, the table is shared
              using the node name.
            </param>
            <param name="key_dtype">
              Type of the table keys.
            </param>
            <param name="value_dtype">
              Type of the table values.
            </param>
            <returns>
              Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op creates a hash table, specifying the type of its keys and values.
              Before using the table you will have to initialize it.  After initialization the
              table will be immutable.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.HashTableV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
              Creates a non-initialized hash table.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'HashTableV2'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.
            </param>
            <param name="use_node_name_sharing">
              Optional argument
              If true and shared_name is empty, the table is shared
              using the node name.
            </param>
            <param name="key_dtype">
              Type of the table keys.
            </param>
            <param name="value_dtype">
              Type of the table values.
            </param>
            <returns>
              Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op creates a hash table, specifying the type of its keys and values.
              Before using the table you will have to initialize it.  After initialization the
              table will be immutable.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.HistogramFixedWidth(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Return histogram of values.
            </summary>
            <param name="values">
              Numeric `Tensor`.
            </param>
            <param name="value_range">
              Shape [2] `Tensor` of same `dtype` as `values`.
              values &amp;lt;= value_range[0] will be mapped to hist[0],
              values &amp;gt;= value_range[1] will be mapped to hist[-1].
            </param>
            <param name="nbins">
              Scalar `int32 Tensor`.  Number of histogram bins.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'HistogramFixedWidth'.
            </param>
            <param name="dtype">
              Optional argument
            </param>
            <returns>
              A 1-D `Tensor` holding histogram of values.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given the tensor `values`, this operation returns a rank 1 histogram counting
              the number of entries in `values` that fall into every bin.  The bins are
              equal width and determined by the arguments `value_range` and `nbins`.
              
              ```python
              # Bins will be:  (-inf, 1), [1, 2), [2, 3), [3, 4), [4, inf)
              nbins = 5
              value_range = [0.0, 5.0]
              new_values = [-1.0, 0.0, 1.5, 2.0, 5.0, 15]
              
              with tf.get_default_session() as sess:
                hist = tf.histogram_fixed_width(new_values, value_range, nbins=5)
                variables.global_variables_initializer().run()
                sess.run(hist) =&amp;gt; [2, 1, 1, 0, 2]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.HistogramSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Outputs a `Summary` protocol buffer with a histogram.
            </summary>
            <param name="tag">
              Scalar.  Tag to use for the `Summary.Value`.
            </param>
            <param name="values">
              Any shape. Values to use to build the histogram.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'HistogramSummary'.
            </param>
            <returns>
              Scalar. Serialized `Summary` protocol buffer.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The generated
              [`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)
              has one summary value containing a histogram for `values`.
              
              This op reports an `InvalidArgument` error if any value is not finite.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.HSVToRGB(TensorFlow.TFOutput,System.String)">
            <summary>
              Convert one or more images from HSV to RGB.
            </summary>
            <param name="images">
              1-D or higher rank. HSV data to convert. Last dimension must be size 3.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'HSVToRGB'.
            </param>
            <returns>
              `images` converted to RGB.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Outputs a tensor of the same shape as the `images` tensor, containing the RGB
              value of the pixels. The output is only well defined if the value in `images`
              are in `[0,1]`.
              
              See `rgb_to_hsv` for a description of the HSV encoding.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Identity(TensorFlow.TFOutput,System.String)">
            <summary>
              Return a tensor with the same shape and contents as the input tensor or value.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Identity'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.IdentityN(TensorFlow.TFOutput[],System.String)">
            <summary>
              Returns a list of tensors with the same shapes and contents as the input
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IdentityN'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              tensors.
              
              This op can be used to override the gradient for complicated functions. For
              example, suppose y = f(x) and we wish to apply a custom function g for backprop
              such that dx = g(dy). In Python,
              
              ```python
              with tf.get_default_graph().gradient_override_map(
                  {'IdentityN': 'OverrideGradientWithG'}):
                y, _ = identity_n([f(x), x])
              
              @tf.RegisterGradient('OverrideGradientWithG')
              def ApplyG(op, dy, _):
                return [None, g(dy)]  # Do not backprop to f(x).
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.IdentityReader(System.String,System.String,System.String)">
            <summary>
              A Reader that outputs the queued work as both the key and value.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IdentityReader'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.
            </param>
            <returns>
              The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              To use, enqueue strings in a Queue.  ReaderRead will take the front
              work string and output (work, work).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.IdentityReaderV2(System.String,System.String,System.String)">
            <summary>
              A Reader that outputs the queued work as both the key and value.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IdentityReaderV2'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.
            </param>
            <returns>
              The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              To use, enqueue strings in a Queue.  ReaderRead will take the front
              work string and output (work, work).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.IFFT(TensorFlow.TFOutput,System.String)">
            <summary>
              Inverse fast Fourier transform.
            </summary>
            <param name="input">
              A complex64 tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IFFT'.
            </param>
            <returns>
              A complex64 tensor of the same shape as `input`. The inner-most
                dimension of `input` is replaced with its inverse 1D Fourier transform.
              
              @compatibility(numpy)
              Equivalent to np.fft.ifft
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes the inverse 1-dimensional discrete Fourier transform over the
              inner-most dimension of `input`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.IFFT2D(TensorFlow.TFOutput,System.String)">
            <summary>
              Inverse 2D fast Fourier transform.
            </summary>
            <param name="input">
              A complex64 tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IFFT2D'.
            </param>
            <returns>
              A complex64 tensor of the same shape as `input`. The inner-most 2
                dimensions of `input` are replaced with their inverse 2D Fourier transform.
              
              @compatibility(numpy)
              Equivalent to np.fft.ifft2
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes the inverse 2-dimensional discrete Fourier transform over the
              inner-most 2 dimensions of `input`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.IFFT3D(TensorFlow.TFOutput,System.String)">
            <summary>
              Inverse 3D fast Fourier transform.
            </summary>
            <param name="input">
              A complex64 tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IFFT3D'.
            </param>
            <returns>
              A complex64 tensor of the same shape as `input`. The inner-most 3
                dimensions of `input` are replaced with their inverse 3D Fourier transform.
              
              @compatibility(numpy)
              Equivalent to np.fft.ifftn with 3 dimensions.
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes the inverse 3-dimensional discrete Fourier transform over the
              inner-most 3 dimensions of `input`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Igamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Compute the lower regularized incomplete Gamma function `Q(a, x)`.
            </summary>
            <param name="a">
            </param>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Igamma'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The lower regularized incomplete Gamma function is defined as:
              
              
              \\(P(a, x) = gamma(a, x) / Gamma(a) = 1 - Q(a, x)\\)
              
              where
              
              \\(gamma(a, x) = int_{0}^{x} t^{a-1} exp(-t) dt\\)
              
              is the lower incomplete Gamma function.
              
              Note, above `Q(a, x)` (`Igammac`) is the upper regularized complete
              Gamma function.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Igammac(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Compute the upper regularized incomplete Gamma function `Q(a, x)`.
            </summary>
            <param name="a">
            </param>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Igammac'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The upper regularized incomplete Gamma function is defined as:
              
              \\(Q(a, x) = Gamma(a, x) / Gamma(a) = 1 - P(a, x)\\)
              
              where
              
              \\(Gamma(a, x) = int_{x}^{\infty} t^{a-1} exp(-t) dt\\)
              
              is the upper incomplete Gama function.
              
              Note, above `P(a, x)` (`Igamma`) is the lower regularized complete
              Gamma function.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.IgnoreErrorsDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that contains the elements of `input_dataset` ignoring errors.
            </summary>
            <param name="input_dataset">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IgnoreErrorsDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Imag(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Returns the imaginary part of a complex number.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Imag'.
            </param>
            <param name="Tout">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a tensor `input` of complex numbers, this operation returns a tensor of
              type `float` that is the imaginary part of each element in `input`. All
              elements in `input` must be complex numbers of the form \\(a + bj\\), where *a*
              is the real part and *b* is the imaginary part returned by this operation.
              
              For example:
              
              ```
              # tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]
              tf.imag(input) ==&amp;gt; [4.75, 5.75]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ImageSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},TensorFlow.TFTensor,System.String)">
            <summary>
              Outputs a `Summary` protocol buffer with images.
            </summary>
            <param name="tag">
              Scalar. Used to build the `tag` attribute of the summary values.
            </param>
            <param name="tensor">
              4-D of shape `[batch_size, height, width, channels]` where
              `channels` is 1, 3, or 4.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ImageSummary'.
            </param>
            <param name="max_images">
              Optional argument
              Max number of batch elements to generate images for.
            </param>
            <param name="bad_color">
              Optional argument
              Color to use for pixels with non-finite values.
            </param>
            <returns>
              Scalar. Serialized `Summary` protocol buffer.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The summary has up to `max_images` summary values containing images. The
              images are built from `tensor` which must be 4-D with shape `[batch_size,
              height, width, channels]` and where `channels` can be:
              
              *  1: `tensor` is interpreted as Grayscale.
              *  3: `tensor` is interpreted as RGB.
              *  4: `tensor` is interpreted as RGBA.
              
              The images have the same number of channels as the input tensor. For float
              input, the values are normalized one image at a time to fit in the range
              `[0, 255]`.  `uint8` values are unchanged.  The op uses two different
              normalization algorithms:
              
              *  If the input values are all positive, they are rescaled so the largest one
                 is 255.
              
              *  If any input value is negative, the values are shifted so input value 0.0
                 is at 127.  They are then rescaled so that either the smallest value is 0,
                 or the largest one is 255.
              
              The `tag` argument is a scalar `Tensor` of type `string`.  It is used to
              build the `tag` of the summary values:
              
              *  If `max_images` is 1, the summary value tag is '*tag*/image'.
              *  If `max_images` is greater than 1, the summary value tags are
                 generated sequentially as '*tag*/image/0', '*tag*/image/1', etc.
              
              The `bad_color` argument is the color to use in the generated images for
              non-finite input values.  It is a `unit8` 1-D tensor of length `channels`.
              Each element must be in the range `[0, 255]` (It represents the value of a
              pixel in the output image).  Non-finite values in the input tensor are
              replaced by this tensor in the output image.  The default value is the color
              red.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ImmutableConst(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String)">
            <summary>
              Returns immutable tensor from memory region.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ImmutableConst'.
            </param>
            <param name="dtype">
              Type of the returned tensor.
            </param>
            <param name="shape">
              Shape of the returned tensor.
            </param>
            <param name="memory_region_name">
              Name of readonly memory region used by the tensor, see
              NewReadOnlyMemoryRegionFromFile in tensorflow::Env.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The current implementation memmaps the tensor from a file.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ImportEvent(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Outputs a `tf.Event` protocol buffer.
            </summary>
            <param name="writer">
              A handle to a summary writer.
            </param>
            <param name="evnt">
              A string containing a binary-encoded tf.Event proto.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ImportEvent'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              When CreateSummaryDbWriter is being used, this op can be useful for
              importing data from event logs.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.InitializeTable(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Table initializer that takes two tensors for keys and values respectively.
            </summary>
            <param name="table_handle">
              Handle to a table which will be initialized.
            </param>
            <param name="keys">
              Keys of type Tkey.
            </param>
            <param name="values">
              Values of type Tval.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTable'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.InitializeTableFromTextFile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">
            <summary>
              Initializes a table from a text file.
            </summary>
            <param name="table_handle">
              Handle to a table which will be initialized.
            </param>
            <param name="filename">
              Filename of a vocabulary text file.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTableFromTextFile'.
            </param>
            <param name="vocab_size">
              Optional argument
              Number of elements of the file, use -1 if unknown.
            </param>
            <param name="delimiter">
              Optional argument
              Delimiter to separate fields in a line.
            </param>
            <param name="key_index">
              Column index in a line to get the table `key` values from.
            </param>
            <param name="value_index">
              Column index that represents information of a line to get the table
              `value` values from.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              It inserts one key-value pair into the table for each line of the file.
              The key and value is extracted from the whole line content, elements from the
              split line based on `delimiter` or the line number (starting from zero).
              Where to extract the key and value from a line is specified by `key_index` and
              `value_index`.
              
              - A value of -1 means use the line number(starting from zero), expects `int64`.
              - A value of -2 means use the whole line content, expects `string`.
              - A value &amp;gt;= 0 means use the index (starting at zero) of the split line based
                on `delimiter`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.InitializeTableFromTextFileV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">
            <summary>
              Initializes a table from a text file.
            </summary>
            <param name="table_handle">
              Handle to a table which will be initialized.
            </param>
            <param name="filename">
              Filename of a vocabulary text file.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTableFromTextFileV2'.
            </param>
            <param name="vocab_size">
              Optional argument
              Number of elements of the file, use -1 if unknown.
            </param>
            <param name="delimiter">
              Optional argument
              Delimiter to separate fields in a line.
            </param>
            <param name="key_index">
              Column index in a line to get the table `key` values from.
            </param>
            <param name="value_index">
              Column index that represents information of a line to get the table
              `value` values from.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              It inserts one key-value pair into the table for each line of the file.
              The key and value is extracted from the whole line content, elements from the
              split line based on `delimiter` or the line number (starting from zero).
              Where to extract the key and value from a line is specified by `key_index` and
              `value_index`.
              
              - A value of -1 means use the line number(starting from zero), expects `int64`.
              - A value of -2 means use the whole line content, expects `string`.
              - A value &amp;gt;= 0 means use the index (starting at zero) of the split line based
                on `delimiter`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.InitializeTableV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Table initializer that takes two tensors for keys and values respectively.
            </summary>
            <param name="table_handle">
              Handle to a table which will be initialized.
            </param>
            <param name="keys">
              Keys of type Tkey.
            </param>
            <param name="values">
              Values of type Tval.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTableV2'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.InTopK(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">
            <summary>
              Says whether the targets are in the top `K` predictions.
            </summary>
            <param name="predictions">
              A `batch_size` x `classes` tensor.
            </param>
            <param name="targets">
              A `batch_size` vector of class ids.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'InTopK'.
            </param>
            <param name="k">
              Number of top elements to look at for computing precision.
            </param>
            <returns>
              Computed Precision at `k` as a `bool Tensor`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This outputs a `batch_size` bool array, an entry `out[i]` is `true` if the
              prediction for the target class is among the top `k` predictions among
              all predictions for example `i`. Note that the behavior of `InTopK` differs
              from the `TopK` op in its handling of ties; if multiple classes have the
              same prediction value and straddle the top-`k` boundary, all of those
              classes are considered to be in the top `k`.
              
              More formally, let
              
                \\(predictions_i\\) be the predictions for all classes for example `i`,
                \\(targets_i\\) be the target class for example `i`,
                \\(out_i\\) be the output for example `i`,
              
              $$out_i = predictions_{i, targets_i} \in TopKIncludingTies(predictions_i)$$
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.InTopKV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Says whether the targets are in the top `K` predictions.
            </summary>
            <param name="predictions">
              A `batch_size` x `classes` tensor.
            </param>
            <param name="targets">
              A `batch_size` vector of class ids.
            </param>
            <param name="k">
              Number of top elements to look at for computing precision.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'InTopKV2'.
            </param>
            <returns>
              Computed precision at `k` as a `bool Tensor`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This outputs a `batch_size` bool array, an entry `out[i]` is `true` if the
              prediction for the target class is among the top `k` predictions among
              all predictions for example `i`. Note that the behavior of `InTopK` differs
              from the `TopK` op in its handling of ties; if multiple classes have the
              same prediction value and straddle the top-`k` boundary, all of those
              classes are considered to be in the top `k`.
              
              More formally, let
              
                \\(predictions_i\\) be the predictions for all classes for example `i`,
                \\(targets_i\\) be the target class for example `i`,
                \\(out_i\\) be the output for example `i`,
              
              $$out_i = predictions_{i, targets_i} \in TopKIncludingTies(predictions_i)$$
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Inv(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the reciprocal of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Inv'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              I.e., \\(y = 1 / x\\).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Invert(TensorFlow.TFOutput,System.String)">
            <summary>
              Flips all bits elementwise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Invert'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The result will have exactly those bits set, that are not set in `x`. The
              computation is performed on the underlying representation of x.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.InvertPermutation(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the inverse permutation of a tensor.
            </summary>
            <param name="x">
              1-D.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'InvertPermutation'.
            </param>
            <returns>
              1-D.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation computes the inverse of an index permutation. It takes a 1-D
              integer tensor `x`, which represents the indices of a zero-based array, and
              swaps each value with its index position. In other words, for an output tensor
              `y` and an input tensor `x`, this operation computes the following:
              
              `y[x[i]] = i for i in [0, 1, ..., len(x) - 1]`
              
              The values must include 0. There can be no duplicate values or negative values.
              
              For example:
              
              ```
              # tensor `x` is [3, 4, 0, 2, 1]
              invert_permutation(x) ==&amp;gt; [2, 4, 3, 0, 1]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.InvGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the gradient for the inverse of `x` wrt its input.
            </summary>
            <param name="y">
            </param>
            <param name="dy">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'InvGrad'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Specifically, `grad = -dy * y*y`, where `y = 1/x`, and `dy`
              is the corresponding input gradient.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.IRFFT(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Inverse real-valued fast Fourier transform.
            </summary>
            <param name="input">
              A complex64 tensor.
            </param>
            <param name="fft_length">
              An int32 tensor of shape [1]. The FFT length.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IRFFT'.
            </param>
            <returns>
              A float32 tensor of the same rank as `input`. The inner-most
                dimension of `input` is replaced with the `fft_length` samples of its inverse
                1D Fourier transform.
              
              @compatibility(numpy)
              Equivalent to np.fft.irfft
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes the inverse 1-dimensional discrete Fourier transform of a real-valued
              signal over the inner-most dimension of `input`.
              
              The inner-most dimension of `input` is assumed to be the result of `RFFT`: the
              `fft_length / 2 + 1` unique components of the DFT of a real-valued signal. If
              `fft_length` is not provided, it is computed from the size of the inner-most
              dimension of `input` (`fft_length = 2 * (inner - 1)`). If the FFT length used to
              compute `input` is odd, it should be provided since it cannot be inferred
              properly.
              
              Along the axis `IRFFT` is computed on, if `fft_length / 2 + 1` is smaller
              than the corresponding dimension of `input`, the dimension is cropped. If it is
              larger, the dimension is padded with zeros.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.IRFFT2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Inverse 2D real-valued fast Fourier transform.
            </summary>
            <param name="input">
              A complex64 tensor.
            </param>
            <param name="fft_length">
              An int32 tensor of shape [2]. The FFT length for each dimension.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IRFFT2D'.
            </param>
            <returns>
              A float32 tensor of the same rank as `input`. The inner-most 2
                dimensions of `input` are replaced with the `fft_length` samples of their
                inverse 2D Fourier transform.
              
              @compatibility(numpy)
              Equivalent to np.fft.irfft2
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes the inverse 2-dimensional discrete Fourier transform of a real-valued
              signal over the inner-most 2 dimensions of `input`.
              
              The inner-most 2 dimensions of `input` are assumed to be the result of `RFFT2D`:
              The inner-most dimension contains the `fft_length / 2 + 1` unique components of
              the DFT of a real-valued signal. If `fft_length` is not provided, it is computed
              from the size of the inner-most 2 dimensions of `input`. If the FFT length used
              to compute `input` is odd, it should be provided since it cannot be inferred
              properly.
              
              Along each axis `IRFFT2D` is computed on, if `fft_length` (or
              `fft_length / 2 + 1` for the inner-most dimension) is smaller than the
              corresponding dimension of `input`, the dimension is cropped. If it is larger,
              the dimension is padded with zeros.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.IRFFT3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Inverse 3D real-valued fast Fourier transform.
            </summary>
            <param name="input">
              A complex64 tensor.
            </param>
            <param name="fft_length">
              An int32 tensor of shape [3]. The FFT length for each dimension.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IRFFT3D'.
            </param>
            <returns>
              A float32 tensor of the same rank as `input`. The inner-most 3
                dimensions of `input` are replaced with the `fft_length` samples of their
                inverse 3D real Fourier transform.
              
              @compatibility(numpy)
              Equivalent to np.irfftn with 3 dimensions.
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes the inverse 3-dimensional discrete Fourier transform of a real-valued
              signal over the inner-most 3 dimensions of `input`.
              
              The inner-most 3 dimensions of `input` are assumed to be the result of `RFFT3D`:
              The inner-most dimension contains the `fft_length / 2 + 1` unique components of
              the DFT of a real-valued signal. If `fft_length` is not provided, it is computed
              from the size of the inner-most 3 dimensions of `input`. If the FFT length used
              to compute `input` is odd, it should be provided since it cannot be inferred
              properly.
              
              Along each axis `IRFFT3D` is computed on, if `fft_length` (or
              `fft_length / 2 + 1` for the inner-most dimension) is smaller than the
              corresponding dimension of `input`, the dimension is cropped. If it is larger,
              the dimension is padded with zeros.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.IsFinite(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns which elements of x are finite.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IsFinite'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              @compatibility(numpy)
              Equivalent to np.isfinite
              @end_compatibility
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.IsInf(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns which elements of x are Inf.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IsInf'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              @compatibility(numpy)
              Equivalent to np.isinf
              @end_compatibility
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.IsNan(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns which elements of x are NaN.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IsNan'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              @compatibility(numpy)
              Equivalent to np.isnan
              @end_compatibility
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.IsVariableInitialized(TensorFlow.TFOutput,System.String)">
            <summary>
              Checks whether a tensor has been initialized.
            </summary>
            <param name="reference">
              Should be from a `Variable` node. May be uninitialized.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IsVariableInitialized'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Outputs boolean scalar indicating whether the tensor has been initialized.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Iterator(System.String,System.String,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              A container for an iterator resource.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Iterator'.
            </param>
            <param name="shared_name">
            </param>
            <param name="container">
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              A handle to the iterator that can be passed to a "MakeIterator"
              or "IteratorGetNext" op.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.IteratorFromStringHandle(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Converts the given string representing a handle to an iterator to a resource.
            </summary>
            <param name="string_handle">
              A string representation of the given handle.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorFromStringHandle'.
            </param>
            <param name="output_types">
              Optional argument
              If specified, defines the type of each tuple component in an
              element produced by the resulting iterator.
            </param>
            <param name="output_shapes">
              Optional argument
              If specified, defines the shape of each tuple component in an
              element produced by the resulting iterator.
            </param>
            <returns>
              A handle to an iterator resource.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.IteratorGetNext(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Gets the next output from the given iterator.
            </summary>
            <param name="iterator">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorGetNext'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.IteratorSetStatsAggregator(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Associates the given iterator with the given statistics aggregator.
            </summary>
            <param name="iterator_handle">
            </param>
            <param name="stats_aggregator_handle">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorSetStatsAggregator'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.IteratorToStringHandle(TensorFlow.TFOutput,System.String)">
            <summary>
              Converts the given `resource_handle` representing an iterator to a string.
            </summary>
            <param name="resource_handle">
              A handle to an iterator resource.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorToStringHandle'.
            </param>
            <returns>
              A string representation of the given handle.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.L2Loss(TensorFlow.TFOutput,System.String)">
            <summary>
              L2 Loss.
            </summary>
            <param name="t">
              Typically 2-D, but may have any dimensions.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'L2Loss'.
            </param>
            <returns>
              0-D.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes half the L2 norm of a tensor without the `sqrt`:
              
                  output = sum(t ** 2) / 2
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LatencyStatsDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Records the latency of producing `input_dataset` elements in a StatsAggregator.
            </summary>
            <param name="input_dataset">
            </param>
            <param name="tag">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LatencyStatsDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.LearnedUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Generates labels for candidate sampling with a learned unigram distribution.
            </summary>
            <param name="true_classes">
              A batch_size * num_true matrix, in which each row contains the
              IDs of the num_true target_classes in the corresponding original label.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LearnedUnigramCandidateSampler'.
            </param>
            <param name="seed">
              Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              An second seed to avoid seed collision.
            </param>
            <param name="num_true">
              Number of true labels per context.
            </param>
            <param name="num_sampled">
              Number of candidates to randomly sample.
            </param>
            <param name="unique">
              If unique is true, we sample with rejection, so that all sampled
              candidates in a batch are unique. This requires some approximation to
              estimate the post-rejection sampling probabilities.
            </param>
            <param name="range_max">
              The sampler will sample integers from the interval [0, range_max).
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              sampled_candidates: A vector of length num_sampled, in which each element is
              the ID of a sampled candidate.
              true_expected_count: A batch_size * num_true matrix, representing
              the number of times each candidate is expected to occur in a batch
              of sampled candidates. If unique=true, then this is a probability.
              sampled_expected_count: A vector of length num_sampled, for each sampled
              candidate representing the number of times the candidate is expected
              to occur in a batch of sampled candidates.  If unique=true, then this is a
              probability.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              See explanations of candidate sampling and the data formats at
              go/candidate-sampling.
              
              For each batch, this op picks a single set of sampled candidate labels.
              
              The advantages of sampling candidates per-batch are simplicity and the
              possibility of efficient dense matrix multiplication. The disadvantage is that
              the sampled candidates must be chosen independently of the context and of the
              true labels.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LeftShift(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Elementwise computes the bitwise left-shift of `x` and `y`.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LeftShift'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              If `y` is negative, or greater than or equal to the width of `x` in bits the
              result is implementation defined.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Less(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the truth value of (x &amp;lt; y) element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Less'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `Less` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LessEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the truth value of (x &amp;lt;= y) element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LessEqual'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `LessEqual` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Lgamma(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the log of the absolute value of `Gamma(x)` element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Lgamma'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.LinSpace(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Generates values in an interval.
            </summary>
            <param name="start">
              First entry in the range.
            </param>
            <param name="stop">
              Last entry in the range.
            </param>
            <param name="num">
              Number of values to generate.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LinSpace'.
            </param>
            <returns>
              1-D. The generated values.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              A sequence of `num` evenly-spaced values are generated beginning at `start`.
              If `num &amp;gt; 1`, the values in the sequence increase by `stop - start / num - 1`,
              so that the last one is exactly `stop`.
              
              For example:
              
              ```
              tf.linspace(10.0, 12.0, 3, name="linspace") =&amp;gt; [ 10.0  11.0  12.0]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ListDiff(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Computes the difference between two lists of numbers or strings.
            </summary>
            <param name="x">
              1-D. Values to keep.
            </param>
            <param name="y">
              1-D. Values to remove.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ListDiff'.
            </param>
            <param name="out_idx">
              Optional argument
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: 1-D. Values present in `x` but not in `y`.
              idx: 1-D. Positions of `x` values preserved in `out`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Given a list `x` and a list `y`, this operation returns a list `out` that
              represents all values that are in `x` but not in `y`. The returned list `out`
              is sorted in the same order that the numbers appear in `x` (duplicates are
              preserved). This operation also returns a list `idx` that represents the
              position of each `out` element in `x`. In other words:
              
              `out[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]`
              
              For example, given this input:
              
              ```
              x = [1, 2, 3, 4, 5, 6]
              y = [1, 3, 5]
              ```
              
              This operation would return:
              
              ```
              out ==&amp;gt; [2, 4, 6]
              idx ==&amp;gt; [1, 3, 5]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LMDBReader(System.String,System.String,System.String)">
            <summary>
              A Reader that outputs the records from a LMDB file.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LMDBReader'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.
            </param>
            <returns>
              The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.LoadAndRemapMatrix(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String)">
            <summary>
              Loads a 2-D (matrix) `Tensor` with name `old_tensor_name` from the checkpoint
            </summary>
            <param name="ckpt_path">
              Path to the TensorFlow checkpoint (version 2, `TensorBundle`) from
              which the old matrix `Tensor` will be loaded.
            </param>
            <param name="old_tensor_name">
              Name of the 2-D `Tensor` to load from checkpoint.
            </param>
            <param name="row_remapping">
              An int `Tensor` of row remappings (generally created by
              `generate_vocab_remapping`).  Even if no row remapping is needed, this must
              still be an index-valued Tensor (e.g. [0, 1, 2, ...]), or a shifted
              index-valued `Tensor` (e.g. [8, 9, 10, ...], for partitioned `Variables`).
            </param>
            <param name="col_remapping">
              An int `Tensor` of column remappings (generally created by
              `generate_vocab_remapping`).  May be a size-0 `Tensor` if only row remapping
              is to be done (e.g. column ordering is the same).
            </param>
            <param name="initializing_values">
              A float `Tensor` containing  values to fill in for cells
              in the output matrix that are not loaded from the checkpoint. Length must be
              exactly the same as the number of missing / new cells.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadAndRemapMatrix'.
            </param>
            <param name="max_rows_in_memory">
              Optional argument
              The maximum number of rows to load from the checkpoint at
              once. If less than or equal to 0, the entire matrix will be loaded into
              memory. Setting this arg trades increased disk reads for lower memory usage.
            </param>
            <param name="num_rows">
              Number of rows (length of the 1st dimension) in the output matrix.
            </param>
            <param name="num_cols">
              Number of columns (length of the 2nd dimension) in the output matrix.
            </param>
            <returns>
              Output matrix containing existing values loaded from the
              checkpoint, and with any missing values filled in from initializing_values.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              at `ckpt_path` and potentially reorders its rows and columns using the
              specified remappings.
              
              Most users should use one of the wrapper initializers (such as
              `tf.contrib.framework.load_and_remap_matrix_initializer`) instead of this
              function directly.
              
              The remappings are 1-D tensors with the following properties:
              
              * `row_remapping` must have exactly `num_rows` entries. Row `i` of the output
                matrix will be initialized from the row corresponding to index
                `row_remapping[i]` in the old `Tensor` from the checkpoint.
              * `col_remapping` must have either 0 entries (indicating that no column
                reordering is needed) or `num_cols` entries. If specified, column `j` of the
                output matrix will be initialized from the column corresponding to index
                `col_remapping[j]` in the old `Tensor` from the checkpoint.
              * A value of -1 in either of the remappings signifies a "missing" entry. In that
                case, values from the `initializing_values` tensor will be used to fill that
                missing row or column. If `row_remapping` has `r` missing entries and
                `col_remapping` has `c` missing entries, then the following condition must be
                true:
              
              `(r * num_cols) + (c * num_rows) - (r * c) == len(initializing_values)`
              
              The remapping tensors can be generated using the GenerateVocabRemapping op.
              
              As an example, with row_remapping = [1, 0, -1], col_remapping = [0, 2, -1],
              initializing_values = [0.5, -0.5, 0.25, -0.25, 42], and w(i, j) representing
              the value from row i, column j of the old tensor in the checkpoint, the output
              matrix will look like the following:
              
              [[w(1, 0),  w(1, 2),  0.5],
               [w(0, 0),  w(0, 2), -0.5],
               [0.25,    -0.25,      42]]
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Log(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes natural logarithm of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Log'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              I.e., \\(y = \log_e x\\).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Log1p(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes natural logarithm of (1 + x) element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Log1p'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              I.e., \\(y = \log_e (1 + x)\\).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LogicalAnd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the truth value of x AND y element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LogicalAnd'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `LogicalAnd` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LogicalNot(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the truth value of NOT x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LogicalNot'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.LogicalOr(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the truth value of x OR y element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LogicalOr'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `LogicalOr` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LogMatrixDeterminant(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the sign and the log of the absolute value of the determinant of
            </summary>
            <param name="input">
              Shape is `[N, M, M]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LogMatrixDeterminant'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              sign: The signs of the log determinants of the inputs. Shape is `[N]`.
              log_abs_determinant: The logs of the absolute values of the determinants
              of the N input matrices.  Shape is `[N]`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              one or more square matrices.
              
              The input is a tensor of shape `[N, M, M]` whose inner-most 2 dimensions
              form square matrices. The outputs are two tensors containing the signs and
              absolute values of the log determinants for all N input submatrices
              `[..., :, :]` such that the determinant = sign*exp(log_abs_determinant).
              The log_abs_determinant is computed as det(P)*sum(log(diag(LU))) where LU
              is the LU decomposition of the input and P is the corresponding
              permutation matrix.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LogSoftmax(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes log softmax activations.
            </summary>
            <param name="logits">
              2-D with shape `[batch_size, num_classes]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LogSoftmax'.
            </param>
            <returns>
              Same shape as `logits`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              For each batch `i` and class `j` we have
              
                  logsoftmax[i, j] = logits[i, j] - log(sum(exp(logits[i])))
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LogUniformCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Generates labels for candidate sampling with a log-uniform distribution.
            </summary>
            <param name="true_classes">
              A batch_size * num_true matrix, in which each row contains the
              IDs of the num_true target_classes in the corresponding original label.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LogUniformCandidateSampler'.
            </param>
            <param name="seed">
              Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              An second seed to avoid seed collision.
            </param>
            <param name="num_true">
              Number of true labels per context.
            </param>
            <param name="num_sampled">
              Number of candidates to randomly sample.
            </param>
            <param name="unique">
              If unique is true, we sample with rejection, so that all sampled
              candidates in a batch are unique. This requires some approximation to
              estimate the post-rejection sampling probabilities.
            </param>
            <param name="range_max">
              The sampler will sample integers from the interval [0, range_max).
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              sampled_candidates: A vector of length num_sampled, in which each element is
              the ID of a sampled candidate.
              true_expected_count: A batch_size * num_true matrix, representing
              the number of times each candidate is expected to occur in a batch
              of sampled candidates. If unique=true, then this is a probability.
              sampled_expected_count: A vector of length num_sampled, for each sampled
              candidate representing the number of times the candidate is expected
              to occur in a batch of sampled candidates.  If unique=true, then this is a
              probability.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              See explanations of candidate sampling and the data formats at
              go/candidate-sampling.
              
              For each batch, this op picks a single set of sampled candidate labels.
              
              The advantages of sampling candidates per-batch are simplicity and the
              possibility of efficient dense matrix multiplication. The disadvantage is that
              the sampled candidates must be chosen independently of the context and of the
              true labels.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LookupTableExport(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)">
            <summary>
              Outputs all keys and values in the table.
            </summary>
            <param name="table_handle">
              Handle to the table.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableExport'.
            </param>
            <param name="Tkeys">
            </param>
            <param name="Tvalues">
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              keys: Vector of all keys present in the table.
              values: Tensor of all values in the table. Indexed in parallel with `keys`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.LookupTableExportV2(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)">
            <summary>
              Outputs all keys and values in the table.
            </summary>
            <param name="table_handle">
              Handle to the table.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableExportV2'.
            </param>
            <param name="Tkeys">
            </param>
            <param name="Tvalues">
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              keys: Vector of all keys present in the table.
              values: Tensor of all values in the table. Indexed in parallel with `keys`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.LookupTableFind(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Looks up keys in a table, outputs the corresponding values.
            </summary>
            <param name="table_handle">
              Handle to the table.
            </param>
            <param name="keys">
              Any shape.  Keys to look up.
            </param>
            <param name="default_value">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableFind'.
            </param>
            <returns>
              Same shape as `keys`.  Values found in the table, or `default_values`
              for missing keys.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The tensor `keys` must of the same type as the keys of the table.
              The output `values` is of the type of the table values.
              
              The scalar `default_value` is the value output for keys not present in the
              table. It must also be of the same type as the table values.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LookupTableFindV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Looks up keys in a table, outputs the corresponding values.
            </summary>
            <param name="table_handle">
              Handle to the table.
            </param>
            <param name="keys">
              Any shape.  Keys to look up.
            </param>
            <param name="default_value">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableFindV2'.
            </param>
            <returns>
              Same shape as `keys`.  Values found in the table, or `default_values`
              for missing keys.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The tensor `keys` must of the same type as the keys of the table.
              The output `values` is of the type of the table values.
              
              The scalar `default_value` is the value output for keys not present in the
              table. It must also be of the same type as the table values.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LookupTableImport(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Replaces the contents of the table with the specified keys and values.
            </summary>
            <param name="table_handle">
              Handle to the table.
            </param>
            <param name="keys">
              Any shape.  Keys to look up.
            </param>
            <param name="values">
              Values to associate with keys.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableImport'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The tensor `keys` must be of the same type as the keys of the table.
              The tensor `values` must be of the type of the table values.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LookupTableImportV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Replaces the contents of the table with the specified keys and values.
            </summary>
            <param name="table_handle">
              Handle to the table.
            </param>
            <param name="keys">
              Any shape.  Keys to look up.
            </param>
            <param name="values">
              Values to associate with keys.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableImportV2'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The tensor `keys` must be of the same type as the keys of the table.
              The tensor `values` must be of the type of the table values.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LookupTableInsert(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Updates the table to associates keys with values.
            </summary>
            <param name="table_handle">
              Handle to the table.
            </param>
            <param name="keys">
              Any shape.  Keys to look up.
            </param>
            <param name="values">
              Values to associate with keys.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableInsert'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The tensor `keys` must be of the same type as the keys of the table.
              The tensor `values` must be of the type of the table values.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LookupTableInsertV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Updates the table to associates keys with values.
            </summary>
            <param name="table_handle">
              Handle to the table.
            </param>
            <param name="keys">
              Any shape.  Keys to look up.
            </param>
            <param name="values">
              Values to associate with keys.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableInsertV2'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The tensor `keys` must be of the same type as the keys of the table.
              The tensor `values` must be of the type of the table values.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LookupTableSize(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the number of elements in the given table.
            </summary>
            <param name="table_handle">
              Handle to the table.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableSize'.
            </param>
            <returns>
              Scalar that contains number of elements in the table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.LookupTableSizeV2(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the number of elements in the given table.
            </summary>
            <param name="table_handle">
              Handle to the table.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableSizeV2'.
            </param>
            <returns>
              Scalar that contains number of elements in the table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.LoopCond(TensorFlow.TFOutput,System.String)">
            <summary>
              Forwards the input to the output.
            </summary>
            <param name="input">
              A boolean scalar, representing the branch predicate of the Switch op.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LoopCond'.
            </param>
            <returns>
              The same tensor as `input`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operator represents the loop termination condition used by the
              "pivot" switches of a loop.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LRN(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)">
            <summary>
              Local Response Normalization.
            </summary>
            <param name="input">
              4-D.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LRN'.
            </param>
            <param name="depth_radius">
              Optional argument
              0-D.  Half-width of the 1-D normalization window.
            </param>
            <param name="bias">
              Optional argument
              An offset (usually positive to avoid dividing by 0).
            </param>
            <param name="alpha">
              Optional argument
              A scale factor, usually positive.
            </param>
            <param name="beta">
              Optional argument
              An exponent.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The 4-D `input` tensor is treated as a 3-D array of 1-D vectors (along the last
              dimension), and each vector is normalized independently.  Within a given vector,
              each component is divided by the weighted, squared sum of inputs within
              `depth_radius`.  In detail,
              
                  sqr_sum[a, b, c, d] =
                      sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
                  output = input / (bias + alpha * sqr_sum) ** beta
              
              For details, see [Krizhevsky et al., ImageNet classification with deep
              convolutional neural networks (NIPS 2012)](http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.LRNGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)">
            <summary>
              Gradients for Local Response Normalization.
            </summary>
            <param name="input_grads">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="input_image">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="output_image">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'LRNGrad'.
            </param>
            <param name="depth_radius">
              Optional argument
              A depth radius.
            </param>
            <param name="bias">
              Optional argument
              An offset (usually &amp;gt; 0 to avoid dividing by 0).
            </param>
            <param name="alpha">
              Optional argument
              A scale factor, usually positive.
            </param>
            <param name="beta">
              Optional argument
              An exponent.
            </param>
            <returns>
              The gradients for LRN.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MakeIterator(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Makes a new iterator from the given `dataset` and stores it in `iterator`.
            </summary>
            <param name="dataset">
            </param>
            <param name="iterator">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MakeIterator'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              This operation may be executed multiple times. Each execution will reset the
              iterator in `iterator` to the first element of `dataset`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MapClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op removes all elements in the underlying container.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MapClear'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MapIncompleteSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op returns the number of incomplete elements in the underlying container.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MapIncompleteSize'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MapPeek(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op peeks at the values at the specified key.  If the
            </summary>
            <param name="key">
            </param>
            <param name="indices">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MapPeek'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              underlying container does not contain this key
              this op will block until it does.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MapSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op returns the number of elements in the underlying container.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MapSize'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MapStage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Stage (key, values) in the underlying container which behaves like a hashtable.
            </summary>
            <param name="key">
              int64
            </param>
            <param name="indices">
            </param>
            <param name="values">
              a list of tensors
              dtypes A list of data types that inserted values should adhere to.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MapStage'.
            </param>
            <param name="capacity">
              Optional argument
              Maximum number of elements in the Staging Area. If &amp;gt; 0, inserts
              on the container will block when the capacity is reached.
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
              If non-empty, this queue is placed in the given container. Otherwise,
              a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              It is necessary to match this name to the matching Unstage Op.
            </param>
            <param name="dtypes">
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MapUnstage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op removes and returns the values associated with the key
            </summary>
            <param name="key">
            </param>
            <param name="indices">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MapUnstage'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              from the underlying container.   If the underlying container
              does not contain this key, the op will block until it does.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MapUnstageNoKey(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op removes and returns a random (key, value)
            </summary>
            <param name="indices">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MapUnstageNoKey'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              key: 
              values: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              from the underlying container.   If the underlying container
              does not contain elements, the op will block until it does.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MatchingFiles(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the set of files matching one or more glob patterns.
            </summary>
            <param name="pattern">
              Shell wildcard pattern(s). Scalar or vector of type string.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MatchingFiles'.
            </param>
            <returns>
              A vector of matching filenames.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Note that this routine only supports wildcard characters in the
              basename portion of the pattern, not in the directory portion.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Multiply the matrix "a" by the matrix "b".
            </summary>
            <param name="a">
            </param>
            <param name="b">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MatMul'.
            </param>
            <param name="transpose_a">
              Optional argument
              If true, "a" is transposed before multiplication.
            </param>
            <param name="transpose_b">
              Optional argument
              If true, "b" is transposed before multiplication.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The inputs must be two-dimensional matrices and the inner dimension of
              "a" (after being transposed if transpose_a is true) must match the
              outer dimension of "b" (after being transposed if transposed_b is
              true).
              
              *Note*: The default kernel implementation for MatMul on GPUs uses
              cublas.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MatrixBandPart(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Copy a tensor setting everything outside a central band in each innermost matrix
            </summary>
            <param name="input">
              Rank `k` tensor.
            </param>
            <param name="num_lower">
              0-D tensor. Number of subdiagonals to keep. If negative, keep entire
              lower triangle.
            </param>
            <param name="num_upper">
              0-D tensor. Number of superdiagonals to keep. If negative, keep
              entire upper triangle.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixBandPart'.
            </param>
            <returns>
              Rank `k` tensor of the same shape as input. The extracted banded tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              to zero.
              
              The `band` part is computed as follows:
              Assume `input` has `k` dimensions `[I, J, K, ..., M, N]`, then the output is a
              tensor with the same shape where
              
              `band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]`.
              
              The indicator function
              
              `in_band(m, n) = (num_lower &amp;lt; 0 || (m-n) &amp;lt;= num_lower)) &amp;&amp;
                               (num_upper &amp;lt; 0 || (n-m) &amp;lt;= num_upper)`.
              
              For example:
              
              ```
              # if 'input' is [[ 0,  1,  2, 3]
                               [-1,  0,  1, 2]
                               [-2, -1,  0, 1]
                               [-3, -2, -1, 0]],
              
              tf.matrix_band_part(input, 1, -1) ==&amp;gt; [[ 0,  1,  2, 3]
                                                     [-1,  0,  1, 2]
                                                     [ 0, -1,  0, 1]
                                                     [ 0,  0, -1, 0]],
              
              tf.matrix_band_part(input, 2, 1) ==&amp;gt; [[ 0,  1,  0, 0]
                                                    [-1,  0,  1, 0]
                                                    [-2, -1,  0, 1]
                                                    [ 0, -2, -1, 0]]
              ```
              
              Useful special cases:
              
              ```
               tf.matrix_band_part(input, 0, -1) ==&amp;gt; Upper triangular part.
               tf.matrix_band_part(input, -1, 0) ==&amp;gt; Lower triangular part.
               tf.matrix_band_part(input, 0, 0) ==&amp;gt; Diagonal.
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MatrixDeterminant(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the determinant of one or more square matrices.
            </summary>
            <param name="input">
              Shape is `[..., M, M]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDeterminant'.
            </param>
            <returns>
              Shape is `[...]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions
              form square matrices. The output is a tensor containing the determinants
              for all input submatrices `[..., :, :]`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MatrixDiag(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns a batched diagonal tensor with a given batched diagonal values.
            </summary>
            <param name="diagonal">
              Rank `k`, where `k &amp;gt;= 1`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDiag'.
            </param>
            <returns>
              Rank `k+1`, with `output.shape = diagonal.shape + [diagonal.shape[-1]]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a `diagonal`, this operation returns a tensor with the `diagonal` and
              everything else padded with zeros. The diagonal is computed as follows:
              
              Assume `diagonal` has `k` dimensions `[I, J, K, ..., N]`, then the output is a
              tensor of rank `k+1` with dimensions [I, J, K, ..., N, N]` where:
              
              `output[i, j, k, ..., m, n] = 1{m=n} * diagonal[i, j, k, ..., n]`.
              
              For example:
              
              ```
              # 'diagonal' is [[1, 2, 3, 4], [5, 6, 7, 8]]
              
              and diagonal.shape = (2, 4)
              
              tf.matrix_diag(diagonal) ==&amp;gt; [[[1, 0, 0, 0]
                                                   [0, 2, 0, 0]
                                                   [0, 0, 3, 0]
                                                   [0, 0, 0, 4]],
                                                  [[5, 0, 0, 0]
                                                   [0, 6, 0, 0]
                                                   [0, 0, 7, 0]
                                                   [0, 0, 0, 8]]]
              
              which has shape (2, 4, 4)
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MatrixDiagPart(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the batched diagonal part of a batched tensor.
            </summary>
            <param name="input">
              Rank `k` tensor where `k &amp;gt;= 2`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDiagPart'.
            </param>
            <returns>
              The extracted diagonal(s) having shape
              `diagonal.shape = input.shape[:-2] + [min(input.shape[-2:])]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation returns a tensor with the `diagonal` part
              of the batched `input`. The `diagonal` part is computed as follows:
              
              Assume `input` has `k` dimensions `[I, J, K, ..., M, N]`, then the output is a
              tensor of rank `k - 1` with dimensions `[I, J, K, ..., min(M, N)]` where:
              
              `diagonal[i, j, k, ..., n] = input[i, j, k, ..., n, n]`.
              
              The input must be at least a matrix.
              
              For example:
              
              ```
              # 'input' is [[[1, 0, 0, 0]
                             [0, 2, 0, 0]
                             [0, 0, 3, 0]
                             [0, 0, 0, 4]],
                            [[5, 0, 0, 0]
                             [0, 6, 0, 0]
                             [0, 0, 7, 0]
                             [0, 0, 0, 8]]]
              
              and input.shape = (2, 4, 4)
              
              tf.matrix_diag_part(input) ==&amp;gt; [[1, 2, 3, 4], [5, 6, 7, 8]]
              
              which has shape (2, 4)
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MatrixExponential(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the matrix exponential of one or more square matrices:
            </summary>
            <param name="input">
              Shape is `[..., M, M]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixExponential'.
            </param>
            <returns>
              Shape is `[..., M, M]`.
              
              @compatibility(scipy)
              Equivalent to scipy.linalg.expm
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              exp(A) = \sum_{n=0}^\infty A^n/n!
              
              The exponential is computed using a combination of the scaling and squaring
              method and the Pade approximation. Details can be founds in:
              Nicholas J. Higham, "The scaling and squaring method for the matrix exponential
              revisited," SIAM J. Matrix Anal. Applic., 26:1179-1193, 2005.
              
              The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions
              form square matrices. The output is a tensor of the same shape as the input
              containing the exponential for all input submatrices `[..., :, :]`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MatrixInverse(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the inverse of one or more square invertible matrices or their
            </summary>
            <param name="input">
              Shape is `[..., M, M]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixInverse'.
            </param>
            <param name="adjoint">
              Optional argument
            </param>
            <returns>
              Shape is `[..., M, M]`.
              
              @compatibility(numpy)
              Equivalent to np.linalg.inv
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              adjoints (conjugate transposes).
              
              The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions
              form square matrices. The output is a tensor of the same shape as the input
              containing the inverse for all input submatrices `[..., :, :]`.
              
              The op uses LU decomposition with partial pivoting to compute the inverses.
              
              If a matrix is not invertible there is no guarantee what the op does. It
              may detect the condition and raise an exception or it may simply return a
              garbage result.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MatrixSetDiag(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns a batched matrix tensor with new batched diagonal values.
            </summary>
            <param name="input">
              Rank `k+1`, where `k &amp;gt;= 1`.
            </param>
            <param name="diagonal">
              Rank `k`, where `k &amp;gt;= 1`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSetDiag'.
            </param>
            <returns>
              Rank `k+1`, with `output.shape = input.shape`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given `input` and `diagonal`, this operation returns a tensor with the
              same shape and values as `input`, except for the main diagonal of the
              innermost matrices.  These will be overwritten by the values in `diagonal`.
              
              The output is computed as follows:
              
              Assume `input` has `k+1` dimensions `[I, J, K, ..., M, N]` and `diagonal` has
              `k` dimensions `[I, J, K, ..., min(M, N)]`.  Then the output is a
              tensor of rank `k+1` with dimensions `[I, J, K, ..., M, N]` where:
              
                * `output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]` for `m == n`.
                * `output[i, j, k, ..., m, n] = input[i, j, k, ..., m, n]` for `m != n`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MatrixSolve(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Solves systems of linear equations.
            </summary>
            <param name="matrix">
              Shape is `[..., M, M]`.
            </param>
            <param name="rhs">
              Shape is `[..., M, K]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSolve'.
            </param>
            <param name="adjoint">
              Optional argument
              Boolean indicating whether to solve with `matrix` or its (block-wise)
              adjoint.
            </param>
            <returns>
              Shape is `[..., M, K]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `Matrix` is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions
              form square matrices. `Rhs` is a tensor of shape `[..., M, K]`. The `output` is
              a tensor shape `[..., M, K]`.  If `adjoint` is `False` then each output matrix
              satisfies `matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]`.
              If `adjoint` is `True` then each output matrix satisfies
              `adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MatrixSolveLs(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Solves one or more linear least-squares problems.
            </summary>
            <param name="matrix">
              Shape is `[..., M, N]`.
            </param>
            <param name="rhs">
              Shape is `[..., M, K]`.
            </param>
            <param name="l2_regularizer">
              Scalar tensor.
              
              @compatibility(numpy)
              Equivalent to np.linalg.lstsq
              @end_compatibility
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSolveLs'.
            </param>
            <param name="fast">
              Optional argument
            </param>
            <returns>
              Shape is `[..., N, K]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `matrix` is a tensor of shape `[..., M, N]` whose inner-most 2 dimensions
              form real or complex matrices of size `[M, N]`. `Rhs` is a tensor of the same
              type as `matrix` and shape `[..., M, K]`.
              The output is a tensor shape `[..., N, K]` where each output matrix solves
              each of the equations
              `matrix[..., :, :]` * `output[..., :, :]` = `rhs[..., :, :]`
              in the least squares sense.
              
              We use the following notation for (complex) matrix and right-hand sides
              in the batch:
              
              `matrix`=\\(A \in \mathbb{C}^{m \times n}\\),
              `rhs`=\\(B  \in \mathbb{C}^{m \times k}\\),
              `output`=\\(X  \in \mathbb{C}^{n \times k}\\),
              `l2_regularizer`=\\(\lambda \in \mathbb{R}\\).
              
              If `fast` is `True`, then the solution is computed by solving the normal
              equations using Cholesky decomposition. Specifically, if \\(m \ge n\\) then
              \\(X = (A^H A + \lambda I)^{-1} A^H B\\), which solves the least-squares
              problem \\(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||A Z - B||_F^2 +
              \lambda ||Z||_F^2\\). If \\(m \lt n\\) then `output` is computed as
              \\(X = A^H (A A^H + \lambda I)^{-1} B\\), which (for \\(\lambda = 0\\)) is the
              minimum-norm solution to the under-determined linear system, i.e.
              \\(X = \mathrm{argmin}_{Z \in \mathbb{C}^{n \times k} } ||Z||_F^2 \\),
              subject to \\(A Z = B\\). Notice that the fast path is only numerically stable
              when \\(A\\) is numerically full rank and has a condition number
              \\(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach} } }\\) or\\(\lambda\\) is
              sufficiently large.
              
              If `fast` is `False` an algorithm based on the numerically robust complete
              orthogonal decomposition is used. This computes the minimum-norm
              least-squares solution, even when \\(A\\) is rank deficient. This path is
              typically 6-7 times slower than the fast path. If `fast` is `False` then
              `l2_regularizer` is ignored.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MatrixTriangularSolve(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Solves systems of linear equations with upper or lower triangular matrices by
            </summary>
            <param name="matrix">
              Shape is `[..., M, M]`.
            </param>
            <param name="rhs">
              Shape is `[..., M, K]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixTriangularSolve'.
            </param>
            <param name="lower">
              Optional argument
              Boolean indicating whether the innermost matrices in `matrix` are
              lower or upper triangular.
            </param>
            <param name="adjoint">
              Optional argument
              Boolean indicating whether to solve with `matrix` or its (block-wise)
                       adjoint.
              
              @compatibility(numpy)
              Equivalent to np.linalg.triangular_solve
              @end_compatibility
            </param>
            <returns>
              Shape is `[..., M, K]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              backsubstitution.
              
              `matrix` is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions form
              square matrices. If `lower` is `True` then the strictly upper triangular part
              of each inner-most matrix is assumed to be zero and not accessed.
              If `lower` is False then the strictly lower triangular part of each inner-most
              matrix is assumed to be zero and not accessed.
              `rhs` is a tensor of shape `[..., M, K]`.
              
              The output is a tensor of shape `[..., M, K]`. If `adjoint` is
              `True` then the innermost matrices in `output` satisfy matrix equations
              `matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]`.
              If `adjoint` is `False` then the strictly then the  innermost matrices in
              `output` satisfy matrix equations
              `adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Max(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the maximum of elements across dimensions of a tensor.
            </summary>
            <param name="input">
              The tensor to reduce.
            </param>
            <param name="reduction_indices">
              The dimensions to reduce. Must be in the range
              `[-rank(input), rank(input))`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Max'.
            </param>
            <param name="keep_dims">
              Optional argument
              If true, retain reduced dimensions with length 1.
            </param>
            <returns>
              The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Reduces `input` along the dimensions given in `reduction_indices`. Unless
              `keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
              `reduction_indices`. If `keep_dims` is true, the reduced dimensions are
              retained with length 1.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Maximum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the max of x and y (i.e. x &amp;gt; y ? x : y) element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Maximum'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `Maximum` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MaxPool(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
              Performs max pooling on the input.
            </summary>
            <param name="input">
              4-D input to pool over.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool'.
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, in_height, in_width, in_channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, in_channels, in_height, in_width].
            </param>
            <param name="ksize">
              The size of the window for each dimension of the input tensor.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the
              input tensor.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The max pooled output tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MaxPool3D(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
              Performs 3D max pooling on the input.
            </summary>
            <param name="input">
              Shape `[batch, depth, rows, cols, channels]` tensor to pool over.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool3D'.
            </param>
            <param name="data_format">
              Optional argument
              The data format of the input and output data. With the
              default format "NDHWC", the data is stored in the order of:
                  [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be "NCDHW", the data storage order is:
                  [batch, in_channels, in_depth, in_height, in_width].
            </param>
            <param name="ksize">
              1-D tensor of length 5. The size of the window for each dimension of
              the input tensor. Must have `ksize[0] = ksize[4] = 1`.
            </param>
            <param name="strides">
              1-D tensor of length 5. The stride of the sliding window for each
              dimension of `input`. Must have `strides[0] = strides[4] = 1`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The max pooled output tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MaxPool3DGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
              Computes gradients of max pooling function.
            </summary>
            <param name="orig_input">
              The original input tensor.
            </param>
            <param name="orig_output">
              The original output tensor.
            </param>
            <param name="grad">
              Output backprop of shape `[batch, depth, rows, cols, channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool3DGrad'.
            </param>
            <param name="data_format">
              Optional argument
              The data format of the input and output data. With the
              default format "NDHWC", the data is stored in the order of:
                  [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be "NCDHW", the data storage order is:
                  [batch, in_channels, in_depth, in_height, in_width].
            </param>
            <param name="ksize">
              1-D tensor of length 5. The size of the window for each dimension of
              the input tensor. Must have `ksize[0] = ksize[4] = 1`.
            </param>
            <param name="strides">
              1-D tensor of length 5. The stride of the sliding window for each
              dimension of `input`. Must have `strides[0] = strides[4] = 1`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MaxPool3DGradGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
              Computes second-order gradients of the maxpooling function.
            </summary>
            <param name="orig_input">
              The original input tensor.
            </param>
            <param name="orig_output">
              The original output tensor.
            </param>
            <param name="grad">
              Output backprop of shape `[batch, depth, rows, cols, channels]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool3DGradGrad'.
            </param>
            <param name="data_format">
              Optional argument
              The data format of the input and output data. With the
              default format "NDHWC", the data is stored in the order of:
                  [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be "NCDHW", the data storage order is:
                  [batch, in_channels, in_depth, in_height, in_width].
            </param>
            <param name="ksize">
              1-D tensor of length 5. The size of the window for each dimension of
              the input tensor. Must have `ksize[0] = ksize[4] = 1`.
            </param>
            <param name="strides">
              1-D tensor of length 5. The stride of the sliding window for each
              dimension of `input`. Must have `strides[0] = strides[4] = 1`.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              Gradients of gradients w.r.t. the input to `max_pool`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MaxPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
              Computes gradients of the maxpooling function.
            </summary>
            <param name="orig_input">
              The original input tensor.
            </param>
            <param name="orig_output">
              The original output tensor.
            </param>
            <param name="grad">
              4-D.  Gradients w.r.t. the output of `max_pool`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGrad'.
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, in_height, in_width, in_channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, in_channels, in_height, in_width].
            </param>
            <param name="ksize">
              The size of the window for each dimension of the input tensor.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the
              input tensor.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              Gradients w.r.t. the input to `max_pool`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MaxPoolGradGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
              Computes second-order gradients of the maxpooling function.
            </summary>
            <param name="orig_input">
              The original input tensor.
            </param>
            <param name="orig_output">
              The original output tensor.
            </param>
            <param name="grad">
              4-D.  Gradients of gradients w.r.t. the input of `max_pool`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradGrad'.
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, in_height, in_width, in_channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, in_channels, in_height, in_width].
            </param>
            <param name="ksize">
              The size of the window for each dimension of the input tensor.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the
              input tensor.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              Gradients of gradients w.r.t. the input to `max_pool`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MaxPoolGradGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)">
            <summary>
              Computes second-order gradients of the maxpooling function.
            </summary>
            <param name="orig_input">
              The original input tensor.
            </param>
            <param name="orig_output">
              The original output tensor.
            </param>
            <param name="grad">
              4-D.  Gradients of gradients w.r.t. the input of `max_pool`.
            </param>
            <param name="ksize">
              The size of the window for each dimension of the input tensor.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the
              input tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradGradV2'.
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, in_height, in_width, in_channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, in_channels, in_height, in_width].
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              Gradients of gradients w.r.t. the input to `max_pool`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MaxPoolGradGradWithArgmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
              Computes second-order gradients of the maxpooling function.
            </summary>
            <param name="input">
              The original input.
            </param>
            <param name="grad">
              4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the
              input of `max_pool`.
            </param>
            <param name="argmax">
              The indices of the maximum values chosen for each output of `max_pool`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradGradWithArgmax'.
            </param>
            <param name="ksize">
              The size of the window for each dimension of the input tensor.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the
              input tensor.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              Gradients of gradients w.r.t. the input of `max_pool`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MaxPoolGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)">
            <summary>
              Computes gradients of the maxpooling function.
            </summary>
            <param name="orig_input">
              The original input tensor.
            </param>
            <param name="orig_output">
              The original output tensor.
            </param>
            <param name="grad">
              4-D.  Gradients w.r.t. the output of `max_pool`.
            </param>
            <param name="ksize">
              The size of the window for each dimension of the input tensor.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the
              input tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradV2'.
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, in_height, in_width, in_channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, in_channels, in_height, in_width].
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              Gradients w.r.t. the input to `max_pool`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MaxPoolGradWithArgmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
              Computes gradients of the maxpooling function.
            </summary>
            <param name="input">
              The original input.
            </param>
            <param name="grad">
              4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the
              output of `max_pool`.
            </param>
            <param name="argmax">
              The indices of the maximum values chosen for each output of `max_pool`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradWithArgmax'.
            </param>
            <param name="ksize">
              The size of the window for each dimension of the input tensor.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the
              input tensor.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              Gradients w.r.t. the input of `max_pool`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MaxPoolV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)">
            <summary>
              Performs max pooling on the input.
            </summary>
            <param name="input">
              4-D input to pool over.
            </param>
            <param name="ksize">
              The size of the window for each dimension of the input tensor.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the
              input tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolV2'.
            </param>
            <param name="data_format">
              Optional argument
              Specify the data format of the input and output data. With the
              default format "NHWC", the data is stored in the order of:
                  [batch, in_height, in_width, in_channels].
              Alternatively, the format could be "NCHW", the data storage order of:
                  [batch, in_channels, in_height, in_width].
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              The max pooled output tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MaxPoolWithArgmax(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Performs max pooling on the input and outputs both max values and indices.
            </summary>
            <param name="input">
              4-D with shape `[batch, height, width, channels]`.  Input to pool over.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolWithArgmax'.
            </param>
            <param name="Targmax">
              Optional argument
            </param>
            <param name="ksize">
              The size of the window for each dimension of the input tensor.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the
              input tensor.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: The max pooled output tensor.
              argmax: 4-D.  The flattened indices of the max values chosen for each output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              The indices in `argmax` are flattened, so that a maximum value at position
              `[b, y, x, c]` becomes flattened index
              `((b * height + y) * width + x) * channels + c`.
              
              The indices returned are always in `[0, height) x [0, width)` before flattening,
              even if padding is involved and the mathematically correct answer is outside
              (either negative or too large).  This is a bug, but fixing it is difficult to do
              in a safe backwards compatible way, especially due to flattening.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Mean(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the mean of elements across dimensions of a tensor.
            </summary>
            <param name="input">
              The tensor to reduce.
            </param>
            <param name="reduction_indices">
              The dimensions to reduce. Must be in the range
              `[-rank(input), rank(input))`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Mean'.
            </param>
            <param name="keep_dims">
              Optional argument
              If true, retain reduced dimensions with length 1.
            </param>
            <returns>
              The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Reduces `input` along the dimensions given in `reduction_indices`. Unless
              `keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
              `reduction_indices`. If `keep_dims` is true, the reduced dimensions are
              retained with length 1.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Merge(TensorFlow.TFOutput[],System.String)">
            <summary>
              Forwards the value of an available tensor from `inputs` to `output`.
            </summary>
            <param name="inputs">
              The input tensors, exactly one of which will become available.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Merge'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: Will be set to the available input tensor.
              value_index: The index of the chosen input tensor in `inputs`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              `Merge` waits for at least one of the tensors in `inputs` to become available.
              It is usually combined with `Switch` to implement branching.
              
              `Merge` forwards the first tensor to become available to `output`, and sets
              `value_index` to its index in `inputs`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MergeSummary(TensorFlow.TFOutput[],System.String)">
            <summary>
              Merges summaries.
            </summary>
            <param name="inputs">
              Can be of any shape.  Each must contain serialized `Summary` protocol
              buffers.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MergeSummary'.
            </param>
            <returns>
              Scalar. Serialized `Summary` protocol buffer.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op creates a
              [`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)
              protocol buffer that contains the union of all the values in the input
              summaries.
              
              When the Op is run, it reports an `InvalidArgument` error if multiple values
              in the summaries to merge use the same tag.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MergeV2Checkpoints(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              V2 format specific: merges the metadata files of sharded checkpoints.  The
            </summary>
            <param name="checkpoint_prefixes">
              prefixes of V2 checkpoints to merge.
            </param>
            <param name="destination_prefix">
              scalar.  The desired final prefix.  Allowed to be the same
              as one of the checkpoint_prefixes.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MergeV2Checkpoints'.
            </param>
            <param name="delete_old_dirs">
              Optional argument
              see above.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              result is one logical checkpoint, with one physical metadata file and renamed
              data files.
              
              Intended for "grouping" multiple checkpoints in a sharded checkpoint setup.
              
              If delete_old_dirs is true, attempts to delete recursively the dirname of each
              path in the input checkpoint_prefixes.  This is useful when those paths are non
              user-facing temporary locations.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Mfcc(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Transforms a spectrogram into a form that's useful for speech recognition.
            </summary>
            <param name="spectrogram">
              Typically produced by the Spectrogram op, with magnitude_squared
              set to true.
            </param>
            <param name="sample_rate">
              How many samples per second the source audio used.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Mfcc'.
            </param>
            <param name="upper_frequency_limit">
              Optional argument
              The highest frequency to use when calculating the
              ceptstrum.
            </param>
            <param name="lower_frequency_limit">
              Optional argument
              The lowest frequency to use when calculating the
              ceptstrum.
            </param>
            <param name="filterbank_channel_count">
              Optional argument
              Resolution of the Mel bank used internally.
            </param>
            <param name="dct_coefficient_count">
              Optional argument
              How many output channels to produce per time slice.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Mel Frequency Cepstral Coefficients are a way of representing audio data that's
              been effective as an input feature for machine learning. They are created by
              taking the spectrum of a spectrogram (a 'cepstrum'), and discarding some of the
              higher frequencies that are less significant to the human ear. They have a long
              history in the speech recognition world, and https://en.wikipedia.org/wiki/Mel-frequency_cepstrum
              is a good resource to learn more.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Min(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the minimum of elements across dimensions of a tensor.
            </summary>
            <param name="input">
              The tensor to reduce.
            </param>
            <param name="reduction_indices">
              The dimensions to reduce. Must be in the range
              `[-rank(input), rank(input))`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Min'.
            </param>
            <param name="keep_dims">
              Optional argument
              If true, retain reduced dimensions with length 1.
            </param>
            <returns>
              The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Reduces `input` along the dimensions given in `reduction_indices`. Unless
              `keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
              `reduction_indices`. If `keep_dims` is true, the reduced dimensions are
              retained with length 1.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Minimum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the min of x and y (i.e. x &amp;lt; y ? x : y) element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Minimum'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `Minimum` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MirrorPad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">
            <summary>
              Pads a tensor with mirrored values.
            </summary>
            <param name="input">
              The input tensor to be padded.
            </param>
            <param name="paddings">
              A two-column matrix specifying the padding sizes. The number of
              rows must be the same as the rank of `input`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MirrorPad'.
            </param>
            <param name="mode">
              Either `REFLECT` or `SYMMETRIC`. In reflect mode the padded regions
              do not include the borders, while in symmetric mode the padded regions
              do include the borders. For example, if `input` is `[1, 2, 3]` and `paddings`
              is `[0, 2]`, then the output is `[1, 2, 3, 2, 1]` in reflect mode, and
              it is `[1, 2, 3, 3, 2]` in symmetric mode.
            </param>
            <returns>
              The padded tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation pads a `input` with mirrored values according to the `paddings`
              you specify. `paddings` is an integer tensor with shape `[n, 2]`, where n is
              the rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates
              how many values to add before the contents of `input` in that dimension, and
              `paddings[D, 1]` indicates how many values to add after the contents of `input`
              in that dimension. Both `paddings[D, 0]` and `paddings[D, 1]` must be no greater
              than `input.dim_size(D)` (or `input.dim_size(D) - 1`) if `copy_border` is true
              (if false, respectively).
              
              The padded size of each dimension D of the output is:
              
              `paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`
              
              For example:
              
              ```
              # 't' is [[1, 2, 3], [4, 5, 6]].
              # 'paddings' is [[1, 1]], [2, 2]].
              # 'mode' is SYMMETRIC.
              # rank of 't' is 2.
              pad(t, paddings) ==&amp;gt; [[2, 1, 1, 2, 3, 3, 2]
                                    [2, 1, 1, 2, 3, 3, 2]
                                    [5, 4, 4, 5, 6, 6, 5]
                                    [5, 4, 4, 5, 6, 6, 5]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MirrorPadGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">
            <summary>
              Gradient op for `MirrorPad` op. This op folds a mirror-padded tensor.
            </summary>
            <param name="input">
              The input tensor to be folded.
            </param>
            <param name="paddings">
              A two-column matrix specifying the padding sizes. The number of
              rows must be the same as the rank of `input`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MirrorPadGrad'.
            </param>
            <param name="mode">
              The mode used in the `MirrorPad` op.
            </param>
            <returns>
              The folded tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation folds the padded areas of `input` by `MirrorPad` according to the
              `paddings` you specify. `paddings` must be the same as `paddings` argument
              given to the corresponding `MirrorPad` op.
              
              The folded size of each dimension D of the output is:
              
              `input.dim_size(D) - paddings(D, 0) - paddings(D, 1)`
              
              For example:
              
              ```
              # 't' is [[1, 2, 3], [4, 5, 6], [7, 8, 9]].
              # 'paddings' is [[0, 1]], [0, 1]].
              # 'mode' is SYMMETRIC.
              # rank of 't' is 2.
              pad(t, paddings) ==&amp;gt; [[ 1,  5]
                                    [11, 28]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Mod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns element-wise remainder of division. This emulates C semantics in that
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Mod'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              the result here is consistent with a truncating divide. E.g.
              `tf.truncatediv(x, y) * y + truncate_mod(x, y) = x`.
              
              *NOTE*: `Mod` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Mul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns x * y element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Mul'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `Mul` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Multinomial(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Draws samples from a multinomial distribution.
            </summary>
            <param name="logits">
              2-D Tensor with shape `[batch_size, num_classes]`.  Each slice `[i, :]`
              represents the unnormalized log probabilities for all classes.
            </param>
            <param name="num_samples">
              0-D.  Number of independent samples to draw for each row slice.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Multinomial'.
            </param>
            <param name="seed">
              Optional argument
              If either seed or seed2 is set to be non-zero, the internal random number
              generator is seeded by the given seed.  Otherwise, a random seed is used.
            </param>
            <param name="seed2">
              Optional argument
              A second seed to avoid seed collision.
            </param>
            <param name="output_dtype">
              Optional argument
            </param>
            <returns>
              2-D Tensor with shape `[batch_size, num_samples]`.  Each slice `[i, :]`
              contains the drawn class labels with range `[0, num_classes)`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.MutableDenseHashTable(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.Nullable{System.Int64},System.Nullable{System.Single},System.String)">
            <summary>
              Creates an empty hash table that uses tensors as the backing store.
            </summary>
            <param name="empty_key">
              The key used to represent empty key buckets internally. Must not
              be used in insert or lookup operations.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableDenseHashTable'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.
            </param>
            <param name="use_node_name_sharing">
              Optional argument
            </param>
            <param name="value_shape">
              Optional argument
              The shape of each value.
            </param>
            <param name="initial_num_buckets">
              Optional argument
              The initial number of hash table buckets. Must be a power
              to 2.
            </param>
            <param name="max_load_factor">
              Optional argument
              The maximum ratio between number of entries and number of
              buckets before growing the table. Must be between 0 and 1.
            </param>
            <param name="value_dtype">
              Type of the table values.
            </param>
            <returns>
              Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              It uses "open addressing" with quadratic reprobing to resolve
              collisions.
              
              This op creates a mutable hash table, specifying the type of its keys and
              values. Each value must be a scalar. Data can be inserted into the table using
              the insert operations. It does not support the initialization operation.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MutableDenseHashTableV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.Nullable{System.Int64},System.Nullable{System.Single},System.String)">
            <summary>
              Creates an empty hash table that uses tensors as the backing store.
            </summary>
            <param name="empty_key">
              The key used to represent empty key buckets internally. Must not
              be used in insert or lookup operations.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableDenseHashTableV2'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.
            </param>
            <param name="use_node_name_sharing">
              Optional argument
            </param>
            <param name="value_shape">
              Optional argument
              The shape of each value.
            </param>
            <param name="initial_num_buckets">
              Optional argument
              The initial number of hash table buckets. Must be a power
              to 2.
            </param>
            <param name="max_load_factor">
              Optional argument
              The maximum ratio between number of entries and number of
              buckets before growing the table. Must be between 0 and 1.
            </param>
            <param name="value_dtype">
              Type of the table values.
            </param>
            <returns>
              Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              It uses "open addressing" with quadratic reprobing to resolve
              collisions.
              
              This op creates a mutable hash table, specifying the type of its keys and
              values. Each value must be a scalar. Data can be inserted into the table using
              the insert operations. It does not support the initialization operation.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MutableHashTable(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
              Creates an empty hash table.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTable'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.
            </param>
            <param name="use_node_name_sharing">
              Optional argument
              If true and shared_name is empty, the table is shared
              using the node name.
            </param>
            <param name="key_dtype">
              Type of the table keys.
            </param>
            <param name="value_dtype">
              Type of the table values.
            </param>
            <returns>
              Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op creates a mutable hash table, specifying the type of its keys and
              values. Each value must be a scalar. Data can be inserted into the table using
              the insert operations. It does not support the initialization operation.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MutableHashTableOfTensors(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.String)">
            <summary>
              Creates an empty hash table.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTableOfTensors'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.
            </param>
            <param name="use_node_name_sharing">
              Optional argument
            </param>
            <param name="value_shape">
              Optional argument
            </param>
            <param name="key_dtype">
              Type of the table keys.
            </param>
            <param name="value_dtype">
              Type of the table values.
            </param>
            <returns>
              Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op creates a mutable hash table, specifying the type of its keys and
              values. Each value must be a vector. Data can be inserted into the table using
              the insert operations. It does not support the initialization operation.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MutableHashTableOfTensorsV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.String)">
            <summary>
              Creates an empty hash table.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTableOfTensorsV2'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.
            </param>
            <param name="use_node_name_sharing">
              Optional argument
            </param>
            <param name="value_shape">
              Optional argument
            </param>
            <param name="key_dtype">
              Type of the table keys.
            </param>
            <param name="value_dtype">
              Type of the table values.
            </param>
            <returns>
              Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op creates a mutable hash table, specifying the type of its keys and
              values. Each value must be a vector. Data can be inserted into the table using
              the insert operations. It does not support the initialization operation.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.MutableHashTableV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
              Creates an empty hash table.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTableV2'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.
            </param>
            <param name="use_node_name_sharing">
              Optional argument
              If true and shared_name is empty, the table is shared
              using the node name.
            </param>
            <param name="key_dtype">
              Type of the table keys.
            </param>
            <param name="value_dtype">
              Type of the table values.
            </param>
            <returns>
              Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op creates a mutable hash table, specifying the type of its keys and
              values. Each value must be a scalar. Data can be inserted into the table using
              the insert operations. It does not support the initialization operation.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Neg(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes numerical negative value element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Neg'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              I.e., \\(y = -x\\).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.NegTrain(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64,System.String)">
            <summary>
              Training via negative sampling.
            </summary>
            <param name="w_in">
              input word embedding.
            </param>
            <param name="w_out">
              output word embedding.
            </param>
            <param name="examples">
              A vector of word ids.
            </param>
            <param name="labels">
              A vector of word ids.
            </param>
            <param name="lr">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'NegTrain'.
            </param>
            <param name="vocab_count">
              Count of words in the vocabulary.
            </param>
            <param name="num_negative_samples">
              Number of negative samples per example.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.NextIteration(TensorFlow.TFOutput,System.String)">
            <summary>
              Makes its input available to the next iteration.
            </summary>
            <param name="data">
              The tensor to be made available to the next iteration.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'NextIteration'.
            </param>
            <returns>
              The same tensor as `data`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.NonMaxSuppression(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String)">
            <summary>
              Greedily selects a subset of bounding boxes in descending order of score,
            </summary>
            <param name="boxes">
              A 2-D float tensor of shape `[num_boxes, 4]`.
            </param>
            <param name="scores">
              A 1-D float tensor of shape `[num_boxes]` representing a single
              score corresponding to each box (each row of boxes).
            </param>
            <param name="max_output_size">
              A scalar integer tensor representing the maximum number of
              boxes to be selected by non max suppression.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppression'.
            </param>
            <param name="iou_threshold">
              Optional argument
              A float representing the threshold for deciding whether boxes
              overlap too much with respect to IOU.
            </param>
            <returns>
              A 1-D integer tensor of shape `[M]` representing the selected
              indices from the boxes tensor, where `M &amp;lt;= max_output_size`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              pruning away boxes that have high intersection-over-union (IOU) overlap
              with previously selected boxes.  Bounding boxes are supplied as
              [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
              diagonal pair of box corners and the coordinates can be provided as normalized
              (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
              is agnostic to where the origin is in the coordinate system.  Note that this
              algorithm is invariant to orthogonal transformations and translations
              of the coordinate system; thus translating or reflections of the coordinate
              system result in the same boxes being selected by the algorithm.
              The output of this operation is a set of integers indexing into the input
              collection of bounding boxes representing the selected boxes.  The bounding
              box coordinates corresponding to the selected indices can then be obtained
              using the `tf.gather operation`.  For example:
                selected_indices = tf.image.non_max_suppression(
                    boxes, scores, max_output_size, iou_threshold)
                selected_boxes = tf.gather(boxes, selected_indices)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.NonMaxSuppressionV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Greedily selects a subset of bounding boxes in descending order of score,
            </summary>
            <param name="boxes">
              A 2-D float tensor of shape `[num_boxes, 4]`.
            </param>
            <param name="scores">
              A 1-D float tensor of shape `[num_boxes]` representing a single
              score corresponding to each box (each row of boxes).
            </param>
            <param name="max_output_size">
              A scalar integer tensor representing the maximum number of
              boxes to be selected by non max suppression.
            </param>
            <param name="iou_threshold">
              A 0-D float tensor representing the threshold for deciding whether
              boxes overlap too much with respect to IOU.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionV2'.
            </param>
            <returns>
              A 1-D integer tensor of shape `[M]` representing the selected
              indices from the boxes tensor, where `M &amp;lt;= max_output_size`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              pruning away boxes that have high intersection-over-union (IOU) overlap
              with previously selected boxes.  Bounding boxes are supplied as
              [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
              diagonal pair of box corners and the coordinates can be provided as normalized
              (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
              is agnostic to where the origin is in the coordinate system.  Note that this
              algorithm is invariant to orthogonal transformations and translations
              of the coordinate system; thus translating or reflections of the coordinate
              system result in the same boxes being selected by the algorithm.
              
              The output of this operation is a set of integers indexing into the input
              collection of bounding boxes representing the selected boxes.  The bounding
              box coordinates corresponding to the selected indices can then be obtained
              using the `tf.gather operation`.  For example:
              
                selected_indices = tf.image.non_max_suppression_v2(
                    boxes, scores, max_output_size, iou_threshold)
                selected_boxes = tf.gather(boxes, selected_indices)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.NoOp(System.String)">
            <summary>
              Does nothing. Only useful as a placeholder for control edges.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'NoOp'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.NotEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the truth value of (x != y) element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'NotEqual'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `NotEqual` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.NthElement(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Finds values of the `n`-th order statistic for the last dimension.
            </summary>
            <param name="input">
              1-D or higher with last dimension at least `n+1`.
            </param>
            <param name="n">
              0-D. Position of sorted vector to select along the last dimension (along
              each row for matrices). Valid range of n is `[0, input.shape[:-1])`
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'NthElement'.
            </param>
            <param name="reverse">
              Optional argument
              When set to True, find the nth-largest value in the vector and vice
              versa.
            </param>
            <returns>
              The `n`-th order statistic along each last dimensional slice.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              If the input is a vector (rank-1), finds the entries which is the nth-smallest
              value in the vector and outputs their values as scalar tensor.
              
              For matrices (resp. higher rank input), computes the entries which is the
              nth-smallest value in each row (resp. vector along the last dimension). Thus,
              
                  values.shape = input.shape[:-1]
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.OneHot(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)">
            <summary>
              Returns a one-hot tensor.
            </summary>
            <param name="indices">
              A tensor of indices.
            </param>
            <param name="depth">
              A scalar defining the depth of the one hot dimension.
            </param>
            <param name="on_value">
              A scalar defining the value to fill in output when `indices[j] = i`.
            </param>
            <param name="off_value">
              A scalar defining the value to fill in output when `indices[j] != i`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'OneHot'.
            </param>
            <param name="axis">
              Optional argument
              The axis to fill (default: -1, a new inner-most axis).
            </param>
            <returns>
              The one-hot tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The locations represented by indices in `indices` take value `on_value`,
              while all other locations take value `off_value`.
              
              If the input `indices` is rank `N`, the output will have rank `N+1`,
              The new axis is created at dimension `axis` (default: the new axis is
              appended at the end).
              
              If `indices` is a scalar the output shape will be a vector of length `depth`.
              
              If `indices` is a vector of length `features`, the output shape will be:
              ```
                features x depth if axis == -1
                depth x features if axis == 0
              ```
              
              If `indices` is a matrix (batch) with shape `[batch, features]`,
              the output shape will be:
              ```
                batch x features x depth if axis == -1
                batch x depth x features if axis == 1
                depth x batch x features if axis == 0
              ```
              
              
              Examples
              =========
              
              Suppose that
              
              ```
                indices = [0, 2, -1, 1]
                depth = 3
                on_value = 5.0
                off_value = 0.0
                axis = -1
              ```
              
              Then output is `[4 x 3]`:
              
                  ```output =
                    [5.0 0.0 0.0]  // one_hot(0)
                    [0.0 0.0 5.0]  // one_hot(2)
                    [0.0 0.0 0.0]  // one_hot(-1)
                    [0.0 5.0 0.0]  // one_hot(1)
                  ```
              
              Suppose that
              
              ```
                indices = [0, 2, -1, 1]
                depth = 3
                on_value = 0.0
                off_value = 3.0
                axis = 0
              ```
              
              Then output is `[3 x 4]`:
              
                  ```output =
                    [0.0 3.0 3.0 3.0]
                    [3.0 3.0 3.0 0.0]
                    [3.0 3.0 3.0 3.0]
                    [3.0 0.0 3.0 3.0]
                  //  ^                one_hot(0)
                  //      ^            one_hot(2)
                  //          ^        one_hot(-1)
                  //              ^    one_hot(1)
                  ```
              Suppose that
              
              ```
                indices = [[0, 2], [1, -1]]
                depth = 3
                on_value = 1.0
                off_value = 0.0
                axis = -1
              ```
              
              Then output is `[2 x 2 x 3]`:
              
                  ```output =
                    [
                      [1.0, 0.0, 0.0]  // one_hot(0)
                      [0.0, 0.0, 1.0]  // one_hot(2)
                    ][
                      [0.0, 1.0, 0.0]  // one_hot(1)
                      [0.0, 0.0, 0.0]  // one_hot(-1)
                    ]```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.OnesLike(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns a tensor of ones with the same shape and type as x.
            </summary>
            <param name="x">
              a tensor of type T.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'OnesLike'.
            </param>
            <returns>
              a tensor of the same shape and type as x but filled with ones.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.OrderedMapClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op removes all elements in the underlying container.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapClear'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.OrderedMapIncompleteSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op returns the number of incomplete elements in the underlying container.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapIncompleteSize'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.OrderedMapPeek(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op peeks at the values at the specified key.  If the
            </summary>
            <param name="key">
            </param>
            <param name="indices">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapPeek'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              underlying container does not contain this key
              this op will block until it does.   This Op is optimized for
              performance.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.OrderedMapSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op returns the number of elements in the underlying container.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapSize'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.OrderedMapStage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Stage (key, values) in the underlying container which behaves like a ordered
            </summary>
            <param name="key">
              int64
            </param>
            <param name="indices">
            </param>
            <param name="values">
              a list of tensors
              dtypes A list of data types that inserted values should adhere to.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapStage'.
            </param>
            <param name="capacity">
              Optional argument
              Maximum number of elements in the Staging Area. If &amp;gt; 0, inserts
              on the container will block when the capacity is reached.
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
              If non-empty, this queue is placed in the given container. Otherwise,
              a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              It is necessary to match this name to the matching Unstage Op.
            </param>
            <param name="dtypes">
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              associative container.   Elements are ordered by key.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.OrderedMapUnstage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op removes and returns the values associated with the key
            </summary>
            <param name="key">
            </param>
            <param name="indices">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapUnstage'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              from the underlying container.   If the underlying container
              does not contain this key, the op will block until it does.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.OrderedMapUnstageNoKey(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op removes and returns the (key, value) element with the smallest
            </summary>
            <param name="indices">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapUnstageNoKey'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              key: 
              values: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              key from the underlying container.   If the underlying container
              does not contain elements, the op will block until it does.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Pack(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">
            <summary>
              Packs a list of `N` rank-`R` tensors into one rank-`(R+1)` tensor.
            </summary>
            <param name="values">
              Must be of same shape and type.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Pack'.
            </param>
            <param name="axis">
              Optional argument
              Dimension along which to pack.  Negative values wrap around, so the
              valid range is `[-(R+1), R+1)`.
            </param>
            <returns>
              The packed tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Packs the `N` tensors in `values` into a tensor with rank one higher than each
              tensor in `values`, by packing them along the `axis` dimension.
              Given a list of tensors of shape `(A, B, C)`;
              
              if `axis == 0` then the `output` tensor will have the shape `(N, A, B, C)`.
              if `axis == 1` then the `output` tensor will have the shape `(A, N, B, C)`.
              Etc.
              
              For example:
              
              ```
              # 'x' is [1, 4]
              # 'y' is [2, 5]
              # 'z' is [3, 6]
              pack([x, y, z]) =&amp;gt; [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.
              pack([x, y, z], axis=1) =&amp;gt; [[1, 2, 3], [4, 5, 6]]
              ```
              
              This is the opposite of `unpack`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Pad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Pads a tensor with zeros.
            </summary>
            <param name="input">
            </param>
            <param name="paddings">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Pad'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation pads a `input` with zeros according to the `paddings` you
              specify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is the
              rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates
              how many zeros to add before the contents of `input` in that dimension, and
              `paddings[D, 1]` indicates how many zeros to add after the contents of `input`
              in that dimension.
              
              The padded size of each dimension D of the output is:
              
              `paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`
              
              For example:
              
              ```
              # 't' is [[1, 1], [2, 2]]
              # 'paddings' is [[1, 1], [2, 2]]
              # rank of 't' is 2
              pad(t, paddings) ==&amp;gt; [[0, 0, 0, 0, 0, 0]
                                    [0, 0, 1, 1, 0, 0]
                                    [0, 0, 2, 2, 0, 0]
                                    [0, 0, 0, 0, 0, 0]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.PaddedBatchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that batches and pads `batch_size` elements from the input.
            </summary>
            <param name="input_dataset">
            </param>
            <param name="batch_size">
              A scalar representing the number of elements to accumulate in a
              batch.
            </param>
            <param name="padded_shapes">
              A list of int64 tensors representing the desired padded shapes
              of the corresponding output components. These shapes may be partially
              specified, using `-1` to indicate that a particular dimension should be
              padded to the maximum size of all batch elements.
            </param>
            <param name="padding_values">
              A list of scalars containing the padding value to use for
              each of the outputs.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddedBatchDataset'.
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.PaddingFIFOQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              A queue that produces elements in first-in first-out order.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddingFIFOQueue'.
            </param>
            <param name="shapes">
              Optional argument
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types.
              Shapes of fixed rank but variable size are allowed by setting
              any shape dimension to -1.  In this case, the inputs' shape may vary along
              the given dimension, and DequeueMany will pad the given dimension with
              zeros up to the maximum shape of all elements in the given batch.
              If the length of this attr is 0, different queue elements may have
              different ranks and shapes, but only one element may be dequeued at a time.
            </param>
            <param name="capacity">
              Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.
            </param>
            <param name="component_types">
              The type of each component in a value.
            </param>
            <returns>
              The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Variable-size shapes are allowed by setting the corresponding shape dimensions
              to 0 in the shape attr.  In this case DequeueMany will pad up to the maximum
              size of any given element in the minibatch.  See below for details.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.PaddingFIFOQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              A queue that produces elements in first-in first-out order.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddingFIFOQueueV2'.
            </param>
            <param name="shapes">
              Optional argument
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types.
              Shapes of fixed rank but variable size are allowed by setting
              any shape dimension to -1.  In this case, the inputs' shape may vary along
              the given dimension, and DequeueMany will pad the given dimension with
              zeros up to the maximum shape of all elements in the given batch.
              If the length of this attr is 0, different queue elements may have
              different ranks and shapes, but only one element may be dequeued at a time.
            </param>
            <param name="capacity">
              Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.
            </param>
            <param name="component_types">
              The type of each component in a value.
            </param>
            <returns>
              The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Variable-size shapes are allowed by setting the corresponding shape dimensions
              to 0 in the shape attr.  In this case DequeueMany will pad up to the maximum
              size of any given element in the minibatch.  See below for details.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.PadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Pads a tensor.
            </summary>
            <param name="input">
            </param>
            <param name="paddings">
            </param>
            <param name="constant_values">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'PadV2'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation pads `input` according to the `paddings` and `constant_values`
              you specify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is
              the rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates
              how many padding values to add before the contents of `input` in that dimension,
              and `paddings[D, 1]` indicates how many padding values to add after the contents
              of `input` in that dimension. `constant_values` is a scalar tensor of the same
              type as `input` that indicates the value to use for padding `input`.
              
              The padded size of each dimension D of the output is:
              
              `paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`
              
              For example:
              
              ```
              # 't' is [[1, 1], [2, 2]]
              # 'paddings' is [[1, 1], [2, 2]]
              # 'constant_values' is 0
              # rank of 't' is 2
              pad(t, paddings) ==&amp;gt; [[0, 0, 0, 0, 0, 0]
                                    [0, 0, 1, 1, 0, 0]
                                    [0, 0, 2, 2, 0, 0]
                                    [0, 0, 0, 0, 0, 0]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ParallelConcat(TensorFlow.TFOutput[],TensorFlow.TFShape,System.String)">
            <summary>
              Concatenates a list of `N` tensors along the first dimension.
            </summary>
            <param name="values">
              Tensors to be concatenated. All must have size 1 in the first dimension
              and same shape.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ParallelConcat'.
            </param>
            <param name="shape">
              the final shape of the result; should be equal to the shapes of any input
              but with the number of input values in the first dimension.
            </param>
            <returns>
              The concatenated tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The input tensors are all required to have size 1 in the first dimension.
              
              For example:
              
              ```
              # 'x' is [[1, 4]]
              # 'y' is [[2, 5]]
              # 'z' is [[3, 6]]
              parallel_concat([x, y, z]) =&amp;gt; [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.
              ```
              
              The difference between concat and parallel_concat is that concat requires all
              of the inputs be computed before the operation will begin but doesn't require
              that the input shapes be known during graph construction.  Parallel concat
              will copy pieces of the input into the output as they become available, in
              some situations this can provide a performance benefit.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ParallelDynamicStitch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)">
            <summary>
              Interleave the values from the `data` tensors into a single tensor.
            </summary>
            <param name="indices">
            </param>
            <param name="data">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ParallelDynamicStitch'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Builds a merged tensor such that
              
              ```python
                  merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]
              ```
              
              For example, if each `indices[m]` is scalar or vector, we have
              
              ```python
                  # Scalar indices:
                  merged[indices[m], ...] = data[m][...]
              
                  # Vector indices:
                  merged[indices[m][i], ...] = data[m][i, ...]
              ```
              
              Each `data[i].shape` must start with the corresponding `indices[i].shape`,
              and the rest of `data[i].shape` must be constant w.r.t. `i`.  That is, we
              must have `data[i].shape = indices[i].shape + constant`.  In terms of this
              `constant`, the output shape is
              
                  merged.shape = [max(indices)] + constant
              
              Values may be merged in parallel, so if an index appears in both `indices[m][i]`
              and `indices[n][j]`, the result may be invalid. This differs from the normal
              DynamicStitch operator that defines the behavior in that case.
              
              For example:
              
              ```python
                  indices[0] = 6
                  indices[1] = [4, 1]
                  indices[2] = [[5, 2], [0, 3]]
                  data[0] = [61, 62]
                  data[1] = [[41, 42], [11, 12]]
                  data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]
                  merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],
                            [51, 52], [61, 62]]
              ```
              
              This method can be used to merge partitions created by `dynamic_partition`
              as illustrated on the following example:
              
              ```python
                  # Apply function (increments x_i) on elements for which a certain condition
                  # apply (x_i != -1 in this example).
                  x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])
                  condition_mask=tf.not_equal(x,tf.constant(-1.))
                  partitioned_data = tf.dynamic_partition(
                      x, tf.cast(condition_mask, tf.int32) , 2)
                  partitioned_data[1] = partitioned_data[1] + 1.0
                  condition_indices = tf.dynamic_partition(
                      tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)
                  x = tf.dynamic_stitch(condition_indices, partitioned_data)
                  # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain
                  # unchanged.
              ```
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/DynamicStitch.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ParameterizedTruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Outputs random values from a normal distribution. The parameters may each be a
            </summary>
            <param name="shape">
              The shape of the output tensor. Batches are indexed by the 0th dimension.
            </param>
            <param name="means">
              The mean parameter of each batch.
            </param>
            <param name="stdevs">
              The standard deviation parameter of each batch. Must be greater than 0.
            </param>
            <param name="minvals">
              The minimum cutoff. May be -infinity.
            </param>
            <param name="maxvals">
              The maximum cutoff. May be +infinity, and must be more than the minval
              for each batch.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ParameterizedTruncatedNormal'.
            </param>
            <param name="seed">
              Optional argument
              If either `seed` or `seed2` are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              A second seed to avoid seed collision.
            </param>
            <returns>
              A matrix of shape num_batches x samples_per_batch, filled with random
              truncated normal values using the parameters for each row.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              scalar which applies to the entire output, or a vector of length shape[0] which
              stores the parameters for each batch.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ParseExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Transforms a vector of brain.Example protos (as strings) into typed tensors.
            </summary>
            <param name="serialized">
              A vector containing a batch of binary serialized Example protos.
            </param>
            <param name="names">
              A vector containing the names of the serialized protos.
              May contain, for example, table key (descriptive) names for the
              corresponding serialized protos.  These are purely useful for debugging
              purposes, and the presence of values here has no effect on the output.
              May also be an empty vector if no names are available.
              If non-empty, this vector must be the same length as "serialized".
            </param>
            <param name="sparse_keys">
              A list of Nsparse string Tensors (scalars).
              The keys expected in the Examples' features associated with sparse values.
            </param>
            <param name="dense_keys">
              A list of Ndense string Tensors (scalars).
              The keys expected in the Examples' features associated with dense values.
            </param>
            <param name="dense_defaults">
              A list of Ndense Tensors (some may be empty).
              dense_defaults[j] provides default values
              when the example's feature_map lacks dense_key[j].  If an empty Tensor is
              provided for dense_defaults[j], then the Feature dense_keys[j] is required.
              The input type is inferred from dense_defaults[j], even when it's empty.
              If dense_defaults[j] is not empty, and dense_shapes[j] is fully defined,
              then the shape of dense_defaults[j] must match that of dense_shapes[j].
              If dense_shapes[j] has an undefined major dimension (variable strides dense
              feature), dense_defaults[j] must contain a single element:
              the padding element.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseExample'.
            </param>
            <param name="sparse_types">
              A list of Nsparse types; the data types of data in each Feature
              given in sparse_keys.
              Currently the ParseExample supports DT_FLOAT (FloatList),
              DT_INT64 (Int64List), and DT_STRING (BytesList).
            </param>
            <param name="dense_shapes">
              A list of Ndense shapes; the shapes of data in each Feature
              given in dense_keys.
              The number of elements in the Feature corresponding to dense_key[j]
              must always equal dense_shapes[j].NumEntries().
              If dense_shapes[j] == (D0, D1, ..., DN) then the shape of output
              Tensor dense_values[j] will be (|serialized|, D0, D1, ..., DN):
              The dense outputs are just the inputs row-stacked by batch.
              This works for dense_shapes[j] = (-1, D1, ..., DN).  In this case
              the shape of the output Tensor dense_values[j] will be
              (|serialized|, M, D1, .., DN), where M is the maximum number of blocks
              of elements of length D1 * .... * DN, across all minibatch entries
              in the input.  Any minibatch entry with less than M blocks of elements of
              length D1 * ... * DN will be padded with the corresponding default_value
              scalar element along the second dimension.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              sparse_indices: 
              sparse_values: 
              sparse_shapes: 
              dense_values: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ParseSingleSequenceExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFDataType[],TensorFlow.TFShape[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Transforms a scalar brain.SequenceExample proto (as strings) into typed tensors.
            </summary>
            <param name="serialized">
              A scalar containing a binary serialized SequenceExample proto.
            </param>
            <param name="feature_list_dense_missing_assumed_empty">
              A vector listing the
              FeatureList keys which may be missing from the SequenceExample.  If the
              associated FeatureList is missing, it is treated as empty.  By default,
              any FeatureList not listed in this vector must exist in the SequenceExample.
            </param>
            <param name="context_sparse_keys">
              A list of Ncontext_sparse string Tensors (scalars).
              The keys expected in the Examples' features associated with context_sparse
              values.
            </param>
            <param name="context_dense_keys">
              A list of Ncontext_dense string Tensors (scalars).
              The keys expected in the SequenceExamples' context features associated with
              dense values.
            </param>
            <param name="feature_list_sparse_keys">
              A list of Nfeature_list_sparse string Tensors
              (scalars).  The keys expected in the FeatureLists associated with sparse
              values.
            </param>
            <param name="feature_list_dense_keys">
              A list of Nfeature_list_dense string Tensors (scalars).
              The keys expected in the SequenceExamples' feature_lists associated
              with lists of dense values.
            </param>
            <param name="context_dense_defaults">
              A list of Ncontext_dense Tensors (some may be empty).
              context_dense_defaults[j] provides default values
              when the SequenceExample's context map lacks context_dense_key[j].
              If an empty Tensor is provided for context_dense_defaults[j],
              then the Feature context_dense_keys[j] is required.
              The input type is inferred from context_dense_defaults[j], even when it's
              empty.  If context_dense_defaults[j] is not empty, its shape must match
              context_dense_shapes[j].
            </param>
            <param name="debug_name">
              A scalar containing the name of the serialized proto.
              May contain, for example, table key (descriptive) name for the
              corresponding serialized proto.  This is purely useful for debugging
              purposes, and the presence of values here has no effect on the output.
              May also be an empty scalar if no name is available.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseSingleSequenceExample'.
            </param>
            <param name="context_sparse_types">
              Optional argument
              A list of Ncontext_sparse types; the data types of data in
              each context Feature given in context_sparse_keys.
              Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
              DT_INT64 (Int64List), and DT_STRING (BytesList).
            </param>
            <param name="feature_list_dense_types">
              Optional argument
            </param>
            <param name="context_dense_shapes">
              Optional argument
              A list of Ncontext_dense shapes; the shapes of data in
              each context Feature given in context_dense_keys.
              The number of elements in the Feature corresponding to context_dense_key[j]
              must always equal context_dense_shapes[j].NumEntries().
              The shape of context_dense_values[j] will match context_dense_shapes[j].
            </param>
            <param name="feature_list_sparse_types">
              Optional argument
              A list of Nfeature_list_sparse types; the data types
              of data in each FeatureList given in feature_list_sparse_keys.
              Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
              DT_INT64 (Int64List), and DT_STRING (BytesList).
            </param>
            <param name="feature_list_dense_shapes">
              Optional argument
              A list of Nfeature_list_dense shapes; the shapes of
              data in each FeatureList given in feature_list_dense_keys.
              The shape of each Feature in the FeatureList corresponding to
              feature_list_dense_key[j] must always equal
              feature_list_dense_shapes[j].NumEntries().
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              context_sparse_indices: 
              context_sparse_values: 
              context_sparse_shapes: 
              context_dense_values: 
              feature_list_sparse_indices: 
              feature_list_sparse_values: 
              feature_list_sparse_shapes: 
              feature_list_dense_values: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ParseTensor(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Transforms a serialized tensorflow.TensorProto proto into a Tensor.
            </summary>
            <param name="serialized">
              A scalar string containing a serialized TensorProto proto.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseTensor'.
            </param>
            <param name="out_type">
              The type of the serialized tensor.  The provided type must match the
              type of the serialized tensor and no implicit conversion will take place.
            </param>
            <returns>
              A Tensor of type `out_type`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Placeholder(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">
            <summary>
              A placeholder op for a value that will be fed into the computation.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Placeholder'.
            </param>
            <param name="shape">
              Optional argument
              (Optional) The shape of the tensor. If the shape has 0 dimensions, the
              shape is unconstrained.
            </param>
            <param name="dtype">
              The type of elements in the tensor.
            </param>
            <returns>
              A placeholder tensor that must be replaced using the feed mechanism.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              N.B. This operation will fail with an error if it is executed. It is
              intended as a way to represent a value that will always be fed, and to
              provide attrs that enable the fed value to be checked at runtime.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.PlaceholderV2(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">
            <summary>
              A placeholder op for a value that will be fed into the computation.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'PlaceholderV2'.
            </param>
            <param name="dtype">
              The type of elements in the tensor.
            </param>
            <param name="shape">
              The shape of the tensor. The shape can be any partially-specified
              shape.  To be unconstrained, pass in a shape with unknown rank.
            </param>
            <returns>
              A placeholder tensor that must be replaced using the feed mechanism.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              N.B. This operation will fail with an error if it is executed. It is
              intended as a way to represent a value that will always be fed, and to
              provide attrs that enable the fed value to be checked at runtime.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.PlaceholderWithDefault(TensorFlow.TFOutput,TensorFlow.TFShape,System.String)">
            <summary>
              A placeholder op that passes through `input` when its output is not fed.
            </summary>
            <param name="input">
              The default value to produce when `output` is not fed.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'PlaceholderWithDefault'.
            </param>
            <param name="shape">
              The (possibly partial) shape of the tensor.
            </param>
            <returns>
              A placeholder tensor that defaults to `input` if it is not fed.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Polygamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Compute the polygamma function \\(\psi^{(n)}(x)\\).
            </summary>
            <param name="a">
            </param>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Polygamma'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The polygamma function is defined as:
              
              
              \\(\psi^{(n)}(x) = \frac{d^n}{dx^n} \psi(x)\\)
              
              where \\(\psi(x)\\) is the digamma function.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.PopulationCount(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes element-wise population count (a.k.a. popcount, bitsum, bitcount).
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'PopulationCount'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              For each entry in `x`, calculates the number of `1` (on) bits in the binary
              representation of that entry.
              
              **NOTE**: It is more efficient to first `tf.bitcast` your tensors into
              `int32` or `int64` and perform the bitcount on the result, than to feed in
              8- or 16-bit inputs and then aggregate the resulting counts.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Pow(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the power of one value to another.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Pow'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a tensor `x` and a tensor `y`, this operation computes \\(x^y\\) for
              corresponding elements in `x` and `y`. For example:
              
              ```
              # tensor 'x' is [[2, 2]], [3, 3]]
              # tensor 'y' is [[8, 16], [2, 3]]
              tf.pow(x, y) ==&amp;gt; [[256, 65536], [9, 27]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.PrefetchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that asynchronously prefetches elements from `input_dataset`.
            </summary>
            <param name="input_dataset">
            </param>
            <param name="buffer_size">
              The maximum number of elements to buffer in an iterator over
              this dataset.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'PrefetchDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.PreventGradient(TensorFlow.TFOutput,System.String,System.String)">
            <summary>
              An identity op that triggers an error if a gradient is requested.
            </summary>
            <param name="input">
              any tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'PreventGradient'.
            </param>
            <param name="message">
              Optional argument
              Will be printed in the error when anyone tries to differentiate
              this operation.
            </param>
            <returns>
              the same input tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              When executed in a graph, this op outputs its input tensor as-is.
              
              When building ops to compute gradients, the TensorFlow gradient system
              will return an error when trying to lookup the gradient of this op,
              because no gradient must ever be registered for this function.  This
              op exists to prevent subtle bugs from silently returning unimplemented
              gradients in some corner cases.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Print(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Prints a list of tensors.
            </summary>
            <param name="input">
              The tensor passed to `output`
            </param>
            <param name="data">
              A list of tensors to print out when op is evaluated.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Print'.
            </param>
            <param name="message">
              Optional argument
              A string, prefix of the error message.
            </param>
            <param name="first_n">
              Optional argument
              Only log `first_n` number of times. -1 disables logging.
            </param>
            <param name="summarize">
              Optional argument
              Only print this many entries of each tensor.
            </param>
            <returns>
              = The unmodified `input` tensor
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Passes `input` through to `output` and prints `data` when evaluating.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.PriorityQueue(TensorFlow.TFShape[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              A queue that produces elements sorted by the first component value.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'PriorityQueue'.
            </param>
            <param name="component_types">
              Optional argument
              The type of each component in a value.
            </param>
            <param name="capacity">
              Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.
            </param>
            <param name="shapes">
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types. If the length of
              this attr is 0, the shapes of queue elements are not constrained, and
              only one element may be dequeued at a time.
            </param>
            <returns>
              The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Note that the PriorityQueue requires the first component of any element
              to be a scalar int64, in addition to the other elements declared by
              component_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue
              and DequeueMany) on a PriorityQueue will all require (resp. output) one extra
              entry in their input (resp. output) lists.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.PriorityQueueV2(TensorFlow.TFShape[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              A queue that produces elements sorted by the first component value.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'PriorityQueueV2'.
            </param>
            <param name="component_types">
              Optional argument
              The type of each component in a value.
            </param>
            <param name="capacity">
              Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.
            </param>
            <param name="shapes">
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types. If the length of
              this attr is 0, the shapes of queue elements are not constrained, and
              only one element may be dequeued at a time.
            </param>
            <returns>
              The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Note that the PriorityQueue requires the first component of any element
              to be a scalar int64, in addition to the other elements declared by
              component_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue
              and DequeueMany) on a PriorityQueue will all require (resp. output) one extra
              entry in their input (resp. output) lists.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Prod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the product of elements across dimensions of a tensor.
            </summary>
            <param name="input">
              The tensor to reduce.
            </param>
            <param name="reduction_indices">
              The dimensions to reduce. Must be in the range
              `[-rank(input), rank(input))`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Prod'.
            </param>
            <param name="keep_dims">
              Optional argument
              If true, retain reduced dimensions with length 1.
            </param>
            <returns>
              The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Reduces `input` along the dimensions given in `reduction_indices`. Unless
              `keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
              `reduction_indices`. If `keep_dims` is true, the reduced dimensions are
              retained with length 1.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Qr(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the QR decompositions of one or more matrices.
            </summary>
            <param name="input">
              A tensor of shape `[..., M, N]` whose inner-most 2 dimensions
              form matrices of size `[M, N]`. Let `P` be the minimum of `M` and `N`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Qr'.
            </param>
            <param name="full_matrices">
              Optional argument
              If true, compute full-sized `q` and `r`. If false
              (the default), compute only the leading `P` columns of `q`.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              q: Orthonormal basis for range of `a`. If `full_matrices` is `False` then
              shape is `[..., M, P]`; if `full_matrices` is `True` then shape is
              `[..., M, M]`.
              r: Triangular factor. If `full_matrices` is `False` then shape is
              `[..., P, N]`. If `full_matrices` is `True` then shape is `[..., M, N]`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Computes the QR decomposition of each inner matrix in `tensor` such that
              `tensor[..., :, :] = q[..., :, :] * r[..., :,:])`
              
              ```python
              # a is a tensor.
              # q is a tensor of orthonormal matrices.
              # r is a tensor of upper triangular matrices.
              q, r = qr(a)
              q_full, r_full = qr(a, full_matrices=True)
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizeAndDequantize(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Single},System.Nullable{System.Single},System.String)">
            <summary>
              Use QuantizeAndDequantizeV2 instead.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeAndDequantize'.
            </param>
            <param name="signed_input">
              Optional argument
            </param>
            <param name="num_bits">
              Optional argument
            </param>
            <param name="range_given">
              Optional argument
            </param>
            <param name="input_min">
              Optional argument
            </param>
            <param name="input_max">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizeAndDequantizeV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">
            <summary>
              Quantizes then dequantizes a tensor.
            </summary>
            <param name="input">
              Tensor to quantize and then dequantize.
            </param>
            <param name="input_min">
              If range_given, this is the min of the range, otherwise this input
              will be ignored.
            </param>
            <param name="input_max">
              If range_given, this is the max of the range, otherwise this input
              will be ignored.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeAndDequantizeV2'.
            </param>
            <param name="signed_input">
              Optional argument
              If the quantization is signed or unsigned.
            </param>
            <param name="num_bits">
              Optional argument
              The bitwidth of the quantization.
            </param>
            <param name="range_given">
              Optional argument
              If the range is given or should be computed from the tensor.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op simulates the precision loss from the quantized forward pass by:
              1. Quantizing the tensor to fixed point numbers, which should match the target
                 quantization method when it is used in inference.
              2. Dequantizing it back to floating point numbers for the following ops, most
                 likely matmul.
              
              There are different ways to quantize. This version does not use the full range
              of the output type, choosing to elide the lowest possible value for symmetry
              (e.g., output range is -127 to 127, not -128 to 127 for signed 8 bit
              quantization), so that 0.0 maps to 0.
              
              To perform this op, we first find the range of values in our tensor. The range
              we use is always centered on 0, so we find m such that
              
              1. m = max(abs(input_min), abs(input_max)) if range_given is true,
              2. m = max(abs(min_elem(input)), abs(max_elem(input))) otherwise.
              
              Our input tensor range is then [-m, m].
              
              Next, we choose our fixed-point quantization buckets, [min_fixed, max_fixed].
              If signed_input is true, this is
              
                [min_fixed, max_fixed ] =
                    [-(1 &amp;lt;&amp;lt; (num_bits - 1) - 1), (1 &amp;lt;&amp;lt; (num_bits - 1)) - 1].
              
              Otherwise, if signed_input is false, the fixed-point range is
              
                [min_fixed, max_fixed] = [0, (1 &amp;lt;&amp;lt; num_bits) - 1].
              
              From this we compute our scaling factor, s:
              
                s = (max_fixed - min_fixed) / (2 * m).
              
              Now we can quantize and dequantize the elements of our tensor.  An element e
              is transformed into e':
              
                e' = (e * s).round_to_nearest() / s.
              
              Note that we have a different number of buckets in the signed vs. unsigned
              cases.  For example, if num_bits == 8, we get 254 buckets in the signed case
              vs. 255 in the unsigned case.
              
              For example, suppose num_bits = 8 and m = 1.  Then
              
                [min_fixed, max_fixed] = [-127, 127], and
                s = (127 + 127) / 2 = 127.
              
              Given the vector {-1, -0.5, 0, 0.3}, this is quantized to
              {-127, -63, 0, 38}, and dequantized to {-1, -63.0/127, 0, 38.0/127}.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizeAndDequantizeV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Quantizes then dequantizes a tensor.
            </summary>
            <param name="input">
            </param>
            <param name="input_min">
            </param>
            <param name="input_max">
            </param>
            <param name="num_bits">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeAndDequantizeV3'.
            </param>
            <param name="signed_input">
              Optional argument
            </param>
            <param name="range_given">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This is almost identical to QuantizeAndDequantizeV2, except that num_bits is a
              tensor, so its value can change during training.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Returns x + y element-wise, working on quantized buffers.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="min_x">
              The float value that the lowest quantized `x` value represents.
            </param>
            <param name="max_x">
              The float value that the highest quantized `x` value represents.
            </param>
            <param name="min_y">
              The float value that the lowest quantized `y` value represents.
            </param>
            <param name="max_y">
              The float value that the highest quantized `y` value represents.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedAdd'.
            </param>
            <param name="Toutput">
              Optional argument
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              z: 
              min_z: The float value that the lowest quantized output value represents.
              max_z: The float value that the highest quantized output value represents.
              
              *NOTE*: `QuantizedAdd` supports limited forms of broadcasting. More about
              broadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedAvgPool(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
              Produces the average pool of the input tensor for quantized types.
            </summary>
            <param name="input">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="min_input">
              The float value that the lowest quantized input value represents.
            </param>
            <param name="max_input">
              The float value that the highest quantized input value represents.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedAvgPool'.
            </param>
            <param name="ksize">
              The size of the window for each dimension of the input tensor.
              The length must be 4 to match the number of dimensions of the input.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the input
              tensor.  The length must be 4 to match the number of dimensions of the input.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: 
              min_output: The float value that the lowest quantized output value represents.
              max_output: The float value that the highest quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedBatchNormWithGlobalNormalization(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Single,System.Boolean,System.String)">
            <summary>
              Quantized Batch normalization.
            </summary>
            <param name="t">
              A 4D input Tensor.
            </param>
            <param name="t_min">
              The value represented by the lowest quantized input.
            </param>
            <param name="t_max">
              The value represented by the highest quantized input.
            </param>
            <param name="m">
              A 1D mean Tensor with size matching the last dimension of t.
              This is the first output from tf.nn.moments,
              or a saved moving average thereof.
            </param>
            <param name="m_min">
              The value represented by the lowest quantized mean.
            </param>
            <param name="m_max">
              The value represented by the highest quantized mean.
            </param>
            <param name="v">
              A 1D variance Tensor with size matching the last dimension of t.
              This is the second output from tf.nn.moments,
              or a saved moving average thereof.
            </param>
            <param name="v_min">
              The value represented by the lowest quantized variance.
            </param>
            <param name="v_max">
              The value represented by the highest quantized variance.
            </param>
            <param name="beta">
              A 1D beta Tensor with size matching the last dimension of t.
              An offset to be added to the normalized tensor.
            </param>
            <param name="beta_min">
              The value represented by the lowest quantized offset.
            </param>
            <param name="beta_max">
              The value represented by the highest quantized offset.
            </param>
            <param name="gamma">
              A 1D gamma Tensor with size matching the last dimension of t.
              If "scale_after_normalization" is true, this tensor will be multiplied
              with the normalized tensor.
            </param>
            <param name="gamma_min">
              The value represented by the lowest quantized gamma.
            </param>
            <param name="gamma_max">
              The value represented by the highest quantized gamma.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedBatchNormWithGlobalNormalization'.
            </param>
            <param name="out_type">
            </param>
            <param name="variance_epsilon">
              A small float number to avoid dividing by 0.
            </param>
            <param name="scale_after_normalization">
              A bool indicating whether the resulted tensor
              needs to be multiplied with gamma.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              result: 
              result_min: 
              result_max: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              This op is deprecated and will be removed in the future. Prefer
              `tf.nn.batch_normalization`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedBiasAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Adds Tensor 'bias' to Tensor 'input' for Quantized types.
            </summary>
            <param name="input">
            </param>
            <param name="bias">
              A 1D bias Tensor with size matching the last dimension of 'input'.
            </param>
            <param name="min_input">
              The float value that the lowest quantized input value represents.
            </param>
            <param name="max_input">
              The float value that the highest quantized input value represents.
            </param>
            <param name="min_bias">
              The float value that the lowest quantized bias value represents.
            </param>
            <param name="max_bias">
              The float value that the highest quantized bias value represents.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedBiasAdd'.
            </param>
            <param name="out_type">
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: 
              min_out: The float value that the lowest quantized output value represents.
              max_out: The float value that the highest quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Broadcasts the values of bias on dimensions 0..N-2 of 'input'.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedConcat(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)">
            <summary>
              Concatenates quantized tensors along one dimension.
            </summary>
            <param name="concat_dim">
              0-D.  The dimension along which to concatenate.  Must be in the
              range [0, rank(values)).
            </param>
            <param name="values">
              The `N` Tensors to concatenate. Their ranks and types must match,
              and their sizes must match in all dimensions except `concat_dim`.
            </param>
            <param name="input_mins">
              The minimum scalar values for each of the input tensors.
            </param>
            <param name="input_maxes">
              The maximum scalar values for each of the input tensors.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConcat'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: A `Tensor` with the concatenation of values stacked along the
              `concat_dim` dimension.  This tensor's shape matches that of `values` except
              in `concat_dim` where it has the sum of the sizes.
              output_min: The float value that the minimum quantized output value represents.
              output_max: The float value that the maximum quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{TensorFlow.TFDataType},System.Int64[],System.String)">
            <summary>
              Computes a 2D convolution given quantized 4D input and filter tensors.
            </summary>
            <param name="input">
            </param>
            <param name="filter">
              filter's input_depth dimension must match input's depth dimensions.
            </param>
            <param name="min_input">
              The float value that the lowest quantized input value represents.
            </param>
            <param name="max_input">
              The float value that the highest quantized input value represents.
            </param>
            <param name="min_filter">
              The float value that the lowest quantized filter value represents.
            </param>
            <param name="max_filter">
              The float value that the highest quantized filter value represents.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2D'.
            </param>
            <param name="out_type">
              Optional argument
            </param>
            <param name="dilations">
              Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              `input`. If set to k &amp;gt; 1, there will be k-1 skipped cells between each
              filter element on that dimension. The dimension order is determined by the
              value of `data_format`, see above for details. Dilations in the batch and
              depth dimensions must be 1.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the input
              tensor.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: 
              min_output: The float value that the lowest quantized output value represents.
              max_output: The float value that the highest quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              The inputs are quantized tensors where the lowest value represents the real
              number of the associated minimum, and the highest represents the maximum.
              This means that you can only interpret the quantized output in the same way, by
              taking the returned minimum and maximum values into account.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedInstanceNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)">
            <summary>
              Quantized Instance normalization.
            </summary>
            <param name="x">
              A 4D input Tensor.
            </param>
            <param name="x_min">
              The value represented by the lowest quantized input.
            </param>
            <param name="x_max">
              The value represented by the highest quantized input.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedInstanceNorm'.
            </param>
            <param name="output_range_given">
              Optional argument
              If True, `given_y_min` and `given_y_min`
              and `given_y_max` are used as the output range. Otherwise,
              the implementation computes the output range.
            </param>
            <param name="given_y_min">
              Optional argument
              Output in `y_min` if `output_range_given` is True.
            </param>
            <param name="given_y_max">
              Optional argument
              Output in `y_max` if `output_range_given` is True.
            </param>
            <param name="variance_epsilon">
              Optional argument
              A small float number to avoid dividing by 0.
            </param>
            <param name="min_separation">
              Optional argument
              Minimum value of `y_max - y_min`
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              y: A 4D Tensor.
              y_min: The value represented by the lowest quantized output.
              y_max: The value represented by the highest quantized output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Perform a quantized matrix multiplication of  `a` by the matrix `b`.
            </summary>
            <param name="a">
              Must be a two-dimensional tensor.
            </param>
            <param name="b">
              Must be a two-dimensional tensor.
            </param>
            <param name="min_a">
              The float value that the lowest quantized `a` value represents.
            </param>
            <param name="max_a">
              The float value that the highest quantized `a` value represents.
            </param>
            <param name="min_b">
              The float value that the lowest quantized `b` value represents.
            </param>
            <param name="max_b">
              The float value that the highest quantized `b` value represents.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMatMul'.
            </param>
            <param name="Toutput">
              Optional argument
            </param>
            <param name="transpose_a">
              Optional argument
              If true, `a` is transposed before multiplication.
            </param>
            <param name="transpose_b">
              Optional argument
              If true, `b` is transposed before multiplication.
            </param>
            <param name="Tactivation">
              Optional argument
              The type of output produced by activation function
              following this operation.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: 
              min_out: The float value that the lowest quantized output value represents.
              max_out: The float value that the highest quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              The inputs must be two-dimensional matrices and the inner dimension of
              `a` (after being transposed if `transpose_a` is non-zero) must match the
              outer dimension of `b` (after being transposed if `transposed_b` is
              non-zero).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedMaxPool(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
              Produces the max pool of the input tensor for quantized types.
            </summary>
            <param name="input">
              The 4D (batch x rows x cols x depth) Tensor to MaxReduce over.
            </param>
            <param name="min_input">
              The float value that the lowest quantized input value represents.
            </param>
            <param name="max_input">
              The float value that the highest quantized input value represents.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMaxPool'.
            </param>
            <param name="ksize">
              The size of the window for each dimension of the input tensor.
              The length must be 4 to match the number of dimensions of the input.
            </param>
            <param name="strides">
              The stride of the sliding window for each dimension of the input
              tensor. The length must be 4 to match the number of dimensions of the input.
            </param>
            <param name="padding">
              The type of padding algorithm to use.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: 
              min_output: The float value that the lowest quantized output value represents.
              max_output: The float value that the highest quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Returns x * y element-wise, working on quantized buffers.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="min_x">
              The float value that the lowest quantized `x` value represents.
            </param>
            <param name="max_x">
              The float value that the highest quantized `x` value represents.
            </param>
            <param name="min_y">
              The float value that the lowest quantized `y` value represents.
            </param>
            <param name="max_y">
              The float value that the highest quantized `y` value represents.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMul'.
            </param>
            <param name="Toutput">
              Optional argument
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              z: 
              min_z: The float value that the lowest quantized output value represents.
              max_z: The float value that the highest quantized output value represents.
              
              *NOTE*: `QuantizedMul` supports limited forms of broadcasting. More about
              broadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizeDownAndShrinkRange(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Convert the quantized 'input' tensor into a lower-precision 'output', using the
            </summary>
            <param name="input">
            </param>
            <param name="input_min">
              The float value that the minimum quantized input value represents.
            </param>
            <param name="input_max">
              The float value that the maximum quantized input value represents.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeDownAndShrinkRange'.
            </param>
            <param name="out_type">
              The type of the output. Should be a lower bit depth than Tinput.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: 
              output_min: The float value that the minimum quantized output value represents.
              output_max: The float value that the maximum quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              actual distribution of the values to maximize the usage of the lower bit depth
              and adjusting the output min and max ranges accordingly.
              
              [input_min, input_max] are scalar floats that specify the range for the float
              interpretation of the 'input' data. For example, if input_min is -1.0f and
              input_max is 1.0f, and we are dealing with quint16 quantized data, then a 0
              value in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.
              
              This operator tries to squeeze as much precision as possible into an output with
              a lower bit depth by calculating the actual min and max values found in the
              data. For example, maybe that quint16 input has no values lower than 16,384 and
              none higher than 49,152. That means only half the range is actually needed, all
              the float interpretations are between -0.5f and 0.5f, so if we want to compress
              the data into a quint8 output, we can use that range rather than the theoretical
              -1.0f to 1.0f that is suggested by the input min and max.
              
              In practice, this is most useful for taking output from operations like
              QuantizedMatMul that can produce higher bit-depth outputs than their inputs and
              may have large potential output ranges, but in practice have a distribution of
              input values that only uses a small fraction of the possible range. By feeding
              that output into this operator, we can reduce it from 32 bits down to 8 with
              minimal loss of accuracy.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedRelu(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Computes Quantized Rectified Linear: `max(features, 0)`
            </summary>
            <param name="features">
            </param>
            <param name="min_features">
              The float value that the lowest quantized value represents.
            </param>
            <param name="max_features">
              The float value that the highest quantized value represents.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedRelu'.
            </param>
            <param name="out_type">
              Optional argument
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              activations: Has the same output shape as "features".
              min_activations: The float value that the lowest quantized value represents.
              max_activations: The float value that the highest quantized value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedRelu6(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Computes Quantized Rectified Linear 6: `min(max(features, 0), 6)`
            </summary>
            <param name="features">
            </param>
            <param name="min_features">
              The float value that the lowest quantized value represents.
            </param>
            <param name="max_features">
              The float value that the highest quantized value represents.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedRelu6'.
            </param>
            <param name="out_type">
              Optional argument
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              activations: Has the same output shape as "features".
              min_activations: The float value that the lowest quantized value represents.
              max_activations: The float value that the highest quantized value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedReluX(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Computes Quantized Rectified Linear X: `min(max(features, 0), max_value)`
            </summary>
            <param name="features">
            </param>
            <param name="max_value">
            </param>
            <param name="min_features">
              The float value that the lowest quantized value represents.
            </param>
            <param name="max_features">
              The float value that the highest quantized value represents.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedReluX'.
            </param>
            <param name="out_type">
              Optional argument
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              activations: Has the same output shape as "features".
              min_activations: The float value that the lowest quantized value represents.
              max_activations: The float value that the highest quantized value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedReshape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Reshapes a quantized tensor as per the Reshape op.
            </summary>
            <param name="tensor">
            </param>
            <param name="shape">
              Defines the shape of the output tensor.
            </param>
            <param name="input_min">
              The minimum value of the input.
            </param>
            <param name="input_max">
              The maximum value of the input.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedReshape'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: 
              output_min: This value is copied from input_min.
              output_max: This value is copied from input_max.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizedResizeBilinear(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Resize quantized `images` to `size` using quantized bilinear interpolation.
            </summary>
            <param name="images">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="size">
              = A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The
              new size for the images.
            </param>
            <param name="min">
            </param>
            <param name="max">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedResizeBilinear'.
            </param>
            <param name="align_corners">
              Optional argument
              If true, rescale input by (new_height - 1) / (height - 1), which
              exactly aligns the 4 corners of images and resized images. If false, rescale
              by new_height / height. Treat similarly the width dimension.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              resized_images: 4-D with shape
              `[batch, new_height, new_width, channels]`.
              out_min: 
              out_max: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Input images and output images must be quantized types.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QuantizeV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.String)">
            <summary>
              Quantize the 'input' tensor of type float to 'output' tensor of type 'T'.
            </summary>
            <param name="input">
            </param>
            <param name="min_range">
              The minimum scalar value possibly produced for the input.
            </param>
            <param name="max_range">
              The maximum scalar value possibly produced for the input.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeV2'.
            </param>
            <param name="mode">
              Optional argument
            </param>
            <param name="round_mode">
              Optional argument
            </param>
            <param name="T">
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: The quantized data produced from the float input.
              output_min: The actual minimum scalar value used for the output.
              output_max: The actual maximum scalar value used for the output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              [min_range, max_range] are scalar floats that specify the range for
              the 'input' data. The 'mode' attribute controls exactly which calculations are
              used to convert the float values to their quantized equivalents.  The
              'round_mode' attribute controls which rounding tie-breaking algorithm is used
              when rounding float values to their quantized equivalents.
              
              In 'MIN_COMBINED' mode, each value of the tensor will undergo the following:
              
              ```
              out[i] = (in[i] - min_range) * range(T) / (max_range - min_range)
              if T == qint8, out[i] -= (range(T) + 1) / 2.0
              ```
              here `range(T) = numeric_limits&amp;lt;T&amp;gt;::max() - numeric_limits&amp;lt;T&amp;gt;::min()`
              
              *MIN_COMBINED Mode Example*
              
              Assume the input is type float and has a possible range of [0.0, 6.0] and the
              output type is quint8 ([0, 255]). The min_range and max_range values should be
              specified as 0.0 and 6.0. Quantizing from float to quint8 will multiply each
              value of the input by 255/6 and cast to quint8.
              
              If the output type was qint8 ([-128, 127]), the operation will additionally
              subtract each value by 128 prior to casting, so that the range of values aligns
              with the range of qint8.
              
              If the mode is 'MIN_FIRST', then this approach is used:
              
              ```
              num_discrete_values = 1 &amp;lt;&amp;lt; (# of bits in T)
              range_adjust = num_discrete_values / (num_discrete_values - 1)
              range = (range_max - range_min) * range_adjust
              range_scale = num_discrete_values / range
              quantized = round(input * range_scale) - round(range_min * range_scale) +
                numeric_limits&amp;lt;T&amp;gt;::min()
              quantized = max(quantized, numeric_limits&amp;lt;T&amp;gt;::min())
              quantized = min(quantized, numeric_limits&amp;lt;T&amp;gt;::max())
              ```
              
              The biggest difference between this and MIN_COMBINED is that the minimum range
              is rounded first, before it's subtracted from the rounded value. With
              MIN_COMBINED, a small bias is introduced where repeated iterations of quantizing
              and dequantizing will introduce a larger and larger error.
              
              *SCALED mode Example*
              
              `SCALED` mode matches the quantization approach used in
              `QuantizeAndDequantize{V2|V3}`.
              
              If the mode is `SCALED`, we do not use the full range of the output type,
              choosing to elide the lowest possible value for symmetry (e.g., output range is
              -127 to 127, not -128 to 127 for signed 8 bit quantization), so that 0.0 maps to
              0.
              
              We first find the range of values in our tensor. The
              range we use is always centered on 0, so we find m such that
              ```c++
                m = max(abs(input_min), abs(input_max))
              ```
              
              Our input tensor range is then `[-m, m]`.
              
              Next, we choose our fixed-point quantization buckets, `[min_fixed, max_fixed]`.
              If T is signed, this is
              ```
                num_bits = sizeof(T) * 8
                [min_fixed, max_fixed] =
                    [-(1 &amp;lt;&amp;lt; (num_bits - 1) - 1), (1 &amp;lt;&amp;lt; (num_bits - 1)) - 1]
              ```
              
              Otherwise, if T is unsigned, the fixed-point range is
              ```
                [min_fixed, max_fixed] = [0, (1 &amp;lt;&amp;lt; num_bits) - 1]
              ```
              
              From this we compute our scaling factor, s:
              ```c++
                s = (max_fixed - min_fixed) / (2 * m)
              ```
              
              Now we can quantize the elements of our tensor:
              ```c++
              result = round(input * s)
              ```
              
              One thing to watch out for is that the operator may choose to adjust the
              requested minimum and maximum values slightly during the quantization process,
              so you should always use the output ports as the range for further calculations.
              For example, if the requested minimum and maximum values are close to equal,
              they will be separated by a small epsilon value to prevent ill-formed quantized
              buffers from being created. Otherwise, you can end up with buffers where all the
              quantized values map to the same float value, which causes problems for
              operations that have to perform further calculations on them.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueClose(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Closes the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueClose'.
            </param>
            <param name="cancel_pending_enqueues">
              Optional argument
              If true, all pending enqueue requests that are
              blocked on the given queue will be canceled.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              This operation signals that no more elements will be enqueued in the
              given queue. Subsequent Enqueue(Many) operations will fail.
              Subsequent Dequeue(Many) operations will continue to succeed if
              sufficient elements remain in the queue. Subsequent Dequeue(Many)
              operations that would block will fail immediately.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueCloseV2(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Closes the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueCloseV2'.
            </param>
            <param name="cancel_pending_enqueues">
              Optional argument
              If true, all pending enqueue requests that are
              blocked on the given queue will be canceled.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              This operation signals that no more elements will be enqueued in the
              given queue. Subsequent Enqueue(Many) operations will fail.
              Subsequent Dequeue(Many) operations will continue to succeed if
              sufficient elements remain in the queue. Subsequent Dequeue(Many)
              operations that would block will fail immediately.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueDequeue(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)">
            <summary>
              Dequeues a tuple of one or more tensors from the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeue'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is empty, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <param name="component_types">
              The type of each component in a tuple.
            </param>
            <returns>
              One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation has k outputs, where k is the number of components
              in the tuples stored in the given queue, and output i is the ith
              component of the dequeued tuple.
              
              N.B. If the queue is empty, this operation will block until an element
              has been dequeued (or 'timeout_ms' elapses, if specified).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueDequeueMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)">
            <summary>
              Dequeues `n` tuples of one or more tensors from the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="n">
              The number of tuples to dequeue.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueMany'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue has fewer than n elements, this operation
              will block for up to timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <param name="component_types">
              The type of each component in a tuple.
            </param>
            <returns>
              One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              If the queue is closed and there are fewer than `n` elements, then an
              OutOfRange error is returned.
              
              This operation concatenates queue-element component tensors along the
              0th dimension to make a single component tensor.  All of the components
              in the dequeued tuple will have size `n` in the 0th dimension.
              
              This operation has `k` outputs, where `k` is the number of components in
              the tuples stored in the given queue, and output `i` is the ith
              component of the dequeued tuple.
              
              N.B. If the queue is empty, this operation will block until `n` elements
              have been dequeued (or 'timeout_ms' elapses, if specified).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueDequeueManyV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)">
            <summary>
              Dequeues `n` tuples of one or more tensors from the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="n">
              The number of tuples to dequeue.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueManyV2'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue has fewer than n elements, this operation
              will block for up to timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <param name="component_types">
              The type of each component in a tuple.
            </param>
            <returns>
              One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              If the queue is closed and there are fewer than `n` elements, then an
              OutOfRange error is returned.
              
              This operation concatenates queue-element component tensors along the
              0th dimension to make a single component tensor.  All of the components
              in the dequeued tuple will have size `n` in the 0th dimension.
              
              This operation has `k` outputs, where `k` is the number of components in
              the tuples stored in the given queue, and output `i` is the ith
              component of the dequeued tuple.
              
              N.B. If the queue is empty, this operation will block until `n` elements
              have been dequeued (or 'timeout_ms' elapses, if specified).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueDequeueUpTo(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)">
            <summary>
              Dequeues `n` tuples of one or more tensors from the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="n">
              The number of tuples to dequeue.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueUpTo'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue has fewer than n elements, this operation
              will block for up to timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <param name="component_types">
              The type of each component in a tuple.
            </param>
            <returns>
              One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation is not supported by all queues.  If a queue does not support
              DequeueUpTo, then an Unimplemented error is returned.
              
              If the queue is closed and there are more than 0 but less than `n`
              elements remaining, then instead of returning an OutOfRange error like
              QueueDequeueMany, less than `n` elements are returned immediately.  If
              the queue is closed and there are 0 elements left in the queue, then
              an OutOfRange error is returned just like in QueueDequeueMany.
              Otherwise the behavior is identical to QueueDequeueMany:
              
              This operation concatenates queue-element component tensors along the
              0th dimension to make a single component tensor.  All of the components
              in the dequeued tuple will have size `n` in the 0th dimension.
              
              This operation has k outputs, where `k` is the number of components in
              the tuples stored in the given queue, and output `i` is the ith
              component of the dequeued tuple.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueDequeueUpToV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)">
            <summary>
              Dequeues `n` tuples of one or more tensors from the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="n">
              The number of tuples to dequeue.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueUpToV2'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue has fewer than n elements, this operation
              will block for up to timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <param name="component_types">
              The type of each component in a tuple.
            </param>
            <returns>
              One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation is not supported by all queues.  If a queue does not support
              DequeueUpTo, then an Unimplemented error is returned.
              
              If the queue is closed and there are more than 0 but less than `n`
              elements remaining, then instead of returning an OutOfRange error like
              QueueDequeueMany, less than `n` elements are returned immediately.  If
              the queue is closed and there are 0 elements left in the queue, then
              an OutOfRange error is returned just like in QueueDequeueMany.
              Otherwise the behavior is identical to QueueDequeueMany:
              
              This operation concatenates queue-element component tensors along the
              0th dimension to make a single component tensor.  All of the components
              in the dequeued tuple will have size n in the 0th dimension.
              
              This operation has `k` outputs, where `k` is the number of components in
              the tuples stored in the given queue, and output `i` is the ith
              component of the dequeued tuple.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueDequeueV2(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)">
            <summary>
              Dequeues a tuple of one or more tensors from the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueV2'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is empty, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <param name="component_types">
              The type of each component in a tuple.
            </param>
            <returns>
              One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation has k outputs, where k is the number of components
              in the tuples stored in the given queue, and output i is the ith
              component of the dequeued tuple.
              
              N.B. If the queue is empty, this operation will block until an element
              has been dequeued (or 'timeout_ms' elapses, if specified).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueEnqueue(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">
            <summary>
              Enqueues a tuple of one or more tensors in the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="components">
              One or more tensors from which the enqueued tensors should be taken.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueue'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is full, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The components input has k elements, which correspond to the components of
              tuples stored in the given queue.
              
              N.B. If the queue is full, this operation will block until the given
              element has been enqueued (or 'timeout_ms' elapses, if specified).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueEnqueueMany(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">
            <summary>
              Enqueues zero or more tuples of one or more tensors in the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="components">
              One or more tensors from which the enqueued tensors should
              be taken.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueMany'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is too full, this operation will block for up
              to timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              This operation slices each component tensor along the 0th dimension to
              make multiple queue elements. All of the tuple components must have the
              same size in the 0th dimension.
              
              The components input has k elements, which correspond to the components of
              tuples stored in the given queue.
              
              N.B. If the queue is full, this operation will block until the given
              elements have been enqueued (or 'timeout_ms' elapses, if specified).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueEnqueueManyV2(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">
            <summary>
              Enqueues zero or more tuples of one or more tensors in the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="components">
              One or more tensors from which the enqueued tensors should
              be taken.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueManyV2'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is too full, this operation will block for up
              to timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              This operation slices each component tensor along the 0th dimension to
              make multiple queue elements. All of the tuple components must have the
              same size in the 0th dimension.
              
              The components input has k elements, which correspond to the components of
              tuples stored in the given queue.
              
              N.B. If the queue is full, this operation will block until the given
              elements have been enqueued (or 'timeout_ms' elapses, if specified).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueEnqueueV2(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">
            <summary>
              Enqueues a tuple of one or more tensors in the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="components">
              One or more tensors from which the enqueued tensors should be taken.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueV2'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is full, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The components input has k elements, which correspond to the components of
              tuples stored in the given queue.
              
              N.B. If the queue is full, this operation will block until the given
              element has been enqueued (or 'timeout_ms' elapses, if specified).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueIsClosed(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns true if queue is closed.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueIsClosed'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation returns true if the queue is closed and false if the queue
              is open.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueIsClosedV2(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns true if queue is closed.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueIsClosedV2'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation returns true if the queue is closed and false if the queue
              is open.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueSize(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the number of elements in the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueSize'.
            </param>
            <returns>
              The number of elements in the given queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.QueueSizeV2(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the number of elements in the given queue.
            </summary>
            <param name="handle">
              The handle to a queue.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueSizeV2'.
            </param>
            <returns>
              The number of elements in the given queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.RandomCrop(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Randomly crop `image`.
            </summary>
            <param name="image">
              3-D of shape `[height, width, channels]`.
            </param>
            <param name="size">
              1-D of length 2 containing: `crop_height`, `crop_width`..
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomCrop'.
            </param>
            <param name="seed">
              Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              An second seed to avoid seed collision.
            </param>
            <returns>
              3-D of shape `[crop_height, crop_width, channels].`
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `size` is a 1-D int64 tensor with 2 elements representing the crop height and
              width.  The values must be non negative.
              
              This Op picks a random location in `image` and crops a `height` by `width`
              rectangle from that location.  The random location is picked so the cropped
              area will fit inside the original image.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RandomDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a Dataset that returns pseudorandom numbers.
            </summary>
            <param name="seed">
              A scalar seed for the random number generator. If either seed or
              seed2 is set to be non-zero, the random number generator is seeded
              by the given seed.  Otherwise, a random seed is used.
            </param>
            <param name="seed2">
              A second scalar seed to avoid seed collision.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.RandomGamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Outputs random values from the Gamma distribution(s) described by alpha.
            </summary>
            <param name="shape">
              1-D integer tensor. Shape of independent samples to draw from each
              distribution described by the shape parameters given in alpha.
            </param>
            <param name="alpha">
              A tensor in which each scalar is a "shape" parameter describing the
              associated gamma distribution.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomGamma'.
            </param>
            <param name="seed">
              Optional argument
              If either `seed` or `seed2` are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              A second seed to avoid seed collision.
            </param>
            <returns>
              A tensor with shape `shape + shape(alpha)`. Each slice
              `[:, ..., :, i0, i1, ...iN]` contains the samples drawn for
              `alpha[i0, i1, ...iN]`. The dtype of the output matches the dtype of alpha.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op uses the algorithm by Marsaglia et al. to acquire samples via
              transformation-rejection from pairs of uniform and normal random variables.
              See http://dl.acm.org/citation.cfm?id=358414
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RandomPoisson(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Use RandomPoissonV2 instead.
            </summary>
            <param name="shape">
            </param>
            <param name="rate">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomPoisson'.
            </param>
            <param name="seed">
              Optional argument
            </param>
            <param name="seed2">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.RandomPoissonV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Outputs random values from the Poisson distribution(s) described by rate.
            </summary>
            <param name="shape">
              1-D integer tensor. Shape of independent samples to draw from each
              distribution described by the shape parameters given in rate.
            </param>
            <param name="rate">
              A tensor in which each scalar is a "rate" parameter describing the
              associated poisson distribution.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomPoissonV2'.
            </param>
            <param name="seed">
              Optional argument
              If either `seed` or `seed2` are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              A second seed to avoid seed collision.
            </param>
            <param name="dtype">
              Optional argument
            </param>
            <returns>
              A tensor with shape `shape + shape(rate)`. Each slice
              `[:, ..., :, i0, i1, ...iN]` contains the samples drawn for
              `rate[i0, i1, ...iN]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op uses two algorithms, depending on rate. If rate &amp;gt;= 10, then
              the algorithm by Hormann is used to acquire samples via
              transformation-rejection.
              See http://www.sciencedirect.com/science/article/pii/0167668793909974.
              
              Otherwise, Knuth's algorithm is used to acquire samples via multiplying uniform
              random variables.
              See Donald E. Knuth (1969). Seminumerical Algorithms. The Art of Computer
              Programming, Volume 2. Addison Wesley
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RandomShuffle(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Randomly shuffles a tensor along its first dimension.
            </summary>
            <param name="value">
              The tensor to be shuffled.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomShuffle'.
            </param>
            <param name="seed">
              Optional argument
              If either `seed` or `seed2` are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              A second seed to avoid seed collision.
            </param>
            <returns>
              A tensor of same shape and type as `value`, shuffled along its first
              dimension.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
                The tensor is shuffled along dimension 0, such that each `value[j]` is mapped
                to one and only one `output[i]`. For example, a mapping that might occur for a
                3x2 tensor is:
              
              ```
              [[1, 2],       [[5, 6],
               [3, 4],  ==&amp;gt;   [1, 2],
               [5, 6]]        [3, 4]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RandomShuffleQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              A queue that randomizes the order of elements.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomShuffleQueue'.
            </param>
            <param name="shapes">
              Optional argument
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types. If the length of
              this attr is 0, the shapes of queue elements are not constrained, and
              only one element may be dequeued at a time.
            </param>
            <param name="capacity">
              Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.
            </param>
            <param name="min_after_dequeue">
              Optional argument
              Dequeue will block unless there would be this
              many elements after the dequeue or the queue is closed. This
              ensures a minimum level of mixing of elements.
            </param>
            <param name="seed">
              Optional argument
              If either seed or seed2 is set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, a random seed is used.
            </param>
            <param name="seed2">
              Optional argument
              A second seed to avoid seed collision.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.
            </param>
            <param name="component_types">
              The type of each component in a value.
            </param>
            <returns>
              The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.RandomShuffleQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              A queue that randomizes the order of elements.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomShuffleQueueV2'.
            </param>
            <param name="shapes">
              Optional argument
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types. If the length of
              this attr is 0, the shapes of queue elements are not constrained, and
              only one element may be dequeued at a time.
            </param>
            <param name="capacity">
              Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.
            </param>
            <param name="min_after_dequeue">
              Optional argument
              Dequeue will block unless there would be this
              many elements after the dequeue or the queue is closed. This
              ensures a minimum level of mixing of elements.
            </param>
            <param name="seed">
              Optional argument
              If either seed or seed2 is set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, a random seed is used.
            </param>
            <param name="seed2">
              Optional argument
              A second seed to avoid seed collision.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.
            </param>
            <param name="component_types">
              The type of each component in a value.
            </param>
            <returns>
              The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.RandomStandardNormal(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Outputs random values from a normal distribution.
            </summary>
            <param name="shape">
              The shape of the output tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomStandardNormal'.
            </param>
            <param name="seed">
              Optional argument
              If either `seed` or `seed2` are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              A second seed to avoid seed collision.
            </param>
            <param name="dtype">
              The type of the output.
            </param>
            <returns>
              A tensor of the specified shape filled with random normal values.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The generated values will have mean 0 and standard deviation 1.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RandomUniform(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Outputs random values from a uniform distribution.
            </summary>
            <param name="shape">
              The shape of the output tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomUniform'.
            </param>
            <param name="seed">
              Optional argument
              If either `seed` or `seed2` are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              A second seed to avoid seed collision.
            </param>
            <param name="dtype">
              The type of the output.
            </param>
            <returns>
              A tensor of the specified shape filled with uniform random values.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The generated values follow a uniform distribution in the range `[0, 1)`. The
              lower bound 0 is included in the range, while the upper bound 1 is excluded.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RandomUniformInt(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Outputs random integers from a uniform distribution.
            </summary>
            <param name="shape">
              The shape of the output tensor.
            </param>
            <param name="minval">
              0-D.  Inclusive lower bound on the generated integers.
            </param>
            <param name="maxval">
              0-D.  Exclusive upper bound on the generated integers.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomUniformInt'.
            </param>
            <param name="seed">
              Optional argument
              If either `seed` or `seed2` are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              A second seed to avoid seed collision.
            </param>
            <returns>
              A tensor of the specified shape filled with uniform random integers.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The generated values are uniform integers in the range `[minval, maxval)`.
              The lower bound `minval` is included in the range, while the upper bound
              `maxval` is excluded.
              
              The random integers are slightly biased unless `maxval - minval` is an exact
              power of two.  The bias is small for values of `maxval - minval` significantly
              smaller than the range of the output (either `2^32` or `2^64`).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Range(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Creates a sequence of numbers.
            </summary>
            <param name="start">
              0-D (scalar). First entry in the sequence.
            </param>
            <param name="limit">
              0-D (scalar). Upper limit of sequence, exclusive.
            </param>
            <param name="delta">
              0-D (scalar). Optional. Default is 1. Number that increments `start`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Range'.
            </param>
            <returns>
              1-D.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation creates a sequence of numbers that begins at `start` and
              extends by increments of `delta` up to but not including `limit`.
              
              For example:
              
              ```
              # 'start' is 3
              # 'limit' is 18
              # 'delta' is 3
              tf.range(start, limit, delta) ==&amp;gt; [3, 6, 9, 12, 15]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RangeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset with a range of values. Corresponds to python's xrange.
            </summary>
            <param name="start">
              corresponds to start in python's xrange().
            </param>
            <param name="stop">
              corresponds to stop in python's xrange().
            </param>
            <param name="step">
              corresponds to step in python's xrange().
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RangeDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Rank(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the rank of a tensor.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Rank'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation returns an integer representing the rank of `input`.
              
              For example:
              
              ```
              # 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
              # shape of tensor 't' is [2, 2, 3]
              rank(t) ==&amp;gt; 3
              ```
              
              **Note**: The rank of a tensor is not the same as the rank of a matrix. The rank
              of a tensor is the number of indices required to uniquely select each element
              of the tensor. Rank is also known as "order", "degree", or "ndims."
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderNumRecordsProduced(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the number of records this Reader has produced.
            </summary>
            <param name="reader_handle">
              Handle to a Reader.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumRecordsProduced'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This is the same as the number of ReaderRead executions that have
              succeeded.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderNumRecordsProducedV2(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the number of records this Reader has produced.
            </summary>
            <param name="reader_handle">
              Handle to a Reader.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumRecordsProducedV2'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This is the same as the number of ReaderRead executions that have
              succeeded.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderNumWorkUnitsCompleted(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the number of work units this Reader has finished processing.
            </summary>
            <param name="reader_handle">
              Handle to a Reader.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumWorkUnitsCompleted'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderNumWorkUnitsCompletedV2(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the number of work units this Reader has finished processing.
            </summary>
            <param name="reader_handle">
              Handle to a Reader.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumWorkUnitsCompletedV2'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderRead(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the next record (key, value pair) produced by a Reader.
            </summary>
            <param name="reader_handle">
              Handle to a Reader.
            </param>
            <param name="queue_handle">
              Handle to a Queue, with string work items.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderRead'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              key: A scalar.
              value: A scalar.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Will dequeue from the input queue if necessary (e.g. when the
              Reader needs to start reading from a new file since it has finished
              with the previous file).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderReadUpTo(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns up to `num_records` (key, value) pairs produced by a Reader.
            </summary>
            <param name="reader_handle">
              Handle to a `Reader`.
            </param>
            <param name="queue_handle">
              Handle to a `Queue`, with string work items.
            </param>
            <param name="num_records">
              number of records to read from `Reader`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReadUpTo'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              keys: A 1-D tensor.
              values: A 1-D tensor.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Will dequeue from the input queue if necessary (e.g. when the
              Reader needs to start reading from a new file since it has finished
              with the previous file).
              It may return less than `num_records` even before the last batch.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderReadUpToV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns up to `num_records` (key, value) pairs produced by a Reader.
            </summary>
            <param name="reader_handle">
              Handle to a `Reader`.
            </param>
            <param name="queue_handle">
              Handle to a `Queue`, with string work items.
            </param>
            <param name="num_records">
              number of records to read from `Reader`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReadUpToV2'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              keys: A 1-D tensor.
              values: A 1-D tensor.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Will dequeue from the input queue if necessary (e.g. when the
              Reader needs to start reading from a new file since it has finished
              with the previous file).
              It may return less than `num_records` even before the last batch.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderReadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the next record (key, value pair) produced by a Reader.
            </summary>
            <param name="reader_handle">
              Handle to a Reader.
            </param>
            <param name="queue_handle">
              Handle to a Queue, with string work items.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReadV2'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              key: A scalar.
              value: A scalar.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Will dequeue from the input queue if necessary (e.g. when the
              Reader needs to start reading from a new file since it has finished
              with the previous file).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderReset(TensorFlow.TFOutput,System.String)">
            <summary>
              Restore a Reader to its initial clean state.
            </summary>
            <param name="reader_handle">
              Handle to a Reader.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReset'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderResetV2(TensorFlow.TFOutput,System.String)">
            <summary>
              Restore a Reader to its initial clean state.
            </summary>
            <param name="reader_handle">
              Handle to a Reader.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderResetV2'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderRestoreState(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Restore a reader to a previously saved state.
            </summary>
            <param name="reader_handle">
              Handle to a Reader.
            </param>
            <param name="state">
              Result of a ReaderSerializeState of a Reader with type
              matching reader_handle.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderRestoreState'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              Not all Readers support being restored, so this can produce an
              Unimplemented error.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderRestoreStateV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Restore a reader to a previously saved state.
            </summary>
            <param name="reader_handle">
              Handle to a Reader.
            </param>
            <param name="state">
              Result of a ReaderSerializeState of a Reader with type
              matching reader_handle.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderRestoreStateV2'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              Not all Readers support being restored, so this can produce an
              Unimplemented error.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderSerializeState(TensorFlow.TFOutput,System.String)">
            <summary>
              Produce a string tensor that encodes the state of a Reader.
            </summary>
            <param name="reader_handle">
              Handle to a Reader.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderSerializeState'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Not all Readers support being serialized, so this can produce an
              Unimplemented error.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReaderSerializeStateV2(TensorFlow.TFOutput,System.String)">
            <summary>
              Produce a string tensor that encodes the state of a Reader.
            </summary>
            <param name="reader_handle">
              Handle to a Reader.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderSerializeStateV2'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Not all Readers support being serialized, so this can produce an
              Unimplemented error.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReadFile(TensorFlow.TFOutput,System.String)">
            <summary>
              Reads and outputs the entire contents of the input filename.
            </summary>
            <param name="filename">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReadFile'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ReadVariableOp(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Reads the value of a variable.
            </summary>
            <param name="resource">
              handle to the resource in which to store the variable.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReadVariableOp'.
            </param>
            <param name="dtype">
              the dtype of the value.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The tensor returned by this operation is immutable.
              
              The value returned by this operation is guaranteed to be influenced by all the
              writes on which this operation depends directly or indirectly, and to not be
              influenced by any of the writes which depend directly or indirectly on this
              operation.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Real(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Returns the real part of a complex number.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Real'.
            </param>
            <param name="Tout">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a tensor `input` of complex numbers, this operation returns a tensor of
              type `float` that is the real part of each element in `input`. All elements in
              `input` must be complex numbers of the form \\(a + bj\\), where *a* is the real
               part returned by this operation and *b* is the imaginary part.
              
              For example:
              
              ```
              # tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]
              tf.real(input) ==&amp;gt; [-2.25, 3.25]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RealDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns x / y element-wise for real types.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RealDiv'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              If `x` and `y` are reals, this will return the floating-point division.
              
              *NOTE*: `Div` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Reciprocal(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the reciprocal of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Reciprocal'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              I.e., \\(y = 1 / x\\).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReciprocalGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the gradient for the inverse of `x` wrt its input.
            </summary>
            <param name="y">
            </param>
            <param name="dy">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReciprocalGrad'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Specifically, `grad = -dy * y*y`, where `y = 1/x`, and `dy`
              is the corresponding input gradient.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RecordInput(System.String,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String)">
            <summary>
              Emits randomized records.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RecordInput'.
            </param>
            <param name="file_random_seed">
              Optional argument
              Random seeds used to produce randomized records.
            </param>
            <param name="file_shuffle_shift_ratio">
              Optional argument
              Shifts the list of files after the list is randomly
              shuffled.
            </param>
            <param name="file_buffer_size">
              Optional argument
              The randomization shuffling buffer.
            </param>
            <param name="file_parallelism">
              Optional argument
              How many sstables are opened and concurrently iterated over.
            </param>
            <param name="batch_size">
              Optional argument
              The batch size.
            </param>
            <param name="compression_type">
              Optional argument
              The type of compression for the file. Currently ZLIB and
              GZIP are supported. Defaults to none.
            </param>
            <param name="file_pattern">
              Glob pattern for the data files.
            </param>
            <returns>
              A tensor of shape [batch_size].
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ReduceJoin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String,System.String)">
            <summary>
              Joins a string Tensor across the given dimensions.
            </summary>
            <param name="inputs">
              The input to be joined.  All reduced indices must have non-zero size.
            </param>
            <param name="reduction_indices">
              The dimensions to reduce over.  Dimensions are reduced in the
              order specified.  Omitting `reduction_indices` is equivalent to passing
              `[n-1, n-2, ..., 0]`.  Negative indices from `-n` to `-1` are supported.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReduceJoin'.
            </param>
            <param name="keep_dims">
              Optional argument
              If `True`, retain reduced dimensions with length `1`.
            </param>
            <param name="separator">
              Optional argument
              The separator to use when joining.
            </param>
            <returns>
              Has shape equal to that of the input with reduced dimensions removed or
              set to `1` depending on `keep_dims`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes the string join across dimensions in the given string Tensor of shape
              `[d_0, d_1, ..., d_n-1]`.  Returns a new Tensor created by joining the input
              strings with the given separator (default: empty string).  Negative indices are
              counted backwards from the end, with `-1` being equivalent to `n - 1`.
              
              For example:
              
              ```python
              # tensor `a` is [["a", "b"], ["c", "d"]]
              tf.reduce_join(a, 0) ==&amp;gt; ["ac", "bd"]
              tf.reduce_join(a, 1) ==&amp;gt; ["ab", "cd"]
              tf.reduce_join(a, -2) = tf.reduce_join(a, 0) ==&amp;gt; ["ac", "bd"]
              tf.reduce_join(a, -1) = tf.reduce_join(a, 1) ==&amp;gt; ["ab", "cd"]
              tf.reduce_join(a, 0, keep_dims=True) ==&amp;gt; [["ac", "bd"]]
              tf.reduce_join(a, 1, keep_dims=True) ==&amp;gt; [["ab"], ["cd"]]
              tf.reduce_join(a, 0, separator=".") ==&amp;gt; ["a.c", "b.d"]
              tf.reduce_join(a, [0, 1]) ==&amp;gt; ["acbd"]
              tf.reduce_join(a, [1, 0]) ==&amp;gt; ["abcd"]
              tf.reduce_join(a, []) ==&amp;gt; ["abcd"]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RefEnter(TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)">
            <summary>
              Creates or finds a child frame, and makes `data` available to the child frame.
            </summary>
            <param name="data">
              The tensor to be made available to the child frame.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RefEnter'.
            </param>
            <param name="is_constant">
              Optional argument
              If true, the output is constant within the child frame.
            </param>
            <param name="parallel_iterations">
              Optional argument
              The number of iterations allowed to run in parallel.
            </param>
            <param name="frame_name">
              The name of the child frame.
            </param>
            <returns>
              The same tensor as `data`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The unique `frame_name` is used by the `Executor` to identify frames. If
              `is_constant` is true, `output` is a constant in the child frame; otherwise
              it may be changed in the child frame. At most `parallel_iterations` iterations
              are run in parallel in the child frame.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RefExit(TensorFlow.TFOutput,System.String)">
            <summary>
              Exits the current frame to its parent frame.
            </summary>
            <param name="data">
              The tensor to be made available to the parent frame.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RefExit'.
            </param>
            <returns>
              The same tensor as `data`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Exit makes its input `data` available to the parent frame.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RefIdentity(TensorFlow.TFOutput,System.String)">
            <summary>
              Return the same ref tensor as the input ref tensor.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RefIdentity'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.RefMerge(TensorFlow.TFOutput[],System.String)">
            <summary>
              Forwards the value of an available tensor from `inputs` to `output`.
            </summary>
            <param name="inputs">
              The input tensors, exactly one of which will become available.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RefMerge'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: Will be set to the available input tensor.
              value_index: The index of the chosen input tensor in `inputs`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              `Merge` waits for at least one of the tensors in `inputs` to become available.
              It is usually combined with `Switch` to implement branching.
              
              `Merge` forwards the first tensor for become available to `output`, and sets
              `value_index` to its index in `inputs`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RefNextIteration(TensorFlow.TFOutput,System.String)">
            <summary>
              Makes its input available to the next iteration.
            </summary>
            <param name="data">
              The tensor to be made available to the next iteration.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RefNextIteration'.
            </param>
            <returns>
              The same tensor as `data`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.RefSelect(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)">
            <summary>
              Forwards the `index`th element of `inputs` to `output`.
            </summary>
            <param name="index">
              A scalar that determines the input that gets selected.
            </param>
            <param name="inputs">
              A list of ref tensors, one of which will be forwarded to `output`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RefSelect'.
            </param>
            <returns>
              The forwarded tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.RefSwitch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Forwards the ref tensor `data` to the output port determined by `pred`.
            </summary>
            <param name="data">
              The ref tensor to be forwarded to the appropriate output.
            </param>
            <param name="pred">
              A scalar that specifies which output port will receive data.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RefSwitch'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_false: If `pred` is false, data will be forwarded to this output.
              output_true: If `pred` is true, data will be forwarded to this output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              If `pred` is true, the `data` input is forwarded to `output_true`. Otherwise,
              the data goes to `output_false`.
              
              See also `Switch` and `Merge`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Relu(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes rectified linear: `max(features, 0)`.
            </summary>
            <param name="features">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Relu'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Relu6(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes rectified linear 6: `min(max(features, 0), 6)`.
            </summary>
            <param name="features">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Relu6'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Relu6Grad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes rectified linear 6 gradients for a Relu6 operation.
            </summary>
            <param name="gradients">
              The backpropagated gradients to the corresponding Relu6 operation.
            </param>
            <param name="features">
              The features passed as input to the corresponding Relu6 operation, or
              its output; using either one produces the same result.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Relu6Grad'.
            </param>
            <returns>
              The gradients:
              `gradients * (features &amp;gt; 0) * (features &amp;lt; 6)`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ReluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes rectified linear gradients for a Relu operation.
            </summary>
            <param name="gradients">
              The backpropagated gradients to the corresponding Relu operation.
            </param>
            <param name="features">
              The features passed as input to the corresponding Relu operation, OR
              the outputs of that operation (both work equivalently).
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReluGrad'.
            </param>
            <returns>
              `gradients * (features &amp;gt; 0)`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.RemoteFusedGraphExecute(TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.String,System.String)">
            <summary>
              Execute a sub graph on a remote processor.
            </summary>
            <param name="inputs">
              Arbitrary number of tensors with arbitrary data types
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RemoteFusedGraphExecute'.
            </param>
            <param name="Toutputs">
            </param>
            <param name="serialized_remote_fused_graph_execute_info">
              Serialized protocol buffer
              of RemoteFusedGraphExecuteInfo which contains graph specifications.
            </param>
            <returns>
              Arbitrary number of tensors with arbitrary data types
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The graph specifications(such as graph itself, input tensors and output names)
              are stored as a serialized protocol buffer of RemoteFusedGraphExecuteInfo
              as serialized_remote_fused_graph_execute_info.
              The specifications will be passed to a dedicated registered
              remote fused graph executor.  The executor will send the graph specifications
              to a remote processor and execute that graph.  The execution results
              will be passed to consumer nodes as outputs of this node.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RepeatDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that emits the outputs of `input_dataset` `count` times.
            </summary>
            <param name="input_dataset">
            </param>
            <param name="count">
              A scalar representing the number of times that `input_dataset` should
              be repeated. A value of `-1` indicates that it should be repeated infinitely.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RepeatDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.RequantizationRange(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Given a quantized tensor described by (input, input_min, input_max), outputs a
            </summary>
            <param name="input">
            </param>
            <param name="input_min">
              The float value that the minimum quantized input value represents.
            </param>
            <param name="input_max">
              The float value that the maximum quantized input value represents.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RequantizationRange'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_min: The computed min output.
              output_max: the computed max output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              range that covers the actual values present in that tensor.  This op is
              typically used to produce the requested_output_min and requested_output_max for
              Requantize.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Requantize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Convert the quantized 'input' tensor into a lower-precision 'output', using the
            </summary>
            <param name="input">
            </param>
            <param name="input_min">
              The float value that the minimum quantized input value represents.
            </param>
            <param name="input_max">
              The float value that the maximum quantized input value represents.
            </param>
            <param name="requested_output_min">
              The float value that the minimum quantized output value represents.
            </param>
            <param name="requested_output_max">
              The float value that the maximum quantized output value represents.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Requantize'.
            </param>
            <param name="out_type">
              The type of the output. Should be a lower bit depth than Tinput.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output: 
              output_min: The requested_output_min value is copied into this output.
              output_max: The requested_output_max value is copied into this output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              output range specified with 'requested_output_min' and 'requested_output_max'.
              
              [input_min, input_max] are scalar floats that specify the range for the float
              interpretation of the 'input' data. For example, if input_min is -1.0f and
              input_max is 1.0f, and we are dealing with quint16 quantized data, then a 0
              value in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Reshape(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Reshapes a tensor.
            </summary>
            <param name="tensor">
            </param>
            <param name="shape">
              Defines the shape of the output tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Reshape'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given `tensor`, this operation returns a tensor that has the same values
              as `tensor` with shape `shape`.
              
              If one component of `shape` is the special value -1, the size of that dimension
              is computed so that the total size remains constant.  In particular, a `shape`
              of `[-1]` flattens into 1-D.  At most one component of `shape` can be -1.
              
              If `shape` is 1-D or higher, then the operation returns a tensor with shape
              `shape` filled with the values of `tensor`. In this case, the number of elements
              implied by `shape` must be the same as the number of elements in `tensor`.
              
              For example:
              
              ```
              # tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]
              # tensor 't' has shape [9]
              reshape(t, [3, 3]) ==&amp;gt; [[1, 2, 3],
                                      [4, 5, 6],
                                      [7, 8, 9]]
              
              # tensor 't' is [[[1, 1], [2, 2]],
              #                [[3, 3], [4, 4]]]
              # tensor 't' has shape [2, 2, 2]
              reshape(t, [2, 4]) ==&amp;gt; [[1, 1, 2, 2],
                                      [3, 3, 4, 4]]
              
              # tensor 't' is [[[1, 1, 1],
              #                 [2, 2, 2]],
              #                [[3, 3, 3],
              #                 [4, 4, 4]],
              #                [[5, 5, 5],
              #                 [6, 6, 6]]]
              # tensor 't' has shape [3, 2, 3]
              # pass '[-1]' to flatten 't'
              reshape(t, [-1]) ==&amp;gt; [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]
              
              # -1 can also be used to infer the shape
              
              # -1 is inferred to be 9:
              reshape(t, [2, -1]) ==&amp;gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],
                                       [4, 4, 4, 5, 5, 5, 6, 6, 6]]
              # -1 is inferred to be 2:
              reshape(t, [-1, 9]) ==&amp;gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],
                                       [4, 4, 4, 5, 5, 5, 6, 6, 6]]
              # -1 is inferred to be 3:
              reshape(t, [ 2, -1, 3]) ==&amp;gt; [[[1, 1, 1],
                                            [2, 2, 2],
                                            [3, 3, 3]],
                                           [[4, 4, 4],
                                            [5, 5, 5],
                                            [6, 6, 6]]]
              
              # tensor 't' is [7]
              # shape `[]` reshapes to a scalar
              reshape(t, []) ==&amp;gt; 7
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResizeArea(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Resize `images` to `size` using area interpolation.
            </summary>
            <param name="images">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="size">
              = A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The
              new size for the images.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeArea'.
            </param>
            <param name="align_corners">
              Optional argument
              If true, rescale input by (new_height - 1) / (height - 1), which
              exactly aligns the 4 corners of images and resized images. If false, rescale
              by new_height / height. Treat similarly the width dimension.
            </param>
            <returns>
              4-D with shape
              `[batch, new_height, new_width, channels]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Input images can be of different types but output images are always float.
              
              Each output pixel is computed by first transforming the pixel's footprint into
              the input tensor and then averaging the pixels that intersect the footprint. An
              input pixel's contribution to the average is weighted by the fraction of its
              area that intersects the footprint.  This is the same as OpenCV's INTER_AREA.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResizeBicubic(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Resize `images` to `size` using bicubic interpolation.
            </summary>
            <param name="images">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="size">
              = A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The
              new size for the images.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBicubic'.
            </param>
            <param name="align_corners">
              Optional argument
              If true, rescale input by (new_height - 1) / (height - 1), which
              exactly aligns the 4 corners of images and resized images. If false, rescale
              by new_height / height. Treat similarly the width dimension.
            </param>
            <returns>
              4-D with shape
              `[batch, new_height, new_width, channels]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Input images can be of different types but output images are always float.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResizeBicubicGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the gradient of bicubic interpolation.
            </summary>
            <param name="grads">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="original_image">
              4-D with shape `[batch, orig_height, orig_width, channels]`,
              The image tensor that was resized.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBicubicGrad'.
            </param>
            <param name="align_corners">
              Optional argument
              If true, rescale grads by (orig_height - 1) / (height - 1), which
              exactly aligns the 4 corners of grads and original_image. If false, rescale by
              orig_height / height. Treat similarly the width dimension.
            </param>
            <returns>
              4-D with shape `[batch, orig_height, orig_width, channels]`.
              Gradients with respect to the input image. Input image must have been
              float or double.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ResizeBilinear(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Resize `images` to `size` using bilinear interpolation.
            </summary>
            <param name="images">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="size">
              = A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The
              new size for the images.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBilinear'.
            </param>
            <param name="align_corners">
              Optional argument
              If true, rescale input by (new_height - 1) / (height - 1), which
              exactly aligns the 4 corners of images and resized images. If false, rescale
              by new_height / height. Treat similarly the width dimension.
            </param>
            <returns>
              4-D with shape
              `[batch, new_height, new_width, channels]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Input images can be of different types but output images are always float.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResizeBilinearGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the gradient of bilinear interpolation.
            </summary>
            <param name="grads">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="original_image">
              4-D with shape `[batch, orig_height, orig_width, channels]`,
              The image tensor that was resized.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBilinearGrad'.
            </param>
            <param name="align_corners">
              Optional argument
              If true, rescale grads by (orig_height - 1) / (height - 1), which
              exactly aligns the 4 corners of grads and original_image. If false, rescale by
              orig_height / height. Treat similarly the width dimension.
            </param>
            <returns>
              4-D with shape `[batch, orig_height, orig_width, channels]`.
              Gradients with respect to the input image. Input image must have been
              float or double.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ResizeNearestNeighbor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Resize `images` to `size` using nearest neighbor interpolation.
            </summary>
            <param name="images">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="size">
              = A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The
              new size for the images.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeNearestNeighbor'.
            </param>
            <param name="align_corners">
              Optional argument
              If true, rescale input by (new_height - 1) / (height - 1), which
              exactly aligns the 4 corners of images and resized images. If false, rescale
              by new_height / height. Treat similarly the width dimension.
            </param>
            <returns>
              4-D with shape
              `[batch, new_height, new_width, channels]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ResizeNearestNeighborGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the gradient of nearest neighbor interpolation.
            </summary>
            <param name="grads">
              4-D with shape `[batch, height, width, channels]`.
            </param>
            <param name="size">
              = A 1-D int32 Tensor of 2 elements: `orig_height, orig_width`. The
              original input size.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeNearestNeighborGrad'.
            </param>
            <param name="align_corners">
              Optional argument
              If true, rescale grads by (orig_height - 1) / (height - 1), which
              exactly aligns the 4 corners of grads and original_image. If false, rescale by
              orig_height / height. Treat similarly the width dimension.
            </param>
            <returns>
              4-D with shape `[batch, orig_height, orig_width, channels]`. Gradients
              with respect to the input image.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the adadelta scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="accum_update">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="rho">
              Decay factor. Must be a scalar.
            </param>
            <param name="epsilon">
              Constant factor. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdadelta'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, updating of the var, accum and update_accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              accum = rho() * accum + (1 - rho()) * grad.square();
              update = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;
              update_accum = rho() * update_accum + (1 - rho()) * update.square();
              var -= update;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the adagrad scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdagrad'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              accum += grad * grad
              var -= lr * grad * (1 / sqrt(accum))
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the proximal adagrad scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="gradient_accumulator">
              Should be from a Variable().
            </param>
            <param name="gradient_squared_accumulator">
              Should be from a Variable().
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="global_step">
              Training step number. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdagradDA'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyAdam(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the Adam algorithm.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="m">
              Should be from a Variable().
            </param>
            <param name="v">
              Should be from a Variable().
            </param>
            <param name="beta1_power">
              Must be a scalar.
            </param>
            <param name="beta2_power">
              Must be a scalar.
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="beta1">
              Momentum factor. Must be a scalar.
            </param>
            <param name="beta2">
              Momentum factor. Must be a scalar.
            </param>
            <param name="epsilon">
              Ridge term. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdam'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var, m, and v tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <param name="use_nesterov">
              Optional argument
              If `True`, uses the nesterov update.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              lr_t &amp;lt;- learning_rate * sqrt(1 - beta2^t) / (1 - beta1^t)
              m_t &amp;lt;- beta1 * m_{t-1} + (1 - beta1) * g_t
              v_t &amp;lt;- beta2 * v_{t-1} + (1 - beta2) * g_t * g_t
              variable &amp;lt;- variable - lr_t * m_t / (sqrt(v_t) + epsilon)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyAddSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the AddSign update.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="m">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="alpha">
              Must be a scalar.
            </param>
            <param name="sign_decay">
              Must be a scalar.
            </param>
            <param name="beta">
              Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAddSign'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and m tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              m_t &amp;lt;- beta1 * m_{t-1} + (1 - beta1) * g
              update &amp;lt;- (alpha + sign_decay * sign(g) *sign(m)) * g
              variable &amp;lt;- variable - lr_t * update
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the centered RMSProp algorithm.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="mg">
              Should be from a Variable().
            </param>
            <param name="ms">
              Should be from a Variable().
            </param>
            <param name="mom">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="rho">
              Decay rate. Must be a scalar.
            </param>
            <param name="momentum">
            </param>
            <param name="epsilon">
              Ridge term. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyCenteredRMSProp'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var, mg, ms, and mom tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The centered RMSProp algorithm uses an estimate of the centered second moment
              (i.e., the variance) for normalization, as opposed to regular RMSProp, which
              uses the (uncentered) second moment. This often helps with training, but is
              slightly more expensive in terms of computation and memory.
              
              Note that in dense implementation of this algorithm, mg, ms, and mom will
              update even if the grad is zero, but in this sparse implementation, mg, ms,
              and mom will not update in iterations during which the grad is zero.
              
              mean_square = decay * mean_square + (1-decay) * gradient ** 2
              mean_grad = decay * mean_grad + (1-decay) * gradient
              
              Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)
              
              mg &amp;lt;- rho * mg_{t-1} + (1-rho) * grad
              ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
              mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)
              var &amp;lt;- var - mom
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="linear">
              Should be from a Variable().
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regulariation. Must be a scalar.
            </param>
            <param name="l2">
              L2 regulariation. Must be a scalar.
            </param>
            <param name="lr_power">
              Scaling factor. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyFtrl'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              accum_new = accum + grad * grad
              linear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
              accum = accum_new
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="linear">
              Should be from a Variable().
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regulariation. Must be a scalar.
            </param>
            <param name="l2">
              L2 shrinkage regulariation. Must be a scalar.
            </param>
            <param name="l2_shrinkage">
            </param>
            <param name="lr_power">
              Scaling factor. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyFtrlV2'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              grad_with_shrinkage = grad + 2 * l2_shrinkage * var
              accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
              linear += grad_with_shrinkage +
                  (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
              accum = accum_new
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' by subtracting 'alpha' * 'delta' from it.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="alpha">
              Scaling factor. Must be a scalar.
            </param>
            <param name="delta">
              The change.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyGradientDescent'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the momentum scheme. Set use_nesterov = True if you
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="momentum">
              Momentum. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyMomentum'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <param name="use_nesterov">
              Optional argument
              If `True`, the tensor passed to compute grad will be
              var - lr * momentum * accum, so in the end, the var you get is actually
              var - lr * momentum * accum.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              want to use Nesterov momentum.
              
              accum = accum * momentum + grad
              var -= lr * accum
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyPowerSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the AddSign update.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="m">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="logbase">
              Must be a scalar.
            </param>
            <param name="sign_decay">
              Must be a scalar.
            </param>
            <param name="beta">
              Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyPowerSign'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and m tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              m_t &amp;lt;- beta1 * m_{t-1} + (1 - beta1) * g
              update &amp;lt;- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g
              variable &amp;lt;- variable - lr_t * update
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyProximalAdagrad'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              accum += grad * grad
              prox_v = var - lr * grad * (1 / sqrt(accum))
              var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' as FOBOS algorithm with fixed learning rate.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="alpha">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="delta">
              The change.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyProximalGradientDescent'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              prox_v = var - alpha * delta
              var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the RMSProp algorithm.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="ms">
              Should be from a Variable().
            </param>
            <param name="mom">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="rho">
              Decay rate. Must be a scalar.
            </param>
            <param name="momentum">
            </param>
            <param name="epsilon">
              Ridge term. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyRMSProp'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var, ms, and mom tensors is protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              Note that in dense implementation of this algorithm, ms and mom will
              update even if the grad is zero, but in this sparse implementation, ms
              and mom will not update in iterations during which the grad is zero.
              
              mean_square = decay * mean_square + (1-decay) * gradient ** 2
              Delta = learning_rate * gradient / sqrt(mean_square + epsilon)
              
              ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
              mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
              var &amp;lt;- var - mom
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceCountUpTo(TensorFlow.TFOutput,System.Int64,TensorFlow.TFDataType,System.String)">
            <summary>
              Increments variable pointed to by 'resource' until it reaches 'limit'.
            </summary>
            <param name="resource">
              Should be from a scalar `Variable` node.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceCountUpTo'.
            </param>
            <param name="limit">
              If incrementing ref would bring it above limit, instead generates an
              'OutOfRange' error.
            </param>
            <param name="T">
            </param>
            <returns>
              A copy of the input before increment. If nothing else modifies the
              input, the values produced will all be distinct.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceGather(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)">
            <summary>
              Gather slices from the variable pointed to by `resource` according to `indices`.
            </summary>
            <param name="resource">
            </param>
            <param name="indices">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceGather'.
            </param>
            <param name="validate_indices">
              Optional argument
            </param>
            <param name="dtype">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `indices` must be an integer tensor of any dimension (usually 0-D or 1-D).
              Produces an output tensor with shape `indices.shape + params.shape[1:]` where:
              
              ```python
                  # Scalar indices
                  output[:, ..., :] = params[indices, :, ... :]
              
                  # Vector indices
                  output[i, :, ..., :] = params[indices[i], :, ... :]
              
                  # Higher rank indices
                  output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceScatterAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Adds sparse updates to the variable referenced by `resource`.
            </summary>
            <param name="resource">
              Should be from a `Variable` node.
            </param>
            <param name="indices">
              A tensor of indices into the first dimension of `ref`.
            </param>
            <param name="updates">
              A tensor of updated values to add to `ref`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterAdd'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              This operation computes
              
                  # Scalar indices
                  ref[indices, ...] += updates[...]
              
                  # Vector indices (for each i)
                  ref[indices[i], ...] += updates[i, ...]
              
                  # High rank indices (for each i, ..., j)
                  ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]
              
              Duplicate entries are handled correctly: if multiple `indices` reference
              the same location, their contributions add.
              
              Requires `updates.shape = indices.shape + ref.shape[1:]`.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src='https://www.tensorflow.org/images/ScatterAdd.png' alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceScatterNdUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Applies sparse `updates` to individual values or slices within a given
            </summary>
            <param name="reference">
              A resource handle. Must be from a VarHandleOp.
            </param>
            <param name="indices">
              A Tensor. Must be one of the following types: int32, int64.
              A tensor of indices into ref.
            </param>
            <param name="updates">
              A Tensor. Must have the same type as ref. A tensor of updated
              values to add to ref.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterNdUpdate'.
            </param>
            <param name="use_locking">
              Optional argument
              An optional bool. Defaults to True. If True, the assignment will
              be protected by a lock; otherwise the behavior is undefined,
              but may exhibit less contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              variable according to `indices`.
              
              `ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.
              
              `indices` must be integer tensor, containing indices into `ref`.
              It must be shape `[d_0, ..., d_{Q-2}, K]` where `0 &amp;lt; K &amp;lt;= P`.
              
              The innermost dimension of `indices` (with length `K`) corresponds to
              indices into elements (if `K = P`) or slices (if `K &amp;lt; P`) along the `K`th
              dimension of `ref`.
              
              `updates` is `Tensor` of rank `Q-1+P-K` with shape:
              
              ```
              [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].
              ```
              
              For example, say we want to update 4 scattered elements to a rank-1 tensor to
              8 elements. In Python, that update would look like this:
              
              ```python
                  ref = tfe.Variable([1, 2, 3, 4, 5, 6, 7, 8])
                  indices = tf.constant([[4], [3], [1] ,[7]])
                  updates = tf.constant([9, 10, 11, 12])
                  update = tf.scatter_nd_update(ref, indices, updates)
                  with tf.Session() as sess:
                    print sess.run(update)
              ```
              
              The resulting update to ref would look like this:
              
                  [1, 11, 3, 10, 9, 6, 7, 12]
              
              See @{tf.scatter_nd} for more details about how to make updates to
              slices.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceScatterUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Assigns sparse updates to the variable referenced by `resource`.
            </summary>
            <param name="resource">
              Should be from a `Variable` node.
            </param>
            <param name="indices">
              A tensor of indices into the first dimension of `ref`.
            </param>
            <param name="updates">
              A tensor of updated values to add to `ref`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterUpdate'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              This operation computes
              
                  # Scalar indices
                  ref[indices, ...] = updates[...]
              
                  # Vector indices (for each i)
                  ref[indices[i], ...] = updates[i, ...]
              
                  # High rank indices (for each i, ..., j)
                  ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceSparseApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              var: Should be from a Variable().
            </summary>
            <param name="var">
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="accum_update">
              : Should be from a Variable().
            </param>
            <param name="lr">
              Learning rate. Must be a scalar.
            </param>
            <param name="rho">
              Decay factor. Must be a scalar.
            </param>
            <param name="epsilon">
              Constant factor. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdadelta'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceSparseApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update relevant entries in '*var' and '*accum' according to the adagrad scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="lr">
              Learning rate. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdagrad'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              That is for rows we have grad for, we update var and accum as follows:
              accum += grad * grad
              var -= lr * grad * (1 / sqrt(accum))
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceSparseApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update entries in '*var' and '*accum' according to the proximal adagrad scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="gradient_accumulator">
              Should be from a Variable().
            </param>
            <param name="gradient_squared_accumulator">
              Should be from a Variable().
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="lr">
              Learning rate. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="global_step">
              Training step number. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdagradDA'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceSparseApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the centered RMSProp algorithm.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="mg">
              Should be from a Variable().
            </param>
            <param name="ms">
              Should be from a Variable().
            </param>
            <param name="mom">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="rho">
              Decay rate. Must be a scalar.
            </param>
            <param name="momentum">
            </param>
            <param name="epsilon">
              Ridge term. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var, ms and mom.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyCenteredRMSProp'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var, mg, ms, and mom tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The centered RMSProp algorithm uses an estimate of the centered second moment
              (i.e., the variance) for normalization, as opposed to regular RMSProp, which
              uses the (uncentered) second moment. This often helps with training, but is
              slightly more expensive in terms of computation and memory.
              
              Note that in dense implementation of this algorithm, mg, ms, and mom will
              update even if the grad is zero, but in this sparse implementation, mg, ms,
              and mom will not update in iterations during which the grad is zero.
              
              mean_square = decay * mean_square + (1-decay) * gradient ** 2
              mean_grad = decay * mean_grad + (1-decay) * gradient
              Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)
              
              ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
              mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
              var &amp;lt;- var - mom
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceSparseApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update relevant entries in '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="linear">
              Should be from a Variable().
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="lr_power">
              Scaling factor. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyFtrl'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              That is for rows we have grad for, we update var, accum and linear as follows:
              accum_new = accum + grad * grad
              linear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
              accum = accum_new
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceSparseApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update relevant entries in '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="linear">
              Should be from a Variable().
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 shrinkage regulariation. Must be a scalar.
            </param>
            <param name="l2_shrinkage">
            </param>
            <param name="lr_power">
              Scaling factor. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyFtrlV2'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              That is for rows we have grad for, we update var, accum and linear as follows:
              grad_with_shrinkage = grad + 2 * l2_shrinkage * var
              accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
              linear += grad_with_shrinkage +
                  (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
              accum = accum_new
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceSparseApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Update relevant entries in '*var' and '*accum' according to the momentum scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="lr">
              Learning rate. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="momentum">
              Momentum. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyMomentum'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <param name="use_nesterov">
              Optional argument
              If `True`, the tensor passed to compute grad will be
              var - lr * momentum * accum, so in the end, the var you get is actually
              var - lr * momentum * accum.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              Set use_nesterov = True if you want to use Nesterov momentum.
              
              That is for rows we have grad for, we update var and accum as follows:
              
              accum = accum * momentum + grad
              var -= lr * accum
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceSparseApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="lr">
              Learning rate. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyProximalAdagrad'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              That is for rows we have grad for, we update var and accum as follows:
              accum += grad * grad
              prox_v = var
              prox_v -= lr * grad * (1 / sqrt(accum))
              var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceSparseApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Sparse update '*var' as FOBOS algorithm with fixed learning rate.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="alpha">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyProximalGradientDescent'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              That is for rows we have grad for, we update var as follows:
              prox_v = var - alpha * grad
              var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceSparseApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the RMSProp algorithm.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="ms">
              Should be from a Variable().
            </param>
            <param name="mom">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="rho">
              Decay rate. Must be a scalar.
            </param>
            <param name="momentum">
            </param>
            <param name="epsilon">
              Ridge term. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var, ms and mom.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyRMSProp'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var, ms, and mom tensors is protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              Note that in dense implementation of this algorithm, ms and mom will
              update even if the grad is zero, but in this sparse implementation, ms
              and mom will not update in iterations during which the grad is zero.
              
              mean_square = decay * mean_square + (1-decay) * gradient ** 2
              Delta = learning_rate * gradient / sqrt(mean_square + epsilon)
              
              ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
              mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
              var &amp;lt;- var - mom
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ResourceStridedSliceAssign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Assign `value` to the sliced l-value reference of `ref`.
            </summary>
            <param name="reference">
            </param>
            <param name="begin">
            </param>
            <param name="end">
            </param>
            <param name="strides">
            </param>
            <param name="value">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceStridedSliceAssign'.
            </param>
            <param name="begin_mask">
              Optional argument
            </param>
            <param name="end_mask">
              Optional argument
            </param>
            <param name="ellipsis_mask">
              Optional argument
            </param>
            <param name="new_axis_mask">
              Optional argument
            </param>
            <param name="shrink_axis_mask">
              Optional argument
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The values of `value` are assigned to the positions in the variable
              `ref` that are selected by the slice parameters. The slice parameters
              `begin, `end`, `strides`, etc. work exactly as in `StridedSlice`.
              
              NOTE this op currently does not support broadcasting and so `value`'s
              shape must be exactly the shape produced by the slice of `ref`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Restore(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)">
            <summary>
              Restores a tensor from checkpoint files.
            </summary>
            <param name="file_pattern">
              Must have a single element. The pattern of the files from
              which we read the tensor.
            </param>
            <param name="tensor_name">
              Must have a single element. The name of the tensor to be
              restored.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Restore'.
            </param>
            <param name="preferred_shard">
              Optional argument
              Index of file to open first if multiple files match
              `file_pattern`.
            </param>
            <param name="dt">
              The type of the tensor to be restored.
            </param>
            <returns>
              The restored tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Reads a tensor stored in one or several files. If there are several files (for
              instance because a tensor was saved as slices), `file_pattern` may contain
              wildcard symbols (`*` and `?`) in the filename portion only, not in the
              directory portion.
              
              If a `file_pattern` matches several files, `preferred_shard` can be used to hint
              in which file the requested tensor is likely to be found. This op will first
              open the file at index `preferred_shard` in the list of matching files and try
              to restore tensors from that file.  Only if some tensors or tensor slices are
              not found in that first file, then the Op opens all the files. Setting
              `preferred_shard` to match the value passed as the `shard` input
              of a matching `Save` Op may speed up Restore.  This attribute only affects
              performance, not correctness.  The default value -1 means files are processed in
              order.
              
              See also `RestoreSlice`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RestoreSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)">
            <summary>
              Restores a tensor from checkpoint files.
            </summary>
            <param name="file_pattern">
              Must have a single element. The pattern of the files from
              which we read the tensor.
            </param>
            <param name="tensor_name">
              Must have a single element. The name of the tensor to be
              restored.
            </param>
            <param name="shape_and_slice">
              Scalar. The shapes and slice specifications to use when
              restoring a tensors.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RestoreSlice'.
            </param>
            <param name="preferred_shard">
              Optional argument
              Index of file to open first if multiple files match
              `file_pattern`. See the documentation for `Restore`.
            </param>
            <param name="dt">
              The type of the tensor to be restored.
            </param>
            <returns>
              The restored tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This is like `Restore` except that restored tensor can be listed as filling
              only a slice of a larger tensor.  `shape_and_slice` specifies the shape of the
              larger tensor and the slice that the restored tensor covers.
              
              The `shape_and_slice` input has the same format as the
              elements of the `shapes_and_slices` input of the `SaveSlices` op.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RestoreV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.String)">
            <summary>
              Restores tensors from a V2 checkpoint.
            </summary>
            <param name="prefix">
              Must have a single element.  The prefix of a V2 checkpoint.
            </param>
            <param name="tensor_names">
              shape {N}.  The names of the tensors to be restored.
            </param>
            <param name="shape_and_slices">
              shape {N}.  The slice specs of the tensors to be restored.
              Empty strings indicate that they are non-partitioned tensors.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RestoreV2'.
            </param>
            <param name="dtypes">
              shape {N}.  The list of expected dtype for the tensors.  Must match
              those stored in the checkpoint.
            </param>
            <returns>
              shape {N}.  The restored tensors, whose shapes are read from the
              checkpoint directly.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              For backward compatibility with the V1 format, this Op currently allows
              restoring from a V1 checkpoint as well:
                - This Op first attempts to find the V2 index file pointed to by "prefix", and
                  if found proceed to read it as a V2 checkpoint;
                - Otherwise the V1 read path is invoked.
              Relying on this behavior is not recommended, as the ability to fall back to read
              V1 might be deprecated and eventually removed.
              
              By default, restores the named tensors in full.  If the caller wishes to restore
              specific slices of stored tensors, "shape_and_slices" should be non-empty
              strings and correspondingly well-formed.
              
              Callers must ensure all the named tensors are indeed stored in the checkpoint.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Reverse(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Reverses specific dimensions of a tensor.
            </summary>
            <param name="tensor">
              Up to 8-D.
            </param>
            <param name="dims">
              1-D. The dimensions to reverse.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Reverse'.
            </param>
            <returns>
              The same shape as `tensor`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a `tensor`, and a `bool` tensor `dims` representing the dimensions
              of `tensor`, this operation reverses each dimension i of `tensor` where
              `dims[i]` is `True`.
              
              `tensor` can have up to 8 dimensions. The number of dimensions
              of `tensor` must equal the number of elements in `dims`. In other words:
              
              `rank(tensor) = size(dims)`
              
              For example:
              
              ```
              # tensor 't' is [[[[ 0,  1,  2,  3],
              #                  [ 4,  5,  6,  7],
              #                  [ 8,  9, 10, 11]],
              #                 [[12, 13, 14, 15],
              #                  [16, 17, 18, 19],
              #                  [20, 21, 22, 23]]]]
              # tensor 't' shape is [1, 2, 3, 4]
              
              # 'dims' is [False, False, False, True]
              reverse(t, dims) ==&amp;gt; [[[[ 3,  2,  1,  0],
                                      [ 7,  6,  5,  4],
                                      [ 11, 10, 9, 8]],
                                     [[15, 14, 13, 12],
                                      [19, 18, 17, 16],
                                      [23, 22, 21, 20]]]]
              
              # 'dims' is [False, True, False, False]
              reverse(t, dims) ==&amp;gt; [[[[12, 13, 14, 15],
                                      [16, 17, 18, 19],
                                      [20, 21, 22, 23]
                                     [[ 0,  1,  2,  3],
                                      [ 4,  5,  6,  7],
                                      [ 8,  9, 10, 11]]]]
              
              # 'dims' is [False, False, True, False]
              reverse(t, dims) ==&amp;gt; [[[[8, 9, 10, 11],
                                      [4, 5, 6, 7],
                                      [0, 1, 2, 3]]
                                     [[20, 21, 22, 23],
                                      [16, 17, 18, 19],
                                      [12, 13, 14, 15]]]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReverseSequence(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.String)">
            <summary>
              Reverses variable length slices.
            </summary>
            <param name="input">
              The input to reverse.
            </param>
            <param name="seq_lengths">
              1-D with length `input.dims(batch_dim)` and
              `max(seq_lengths) &amp;lt;= input.dims(seq_dim)`
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReverseSequence'.
            </param>
            <param name="batch_dim">
              Optional argument
              The dimension along which reversal is performed.
            </param>
            <param name="seq_dim">
              The dimension which is partially reversed.
            </param>
            <returns>
              The partially reversed input. It has the same shape as `input`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op first slices `input` along the dimension `batch_dim`, and for each
              slice `i`, reverses the first `seq_lengths[i]` elements along
              the dimension `seq_dim`.
              
              The elements of `seq_lengths` must obey `seq_lengths[i] &amp;lt;= input.dims[seq_dim]`,
              and `seq_lengths` must be a vector of length `input.dims[batch_dim]`.
              
              The output slice `i` along dimension `batch_dim` is then given by input
              slice `i`, with the first `seq_lengths[i]` slices along dimension
              `seq_dim` reversed.
              
              For example:
              
              ```
              # Given this:
              batch_dim = 0
              seq_dim = 1
              input.dims = (4, 8, ...)
              seq_lengths = [7, 2, 3, 5]
              
              # then slices of input are reversed on seq_dim, but only up to seq_lengths:
              output[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]
              output[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]
              output[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]
              output[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]
              
              # while entries past seq_lens are copied through:
              output[0, 7:, :, ...] = input[0, 7:, :, ...]
              output[1, 2:, :, ...] = input[1, 2:, :, ...]
              output[2, 3:, :, ...] = input[2, 3:, :, ...]
              output[3, 2:, :, ...] = input[3, 2:, :, ...]
              ```
              
              In contrast, if:
              
              ```
              # Given this:
              batch_dim = 2
              seq_dim = 0
              input.dims = (8, ?, 4, ...)
              seq_lengths = [7, 2, 3, 5]
              
              # then slices of input are reversed on seq_dim, but only up to seq_lengths:
              output[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...]
              output[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...]
              output[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...]
              output[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]
              
              # while entries past seq_lens are copied through:
              output[7:, :, 0, :, ...] = input[7:, :, 0, :, ...]
              output[2:, :, 1, :, ...] = input[2:, :, 1, :, ...]
              output[3:, :, 2, :, ...] = input[3:, :, 2, :, ...]
              output[2:, :, 3, :, ...] = input[2:, :, 3, :, ...]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReverseV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Reverses specific dimensions of a tensor.
            </summary>
            <param name="tensor">
              Up to 8-D.
            </param>
            <param name="axis">
              1-D. The indices of the dimensions to reverse. Must be in the range
              `[-rank(tensor), rank(tensor))`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ReverseV2'.
            </param>
            <returns>
              The same shape as `tensor`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              NOTE `tf.reverse` has now changed behavior in preparation for 1.0.
              `tf.reverse_v2` is currently an alias that will be deprecated before TF 1.0.
              
              Given a `tensor`, and a `int32` tensor `axis` representing the set of
              dimensions of `tensor` to reverse. This operation reverses each dimension
              `i` for which there exists `j` s.t. `axis[j] == i`.
              
              `tensor` can have up to 8 dimensions. The number of dimensions specified
              in `axis` may be 0 or more entries. If an index is specified more than
              once, a InvalidArgument error is raised.
              
              For example:
              
              ```
              # tensor 't' is [[[[ 0,  1,  2,  3],
              #                  [ 4,  5,  6,  7],
              #                  [ 8,  9, 10, 11]],
              #                 [[12, 13, 14, 15],
              #                  [16, 17, 18, 19],
              #                  [20, 21, 22, 23]]]]
              # tensor 't' shape is [1, 2, 3, 4]
              
              # 'dims' is [3] or 'dims' is [-1]
              reverse(t, dims) ==&amp;gt; [[[[ 3,  2,  1,  0],
                                      [ 7,  6,  5,  4],
                                      [ 11, 10, 9, 8]],
                                     [[15, 14, 13, 12],
                                      [19, 18, 17, 16],
                                      [23, 22, 21, 20]]]]
              
              # 'dims' is '[1]' (or 'dims' is '[-3]')
              reverse(t, dims) ==&amp;gt; [[[[12, 13, 14, 15],
                                      [16, 17, 18, 19],
                                      [20, 21, 22, 23]
                                     [[ 0,  1,  2,  3],
                                      [ 4,  5,  6,  7],
                                      [ 8,  9, 10, 11]]]]
              
              # 'dims' is '[2]' (or 'dims' is '[-2]')
              reverse(t, dims) ==&amp;gt; [[[[8, 9, 10, 11],
                                      [4, 5, 6, 7],
                                      [0, 1, 2, 3]]
                                     [[20, 21, 22, 23],
                                      [16, 17, 18, 19],
                                      [12, 13, 14, 15]]]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RFFT(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Real-valued fast Fourier transform.
            </summary>
            <param name="input">
              A float32 tensor.
            </param>
            <param name="fft_length">
              An int32 tensor of shape [1]. The FFT length.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RFFT'.
            </param>
            <returns>
              A complex64 tensor of the same rank as `input`. The inner-most
                dimension of `input` is replaced with the `fft_length / 2 + 1` unique
                frequency components of its 1D Fourier transform.
              
              @compatibility(numpy)
              Equivalent to np.fft.rfft
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes the 1-dimensional discrete Fourier transform of a real-valued signal
              over the inner-most dimension of `input`.
              
              Since the DFT of a real signal is Hermitian-symmetric, `RFFT` only returns the
              `fft_length / 2 + 1` unique components of the FFT: the zero-frequency term,
              followed by the `fft_length / 2` positive-frequency terms.
              
              Along the axis `RFFT` is computed on, if `fft_length` is smaller than the
              corresponding dimension of `input`, the dimension is cropped. If it is larger,
              the dimension is padded with zeros.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RFFT2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              2D real-valued fast Fourier transform.
            </summary>
            <param name="input">
              A float32 tensor.
            </param>
            <param name="fft_length">
              An int32 tensor of shape [2]. The FFT length for each dimension.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RFFT2D'.
            </param>
            <returns>
              A complex64 tensor of the same rank as `input`. The inner-most 2
                dimensions of `input` are replaced with their 2D Fourier transform. The
                inner-most dimension contains `fft_length / 2 + 1` unique frequency
                components.
              
              @compatibility(numpy)
              Equivalent to np.fft.rfft2
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes the 2-dimensional discrete Fourier transform of a real-valued signal
              over the inner-most 2 dimensions of `input`.
              
              Since the DFT of a real signal is Hermitian-symmetric, `RFFT2D` only returns the
              `fft_length / 2 + 1` unique components of the FFT for the inner-most dimension
              of `output`: the zero-frequency term, followed by the `fft_length / 2`
              positive-frequency terms.
              
              Along each axis `RFFT2D` is computed on, if `fft_length` is smaller than the
              corresponding dimension of `input`, the dimension is cropped. If it is larger,
              the dimension is padded with zeros.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RFFT3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              3D real-valued fast Fourier transform.
            </summary>
            <param name="input">
              A float32 tensor.
            </param>
            <param name="fft_length">
              An int32 tensor of shape [3]. The FFT length for each dimension.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RFFT3D'.
            </param>
            <returns>
              A complex64 tensor of the same rank as `input`. The inner-most 3
                dimensions of `input` are replaced with the their 3D Fourier transform. The
                inner-most dimension contains `fft_length / 2 + 1` unique frequency
                components.
              
              @compatibility(numpy)
              Equivalent to np.fft.rfftn with 3 dimensions.
              @end_compatibility
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Computes the 3-dimensional discrete Fourier transform of a real-valued signal
              over the inner-most 3 dimensions of `input`.
              
              Since the DFT of a real signal is Hermitian-symmetric, `RFFT3D` only returns the
              `fft_length / 2 + 1` unique components of the FFT for the inner-most dimension
              of `output`: the zero-frequency term, followed by the `fft_length / 2`
              positive-frequency terms.
              
              Along each axis `RFFT3D` is computed on, if `fft_length` is smaller than the
              corresponding dimension of `input`, the dimension is cropped. If it is larger,
              the dimension is padded with zeros.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RGBToHSV(TensorFlow.TFOutput,System.String)">
            <summary>
              Converts one or more images from RGB to HSV.
            </summary>
            <param name="images">
              1-D or higher rank. RGB data to convert. Last dimension must be size 3.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RGBToHSV'.
            </param>
            <returns>
              `images` converted to HSV.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Outputs a tensor of the same shape as the `images` tensor, containing the HSV
              value of the pixels. The output is only well defined if the value in `images`
              are in `[0,1]`.
              
              `output[..., 0]` contains hue, `output[..., 1]` contains saturation, and
              `output[..., 2]` contains value. All HSV values are in `[0,1]`. A hue of 0
              corresponds to pure red, hue 1/3 is pure green, and 2/3 is pure blue.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RightShift(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Elementwise computes the bitwise right-shift of `x` and `y`.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RightShift'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Performs a logical shift for unsigned integer types, and an arithmetic shift
              for signed integer types.
              
              If `y` is negative, or greater than or equal to than the width of `x` in bits
              the result is implementation defined.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Rint(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns element-wise integer closest to x.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Rint'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              If the result is midway between two representable values,
              the even representable is chosen.
              For example:
              
              ```
              rint(-1.5) ==&amp;gt; -2.0
              rint(0.5000001) ==&amp;gt; 1.0
              rint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) ==&amp;gt; [-2., -2., -0., 0., 2., 2., 2.]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Round(TensorFlow.TFOutput,System.String)">
            <summary>
              Rounds the values of a tensor to the nearest integer, element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Round'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Rounds half to even.  Also known as bankers rounding. If you want to round
              according to the current system rounding mode use std::cint.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Rsqrt(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes reciprocal of square root of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Rsqrt'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              I.e., \\(y = 1 / \sqrt{x}\\).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.RsqrtGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the gradient for the rsqrt of `x` wrt its input.
            </summary>
            <param name="y">
            </param>
            <param name="dy">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'RsqrtGrad'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Specifically, `grad = dy * -0.5 * y^3`, where `y = rsqrt(x)`, and `dy`
              is the corresponding input gradient.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SampleDistortedBoundingBox(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Single},System.Single[],System.Single[],System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">
            <summary>
              Generate a single randomly distorted bounding box for an image.
            </summary>
            <param name="image_size">
              1-D, containing `[height, width, channels]`.
            </param>
            <param name="bounding_boxes">
              3-D with shape `[batch, N, 4]` describing the N bounding boxes
              associated with the image.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SampleDistortedBoundingBox'.
            </param>
            <param name="seed">
              Optional argument
              If either `seed` or `seed2` are set to non-zero, the random number
              generator is seeded by the given `seed`.  Otherwise, it is seeded by a random
              seed.
            </param>
            <param name="seed2">
              Optional argument
              A second seed to avoid seed collision.
            </param>
            <param name="min_object_covered">
              Optional argument
              The cropped area of the image must contain at least this
              fraction of any bounding box supplied. The value of this parameter should be
              non-negative. In the case of 0, the cropped area does not need to overlap
              any of the bounding boxes supplied.
            </param>
            <param name="aspect_ratio_range">
              Optional argument
              The cropped area of the image must have an aspect ratio =
              width / height within this range.
            </param>
            <param name="area_range">
              Optional argument
              The cropped area of the image must contain a fraction of the
              supplied image within in this range.
            </param>
            <param name="max_attempts">
              Optional argument
              Number of attempts at generating a cropped region of the image
              of the specified constraints. After `max_attempts` failures, return the entire
              image.
            </param>
            <param name="use_image_if_no_bounding_boxes">
              Optional argument
              Controls behavior if no bounding boxes supplied.
              If true, assume an implicit bounding box covering the whole input. If false,
              raise an error.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              begin: 1-D, containing `[offset_height, offset_width, 0]`. Provide as input to
              `tf.slice`.
              size: 1-D, containing `[target_height, target_width, -1]`. Provide as input to
              `tf.slice`.
              bboxes: 3-D with shape `[1, 1, 4]` containing the distorted bounding box.
              Provide as input to `tf.image.draw_bounding_boxes`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Bounding box annotations are often supplied in addition to ground-truth labels
              in image recognition or object localization tasks. A common technique for
              training such a system is to randomly distort an image while preserving
              its content, i.e. *data augmentation*. This Op outputs a randomly distorted
              localization of an object, i.e. bounding box, given an `image_size`,
              `bounding_boxes` and a series of constraints.
              
              The output of this Op is a single bounding box that may be used to crop the
              original image. The output is returned as 3 tensors: `begin`, `size` and
              `bboxes`. The first 2 tensors can be fed directly into `tf.slice` to crop the
              image. The latter may be supplied to `tf.image.draw_bounding_boxes` to visualize
              what the bounding box looks like.
              
              Bounding boxes are supplied and returned as `[y_min, x_min, y_max, x_max]`. The
              bounding box coordinates are floats in `[0.0, 1.0]` relative to the width and
              height of the underlying image.
              
              For example,
              
              ```python
                  # Generate a single distorted bounding box.
                  begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(
                      tf.shape(image),
                      bounding_boxes=bounding_boxes)
              
                  # Draw the bounding box in an image summary.
                  image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),
                                                                bbox_for_draw)
                  tf.image_summary('images_with_box', image_with_box)
              
                  # Employ the bounding box to distort the image.
                  distorted_image = tf.slice(image, begin, size)
              ```
              
              Note that if no bounding box information is available, setting
              `use_image_if_no_bounding_boxes = true` will assume there is a single implicit
              bounding box covering the whole image. If `use_image_if_no_bounding_boxes` is
              false and no bounding boxes are supplied, an error is raised.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SampleDistortedBoundingBoxV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Single[],System.Single[],System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">
            <summary>
              Generate a single randomly distorted bounding box for an image.
            </summary>
            <param name="image_size">
              1-D, containing `[height, width, channels]`.
            </param>
            <param name="bounding_boxes">
              3-D with shape `[batch, N, 4]` describing the N bounding boxes
              associated with the image.
            </param>
            <param name="min_object_covered">
              The cropped area of the image must contain at least this
              fraction of any bounding box supplied. The value of this parameter should be
              non-negative. In the case of 0, the cropped area does not need to overlap
              any of the bounding boxes supplied.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SampleDistortedBoundingBoxV2'.
            </param>
            <param name="seed">
              Optional argument
              If either `seed` or `seed2` are set to non-zero, the random number
              generator is seeded by the given `seed`.  Otherwise, it is seeded by a random
              seed.
            </param>
            <param name="seed2">
              Optional argument
              A second seed to avoid seed collision.
            </param>
            <param name="aspect_ratio_range">
              Optional argument
              The cropped area of the image must have an aspect ratio =
              width / height within this range.
            </param>
            <param name="area_range">
              Optional argument
              The cropped area of the image must contain a fraction of the
              supplied image within in this range.
            </param>
            <param name="max_attempts">
              Optional argument
              Number of attempts at generating a cropped region of the image
              of the specified constraints. After `max_attempts` failures, return the entire
              image.
            </param>
            <param name="use_image_if_no_bounding_boxes">
              Optional argument
              Controls behavior if no bounding boxes supplied.
              If true, assume an implicit bounding box covering the whole input. If false,
              raise an error.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              begin: 1-D, containing `[offset_height, offset_width, 0]`. Provide as input to
              `tf.slice`.
              size: 1-D, containing `[target_height, target_width, -1]`. Provide as input to
              `tf.slice`.
              bboxes: 3-D with shape `[1, 1, 4]` containing the distorted bounding box.
              Provide as input to `tf.image.draw_bounding_boxes`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Bounding box annotations are often supplied in addition to ground-truth labels
              in image recognition or object localization tasks. A common technique for
              training such a system is to randomly distort an image while preserving
              its content, i.e. *data augmentation*. This Op outputs a randomly distorted
              localization of an object, i.e. bounding box, given an `image_size`,
              `bounding_boxes` and a series of constraints.
              
              The output of this Op is a single bounding box that may be used to crop the
              original image. The output is returned as 3 tensors: `begin`, `size` and
              `bboxes`. The first 2 tensors can be fed directly into `tf.slice` to crop the
              image. The latter may be supplied to `tf.image.draw_bounding_boxes` to visualize
              what the bounding box looks like.
              
              Bounding boxes are supplied and returned as `[y_min, x_min, y_max, x_max]`. The
              bounding box coordinates are floats in `[0.0, 1.0]` relative to the width and
              height of the underlying image.
              
              For example,
              
              ```python
                  # Generate a single distorted bounding box.
                  begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(
                      tf.shape(image),
                      bounding_boxes=bounding_boxes)
              
                  # Draw the bounding box in an image summary.
                  image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),
                                                                bbox_for_draw)
                  tf.image_summary('images_with_box', image_with_box)
              
                  # Employ the bounding box to distort the image.
                  distorted_image = tf.slice(image, begin, size)
              ```
              
              Note that if no bounding box information is available, setting
              `use_image_if_no_bounding_boxes = true` will assume there is a single implicit
              bounding box covering the whole image. If `use_image_if_no_bounding_boxes` is
              false and no bounding boxes are supplied, an error is raised.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Save(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)">
            <summary>
              Saves the input tensors to disk.
            </summary>
            <param name="filename">
              Must have a single element. The name of the file to which we write
              the tensor.
            </param>
            <param name="tensor_names">
              Shape `[N]`. The names of the tensors to be saved.
            </param>
            <param name="data">
              `N` tensors to save.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Save'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The size of `tensor_names` must match the number of tensors in `data`. `data[i]`
              is written to `filename` with name `tensor_names[i]`.
              
              See also `SaveSlices`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SaveSlices(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)">
            <summary>
              Saves input tensors slices to disk.
            </summary>
            <param name="filename">
              Must have a single element. The name of the file to which we write the
              tensor.
            </param>
            <param name="tensor_names">
              Shape `[N]`. The names of the tensors to be saved.
            </param>
            <param name="shapes_and_slices">
              Shape `[N]`.  The shapes and slice specifications to use when
              saving the tensors.
            </param>
            <param name="data">
              `N` tensors to save.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SaveSlices'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              This is like `Save` except that tensors can be listed in the saved file as being
              a slice of a larger tensor.  `shapes_and_slices` specifies the shape of the
              larger tensor and the slice that this tensor covers. `shapes_and_slices` must
              have as many elements as `tensor_names`.
              
              Elements of the `shapes_and_slices` input must either be:
              
              *  The empty string, in which case the corresponding tensor is
                 saved normally.
              *  A string of the form `dim0 dim1 ... dimN-1 slice-spec` where the
                 `dimI` are the dimensions of the larger tensor and `slice-spec`
                 specifies what part is covered by the tensor to save.
              
              `slice-spec` itself is a `:`-separated list: `slice0:slice1:...:sliceN-1`
              where each `sliceI` is either:
              
              *  The string `-` meaning that the slice covers all indices of this dimension
              *  `start,length` where `start` and `length` are integers.  In that
                 case the slice covers `length` indices starting at `start`.
              
              See also `Save`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SaveV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)">
            <summary>
              Saves tensors in V2 checkpoint format.
            </summary>
            <param name="prefix">
              Must have a single element. The prefix of the V2 checkpoint to which we
              write the tensors.
            </param>
            <param name="tensor_names">
              shape {N}. The names of the tensors to be saved.
            </param>
            <param name="shape_and_slices">
              shape {N}.  The slice specs of the tensors to be saved.
              Empty strings indicate that they are non-partitioned tensors.
            </param>
            <param name="tensors">
              `N` tensors to save.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SaveV2'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              By default, saves the named tensors in full.  If the caller wishes to save
              specific slices of full tensors, "shape_and_slices" should be non-empty strings
              and correspondingly well-formed.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ScalarSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Outputs a `Summary` protocol buffer with scalar values.
            </summary>
            <param name="tags">
              Tags for the summary.
            </param>
            <param name="values">
              Same shape as `tags.  Values for the summary.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ScalarSummary'.
            </param>
            <returns>
              Scalar.  Serialized `Summary` protocol buffer.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The input `tags` and `values` must have the same shape.  The generated summary
              has a summary value for each tag-value pair in `tags` and `values`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ScatterAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Adds sparse updates to a variable reference.
            </summary>
            <param name="reference">
              Should be from a `Variable` node.
            </param>
            <param name="indices">
              A tensor of indices into the first dimension of `ref`.
            </param>
            <param name="updates">
              A tensor of updated values to add to `ref`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterAdd'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, the addition will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              = Same as `ref`.  Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation computes
              
                  # Scalar indices
                  ref[indices, ...] += updates[...]
              
                  # Vector indices (for each i)
                  ref[indices[i], ...] += updates[i, ...]
              
                  # High rank indices (for each i, ..., j)
                  ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]
              
              This operation outputs `ref` after the update is done.
              This makes it easier to chain operations that need to use the reset value.
              
              Duplicate entries are handled correctly: if multiple `indices` reference
              the same location, their contributions add.
              
              Requires `updates.shape = indices.shape + ref.shape[1:]`.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/ScatterAdd.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ScatterDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Divides a variable reference by sparse updates.
            </summary>
            <param name="reference">
              Should be from a `Variable` node.
            </param>
            <param name="indices">
              A tensor of indices into the first dimension of `ref`.
            </param>
            <param name="updates">
              A tensor of values that `ref` is divided by.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterDiv'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, the operation will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              = Same as `ref`.  Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation computes
              
              ```python
                  # Scalar indices
                  ref[indices, ...] /= updates[...]
              
                  # Vector indices (for each i)
                  ref[indices[i], ...] /= updates[i, ...]
              
                  # High rank indices (for each i, ..., j)
                  ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]
              ```
              
              This operation outputs `ref` after the update is done.
              This makes it easier to chain operations that need to use the reset value.
              
              Duplicate entries are handled correctly: if multiple `indices` reference
              the same location, their contributions divide.
              
              Requires `updates.shape = indices.shape + ref.shape[1:]`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ScatterMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Multiplies sparse updates into a variable reference.
            </summary>
            <param name="reference">
              Should be from a `Variable` node.
            </param>
            <param name="indices">
              A tensor of indices into the first dimension of `ref`.
            </param>
            <param name="updates">
              A tensor of updated values to multiply to `ref`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterMul'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, the operation will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              = Same as `ref`.  Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation computes
              
              ```python
                  # Scalar indices
                  ref[indices, ...] *= updates[...]
              
                  # Vector indices (for each i)
                  ref[indices[i], ...] *= updates[i, ...]
              
                  # High rank indices (for each i, ..., j)
                  ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]
              ```
              
              This operation outputs `ref` after the update is done.
              This makes it easier to chain operations that need to use the reset value.
              
              Duplicate entries are handled correctly: if multiple `indices` reference
              the same location, their contributions multiply.
              
              Requires `updates.shape = indices.shape + ref.shape[1:]`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ScatterNd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Scatter `updates` into a new (initially zero) tensor according to `indices`.
            </summary>
            <param name="indices">
              Index tensor.
            </param>
            <param name="updates">
              Updates to scatter into output.
            </param>
            <param name="shape">
              1-D. The shape of the resulting tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNd'.
            </param>
            <returns>
              A new tensor with the given shape and updates applied according
              to the indices.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Creates a new tensor by applying sparse `updates` to individual
              values or slices within a zero tensor of the given `shape` according to
              indices.  This operator is the inverse of the @{tf.gather_nd} operator which
              extracts values or slices from a given tensor.
              
              **WARNING**: The order in which updates are applied is nondeterministic, so the
              output will be nondeterministic if `indices` contains duplicates.
              
              `indices` is an integer tensor containing indices into a new tensor of shape
              `shape`.  The last dimension of `indices` can be at most the rank of `shape`:
              
                  indices.shape[-1] &amp;lt;= shape.rank
              
              The last dimension of `indices` corresponds to indices into elements
              (if `indices.shape[-1] = shape.rank`) or slices
              (if `indices.shape[-1] &amp;lt; shape.rank`) along dimension `indices.shape[-1]` of
              `shape`.  `updates` is a tensor with shape
              
                  indices.shape[:-1] + shape[indices.shape[-1]:]
              
              The simplest form of scatter is to insert individual elements in a tensor by
              index. For example, say we want to insert 4 scattered elements in a rank-1
              tensor with 8 elements.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/ScatterNd1.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
              
              In Python, this scatter operation would look like this:
              
              ```python
                  indices = tf.constant([[4], [3], [1], [7]])
                  updates = tf.constant([9, 10, 11, 12])
                  shape = tf.constant([8])
                  scatter = tf.scatter_nd(indices, updates, shape)
                  with tf.Session() as sess:
                    print(sess.run(scatter))
              ```
              
              The resulting tensor would look like this:
              
                  [0, 11, 0, 10, 9, 0, 0, 12]
              
              We can also, insert entire slices of a higher rank tensor all at once. For
              example, if we wanted to insert two slices in the first dimension of a
              rank-3 tensor with two matrices of new values.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/ScatterNd2.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
              
              In Python, this scatter operation would look like this:
              
              ```python
                  indices = tf.constant([[0], [2]])
                  updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],
                                          [7, 7, 7, 7], [8, 8, 8, 8]],
                                         [[5, 5, 5, 5], [6, 6, 6, 6],
                                          [7, 7, 7, 7], [8, 8, 8, 8]]])
                  shape = tf.constant([4, 4, 4])
                  scatter = tf.scatter_nd(indices, updates, shape)
                  with tf.Session() as sess:
                    print(sess.run(scatter))
              ```
              
              The resulting tensor would look like this:
              
                  [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
                   [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
                   [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
                   [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]]
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ScatterNdAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Applies sparse addition between `updates` and individual values or slices
            </summary>
            <param name="reference">
              A mutable Tensor. Should be from a Variable node.
            </param>
            <param name="indices">
              A Tensor. Must be one of the following types: int32, int64.
              A tensor of indices into ref.
            </param>
            <param name="updates">
              A Tensor. Must have the same type as ref. A tensor of updated values
              to add to ref.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdAdd'.
            </param>
            <param name="use_locking">
              Optional argument
              An optional bool. Defaults to True. If True, the assignment will
              be protected by a lock; otherwise the behavior is undefined,
              but may exhibit less contention.
            </param>
            <returns>
              Same as ref. Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              within a given variable according to `indices`.
              
              `ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.
              
              `indices` must be integer tensor, containing indices into `ref`.
              It must be shape `[d_0, ..., d_{Q-2}, K]` where `0 &amp;lt; K &amp;lt;= P`.
              
              The innermost dimension of `indices` (with length `K`) corresponds to
              indices into elements (if `K = P`) or slices (if `K &amp;lt; P`) along the `K`th
              dimension of `ref`.
              
              `updates` is `Tensor` of rank `Q-1+P-K` with shape:
              
              ```
              [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].
              ```
              
              For example, say we want to add 4 scattered elements to a rank-1 tensor to 8
              elements. In Python, that addition would look like this:
              
                  ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
                  indices = tf.constant([[4], [3], [1], [7]])
                  updates = tf.constant([9, 10, 11, 12])
                  add = tf.scatter_nd_add(ref, indices, updates)
                  with tf.Session() as sess:
                    print sess.run(add)
              
              The resulting update to ref would look like this:
              
                  [1, 13, 3, 14, 14, 6, 7, 20]
              
              See @{tf.scatter_nd} for more details about how to make updates to
              slices.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ScatterNdNonAliasingAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Applies sparse addition to `input` using individual values or slices
            </summary>
            <param name="input">
              A Tensor.
            </param>
            <param name="indices">
              A Tensor. Must be one of the following types: `int32`, `int64`.
              A tensor of indices into `input`.
            </param>
            <param name="updates">
              A Tensor. Must have the same type as ref. A tensor of updated values
              to add to `input`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdNonAliasingAdd'.
            </param>
            <returns>
              A `Tensor` with the same shape as `input`, containing values of `input`
              updated with `updates`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              from `updates` according to indices `indices`.  The updates are non-aliasing:
              `input` is only modified in-place if no other operations will use it.
              Otherwise, a copy of `input` is made.  This operation has a gradient with
              respect to both `input` and `updates`.
              
              `input` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.
              
              `indices` must be integer tensor, containing indices into `input`.
              It must be shape `[d_0, ..., d_{Q-2}, K]` where `0 &amp;lt; K &amp;lt;= P`.
              
              The innermost dimension of `indices` (with length `K`) corresponds to
              indices into elements (if `K = P`) or `(P-K)`-dimensional slices
              (if `K &amp;lt; P`) along the `K`th dimension of `input`.
              
              `updates` is `Tensor` of rank `Q-1+P-K` with shape:
              
              ```
              [d_0, ..., d_{Q-2}, input.shape[K], ..., input.shape[P-1]].
              ```
              
              For example, say we want to add 4 scattered elements to a rank-1 tensor to 8
              elements. In Python, that addition would look like this:
              
                  input = tf.constant([1, 2, 3, 4, 5, 6, 7, 8])
                  indices = tf.constant([[4], [3], [1], [7]])
                  updates = tf.constant([9, 10, 11, 12])
                  output = tf.scatter_nd_non_aliasing_add(input, indices, updates)
                  with tf.Session() as sess:
                    print(sess.run(output))
              
              The resulting value `output` would look like this:
              
                  [1, 13, 3, 14, 14, 6, 7, 20]
              
              See @{tf.scatter_nd} for more details about how to make updates to slices.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ScatterNdSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Applies sparse subtraction between `updates` and individual values or slices
            </summary>
            <param name="reference">
              A mutable Tensor. Should be from a Variable node.
            </param>
            <param name="indices">
              A Tensor. Must be one of the following types: int32, int64.
              A tensor of indices into ref.
            </param>
            <param name="updates">
              A Tensor. Must have the same type as ref. A tensor of updated values
              to subtract from ref.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdSub'.
            </param>
            <param name="use_locking">
              Optional argument
              An optional bool. Defaults to True. If True, the assignment will
              be protected by a lock; otherwise the behavior is undefined,
              but may exhibit less contention.
            </param>
            <returns>
              Same as ref. Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              within a given variable according to `indices`.
              
              `ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.
              
              `indices` must be integer tensor, containing indices into `ref`.
              It must be shape `[d_0, ..., d_{Q-2}, K]` where `0 &amp;lt; K &amp;lt;= P`.
              
              The innermost dimension of `indices` (with length `K`) corresponds to
              indices into elements (if `K = P`) or slices (if `K &amp;lt; P`) along the `K`th
              dimension of `ref`.
              
              `updates` is `Tensor` of rank `Q-1+P-K` with shape:
              
              ```
              [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].
              ```
              
              For example, say we want to subtract 4 scattered elements from a rank-1 tensor
              with 8 elements. In Python, that subtraction would look like this:
              
                  ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
                  indices = tf.constant([[4], [3], [1], [7]])
                  updates = tf.constant([9, 10, 11, 12])
                  sub = tf.scatter_nd_sub(ref, indices, updates)
                  with tf.Session() as sess:
                    print sess.run(sub)
              
              The resulting update to ref would look like this:
              
                  [1, -9, 3, -6, -4, 6, 7, -4]
              
              See @{tf.scatter_nd} for more details about how to make updates to
              slices.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ScatterNdUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Applies sparse `updates` to individual values or slices within a given
            </summary>
            <param name="reference">
              A mutable Tensor. Should be from a Variable node.
            </param>
            <param name="indices">
              A Tensor. Must be one of the following types: int32, int64.
              A tensor of indices into ref.
            </param>
            <param name="updates">
              A Tensor. Must have the same type as ref. A tensor of updated
              values to add to ref.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdUpdate'.
            </param>
            <param name="use_locking">
              Optional argument
              An optional bool. Defaults to True. If True, the assignment will
              be protected by a lock; otherwise the behavior is undefined,
              but may exhibit less contention.
            </param>
            <returns>
              Same as ref. Returned as a convenience for operations that want to
              use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              variable according to `indices`.
              
              `ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.
              
              `indices` must be integer tensor, containing indices into `ref`.
              It must be shape `[d_0, ..., d_{Q-2}, K]` where `0 &amp;lt; K &amp;lt;= P`.
              
              The innermost dimension of `indices` (with length `K`) corresponds to
              indices into elements (if `K = P`) or slices (if `K &amp;lt; P`) along the `K`th
              dimension of `ref`.
              
              `updates` is `Tensor` of rank `Q-1+P-K` with shape:
              
              ```
              [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].
              ```
              
              For example, say we want to update 4 scattered elements to a rank-1 tensor to
              8 elements. In Python, that update would look like this:
              
              ```python
                  ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
                  indices = tf.constant([[4], [3], [1] ,[7]])
                  updates = tf.constant([9, 10, 11, 12])
                  update = tf.scatter_nd_update(ref, indices, updates)
                  with tf.Session() as sess:
                    print sess.run(update)
              ```
              
              The resulting update to ref would look like this:
              
                  [1, 11, 3, 10, 9, 6, 7, 12]
              
              See @{tf.scatter_nd} for more details about how to make updates to
              slices.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ScatterSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Subtracts sparse updates to a variable reference.
            </summary>
            <param name="reference">
              Should be from a `Variable` node.
            </param>
            <param name="indices">
              A tensor of indices into the first dimension of `ref`.
            </param>
            <param name="updates">
              A tensor of updated values to subtract from `ref`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterSub'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              = Same as `ref`.  Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              ```python
                  # Scalar indices
                  ref[indices, ...] -= updates[...]
              
                  # Vector indices (for each i)
                  ref[indices[i], ...] -= updates[i, ...]
              
                  # High rank indices (for each i, ..., j)
                  ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]
              ```
              
              This operation outputs `ref` after the update is done.
              This makes it easier to chain operations that need to use the reset value.
              
              Duplicate entries are handled correctly: if multiple `indices` reference
              the same location, their (negated) contributions add.
              
              Requires `updates.shape = indices.shape + ref.shape[1:]`.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/ScatterSub.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ScatterUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Applies sparse updates to a variable reference.
            </summary>
            <param name="reference">
              Should be from a `Variable` node.
            </param>
            <param name="indices">
              A tensor of indices into the first dimension of `ref`.
            </param>
            <param name="updates">
              A tensor of updated values to store in `ref`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterUpdate'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, the assignment will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              = Same as `ref`.  Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation computes
              
              ```python
                  # Scalar indices
                  ref[indices, ...] = updates[...]
              
                  # Vector indices (for each i)
                  ref[indices[i], ...] = updates[i, ...]
              
                  # High rank indices (for each i, ..., j)
                  ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]
              ```
              
              This operation outputs `ref` after the update is done.
              This makes it easier to chain operations that need to use the reset value.
              
              If values in `ref` is to be updated more than once, because there are
              duplicate entries in `indices`, the order at which the updates happen
              for each value is undefined.
              
              Requires `updates.shape = indices.shape + ref.shape[1:]`.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/ScatterUpdate.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SdcaFprint(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes fingerprints of the input strings.
            </summary>
            <param name="input">
              vector of strings to compute fingerprints on.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SdcaFprint'.
            </param>
            <returns>
              a (N,2) shaped matrix where N is the number of elements in the input
              vector. Each row contains the low and high parts of the fingerprint.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SdcaOptimizer(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.String,System.Single,System.Single,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)">
            <summary>
              Distributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for
            </summary>
            <param name="sparse_example_indices">
              a list of vectors which contain example indices.
            </param>
            <param name="sparse_feature_indices">
              a list of vectors which contain feature indices.
            </param>
            <param name="sparse_feature_values">
              a list of vectors which contains feature value
              associated with each feature group.
            </param>
            <param name="dense_features">
              a list of matrices which contains the dense feature values.
            </param>
            <param name="example_weights">
              a vector which contains the weight associated with each
              example.
            </param>
            <param name="example_labels">
              a vector which contains the label/target associated with each
              example.
            </param>
            <param name="sparse_indices">
              a list of vectors where each value is the indices which has
              corresponding weights in sparse_weights. This field maybe omitted for the
              dense approach.
            </param>
            <param name="sparse_weights">
              a list of vectors where each value is the weight associated with
              a sparse feature group.
            </param>
            <param name="dense_weights">
              a list of vectors where the values are the weights associated
              with a dense feature group.
            </param>
            <param name="example_state_data">
              a list of vectors containing the example state data.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SdcaOptimizer'.
            </param>
            <param name="adaptative">
              Optional argument
              Whether to use Adapative SDCA for the inner loop.
            </param>
            <param name="loss_type">
              Type of the primal loss. Currently SdcaSolver supports logistic,
              squared and hinge losses.
            </param>
            <param name="l1">
              Symmetric l1 regularization strength.
            </param>
            <param name="l2">
              Symmetric l2 regularization strength.
            </param>
            <param name="num_loss_partitions">
              Number of partitions of the global loss function.
            </param>
            <param name="num_inner_iterations">
              Number of iterations per mini-batch.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              out_example_state_data: a list of vectors containing the updated example state
              data.
              out_delta_sparse_weights: a list of vectors where each value is the delta
              weights associated with a sparse feature group.
              out_delta_dense_weights: a list of vectors where the values are the delta
              weights associated with a dense feature group.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              linear models with L1 + L2 regularization. As global optimization objective is
              strongly-convex, the optimizer optimizes the dual objective at each step. The
              optimizer applies each update one example at a time. Examples are sampled
              uniformly, and the optimizer is learning rate free and enjoys linear convergence
              rate.
              
              [Proximal Stochastic Dual Coordinate Ascent](http://arxiv.org/pdf/1211.2717v1.pdf).&amp;lt;br&amp;gt;
              Shai Shalev-Shwartz, Tong Zhang. 2012
              
              $$Loss Objective = \sum f_{i} (wx_{i}) + (l2 / 2) * |w|^2 + l1 * |w|$$
              
              [Adding vs. Averaging in Distributed Primal-Dual Optimization](http://arxiv.org/abs/1502.03508).&amp;lt;br&amp;gt;
              Chenxin Ma, Virginia Smith, Martin Jaggi, Michael I. Jordan,
              Peter Richtarik, Martin Takac. 2015
              
              [Stochastic Dual Coordinate Ascent with Adaptive Probabilities](https://arxiv.org/abs/1502.08053).&amp;lt;br&amp;gt;
              Dominik Csiba, Zheng Qu, Peter Richtarik. 2015
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SdcaShrinkL1(TensorFlow.TFOutput[],System.Single,System.Single,System.String)">
            <summary>
              Applies L1 regularization shrink step on the parameters.
            </summary>
            <param name="weights">
              a list of vectors where each value is the weight associated with a
              feature group.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SdcaShrinkL1'.
            </param>
            <param name="l1">
              Symmetric l1 regularization strength.
            </param>
            <param name="l2">
              Symmetric l2 regularization strength. Should be a positive float.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SegmentMax(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the maximum along segments of a tensor.
            </summary>
            <param name="data">
            </param>
            <param name="segment_ids">
              A 1-D tensor whose rank is equal to the rank of `data`'s
              first dimension.  Values should be sorted and can be repeated.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentMax'.
            </param>
            <returns>
              Has same shape as data, except for dimension 0 which
              has size `k`, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Read @{$math_ops#segmentation$the section on segmentation} for an explanation of
              segments.
              
              Computes a tensor such that
              \\(output_i = \max_j(data_j)\\) where `max` is over `j` such
              that `segment_ids[j] == i`.
              
              If the max is empty for a given segment ID `i`, `output[i] = 0`.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/SegmentMax.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SegmentMean(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the mean along segments of a tensor.
            </summary>
            <param name="data">
            </param>
            <param name="segment_ids">
              A 1-D tensor whose rank is equal to the rank of `data`'s
              first dimension.  Values should be sorted and can be repeated.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentMean'.
            </param>
            <returns>
              Has same shape as data, except for dimension 0 which
              has size `k`, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Read @{$math_ops#segmentation$the section on segmentation} for an explanation of
              segments.
              
              Computes a tensor such that
              \\(output_i = \frac{\sum_j data_j}{N}\\) where `mean` is
              over `j` such that `segment_ids[j] == i` and `N` is the total number of
              values summed.
              
              If the mean is empty for a given segment ID `i`, `output[i] = 0`.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/SegmentMean.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SegmentMin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the minimum along segments of a tensor.
            </summary>
            <param name="data">
            </param>
            <param name="segment_ids">
              A 1-D tensor whose rank is equal to the rank of `data`'s
              first dimension.  Values should be sorted and can be repeated.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentMin'.
            </param>
            <returns>
              Has same shape as data, except for dimension 0 which
              has size `k`, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Read @{$math_ops#segmentation$the section on segmentation} for an explanation of
              segments.
              
              Computes a tensor such that
              \\(output_i = \min_j(data_j)\\) where `min` is over `j` such
              that `segment_ids[j] == i`.
              
              If the min is empty for a given segment ID `i`, `output[i] = 0`.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/SegmentMin.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SegmentProd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the product along segments of a tensor.
            </summary>
            <param name="data">
            </param>
            <param name="segment_ids">
              A 1-D tensor whose rank is equal to the rank of `data`'s
              first dimension.  Values should be sorted and can be repeated.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentProd'.
            </param>
            <returns>
              Has same shape as data, except for dimension 0 which
              has size `k`, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Read @{$math_ops#segmentation$the section on segmentation} for an explanation of
              segments.
              
              Computes a tensor such that
              \\(output_i = \prod_j data_j\\) where the product is over `j` such
              that `segment_ids[j] == i`.
              
              If the product is empty for a given segment ID `i`, `output[i] = 1`.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/SegmentProd.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the sum along segments of a tensor.
            </summary>
            <param name="data">
            </param>
            <param name="segment_ids">
              A 1-D tensor whose rank is equal to the rank of `data`'s
              first dimension.  Values should be sorted and can be repeated.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentSum'.
            </param>
            <returns>
              Has same shape as data, except for dimension 0 which
              has size `k`, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Read @{$math_ops#segmentation$the section on segmentation} for an explanation of
              segments.
              
              Computes a tensor such that
              \\(output_i = \sum_j data_j\\) where sum is over `j` such
              that `segment_ids[j] == i`.
              
              If the sum is empty for a given segment ID `i`, `output[i] = 0`.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/SegmentSum.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Select(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Selects elements from `t` or `e`, depending on `condition`.
            </summary>
            <param name="condition">
            </param>
            <param name="t">
              = A `Tensor` which may have the same shape as `condition`.
              If `condition` is rank 1, `t` may have higher rank,
              but its first dimension must match the size of `condition`.
            </param>
            <param name="e">
              = A `Tensor` with the same type and shape as `t`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Select'.
            </param>
            <returns>
              = A `Tensor` with the same type and shape as `t` and `e`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The `t`, and `e` tensors must all have the same shape, and the
              output will also have that shape.
              
              The `condition` tensor must be a scalar if `t` and `e` are scalars.
              If `t` and `e` are vectors or higher rank, then `condition` must be either a
              scalar, a vector with size matching the first dimension of `t`, or must have
              the same shape as `t`.
              
              The `condition` tensor acts as a mask that chooses, based on the value at each
              element, whether the corresponding element / row in the output should be
              taken from `t` (if true) or `e` (if false).
              
              If `condition` is a vector and `t` and `e` are higher rank matrices, then
              it chooses which row (outer dimension) to copy from `t` and `e`.
              If `condition` has the same shape as `t` and `e`, then it chooses which
              element to copy from `t` and `e`.
              
              For example:
              
              ```python
              # 'condition' tensor is [[True,  False]
              #                        [False, True]]
              # 't' is [[1, 2],
              #         [3, 4]]
              # 'e' is [[5, 6],
              #         [7, 8]]
              select(condition, t, e)  # =&amp;gt; [[1, 6], [7, 4]]
              
              
              # 'condition' tensor is [True, False]
              # 't' is [[1, 2],
              #         [3, 4]]
              # 'e' is [[5, 6],
              #         [7, 8]]
              select(condition, t, e) ==&amp;gt; [[1, 2],
                                           [7, 8]]
              
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SelfAdjointEig(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the Eigen Decomposition of a batch of square self-adjoint matrices.
            </summary>
            <param name="input">
              Shape is `[..., M, M]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SelfAdjointEig'.
            </param>
            <returns>
              Shape is `[..., M+1, M]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions
              form square matrices, with the same constraints as the single matrix
              SelfAdjointEig.
              
              The result is a [..., M+1, M] matrix with [..., 0,:] containing the
              eigenvalues, and subsequent [...,1:, :] containing the eigenvectors.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SelfAdjointEigV2(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the eigen decomposition of one or more square self-adjoint matrices.
            </summary>
            <param name="input">
              `Tensor` input of shape `[N, N]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SelfAdjointEigV2'.
            </param>
            <param name="compute_v">
              Optional argument
              If `True` then eigenvectors will be computed and returned in `v`.
              Otherwise, only the eigenvalues will be computed.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              e: Eigenvalues. Shape is `[N]`.
              v: Eigenvectors. Shape is `[N, N]`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Computes the eigenvalues and (optionally) eigenvectors of each inner matrix in
              `input` such that `input[..., :, :] = v[..., :, :] * diag(e[..., :])`.
              
              ```python
              # a is a tensor.
              # e is a tensor of eigenvalues.
              # v is a tensor of eigenvectors.
              e, v = self_adjoint_eig(a)
              e = self_adjoint_eig(a, compute_v=False)
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Selu(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes scaled exponential linear: `scale * alpha * (exp(features) - 1)`
            </summary>
            <param name="features">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Selu'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              if &amp;lt; 0, `scale * features` otherwise.
              
              See [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SeluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes gradients for the scaled exponential linear (Selu) operation.
            </summary>
            <param name="gradients">
              The backpropagated gradients to the corresponding Selu operation.
            </param>
            <param name="outputs">
              The outputs of the corresponding Selu operation.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SeluGrad'.
            </param>
            <returns>
              The gradients: `gradients * (outputs + scale * alpha)`
              if outputs &amp;lt; 0, `scale * gradients` otherwise.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SerializeIterator(TensorFlow.TFOutput,System.String)">
            <summary>
              Converts the given `resource_handle` representing an iterator to a variant tensor.
            </summary>
            <param name="resource_handle">
              A handle to an iterator resource.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeIterator'.
            </param>
            <returns>
              A variant tensor storing the state of the iterator contained in the
              resource.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SerializeManySparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Serialize an `N`-minibatch `SparseTensor` into an `[N, 3]` `Tensor` object.
            </summary>
            <param name="sparse_indices">
              2-D.  The `indices` of the minibatch `SparseTensor`.
            </param>
            <param name="sparse_values">
              1-D.  The `values` of the minibatch `SparseTensor`.
            </param>
            <param name="sparse_shape">
              1-D.  The `shape` of the minibatch `SparseTensor`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeManySparse'.
            </param>
            <param name="out_type">
              Optional argument
              The `dtype` to use for serialization; the supported types are `string`
              (default) and `variant`.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The `SparseTensor` must have rank `R` greater than 1, and the first dimension
              is treated as the minibatch dimension.  Elements of the `SparseTensor`
              must be sorted in increasing order of this first dimension.  The serialized
              `SparseTensor` objects going into each row of `serialized_sparse` will have
              rank `R-1`.
              
              The minibatch size `N` is extracted from `sparse_shape[0]`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SerializeSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Serialize a `SparseTensor` into a `[3]` `Tensor` object.
            </summary>
            <param name="sparse_indices">
              2-D.  The `indices` of the `SparseTensor`.
            </param>
            <param name="sparse_values">
              1-D.  The `values` of the `SparseTensor`.
            </param>
            <param name="sparse_shape">
              1-D.  The `shape` of the `SparseTensor`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeSparse'.
            </param>
            <param name="out_type">
              Optional argument
              The `dtype` to use for serialization; the supported types are `string`
              (default) and `variant`.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SerializeTensor(TensorFlow.TFOutput,System.String)">
            <summary>
              Transforms a Tensor into a serialized TensorProto proto.
            </summary>
            <param name="tensor">
              A Tensor of type `T`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeTensor'.
            </param>
            <returns>
              A serialized TensorProto proto of the input tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SetSize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Number of unique elements along last dimension of input `set`.
            </summary>
            <param name="set_indices">
              2D `Tensor`, indices of a `SparseTensor`.
            </param>
            <param name="set_values">
              1D `Tensor`, values of a `SparseTensor`.
            </param>
            <param name="set_shape">
              1D `Tensor`, shape of a `SparseTensor`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SetSize'.
            </param>
            <param name="validate_indices">
              Optional argument
            </param>
            <returns>
              For `set` ranked `n`, this is a `Tensor` with rank `n-1`, and the same 1st
              `n-1` dimensions as `set`. Each value is the number of unique elements in
              the corresponding `[0...n-1]` dimension of `set`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Input `set` is a `SparseTensor` represented by `set_indices`, `set_values`,
              and `set_shape`. The last dimension contains values in a set, duplicates are
              allowed but ignored.
              
              If `validate_indices` is `True`, this op validates the order and range of `set`
              indices.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Shape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Returns the shape of a tensor.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Shape'.
            </param>
            <param name="out_type">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation returns a 1-D integer tensor representing the shape of `input`.
              
              For example:
              
              ```
              # 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
              shape(t) ==&amp;gt; [2, 2, 3]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ShapeN(TensorFlow.TFOutput[],System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Returns shape of tensors.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ShapeN'.
            </param>
            <param name="out_type">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation returns N 1-D integer tensors representing shape of `input[i]s`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ShardedFilename(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Generate a sharded filename. The filename is printf formatted as
            </summary>
            <param name="basename">
            </param>
            <param name="shard">
            </param>
            <param name="num_shards">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ShardedFilename'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
                 %s-%05d-of-%05d, basename, shard, num_shards.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ShardedFilespec(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Generate a glob pattern matching all sharded file names.
            </summary>
            <param name="basename">
            </param>
            <param name="num_shards">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ShardedFilespec'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ShuffleDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Boolean},System.String)">
            <summary>
              Creates a dataset that shuffles elements from `input_dataset` pseudorandomly.
            </summary>
            <param name="input_dataset">
            </param>
            <param name="buffer_size">
              The number of output elements to buffer in an iterator over
              this dataset. Compare with the `min_after_dequeue` attr when creating a
              `RandomShuffleQueue`.
            </param>
            <param name="seed">
              A scalar seed for the random number generator. If either seed or
              seed2 is set to be non-zero, the random number generator is seeded
              by the given seed.  Otherwise, a random seed is used.
            </param>
            <param name="seed2">
              A second scalar seed to avoid seed collision.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ShuffleDataset'.
            </param>
            <param name="reshuffle_each_iteration">
              Optional argument
              If true, each iterator over this dataset will be given
              a different pseudorandomly generated seed, based on a sequence seeded by the
              `seed` and `seed2` inputs. If false, each iterator will be given the same
              seed, and repeated iteration over this dataset will yield the exact same
              sequence of results.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Sigmoid(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes sigmoid of `x` element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Sigmoid'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Specifically, `y = 1 / (1 + exp(-x))`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SigmoidGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the gradient of the sigmoid of `x` wrt its input.
            </summary>
            <param name="y">
            </param>
            <param name="dy">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SigmoidGrad'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Specifically, `grad = dy * y * (1 - y)`, where `y = sigmoid(x)`, and
              `dy` is the corresponding input gradient.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Sign(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns an element-wise indication of the sign of a number.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Sign'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `y = sign(x) = -1` if `x &amp;lt; 0`; 0 if `x == 0`; 1 if `x &amp;gt; 0`.
              
              For complex numbers, `y = sign(x) = x / |x|` if `x != 0`, otherwise `y = 0`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Sin(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes sin of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Sin'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Sinh(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes hyperbolic sine of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Sinh'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Size(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Returns the size of a tensor.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Size'.
            </param>
            <param name="out_type">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation returns an integer representing the number of elements in
              `input`.
              
              For example:
              
              ```
              # 't' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]
              size(t) ==&amp;gt; 12
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SkipDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that skips `count` elements from the `input_dataset`.
            </summary>
            <param name="input_dataset">
            </param>
            <param name="count">
              A scalar representing the number of elements from the `input_dataset`
              that should be skipped.  If count is -1, skips everything.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SkipDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Skipgram(System.String,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Single},System.String)">
            <summary>
              Parses a text file and creates a batch of examples.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Skipgram'.
            </param>
            <param name="window_size">
              Optional argument
              The number of words to predict to the left and right of the target.
            </param>
            <param name="min_count">
              Optional argument
              The minimum number of word occurrences for it to be included in the
              vocabulary.
            </param>
            <param name="subsample">
              Optional argument
              Threshold for word occurrence. Words that appear with higher
              frequency will be randomly down-sampled. Set to 0 to disable.
            </param>
            <param name="filename">
              The corpus's text file name.
            </param>
            <param name="batch_size">
              The size of produced batch.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              vocab_word: A vector of words in the corpus.
              vocab_freq: Frequencies of words. Sorted in the non-ascending order.
              words_per_epoch: Number of words per epoch in the data file.
              current_epoch: The current epoch number.
              total_words_processed: The total number of words processed so far.
              examples: A vector of word ids.
              labels: A vector of word ids.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Slice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Return a slice from 'input'.
            </summary>
            <param name="input">
            </param>
            <param name="begin">
              begin[i] specifies the offset into the 'i'th dimension of
              'input' to slice from.
            </param>
            <param name="size">
              size[i] specifies the number of elements of the 'i'th dimension
              of 'input' to slice. If size[i] is -1, all remaining elements in dimension
              i are included in the slice (i.e. this is equivalent to setting
              size[i] = input.dim_size(i) - begin[i]).
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Slice'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The output tensor is a tensor with dimensions described by 'size'
              whose values are extracted from 'input' starting at the offsets in
              'begin'.
              
              *Requirements*:
                0 &amp;lt;= begin[i] &amp;lt;= begin[i] + size[i] &amp;lt;= Di  for i in [0, n)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Snapshot(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns a copy of the input tensor.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Snapshot'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Softmax(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes softmax activations.
            </summary>
            <param name="logits">
              2-D with shape `[batch_size, num_classes]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Softmax'.
            </param>
            <returns>
              Same shape as `logits`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              For each batch `i` and class `j` we have
              
                  softmax[i, j] = exp(logits[i, j]) / sum_j(exp(logits[i, j]))
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SoftmaxCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes softmax cross entropy cost and gradients to backpropagate.
            </summary>
            <param name="features">
              batch_size x num_classes matrix
            </param>
            <param name="labels">
              batch_size x num_classes matrix
              The caller must ensure that each batch of labels represents a valid
              probability distribution.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SoftmaxCrossEntropyWithLogits'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              loss: Per example loss (batch_size vector).
              backprop: backpropagated gradients (batch_size x num_classes matrix).
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Inputs are the logits, not probabilities.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Softplus(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes softplus: `log(exp(features) + 1)`.
            </summary>
            <param name="features">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Softplus'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SoftplusGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes softplus gradients for a softplus operation.
            </summary>
            <param name="gradients">
              The backpropagated gradients to the corresponding softplus operation.
            </param>
            <param name="features">
              The features passed as input to the corresponding softplus operation.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SoftplusGrad'.
            </param>
            <returns>
              The gradients: `gradients / (1 + exp(-features))`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Softsign(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes softsign: `features / (abs(features) + 1)`.
            </summary>
            <param name="features">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Softsign'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SoftsignGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes softsign gradients for a softsign operation.
            </summary>
            <param name="gradients">
              The backpropagated gradients to the corresponding softsign operation.
            </param>
            <param name="features">
              The features passed as input to the corresponding softsign operation.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SoftsignGrad'.
            </param>
            <returns>
              The gradients: `gradients / (1 + abs(features)) ** 2`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SpaceToBatch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">
            <summary>
              SpaceToBatch for 4-D tensors of type T.
            </summary>
            <param name="input">
              4-D with shape `[batch, height, width, depth]`.
            </param>
            <param name="paddings">
              2-D tensor of non-negative integers with shape `[2, 2]`. It specifies
                the padding of the input with zeros across the spatial dimensions as follows:
              
                    paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]
              
                The effective spatial dimensions of the zero-padded input tensor will be:
              
                    height_pad = pad_top + height + pad_bottom
                    width_pad = pad_left + width + pad_right
              
              The attr `block_size` must be greater than one. It indicates the block size.
              
                * Non-overlapping blocks of size `block_size x block size` in the height and
                  width dimensions are rearranged into the batch dimension at each location.
                * The batch of the output tensor is `batch * block_size * block_size`.
                * Both height_pad and width_pad must be divisible by block_size.
              
              The shape of the output will be:
              
                  [batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
                   depth]
              
              Some examples:
              
              (1) For the following input of shape `[1, 2, 2, 1]` and block_size of 2:
              
              ```
              x = [[[[1], [2]], [[3], [4]]]]
              ```
              
              The output tensor has shape `[4, 1, 1, 1]` and value:
              
              ```
              [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
              ```
              
              (2) For the following input of shape `[1, 2, 2, 3]` and block_size of 2:
              
              ```
              x = [[[[1, 2, 3], [4, 5, 6]],
                    [[7, 8, 9], [10, 11, 12]]]]
              ```
              
              The output tensor has shape `[4, 1, 1, 3]` and value:
              
              ```
              [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
              ```
              
              (3) For the following input of shape `[1, 4, 4, 1]` and block_size of 2:
              
              ```
              x = [[[[1],   [2],  [3],  [4]],
                    [[5],   [6],  [7],  [8]],
                    [[9],  [10], [11],  [12]],
                    [[13], [14], [15],  [16]]]]
              ```
              
              The output tensor has shape `[4, 2, 2, 1]` and value:
              
              ```
              x = [[[[1], [3]], [[9], [11]]],
                   [[[2], [4]], [[10], [12]]],
                   [[[5], [7]], [[13], [15]]],
                   [[[6], [8]], [[14], [16]]]]
              ```
              
              (4) For the following input of shape `[2, 2, 4, 1]` and block_size of 2:
              
              ```
              x = [[[[1],   [2],  [3],  [4]],
                    [[5],   [6],  [7],  [8]]],
                   [[[9],  [10], [11],  [12]],
                    [[13], [14], [15],  [16]]]]
              ```
              
              The output tensor has shape `[8, 1, 2, 1]` and value:
              
              ```
              x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],
                   [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]
              ```
              
              Among others, this operation is useful for reducing atrous convolution into
              regular convolution.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SpaceToBatch'.
            </param>
            <param name="block_size">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This is a legacy version of the more general SpaceToBatchND.
              
              Zero-pads and then rearranges (permutes) blocks of spatial data into batch.
              More specifically, this op outputs a copy of the input tensor where values from
              the `height` and `width` dimensions are moved to the `batch` dimension. After
              the zero-padding, both `height` and `width` of the input must be divisible by the
              block size.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SpaceToBatchND(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              SpaceToBatch for N-D tensors of type T.
            </summary>
            <param name="input">
              N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`,
              where spatial_shape has `M` dimensions.
            </param>
            <param name="block_shape">
              1-D with shape `[M]`, all values must be &amp;gt;= 1.
            </param>
            <param name="paddings">
              2-D with shape `[M, 2]`, all values must be &amp;gt;= 0.
                `paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension
                `i + 1`, which corresponds to spatial dimension `i`.  It is required that
                `block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.
              
              This operation is equivalent to the following steps:
              
              1. Zero-pad the start and end of dimensions `[1, ..., M]` of the
                 input according to `paddings` to produce `padded` of shape `padded_shape`.
              
              2. Reshape `padded` to `reshaped_padded` of shape:
              
                   [batch] +
                   [padded_shape[1] / block_shape[0],
                     block_shape[0],
                    ...,
                    padded_shape[M] / block_shape[M-1],
                    block_shape[M-1]] +
                   remaining_shape
              
              3. Permute dimensions of `reshaped_padded` to produce
                 `permuted_reshaped_padded` of shape:
              
                   block_shape +
                   [batch] +
                   [padded_shape[1] / block_shape[0],
                    ...,
                    padded_shape[M] / block_shape[M-1]] +
                   remaining_shape
              
              4. Reshape `permuted_reshaped_padded` to flatten `block_shape` into the batch
                 dimension, producing an output tensor of shape:
              
                   [batch * prod(block_shape)] +
                   [padded_shape[1] / block_shape[0],
                    ...,
                    padded_shape[M] / block_shape[M-1]] +
                   remaining_shape
              
              Some examples:
              
              (1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and
                  `paddings = [[0, 0], [0, 0]]`:
              
              ```
              x = [[[[1], [2]], [[3], [4]]]]
              ```
              
              The output tensor has shape `[4, 1, 1, 1]` and value:
              
              ```
              [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
              ```
              
              (2) For the following input of shape `[1, 2, 2, 3]`, `block_shape = [2, 2]`, and
                  `paddings = [[0, 0], [0, 0]]`:
              
              ```
              x = [[[[1, 2, 3], [4, 5, 6]],
                    [[7, 8, 9], [10, 11, 12]]]]
              ```
              
              The output tensor has shape `[4, 1, 1, 3]` and value:
              
              ```
              [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
              ```
              
              (3) For the following input of shape `[1, 4, 4, 1]`, `block_shape = [2, 2]`, and
                  `paddings = [[0, 0], [0, 0]]`:
              
              ```
              x = [[[[1],   [2],  [3],  [4]],
                    [[5],   [6],  [7],  [8]],
                    [[9],  [10], [11],  [12]],
                    [[13], [14], [15],  [16]]]]
              ```
              
              The output tensor has shape `[4, 2, 2, 1]` and value:
              
              ```
              x = [[[[1], [3]], [[9], [11]]],
                   [[[2], [4]], [[10], [12]]],
                   [[[5], [7]], [[13], [15]]],
                   [[[6], [8]], [[14], [16]]]]
              ```
              
              (4) For the following input of shape `[2, 2, 4, 1]`, block_shape = `[2, 2]`, and
                  paddings = `[[0, 0], [2, 0]]`:
              
              ```
              x = [[[[1],   [2],  [3],  [4]],
                    [[5],   [6],  [7],  [8]]],
                   [[[9],  [10], [11],  [12]],
                    [[13], [14], [15],  [16]]]]
              ```
              
              The output tensor has shape `[8, 1, 3, 1]` and value:
              
              ```
              x = [[[[0], [1], [3]]], [[[0], [9], [11]]],
                   [[[0], [2], [4]]], [[[0], [10], [12]]],
                   [[[0], [5], [7]]], [[[0], [13], [15]]],
                   [[[0], [6], [8]]], [[[0], [14], [16]]]]
              ```
              
              Among others, this operation is useful for reducing atrous convolution into
              regular convolution.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SpaceToBatchND'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation divides "spatial" dimensions `[1, ..., M]` of the input into a
              grid of blocks of shape `block_shape`, and interleaves these blocks with the
              "batch" dimension (0) such that in the output, the spatial dimensions
              `[1, ..., M]` correspond to the position within the grid, and the batch
              dimension combines both the position within a spatial block and the original
              batch position.  Prior to division into blocks, the spatial dimensions of the
              input are optionally zero padded according to `paddings`.  See below for a
              precise description.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SpaceToDepth(TensorFlow.TFOutput,System.Int64,System.String,System.String)">
            <summary>
              SpaceToDepth for tensors of type T.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SpaceToDepth'.
            </param>
            <param name="data_format">
              Optional argument
            </param>
            <param name="block_size">
              The size of the spatial block.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Rearranges blocks of spatial data, into depth. More specifically,
              this op outputs a copy of the input tensor where values from the `height`
              and `width` dimensions are moved to the `depth` dimension.
              The attr `block_size` indicates the input block size.
              
                * Non-overlapping blocks of size `block_size x block size` are rearranged
                  into depth at each location.
                * The depth of the output tensor is `block_size * block_size * input_depth`.
                * The Y, X coordinates within each block of the input become the high order
                  component of the output channel index.
                * The input tensor's height and width must be divisible by block_size.
              
              The `data_format` attr specifies the layout of the input and output tensors
              with the following options:
                "NHWC": `[ batch, height, width, channels ]`
                "NCHW": `[ batch, channels, height, width ]`
                "NCHW_VECT_C":
                    `qint8 [ batch, channels / 4, height, width, 4 ]`
              
              It is useful to consider the operation as transforming a 6-D Tensor.
              e.g. for data_format = NHWC,
                   Each element in the input tensor can be specified via 6 coordinates,
                   ordered by decreasing memory layout significance as:
                   n,oY,bY,oX,bX,iC  (where n=batch index, oX, oY means X or Y coordinates
                                      within the output image, bX, bY means coordinates
                                      within the input block, iC means input channels).
                   The output would be a transpose to the following layout:
                   n,oY,oX,bY,bX,iC
              
              This operation is useful for resizing the activations between convolutions
              (but keeping all data), e.g. instead of pooling. It is also useful for training
              purely convolutional models.
              
              For example, given an input of shape `[1, 2, 2, 1]`, data_format = "NHWC" and
              block_size = 2:
              
              ```
              x = [[[[1], [2]],
                    [[3], [4]]]]
              ```
              
              This operation will output a tensor of shape `[1, 1, 1, 4]`:
              
              ```
              [[[[1, 2, 3, 4]]]]
              ```
              
              Here, the input has a batch of 1 and each batch element has shape `[2, 2, 1]`,
              the corresponding output will have a single element (i.e. width and height are
              both 1) and will have a depth of 4 channels (1 * block_size * block_size).
              The output element shape is `[1, 1, 4]`.
              
              For an input tensor with larger depth, here of shape `[1, 2, 2, 3]`, e.g.
              
              ```
              x = [[[[1, 2, 3], [4, 5, 6]],
                    [[7, 8, 9], [10, 11, 12]]]]
              ```
              
              This operation, for block_size of 2, will return the following tensor of shape
              `[1, 1, 1, 12]`
              
              ```
              [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]
              ```
              
              Similarly, for the following input of shape `[1 4 4 1]`, and a block size of 2:
              
              ```
              x = [[[[1],   [2],  [5],  [6]],
                    [[3],   [4],  [7],  [8]],
                    [[9],  [10], [13],  [14]],
                    [[11], [12], [15],  [16]]]]
              ```
              
              the operator will return the following tensor of shape `[1 2 2 4]`:
              
              ```
              x = [[[[1, 2, 3, 4],
                     [5, 6, 7, 8]],
                    [[9, 10, 11, 12],
                     [13, 14, 15, 16]]]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseAccumulatorApplyGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Boolean,System.String)">
            <summary>
              Applies a sparse gradient to a given accumulator.
            </summary>
            <param name="handle">
              The handle to a accumulator.
            </param>
            <param name="local_step">
              The local_step value at which the sparse gradient was computed.
            </param>
            <param name="gradient_indices">
              Indices of the sparse gradient to be accumulated. Must be a
              vector.
            </param>
            <param name="gradient_values">
              Values are the non-zero slices of the gradient, and must have
              the same first dimension as indices, i.e., the nnz represented by indices and
              values must be consistent.
            </param>
            <param name="gradient_shape">
              Shape of the sparse gradient to be accumulated.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAccumulatorApplyGradient'.
            </param>
            <param name="has_known_shape">
              Boolean indicating whether gradient_shape is unknown, in which
              case the input is ignored during validation.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              Does not add if local_step is smaller than the accumulator's
              global_step.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseAccumulatorTakeGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Extracts the average sparse gradient in a SparseConditionalAccumulator.
            </summary>
            <param name="handle">
              The handle to a SparseConditionalAccumulator.
            </param>
            <param name="num_required">
              Number of gradients required before we return an aggregate.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAccumulatorTakeGradient'.
            </param>
            <param name="dtype">
              The data type of accumulated gradients. Needs to correspond to the type
              of the accumulator.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              indices: Indices of the average of the accumulated sparse gradients.
              values: Values of the average of the accumulated sparse gradients.
              shape: Shape of the average of the accumulated sparse gradients.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              The op will blocks until sufficient (i.e., more than num_required)
              gradients have been accumulated. If the accumulator has already
              aggregated more than num_required gradients, it will return its
              average of the accumulated gradients.  Also automatically increments
              the recorded global_step in the accumulator by 1, and resets the
              aggregate to 0.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Adds two `SparseTensor` objects to produce another `SparseTensor`.
            </summary>
            <param name="a_indices">
              2-D.  The `indices` of the first `SparseTensor`, size `[nnz, ndims]` Matrix.
            </param>
            <param name="a_values">
              1-D.  The `values` of the first `SparseTensor`, size `[nnz]` Vector.
            </param>
            <param name="a_shape">
              1-D.  The `shape` of the first `SparseTensor`, size `[ndims]` Vector.
            </param>
            <param name="b_indices">
              2-D.  The `indices` of the second `SparseTensor`, size `[nnz, ndims]` Matrix.
            </param>
            <param name="b_values">
              1-D.  The `values` of the second `SparseTensor`, size `[nnz]` Vector.
            </param>
            <param name="b_shape">
              1-D.  The `shape` of the second `SparseTensor`, size `[ndims]` Vector.
            </param>
            <param name="thresh">
              0-D.  The magnitude threshold that determines if an output value/index
              pair takes space.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAdd'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              sum_indices: 
              sum_values: 
              sum_shape: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              The input `SparseTensor` objects' indices are assumed ordered in standard
              lexicographic order.  If this is not the case, before this step run
              `SparseReorder` to restore index ordering.
              
              By default, if two values sum to zero at some index, the output `SparseTensor`
              would still include that particular location in its index, storing a zero in the
              corresponding value slot.  To override this, callers can specify `thresh`,
              indicating that if the sum has a magnitude strictly smaller than `thresh`, its
              corresponding value and index would then not be included.  In particular,
              `thresh == 0` (default) means everything is kept and actual thresholding happens
              only for a positive value.
              
              In the following shapes, `nnz` is the count after taking `thresh` into account.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseAddGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              The gradient operator for the SparseAdd op.
            </summary>
            <param name="backprop_val_grad">
              1-D with shape `[nnz(sum)]`.  The gradient with respect to
              the non-empty values of the sum.
            </param>
            <param name="a_indices">
              2-D.  The `indices` of the `SparseTensor` A, size `[nnz(A), ndims]`.
            </param>
            <param name="b_indices">
              2-D.  The `indices` of the `SparseTensor` B, size `[nnz(B), ndims]`.
            </param>
            <param name="sum_indices">
              2-D.  The `indices` of the sum `SparseTensor`, size
              `[nnz(sum), ndims]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAddGrad'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              a_val_grad: 1-D with shape `[nnz(A)]`. The gradient with respect to the
              non-empty values of A.
              b_val_grad: 1-D with shape `[nnz(B)]`. The gradient with respect to the
              non-empty values of B.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              The SparseAdd op calculates A + B, where A, B, and the sum are all represented
              as `SparseTensor` objects.  This op takes in the upstream gradient w.r.t.
              non-empty values of the sum, and outputs the gradients w.r.t. the non-empty
              values of A and B.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              var: Should be from a Variable().
            </summary>
            <param name="var">
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="accum_update">
              : Should be from a Variable().
            </param>
            <param name="lr">
              Learning rate. Must be a scalar.
            </param>
            <param name="rho">
              Decay factor. Must be a scalar.
            </param>
            <param name="epsilon">
              Constant factor. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdadelta'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update relevant entries in '*var' and '*accum' according to the adagrad scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="lr">
              Learning rate. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdagrad'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              That is for rows we have grad for, we update var and accum as follows:
              accum += grad * grad
              var -= lr * grad * (1 / sqrt(accum))
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update entries in '*var' and '*accum' according to the proximal adagrad scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="gradient_accumulator">
              Should be from a Variable().
            </param>
            <param name="gradient_squared_accumulator">
              Should be from a Variable().
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="lr">
              Learning rate. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="global_step">
              Training step number. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdagradDA'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the centered RMSProp algorithm.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="mg">
              Should be from a Variable().
            </param>
            <param name="ms">
              Should be from a Variable().
            </param>
            <param name="mom">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="rho">
              Decay rate. Must be a scalar.
            </param>
            <param name="momentum">
            </param>
            <param name="epsilon">
              Ridge term. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var, ms and mom.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyCenteredRMSProp'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var, mg, ms, and mom tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The centered RMSProp algorithm uses an estimate of the centered second moment
              (i.e., the variance) for normalization, as opposed to regular RMSProp, which
              uses the (uncentered) second moment. This often helps with training, but is
              slightly more expensive in terms of computation and memory.
              
              Note that in dense implementation of this algorithm, mg, ms, and mom will
              update even if the grad is zero, but in this sparse implementation, mg, ms,
              and mom will not update in iterations during which the grad is zero.
              
              mean_square = decay * mean_square + (1-decay) * gradient ** 2
              mean_grad = decay * mean_grad + (1-decay) * gradient
              Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)
              
              ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
              mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
              var &amp;lt;- var - mom
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update relevant entries in '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="linear">
              Should be from a Variable().
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="lr_power">
              Scaling factor. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyFtrl'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              That is for rows we have grad for, we update var, accum and linear as follows:
              accum_new = accum + grad * grad
              linear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
              accum = accum_new
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update relevant entries in '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="linear">
              Should be from a Variable().
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 shrinkage regulariation. Must be a scalar.
            </param>
            <param name="l2_shrinkage">
            </param>
            <param name="lr_power">
              Scaling factor. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyFtrlV2'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              That is for rows we have grad for, we update var, accum and linear as follows:
              grad_with_shrinkage = grad + 2 * l2_shrinkage * var
              accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
              linear += grad_with_shrinkage +
                  (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0
              accum = accum_new
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Update relevant entries in '*var' and '*accum' according to the momentum scheme.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="lr">
              Learning rate. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="momentum">
              Momentum. Must be a scalar.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyMomentum'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <param name="use_nesterov">
              Optional argument
              If `True`, the tensor passed to compute grad will be
              var - lr * momentum * accum, so in the end, the var you get is actually
              var - lr * momentum * accum.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Set use_nesterov = True if you want to use Nesterov momentum.
              
              That is for rows we have grad for, we update var and accum as follows:
              
              accum = accum * momentum + grad
              var -= lr * accum
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="accum">
              Should be from a Variable().
            </param>
            <param name="lr">
              Learning rate. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyProximalAdagrad'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              That is for rows we have grad for, we update var and accum as follows:
              accum += grad * grad
              prox_v = var
              prox_v -= lr * grad * (1 / sqrt(accum))
              var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Sparse update '*var' as FOBOS algorithm with fixed learning rate.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="alpha">
              Scaling factor. Must be a scalar.
            </param>
            <param name="l1">
              L1 regularization. Must be a scalar.
            </param>
            <param name="l2">
              L2 regularization. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var and accum.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyProximalGradientDescent'.
            </param>
            <param name="use_locking">
              Optional argument
              If True, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              That is for rows we have grad for, we update var as follows:
              prox_v = var - alpha * grad
              var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Update '*var' according to the RMSProp algorithm.
            </summary>
            <param name="var">
              Should be from a Variable().
            </param>
            <param name="ms">
              Should be from a Variable().
            </param>
            <param name="mom">
              Should be from a Variable().
            </param>
            <param name="lr">
              Scaling factor. Must be a scalar.
            </param>
            <param name="rho">
              Decay rate. Must be a scalar.
            </param>
            <param name="momentum">
            </param>
            <param name="epsilon">
              Ridge term. Must be a scalar.
            </param>
            <param name="grad">
              The gradient.
            </param>
            <param name="indices">
              A vector of indices into the first dimension of var, ms and mom.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyRMSProp'.
            </param>
            <param name="use_locking">
              Optional argument
              If `True`, updating of the var, ms, and mom tensors is protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.
            </param>
            <returns>
              Same as "var".
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Note that in dense implementation of this algorithm, ms and mom will
              update even if the grad is zero, but in this sparse implementation, ms
              and mom will not update in iterations during which the grad is zero.
              
              mean_square = decay * mean_square + (1-decay) * gradient ** 2
              Delta = learning_rate * gradient / sqrt(mean_square + epsilon)
              
              ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
              mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
              var &amp;lt;- var - mom
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseConcat(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.Int64,System.String)">
            <summary>
              Concatenates a list of `SparseTensor` along the specified dimension.
            </summary>
            <param name="indices">
              2-D.  Indices of each input `SparseTensor`.
            </param>
            <param name="values">
              1-D.  Non-empty values of each `SparseTensor`.
            </param>
            <param name="shapes">
              1-D.  Shapes of each `SparseTensor`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseConcat'.
            </param>
            <param name="concat_dim">
              Dimension to concatenate along. Must be in range [-rank, rank),
              where rank is the number of dimensions in each input `SparseTensor`.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_indices: 2-D.  Indices of the concatenated `SparseTensor`.
              output_values: 1-D.  Non-empty values of the concatenated `SparseTensor`.
              output_shape: 1-D.  Shape of the concatenated `SparseTensor`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Concatenation is with respect to the dense versions of these sparse tensors.
              It is assumed that each input is a `SparseTensor` whose elements are ordered
              along increasing dimension number.
              
              All inputs' shapes must match, except for the concat dimension.  The
              `indices`, `values`, and `shapes` lists must have the same length.
              
              The output shape is identical to the inputs', except along the concat
              dimension, where it is the sum of the inputs' sizes along that dimension.
              
              The output elements will be resorted to preserve the sort order along
              increasing dimension number.
              
              This op runs in `O(M log M)` time, where `M` is the total number of non-empty
              values across all inputs. This is due to the need for an internal sort in
              order to concatenate efficiently across an arbitrary dimension.
              
              For example, if `concat_dim = 1` and the inputs are
              
                  sp_inputs[0]: shape = [2, 3]
                  [0, 2]: "a"
                  [1, 0]: "b"
                  [1, 1]: "c"
              
                  sp_inputs[1]: shape = [2, 4]
                  [0, 1]: "d"
                  [0, 2]: "e"
              
              then the output will be
              
                  shape = [2, 7]
                  [0, 2]: "a"
                  [0, 4]: "d"
                  [0, 5]: "e"
                  [1, 0]: "b"
                  [1, 1]: "c"
              
              Graphically this is equivalent to doing
              
                  [    a] concat [  d e  ] = [    a   d e  ]
                  [b c  ]        [       ]   [b c          ]
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseConditionalAccumulator(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String)">
            <summary>
              A conditional accumulator for aggregating sparse gradients.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseConditionalAccumulator'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this accumulator is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this accumulator will be shared under the given name
              across multiple sessions.
            </param>
            <param name="dtype">
              The type of the value being accumulated.
            </param>
            <param name="shape">
              The shape of the values.
            </param>
            <returns>
              The handle to the accumulator.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The accumulator accepts gradients marked with local_step greater or
              equal to the most recent global_step known to the accumulator. The
              average can be extracted from the accumulator, provided sufficient
              gradients have been accumulated. Extracting the average automatically
              resets the aggregate to 0, and increments the global_step recorded by
              the accumulator.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseCross(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.Boolean,System.Int64,System.Int64,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)">
            <summary>
              Generates sparse cross from a list of sparse and dense tensors.
            </summary>
            <param name="indices">
              2-D.  Indices of each input `SparseTensor`.
            </param>
            <param name="values">
              1-D.   values of each `SparseTensor`.
            </param>
            <param name="shapes">
              1-D.   Shapes of each `SparseTensor`.
            </param>
            <param name="dense_inputs">
              2-D.    Columns represented by dense `Tensor`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseCross'.
            </param>
            <param name="hashed_output">
              If true, returns the hash of the cross instead of the string.
              This will allow us avoiding string manipulations.
            </param>
            <param name="num_buckets">
              It is used if hashed_output is true.
              output = hashed_value%num_buckets if num_buckets &amp;gt; 0 else hashed_value.
            </param>
            <param name="hash_key">
              Specify the hash_key that will be used by the `FingerprintCat64`
              function to combine the crosses fingerprints.
            </param>
            <param name="out_type">
            </param>
            <param name="internal_type">
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_indices: 2-D.  Indices of the concatenated `SparseTensor`.
              output_values: 1-D.  Non-empty values of the concatenated or hashed
              `SparseTensor`.
              output_shape: 1-D.  Shape of the concatenated `SparseTensor`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              The op takes two lists, one of 2D `SparseTensor` and one of 2D `Tensor`, each
              representing features of one feature column. It outputs a 2D `SparseTensor` with
              the batchwise crosses of these features.
              
              For example, if the inputs are
              
                  inputs[0]: SparseTensor with shape = [2, 2]
                  [0, 0]: "a"
                  [1, 0]: "b"
                  [1, 1]: "c"
              
                  inputs[1]: SparseTensor with shape = [2, 1]
                  [0, 0]: "d"
                  [1, 0]: "e"
              
                  inputs[2]: Tensor [["f"], ["g"]]
              
              then the output will be
              
                  shape = [2, 2]
                  [0, 0]: "a_X_d_X_f"
                  [1, 0]: "b_X_e_X_g"
                  [1, 1]: "c_X_e_X_g"
              
              if hashed_output=true then the output will be
              
                  shape = [2, 2]
                  [0, 0]: FingerprintCat64(
                              Fingerprint64("f"), FingerprintCat64(
                                  Fingerprint64("d"), Fingerprint64("a")))
                  [1, 0]: FingerprintCat64(
                              Fingerprint64("g"), FingerprintCat64(
                                  Fingerprint64("e"), Fingerprint64("b")))
                  [1, 1]: FingerprintCat64(
                              Fingerprint64("g"), FingerprintCat64(
                                  Fingerprint64("e"), Fingerprint64("c")))
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseDenseCwiseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Adds up a SparseTensor and a dense Tensor, using these special rules:
            </summary>
            <param name="sp_indices">
              2-D.  `N x R` matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.
            </param>
            <param name="sp_values">
              1-D.  `N` non-empty values corresponding to `sp_indices`.
            </param>
            <param name="sp_shape">
              1-D.  Shape of the input SparseTensor.
            </param>
            <param name="dense">
              `R`-D.  The dense Tensor operand.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseDenseCwiseAdd'.
            </param>
            <returns>
              1-D.  The `N` values that are operated on.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              (1) Broadcasts the dense side to have the same shape as the sparse side, if
                  eligible;
              (2) Then, only the dense values pointed to by the indices of the SparseTensor
                  participate in the cwise addition.
              
              By these rules, the result is a logical SparseTensor with exactly the same
              indices and shape, but possibly with different non-zero values.  The output of
              this Op is the resultant non-zero values.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseDenseCwiseDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Component-wise divides a SparseTensor by a dense Tensor.
            </summary>
            <param name="sp_indices">
              2-D.  `N x R` matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.
            </param>
            <param name="sp_values">
              1-D.  `N` non-empty values corresponding to `sp_indices`.
            </param>
            <param name="sp_shape">
              1-D.  Shape of the input SparseTensor.
            </param>
            <param name="dense">
              `R`-D.  The dense Tensor operand.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseDenseCwiseDiv'.
            </param>
            <returns>
              1-D.  The `N` values that are operated on.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *Limitation*: this Op only broadcasts the dense side to the sparse side, but not
              the other direction.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseDenseCwiseMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Component-wise multiplies a SparseTensor by a dense Tensor.
            </summary>
            <param name="sp_indices">
              2-D.  `N x R` matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.
            </param>
            <param name="sp_values">
              1-D.  `N` non-empty values corresponding to `sp_indices`.
            </param>
            <param name="sp_shape">
              1-D.  Shape of the input SparseTensor.
            </param>
            <param name="dense">
              `R`-D.  The dense Tensor operand.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseDenseCwiseMul'.
            </param>
            <returns>
              1-D.  The `N` values that are operated on.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The output locations corresponding to the implicitly zero elements in the sparse
              tensor will be zero (i.e., will not take up storage space), regardless of the
              contents of the dense tensor (even if it's +/-INF and that INF*0 == NaN).
              
              *Limitation*: this Op only broadcasts the dense side to the sparse side, but not
              the other direction.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseFillEmptyRows(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Fills empty rows in the input 2-D `SparseTensor` with a default value.
            </summary>
            <param name="indices">
              2-D. the indices of the sparse tensor.
            </param>
            <param name="values">
              1-D. the values of the sparse tensor.
            </param>
            <param name="dense_shape">
              1-D. the shape of the sparse tensor.
            </param>
            <param name="default_value">
              0-D. default value to insert into location `[row, 0, ..., 0]`
                for rows missing from the input sparse tensor.
              output indices: 2-D. the indices of the filled sparse tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseFillEmptyRows'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_indices: 
              output_values: 1-D. the values of the filled sparse tensor.
              empty_row_indicator: 1-D. whether the dense row was missing in the
              input sparse tensor.
              reverse_index_map: 1-D. a map from the input indices to the output indices.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              The input `SparseTensor` is represented via the tuple of inputs
              (`indices`, `values`, `dense_shape`).  The output `SparseTensor` has the
              same `dense_shape` but with indices `output_indices` and values
              `output_values`.
              
              This op inserts a single entry for every row that doesn't have any values.
              The index is created as `[row, 0, ..., 0]` and the inserted value
              is `default_value`.
              
              For example, suppose `sp_input` has shape `[5, 6]` and non-empty values:
              
                  [0, 1]: a
                  [0, 3]: b
                  [2, 0]: c
                  [3, 1]: d
              
              Rows 1 and 4 are empty, so the output will be of shape `[5, 6]` with values:
              
                  [0, 1]: a
                  [0, 3]: b
                  [1, 0]: default_value
                  [2, 0]: c
                  [3, 1]: d
                  [4, 0]: default_value
              
              The output `SparseTensor` will be in row-major order and will have the
              same shape as the input.
              
              This op also returns an indicator vector shaped `[dense_shape[0]]` such that
              
                  empty_row_indicator[i] = True iff row i was an empty row.
              
              And a reverse index map vector shaped `[indices.shape[0]]` that is used during
              backpropagation,
              
                  reverse_index_map[j] = out_j s.t. indices[j, :] == output_indices[out_j, :]
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseFillEmptyRowsGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              The gradient of SparseFillEmptyRows.
            </summary>
            <param name="reverse_index_map">
              1-D.  The reverse index map from SparseFillEmptyRows.
            </param>
            <param name="grad_values">
              1-D.  The gradients from backprop.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseFillEmptyRowsGrad'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              d_values: 1-D.  The backprop into values.
              d_default_value: 0-D.  The backprop into default_value.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Takes vectors reverse_index_map, shaped `[N]`, and grad_values,
              shaped `[N_full]`, where `N_full &amp;gt;= N` and copies data into either
              `d_values` or `d_default_value`.  Here `d_values` is shaped `[N]` and
              `d_default_value` is a scalar.
              
                d_values[j] = grad_values[reverse_index_map[j]]
                d_default_value = sum_{k : 0 .. N_full - 1} (
                   grad_values[k] * 1{k not in reverse_index_map})
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Multiply matrix "a" by matrix "b".
            </summary>
            <param name="a">
            </param>
            <param name="b">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseMatMul'.
            </param>
            <param name="transpose_a">
              Optional argument
            </param>
            <param name="transpose_b">
              Optional argument
            </param>
            <param name="a_is_sparse">
              Optional argument
            </param>
            <param name="b_is_sparse">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The inputs must be two-dimensional matrices and the inner dimension of "a" must
              match the outer dimension of "b". This op is optimized for the case where at
              least one of "a" or "b" is sparse. The breakeven for using this versus a dense
              matrix multiply on one platform was 30% zero values in the sparse matrix.
              
              The gradient computation of this operation will only take advantage of sparsity
              in the input gradient when that gradient comes from a Relu.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseReduceMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the max of elements across dimensions of a SparseTensor.
            </summary>
            <param name="input_indices">
              2-D.  `N x R` matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.
            </param>
            <param name="input_values">
              1-D.  `N` non-empty values corresponding to `input_indices`.
            </param>
            <param name="input_shape">
              1-D.  Shape of the input SparseTensor.
            </param>
            <param name="reduction_axes">
              1-D.  Length-`K` vector containing the reduction axes.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceMax'.
            </param>
            <param name="keep_dims">
              Optional argument
              If true, retain reduced dimensions with length 1.
            </param>
            <returns>
              `R-K`-D.  The reduced Tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This Op takes a SparseTensor and is the sparse counterpart to
              `tf.reduce_max()`.  In particular, this Op also returns a dense `Tensor`
              instead of a sparse one.
              
              Reduces `sp_input` along the dimensions given in `reduction_axes`.  Unless
              `keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
              `reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained
              with length 1.
              
              If `reduction_axes` has no entries, all dimensions are reduced, and a tensor
              with a single element is returned.  Additionally, the axes can be negative,
              which are interpreted according to the indexing rules in Python.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseReduceMaxSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the max of elements across dimensions of a SparseTensor.
            </summary>
            <param name="input_indices">
              2-D.  `N x R` matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.
            </param>
            <param name="input_values">
              1-D.  `N` non-empty values corresponding to `input_indices`.
            </param>
            <param name="input_shape">
              1-D.  Shape of the input SparseTensor.
            </param>
            <param name="reduction_axes">
              1-D.  Length-`K` vector containing the reduction axes.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceMaxSparse'.
            </param>
            <param name="keep_dims">
              Optional argument
              If true, retain reduced dimensions with length 1.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_indices: 
              output_values: 
              output_shape: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              This Op takes a SparseTensor and is the sparse counterpart to
              `tf.reduce_max()`.  In contrast to SparseReduceMax, this Op returns a
              SparseTensor.
              
              Reduces `sp_input` along the dimensions given in `reduction_axes`.  Unless
              `keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
              `reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained
              with length 1.
              
              If `reduction_axes` has no entries, all dimensions are reduced, and a tensor
              with a single element is returned.  Additionally, the axes can be negative,
              which are interpreted according to the indexing rules in Python.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseReduceSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the sum of elements across dimensions of a SparseTensor.
            </summary>
            <param name="input_indices">
              2-D.  `N x R` matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.
            </param>
            <param name="input_values">
              1-D.  `N` non-empty values corresponding to `input_indices`.
            </param>
            <param name="input_shape">
              1-D.  Shape of the input SparseTensor.
            </param>
            <param name="reduction_axes">
              1-D.  Length-`K` vector containing the reduction axes.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceSum'.
            </param>
            <param name="keep_dims">
              Optional argument
              If true, retain reduced dimensions with length 1.
            </param>
            <returns>
              `R-K`-D.  The reduced Tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This Op takes a SparseTensor and is the sparse counterpart to
              `tf.reduce_sum()`.  In particular, this Op also returns a dense `Tensor`
              instead of a sparse one.
              
              Reduces `sp_input` along the dimensions given in `reduction_axes`.  Unless
              `keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
              `reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained
              with length 1.
              
              If `reduction_axes` has no entries, all dimensions are reduced, and a tensor
              with a single element is returned.  Additionally, the axes can be negative,
              which are interpreted according to the indexing rules in Python.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseReduceSumSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the sum of elements across dimensions of a SparseTensor.
            </summary>
            <param name="input_indices">
              2-D.  `N x R` matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.
            </param>
            <param name="input_values">
              1-D.  `N` non-empty values corresponding to `input_indices`.
            </param>
            <param name="input_shape">
              1-D.  Shape of the input SparseTensor.
            </param>
            <param name="reduction_axes">
              1-D.  Length-`K` vector containing the reduction axes.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceSumSparse'.
            </param>
            <param name="keep_dims">
              Optional argument
              If true, retain reduced dimensions with length 1.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_indices: 
              output_values: 
              output_shape: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              This Op takes a SparseTensor and is the sparse counterpart to
              `tf.reduce_sum()`.  In contrast to SparseReduceSum, this Op returns a
              SparseTensor.
              
              Reduces `sp_input` along the dimensions given in `reduction_axes`.  Unless
              `keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
              `reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained
              with length 1.
              
              If `reduction_axes` has no entries, all dimensions are reduced, and a tensor
              with a single element is returned.  Additionally, the axes can be negative,
              which are interpreted according to the indexing rules in Python.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseReorder(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Reorders a SparseTensor into the canonical, row-major ordering.
            </summary>
            <param name="input_indices">
              2-D.  `N x R` matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.
            </param>
            <param name="input_values">
              1-D.  `N` non-empty values corresponding to `input_indices`.
            </param>
            <param name="input_shape">
              1-D.  Shape of the input SparseTensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReorder'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_indices: 2-D.  `N x R` matrix with the same indices as input_indices, but
              in canonical row-major ordering.
              output_values: 1-D.  `N` non-empty values corresponding to `output_indices`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Note that by convention, all sparse ops preserve the canonical ordering along
              increasing dimension number. The only time ordering can be violated is during
              manual manipulation of the indices and values vectors to add entries.
              
              Reordering does not affect the shape of the SparseTensor.
              
              If the tensor has rank `R` and `N` non-empty values, `input_indices` has
              shape `[N, R]`, input_values has length `N`, and input_shape has length `R`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseReshape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Reshapes a SparseTensor to represent values in a new dense shape.
            </summary>
            <param name="input_indices">
              2-D.  `N x R_in` matrix with the indices of non-empty values in a
              SparseTensor.
            </param>
            <param name="input_shape">
              1-D.  `R_in` vector with the input SparseTensor's dense shape.
            </param>
            <param name="new_shape">
              1-D.  `R_out` vector with the requested new dense shape.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReshape'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_indices: 2-D.  `N x R_out` matrix with the updated indices of non-empty
              values in the output SparseTensor.
              output_shape: 1-D.  `R_out` vector with the full dense shape of the output
              SparseTensor.  This is the same as `new_shape` but with any -1 dimensions
              filled in.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              This operation has the same semantics as reshape on the represented dense
              tensor.  The `input_indices` are recomputed based on the requested `new_shape`.
              
              If one component of `new_shape` is the special value -1, the size of that
              dimension is computed so that the total dense size remains constant.  At
              most one component of `new_shape` can be -1.  The number of dense elements
              implied by `new_shape` must be the same as the number of dense elements
              originally implied by `input_shape`.
              
              Reshaping does not affect the order of values in the SparseTensor.
              
              If the input tensor has rank `R_in` and `N` non-empty values, and `new_shape`
              has length `R_out`, then `input_indices` has shape `[N, R_in]`,
              `input_shape` has length `R_in`, `output_indices` has shape `[N, R_out]`, and
              `output_shape` has length `R_out`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSegmentMean(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the mean along sparse segments of a tensor.
            </summary>
            <param name="data">
            </param>
            <param name="indices">
              A 1-D tensor. Has same rank as `segment_ids`.
            </param>
            <param name="segment_ids">
              A 1-D tensor. Values should be sorted and can be repeated.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentMean'.
            </param>
            <returns>
              Has same shape as data, except for dimension 0 which
              has size `k`, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Read @{$math_ops#segmentation$the section on segmentation} for an explanation of
              segments.
              
              Like `SegmentMean`, but `segment_ids` can have rank less than `data`'s first
              dimension, selecting a subset of dimension 0, specified by `indices`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSegmentMeanGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes gradients for SparseSegmentMean.
            </summary>
            <param name="grad">
              gradient propagated to the SparseSegmentMean op.
            </param>
            <param name="indices">
              indices passed to the corresponding SparseSegmentMean op.
            </param>
            <param name="segment_ids">
              segment_ids passed to the corresponding SparseSegmentMean op.
            </param>
            <param name="output_dim0">
              dimension 0 of "data" passed to SparseSegmentMean op.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentMeanGrad'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Returns tensor "output" with same shape as grad, except for dimension 0 whose
              value is output_dim0.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSegmentMeanWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the mean along sparse segments of a tensor.
            </summary>
            <param name="data">
            </param>
            <param name="indices">
              A 1-D tensor. Has same rank as `segment_ids`.
            </param>
            <param name="segment_ids">
              A 1-D tensor. Values should be sorted and can be repeated.
            </param>
            <param name="num_segments">
              Should equal the number of distinct segment IDs.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentMeanWithNumSegments'.
            </param>
            <returns>
              Has same shape as data, except for dimension 0 which has size
              `num_segments`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Like `SparseSegmentMean`, but allows missing ids in `segment_ids`. If an id is
              misisng, the `output` tensor at that position will be zeroed.
              
              Read @{$math_ops#segmentation$the section on segmentation} for an explanation of
              segments.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSegmentSqrtN(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the sum along sparse segments of a tensor divided by the sqrt of N.
            </summary>
            <param name="data">
            </param>
            <param name="indices">
              A 1-D tensor. Has same rank as `segment_ids`.
            </param>
            <param name="segment_ids">
              A 1-D tensor. Values should be sorted and can be repeated.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSqrtN'.
            </param>
            <returns>
              Has same shape as data, except for dimension 0 which
              has size `k`, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              N is the size of the segment being reduced.
              
              Read @{$math_ops#segmentation$the section on segmentation} for an explanation of
              segments.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSegmentSqrtNGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes gradients for SparseSegmentSqrtN.
            </summary>
            <param name="grad">
              gradient propagated to the SparseSegmentSqrtN op.
            </param>
            <param name="indices">
              indices passed to the corresponding SparseSegmentSqrtN op.
            </param>
            <param name="segment_ids">
              segment_ids passed to the corresponding SparseSegmentSqrtN op.
            </param>
            <param name="output_dim0">
              dimension 0 of "data" passed to SparseSegmentSqrtN op.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSqrtNGrad'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Returns tensor "output" with same shape as grad, except for dimension 0 whose
              value is output_dim0.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSegmentSqrtNWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the sum along sparse segments of a tensor divided by the sqrt of N.
            </summary>
            <param name="data">
            </param>
            <param name="indices">
              A 1-D tensor. Has same rank as `segment_ids`.
            </param>
            <param name="segment_ids">
              A 1-D tensor. Values should be sorted and can be repeated.
            </param>
            <param name="num_segments">
              Should equal the number of distinct segment IDs.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSqrtNWithNumSegments'.
            </param>
            <returns>
              Has same shape as data, except for dimension 0 which
              has size `k`, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              N is the size of the segment being reduced.
              
              Like `SparseSegmentSqrtN`, but allows missing ids in `segment_ids`. If an id is
              misisng, the `output` tensor at that position will be zeroed.
              
              Read @{$math_ops#segmentation$the section on segmentation} for an explanation of
              segments.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the sum along sparse segments of a tensor.
            </summary>
            <param name="data">
            </param>
            <param name="indices">
              A 1-D tensor. Has same rank as `segment_ids`.
            </param>
            <param name="segment_ids">
              A 1-D tensor. Values should be sorted and can be repeated.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSum'.
            </param>
            <returns>
              Has same shape as data, except for dimension 0 which
              has size `k`, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Read @{$math_ops#segmentation$the section on segmentation} for an explanation of
              segments.
              
              Like `SegmentSum`, but `segment_ids` can have rank less than `data`'s first
              dimension, selecting a subset of dimension 0, specified by `indices`.
              
              For example:
              
              ```python
              c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])
              
              # Select two rows, one segment.
              tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))
              # =&amp;gt; [[0 0 0 0]]
              
              # Select two rows, two segment.
              tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))
              # =&amp;gt; [[ 1  2  3  4]
              #     [-1 -2 -3 -4]]
              
              # Select all rows, two segments.
              tf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))
              # =&amp;gt; [[0 0 0 0]
              #     [5 6 7 8]]
              
              # Which is equivalent to:
              tf.segment_sum(c, tf.constant([0, 0, 1]))
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSegmentSumWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the sum along sparse segments of a tensor.
            </summary>
            <param name="data">
            </param>
            <param name="indices">
              A 1-D tensor. Has same rank as `segment_ids`.
            </param>
            <param name="segment_ids">
              A 1-D tensor. Values should be sorted and can be repeated.
            </param>
            <param name="num_segments">
              Should equal the number of distinct segment IDs.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSumWithNumSegments'.
            </param>
            <returns>
              Has same shape as data, except for dimension 0 which
              has size `num_segments`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Like `SparseSegmentSum`, but allows missing ids in `segment_ids`. If an id is
              misisng, the `output` tensor at that position will be zeroed.
              
              Read @{$math_ops#segmentation$the section on segmentation} for an explanation of
              segments.
              
              For example:
              
              ```python
              c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])
              
              tf.sparse_segment_sum_with_num_segments(
                  c, tf.constant([0, 1]), tf.constant([0, 0]), num_segments=3)
              # =&amp;gt; [[0 0 0 0]
              #     [0 0 0 0]
              #     [0 0 0 0]]
              
              tf.sparse_segment_sum_with_num_segments(c,
                                                      tf.constant([0, 1]),
                                                      tf.constant([0, 2],
                                                      num_segments=4))
              # =&amp;gt; [[ 1  2  3  4]
              #     [ 0  0  0  0]
              #     [-1 -2 -3 -4]
              #     [ 0  0  0  0]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Slice a `SparseTensor` based on the `start` and `size`.
            </summary>
            <param name="indices">
              2-D tensor represents the indices of the sparse tensor.
            </param>
            <param name="values">
              1-D tensor represents the values of the sparse tensor.
            </param>
            <param name="shape">
              1-D. tensor represents the shape of the sparse tensor.
            </param>
            <param name="start">
              1-D. tensor represents the start of the slice.
            </param>
            <param name="size">
              1-D. tensor represents the size of the slice.
              output indices: A list of 1-D tensors represents the indices of the output
              sparse tensors.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSlice'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_indices: 
              output_values: A list of 1-D tensors represents the values of the output sparse
              tensors.
              output_shape: A list of 1-D tensors represents the shape of the output sparse
              tensors.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              For example, if the input is
              
                  input_tensor = shape = [2, 7]
                  [    a   d e  ]
                  [b c          ]
              
              Graphically the output tensors are:
              
                  sparse_slice([0, 0], [2, 4]) = shape = [2, 4]
                  [    a  ]
                  [b c    ]
              
                  sparse_slice([0, 4], [2, 3]) = shape = [2, 3]
                  [ d e  ]
                  [      ]
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSoftmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Applies softmax to a batched N-D `SparseTensor`.
            </summary>
            <param name="sp_indices">
              2-D.  `NNZ x R` matrix with the indices of non-empty values in a
              SparseTensor, in canonical ordering.
            </param>
            <param name="sp_values">
              1-D.  `NNZ` non-empty values corresponding to `sp_indices`.
            </param>
            <param name="sp_shape">
              1-D.  Shape of the input SparseTensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSoftmax'.
            </param>
            <returns>
              1-D.  The `NNZ` values for the result `SparseTensor`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The inputs represent an N-D SparseTensor  with logical shape `[..., B, C]`
              (where `N &amp;gt;= 2`), and with indices sorted in the canonical lexicographic order.
              
              This op is equivalent to applying the normal `tf.nn.softmax()` to each innermost
              logical submatrix with shape `[B, C]`, but with the catch that *the implicitly
              zero elements do not participate*.  Specifically, the algorithm is equivalent
              to the following:
              
                (1) Applies `tf.nn.softmax()` to a densified view of each innermost submatrix
                    with shape `[B, C]`, along the size-C dimension;
                (2) Masks out the original implicitly-zero locations;
                (3) Renormalizes the remaining elements.
              
              Hence, the `SparseTensor` result has exactly the same non-zero indices and
              shape.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSoftmaxCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes softmax cross entropy cost and gradients to backpropagate.
            </summary>
            <param name="features">
              batch_size x num_classes matrix
            </param>
            <param name="labels">
              batch_size vector with values in [0, num_classes).
              This is the label for the given minibatch entry.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSoftmaxCrossEntropyWithLogits'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              loss: Per example loss (batch_size vector).
              backprop: backpropagated gradients (batch_size x num_classes matrix).
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Unlike `SoftmaxCrossEntropyWithLogits`, this operation does not accept
              a matrix of label probabilities, but rather a single label per row
              of features.  This label is considered to have probability 1.0 for the
              given row.
              
              Inputs are the logits, not probabilities.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSparseMaximum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the element-wise max of two SparseTensors.
            </summary>
            <param name="a_indices">
              2-D.  `N x R` matrix with the indices of non-empty values in a
              SparseTensor, in the canonical lexicographic ordering.
            </param>
            <param name="a_values">
              1-D.  `N` non-empty values corresponding to `a_indices`.
            </param>
            <param name="a_shape">
              1-D.  Shape of the input SparseTensor.
            </param>
            <param name="b_indices">
              counterpart to `a_indices` for the other operand.
            </param>
            <param name="b_values">
              counterpart to `a_values` for the other operand; must be of the same dtype.
            </param>
            <param name="b_shape">
              counterpart to `a_shape` for the other operand; the two shapes must be equal.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSparseMaximum'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_indices: 2-D.  The indices of the output SparseTensor.
              output_values: 1-D.  The values of the output SparseTensor.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Assumes the two SparseTensors have the same shape, i.e., no broadcasting.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSparseMinimum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the element-wise min of two SparseTensors.
            </summary>
            <param name="a_indices">
              2-D.  `N x R` matrix with the indices of non-empty values in a
              SparseTensor, in the canonical lexicographic ordering.
            </param>
            <param name="a_values">
              1-D.  `N` non-empty values corresponding to `a_indices`.
            </param>
            <param name="a_shape">
              1-D.  Shape of the input SparseTensor.
            </param>
            <param name="b_indices">
              counterpart to `a_indices` for the other operand.
            </param>
            <param name="b_values">
              counterpart to `a_values` for the other operand; must be of the same dtype.
            </param>
            <param name="b_shape">
              counterpart to `a_shape` for the other operand; the two shapes must be equal.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSparseMinimum'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_indices: 2-D.  The indices of the output SparseTensor.
              output_values: 1-D.  The values of the output SparseTensor.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Assumes the two SparseTensors have the same shape, i.e., no broadcasting.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseSplit(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">
            <summary>
              Split a `SparseTensor` into `num_split` tensors along one dimension.
            </summary>
            <param name="split_dim">
              0-D.  The dimension along which to split.  Must be in the range
              `[0, rank(shape))`.
            </param>
            <param name="indices">
              2-D tensor represents the indices of the sparse tensor.
            </param>
            <param name="values">
              1-D tensor represents the values of the sparse tensor.
            </param>
            <param name="shape">
              1-D. tensor represents the shape of the sparse tensor.
              output indices: A list of 1-D tensors represents the indices of the output
              sparse tensors.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSplit'.
            </param>
            <param name="num_split">
              The number of ways to split.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_indices: 
              output_values: A list of 1-D tensors represents the values of the output sparse
              tensors.
              output_shape: A list of 1-D tensors represents the shape of the output sparse
              tensors.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              If the `shape[split_dim]` is not an integer multiple of `num_split`. Slices
              `[0 : shape[split_dim] % num_split]` gets one extra dimension.
              For example, if `split_dim = 1` and `num_split = 2` and the input is
              
                  input_tensor = shape = [2, 7]
                  [    a   d e  ]
                  [b c          ]
              
              Graphically the output tensors are:
              
                  output_tensor[0] = shape = [2, 4]
                  [    a  ]
                  [b c    ]
              
                  output_tensor[1] = shape = [2, 3]
                  [ d e  ]
                  [      ]
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseTensorDenseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Adds up a `SparseTensor` and a dense `Tensor`, producing a dense `Tensor`.
            </summary>
            <param name="a_indices">
              2-D.  The `indices` of the `SparseTensor`, with shape `[nnz, ndims]`.
            </param>
            <param name="a_values">
              1-D.  The `values` of the `SparseTensor`, with shape `[nnz]`.
            </param>
            <param name="a_shape">
              1-D.  The `shape` of the `SparseTensor`, with shape `[ndims]`.
            </param>
            <param name="b">
              `ndims`-D Tensor.  With shape `a_shape`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseTensorDenseAdd'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This Op does not require `a_indices` be sorted in standard lexicographic order.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseTensorDenseMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Multiply SparseTensor (of rank 2) "A" by dense matrix "B".
            </summary>
            <param name="a_indices">
              2-D.  The `indices` of the `SparseTensor`, size `[nnz, 2]` Matrix.
            </param>
            <param name="a_values">
              1-D.  The `values` of the `SparseTensor`, size `[nnz]` Vector.
            </param>
            <param name="a_shape">
              1-D.  The `shape` of the `SparseTensor`, size `[2]` Vector.
            </param>
            <param name="b">
              2-D.  A dense Matrix.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseTensorDenseMatMul'.
            </param>
            <param name="adjoint_a">
              Optional argument
              Use the adjoint of A in the matrix multiply.  If A is complex, this
              is transpose(conj(A)).  Otherwise it's transpose(A).
            </param>
            <param name="adjoint_b">
              Optional argument
              Use the adjoint of B in the matrix multiply.  If B is complex, this
              is transpose(conj(B)).  Otherwise it's transpose(B).
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              No validity checking is performed on the indices of A.  However, the following
              input format is recommended for optimal behavior:
              
              if adjoint_a == false:
                A should be sorted in lexicographically increasing order.  Use SparseReorder
                if you're not sure.
              if adjoint_a == true:
                A should be sorted in order of increasing dimension 1 (i.e., "column major"
                order instead of "row major" order).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseTensorSliceDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Creates a dataset that splits a SparseTensor into elements row-wise.
            </summary>
            <param name="indices">
            </param>
            <param name="values">
            </param>
            <param name="dense_shape">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseTensorSliceDataset'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseToDense(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Converts a sparse representation into a dense tensor.
            </summary>
            <param name="sparse_indices">
              0-D, 1-D, or 2-D.  `sparse_indices[i]` contains the complete
              index where `sparse_values[i]` will be placed.
            </param>
            <param name="output_shape">
              1-D.  Shape of the dense output tensor.
            </param>
            <param name="sparse_values">
              1-D.  Values corresponding to each row of `sparse_indices`,
              or a scalar value to be used for all sparse indices.
            </param>
            <param name="default_value">
              Scalar value to set for indices not specified in
              `sparse_indices`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseToDense'.
            </param>
            <param name="validate_indices">
              Optional argument
              If true, indices are checked to make sure they are sorted in
              lexicographic order and that there are no repeats.
            </param>
            <returns>
              Dense output tensor of shape `output_shape`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Builds an array `dense` with shape `output_shape` such that
              
              ```
              # If sparse_indices is scalar
              dense[i] = (i == sparse_indices ? sparse_values : default_value)
              
              # If sparse_indices is a vector, then for each i
              dense[sparse_indices[i]] = sparse_values[i]
              
              # If sparse_indices is an n by d matrix, then for each i in [0, n)
              dense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]
              ```
              
              All other values in `dense` are set to `default_value`.  If `sparse_values` is a
              scalar, all sparse indices are set to this single value.
              
              Indices should be sorted in lexicographic order, and indices must not
              contain any repeats. If `validate_indices` is true, these properties
              are checked during execution.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SparseToSparseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)">
            <summary>
              Applies set operation along last dimension of 2 `SparseTensor` inputs.
            </summary>
            <param name="set1_indices">
              2D `Tensor`, indices of a `SparseTensor`. Must be in row-major
              order.
            </param>
            <param name="set1_values">
              1D `Tensor`, values of a `SparseTensor`. Must be in row-major
              order.
            </param>
            <param name="set1_shape">
              1D `Tensor`, shape of a `SparseTensor`. `set1_shape[0...n-1]` must
              be the same as `set2_shape[0...n-1]`, `set1_shape[n]` is the
              max set size across `0...n-1` dimensions.
            </param>
            <param name="set2_indices">
              2D `Tensor`, indices of a `SparseTensor`. Must be in row-major
              order.
            </param>
            <param name="set2_values">
              1D `Tensor`, values of a `SparseTensor`. Must be in row-major
              order.
            </param>
            <param name="set2_shape">
              1D `Tensor`, shape of a `SparseTensor`. `set2_shape[0...n-1]` must
              be the same as `set1_shape[0...n-1]`, `set2_shape[n]` is the
              max set size across `0...n-1` dimensions.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseToSparseSetOperation'.
            </param>
            <param name="validate_indices">
              Optional argument
            </param>
            <param name="set_operation">
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              result_indices: 2D indices of a `SparseTensor`.
              result_values: 1D values of a `SparseTensor`.
              result_shape: 1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is
              the same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]`
              is the max result set size across all `0...n-1` dimensions.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              See SetOperationOp::SetOperationFromContext for values of `set_operation`.
              
              If `validate_indices` is `True`, `SparseToSparseSetOperation` validates the
              order and range of `set1` and `set2` indices.
              
              Input `set1` is a `SparseTensor` represented by `set1_indices`, `set1_values`,
              and `set1_shape`. For `set1` ranked `n`, 1st `n-1` dimensions must be the same
              as `set2`. Dimension `n` contains values in a set, duplicates are allowed but
              ignored.
              
              Input `set2` is a `SparseTensor` represented by `set2_indices`, `set2_values`,
              and `set2_shape`. For `set2` ranked `n`, 1st `n-1` dimensions must be the same
              as `set1`. Dimension `n` contains values in a set, duplicates are allowed but
              ignored.
              
              If `validate_indices` is `True`, this op validates the order and range of `set1`
              and `set2` indices.
              
              Output `result` is a `SparseTensor` represented by `result_indices`,
              `result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this
              has rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`
              dimension contains the result of `set_operation` applied to the corresponding
              `[0...n-1]` dimension of `set`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Split(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">
            <summary>
              Splits a tensor into `num_split` tensors along one dimension.
            </summary>
            <param name="split_dim">
              0-D.  The dimension along which to split.  Must be in the range
              `[-rank(value), rank(value))`.
            </param>
            <param name="value">
              The tensor to split.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Split'.
            </param>
            <param name="num_split">
              The number of ways to split.  Must evenly divide
              `value.shape[split_dim]`.
            </param>
            <returns>
              They are identically shaped tensors, whose shape matches that of `value`
              except along `split_dim`, where their sizes are
              `values.shape[split_dim] / num_split`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SplitV(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">
            <summary>
              Splits a tensor into `num_split` tensors along one dimension.
            </summary>
            <param name="value">
              The tensor to split.
            </param>
            <param name="size_splits">
              list containing the sizes of each output tensor along the split
              dimension. Must sum to the dimension of value along split_dim.
              Can contain one -1 indicating that dimension is to be inferred.
            </param>
            <param name="split_dim">
              0-D.  The dimension along which to split.  Must be in the range
              `[-rank(value), rank(value))`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SplitV'.
            </param>
            <param name="num_split">
            </param>
            <returns>
              Tensors whose shape matches that of `value`
              except along `split_dim`, where their sizes are
              `size_splits[i]`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.SqlDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that executes a SQL query and emits rows of the result set.
            </summary>
            <param name="driver_name">
              The database type. Currently, the only supported type is 'sqlite'.
            </param>
            <param name="data_source_name">
              A connection string to connect to the database.
            </param>
            <param name="query">
              A SQL query to execute.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SqlDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Sqrt(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes square root of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Sqrt'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              I.e., \\(y = \sqrt{x} = x^{1/2}\\).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SqrtGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the gradient for the sqrt of `x` wrt its input.
            </summary>
            <param name="y">
            </param>
            <param name="dy">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SqrtGrad'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Specifically, `grad = dy * 0.5 / y`, where `y = sqrt(x)`, and `dy`
              is the corresponding input gradient.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Square(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes square of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Square'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              I.e., \\(y = x * x = x^2\\).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SquaredDifference(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns (x - y)(x - y) element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SquaredDifference'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `SquaredDifference` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Squeeze(TensorFlow.TFOutput,System.Int64[],System.String)">
            <summary>
              Removes dimensions of size 1 from the shape of a tensor.
            </summary>
            <param name="input">
              The `input` to squeeze.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Squeeze'.
            </param>
            <param name="squeeze_dims">
              Optional argument
              If specified, only squeezes the dimensions listed. The dimension
              index starts at 0. It is an error to squeeze a dimension that is not 1. Must
              be in the range `[-rank(input), rank(input))`.
            </param>
            <returns>
              Contains the same data as `input`, but has one or more dimensions of
              size 1 removed.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Given a tensor `input`, this operation returns a tensor of the same type with
              all dimensions of size 1 removed. If you don't want to remove all size 1
              dimensions, you can remove specific size 1 dimensions by specifying
              `squeeze_dims`.
              
              For example:
              
              ```
              # 't' is a tensor of shape [1, 2, 1, 3, 1, 1]
              shape(squeeze(t)) ==&amp;gt; [2, 3]
              ```
              
              Or, to remove specific size 1 dimensions:
              
              ```
              # 't' is a tensor of shape [1, 2, 1, 3, 1, 1]
              shape(squeeze(t, [2, 4])) ==&amp;gt; [1, 2, 3, 1]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Stack(TensorFlow.TFDataType,System.String,System.String)">
            <summary>
              Deprecated, use StackV2.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Stack'.
            </param>
            <param name="stack_name">
              Optional argument
            </param>
            <param name="elem_type">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.StackClose(TensorFlow.TFOutput,System.String)">
            <summary>
              Deprecated, use StackCloseV2.
            </summary>
            <param name="handle">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StackClose'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.StackCloseV2(TensorFlow.TFOutput,System.String)">
            <summary>
              Delete the stack from its resource container.
            </summary>
            <param name="handle">
              The handle to a stack.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StackCloseV2'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.StackPop(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Deprecated, use StackPopV2.
            </summary>
            <param name="handle">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPop'.
            </param>
            <param name="elem_type">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.StackPopV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Pop the element at the top of the stack.
            </summary>
            <param name="handle">
              The handle to a stack.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPopV2'.
            </param>
            <param name="elem_type">
              The type of the elem that is popped.
            </param>
            <returns>
              The tensor that is popped from the top of the stack.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.StackPush(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Deprecated, use StackPushV2.
            </summary>
            <param name="handle">
            </param>
            <param name="elem">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPush'.
            </param>
            <param name="swap_memory">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.StackPushV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Push an element onto the stack.
            </summary>
            <param name="handle">
              The handle to a stack.
            </param>
            <param name="elem">
              The tensor to be pushed onto the stack.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPushV2'.
            </param>
            <param name="swap_memory">
              Optional argument
              Swap `elem` to CPU. Default to false.
            </param>
            <returns>
              The same tensor as the input 'elem'.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.StackV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String)">
            <summary>
              A stack that produces elements in first-in last-out order.
            </summary>
            <param name="max_size">
              The maximum size of the stack if non-negative. If negative, the stack
              size is unlimited.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StackV2'.
            </param>
            <param name="stack_name">
              Optional argument
              Overrides the name used for the temporary stack resource. Default
              value is the name of the 'Stack' op (which is guaranteed unique).
            </param>
            <param name="elem_type">
              The type of the elements on the stack.
            </param>
            <returns>
              The handle to the stack.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Stage(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Stage values similar to a lightweight Enqueue.
            </summary>
            <param name="values">
              a list of tensors
              dtypes A list of data types that inserted values should adhere to.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Stage'.
            </param>
            <param name="capacity">
              Optional argument
              Maximum number of elements in the Staging Area. If &amp;gt; 0, inserts
              on the container will block when the capacity is reached.
            </param>
            <param name="memory_limit">
              Optional argument
              The maximum number of bytes allowed for Tensors in the Staging Area.
              If &amp;gt; 0, inserts will block until sufficient space is available.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this queue is placed in the given container. Otherwise,
              a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              It is necessary to match this name to the matching Unstage Op.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The basic functionality of this Op is similar to a queue with many
              fewer capabilities and options.  This Op is optimized for performance.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StageClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op removes all elements in the underlying container.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StageClear'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.StagePeek(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op peeks at the values at the specified index.  If the
            </summary>
            <param name="index">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StagePeek'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              underlying container does not contain sufficient elements
              this op will block until it does.   This Op is optimized for
              performance.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StageSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op returns the number of elements in the underlying container.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StageSize'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.StatelessRandomNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Outputs deterministic pseudorandom values from a normal distribution.
            </summary>
            <param name="shape">
              The shape of the output tensor.
            </param>
            <param name="seed">
              2 seeds (shape [2]).
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessRandomNormal'.
            </param>
            <param name="dtype">
              Optional argument
              The type of the output.
            </param>
            <returns>
              Random values with specified shape.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The generated values will have mean 0 and standard deviation 1.
              
              The outputs are a deterministic function of `shape` and `seed`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StatelessRandomUniform(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Outputs deterministic pseudorandom random values from a uniform distribution.
            </summary>
            <param name="shape">
              The shape of the output tensor.
            </param>
            <param name="seed">
              2 seeds (shape [2]).
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessRandomUniform'.
            </param>
            <param name="dtype">
              Optional argument
              The type of the output.
            </param>
            <returns>
              Random values with specified shape.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The generated values follow a uniform distribution in the range `[0, 1)`. The
              lower bound 0 is included in the range, while the upper bound 1 is excluded.
              
              The outputs are a deterministic function of `shape` and `seed`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StatelessTruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Outputs deterministic pseudorandom values from a truncated normal distribution.
            </summary>
            <param name="shape">
              The shape of the output tensor.
            </param>
            <param name="seed">
              2 seeds (shape [2]).
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessTruncatedNormal'.
            </param>
            <param name="dtype">
              Optional argument
              The type of the output.
            </param>
            <returns>
              Random values with specified shape.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The generated values follow a normal distribution with mean 0 and standard
              deviation 1, except that values whose magnitude is more than 2 standard
              deviations from the mean are dropped and re-picked.
              
              The outputs are a deterministic function of `shape` and `seed`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StatsAggregatorHandle(System.String,System.String,System.String)">
            <summary>
              Creates a statistics manager resource.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StatsAggregatorHandle'.
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.StatsAggregatorSummary(TensorFlow.TFOutput,System.String)">
            <summary>
              Produces a summary of any statistics recorded by the given statistics manager.
            </summary>
            <param name="iterator">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StatsAggregatorSummary'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.StopGradient(TensorFlow.TFOutput,System.String)">
            <summary>
              Stops gradient computation.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StopGradient'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              When executed in a graph, this op outputs its input tensor as-is.
              
              When building ops to compute gradients, this op prevents the contribution of
              its inputs to be taken into account.  Normally, the gradient generator adds ops
              to a graph to compute the derivatives of a specified 'loss' by recursively
              finding out inputs that contributed to its computation.  If you insert this op
              in the graph it inputs are masked from the gradient generator.  They are not
              taken into account for computing gradients.
              
              This is useful any time you want to compute a value with TensorFlow but need
              to pretend that the value was a constant. Some examples include:
              
              *  The *EM* algorithm where the *M-step* should not involve backpropagation
                 through the output of the *E-step*.
              *  Contrastive divergence training of Boltzmann machines where, when
                 differentiating the energy function, the training must not backpropagate
                 through the graph that generated the samples from the model.
              *  Adversarial training, where no backprop should happen through the adversarial
                 example generation process.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StridedSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Return a strided slice from `input`.
            </summary>
            <param name="input">
            </param>
            <param name="begin">
              `begin[k]` specifies the offset into the `k`th range specification.
              The exact dimension this corresponds to will be determined by context.
              Out-of-bounds values will be silently clamped. If the `k`th bit of
              `begin_mask` then `begin[k]` is ignored and the full range of the
              appropriate dimension is used instead. Negative values causes indexing
              to start from the highest element e.g. If `foo==[1,2,3]` then `foo[-1]==3`.
            </param>
            <param name="end">
              `end[i]` is like `begin` with the exception that `end_mask` is
              used to determine full ranges.
            </param>
            <param name="strides">
              `strides[i]` specifies the increment in the `i`th specification
              after extracting a given element. Negative indices will reverse
              the original order. Out or range values are
              clamped to `[0,dim[i]) if slice[i]&amp;gt;0` or `[-1,dim[i]-1] if slice[i] &amp;lt; 0`
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StridedSlice'.
            </param>
            <param name="begin_mask">
              Optional argument
              a bitmask where a bit i being 1 means to ignore the begin
              value and instead use the largest interval possible. At runtime
              begin[i] will be replaced with `[0, n-1) if `stride[i] &amp;gt; 0` or
              `[-1, n-1]` if `stride[i] &amp;lt; 0`
            </param>
            <param name="end_mask">
              Optional argument
              analogous to `begin_mask`
            </param>
            <param name="ellipsis_mask">
              Optional argument
              a bitmask where bit `i` being 1 means the `i`th
              position is actually an ellipsis. One bit at most can be 1.
              If `ellipsis_mask == 0`, then an implicit ellipsis mask of `1 &amp;lt;&amp;lt; (m+1)`
              is provided. This means that `foo[3:5] == foo[3:5, ...]`. An ellipsis
              implicitly creates as many range specifications as necessary to fully
              specify the sliced range for every dimension. For example for a 4-dimensional
              tensor `foo` the slice `foo[2, ..., 5:8]` implies `foo[2, :, :, 5:8]`.
            </param>
            <param name="new_axis_mask">
              Optional argument
              a bitmask where bit `i` being 1 means the `i`th
              specification creates a new shape 1 dimension. For example
              `foo[:4, tf.newaxis, :2]` would produce a shape `(4, 1, 2)` tensor.
            </param>
            <param name="shrink_axis_mask">
              Optional argument
              a bitmask where bit `i` implies that the `i`th
              specification should shrink the dimensionality. begin and end
              must imply a slice of size 1 in the dimension. For example in
              python one might do `foo[:, 3, :]` which would result in
              `shrink_axis_mask` being 2.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Note, most python users will want to use the Python `Tensor.__getitem__`
              or `Variable.__getitem__` rather than this op directly.
              
              The goal of this op is to produce a new tensor with a subset of
              the elements from the `n` dimensional `input` tensor. The subset is chosen using
              a sequence of `m` sparse range specifications encoded into the arguments
              of this function. Note, in some cases
              `m` could be equal to `n`, but this need not be the case. Each
              range specification entry can be one of the following:
              
              - An ellipsis (...). Ellipses are used to imply zero or more
                dimensions of full-dimension selection and are produced using
                `ellipsis_mask`. For example, `foo[...]` is the identity slice.
              
              - A new axis. This is used to insert a new shape=1 dimension and is
                produced using `new_axis_mask`. For example, `foo[:, ...]` where
                `foo` is shape `(3, 4)` produces a `(1, 3, 4)` tensor.
              
              
              - A range `begin:end:stride`. This is used to specify how much to choose from
                a given dimension. `stride` can be any integer but 0.  `begin` is an integer
                which represents the index of the first value to select while `end` represents
                the index of the last value to select. The number of values selected in each
                dimension is `end - begin` if `stride &amp;gt; 0` and `begin - end` if `stride &amp;lt; 0`.
                `begin` and `end` can be negative where `-1` is the last element, `-2` is
                the second to last. `begin_mask` controls whether to replace the explicitly
                given `begin` with an implicit effective value of `0` if `stride &amp;gt; 0` and
                `-1` if `stride &amp;lt; 0`. `end_mask` is analogous but produces the number
                required to create the largest open interval. For example, given a shape
                `(3,)` tensor `foo[:]`, the effective `begin` and `end` are `0` and `3`. Do
                not assume this is equivalent to `foo[0:-1]` which has an effective `begin`
                and `end` of `0` and `2`. Another example is `foo[-2::-1]` which reverses the
                first dimension of a tensor while dropping the last two (in the original
                order elements). For example `foo = [1,2,3,4]; foo[-2::-1]` is `[4,3]`.
              
              - A single index. This is used to keep only elements that have a given
                index. For example (`foo[2, :]` on a shape `(5,6)` tensor produces a
                shape `(6,)` tensor. This is encoded in `begin` and `end` and
                `shrink_axis_mask`.
              
              Each conceptual range specification is encoded in the op's argument. This
              encoding is best understand by considering a non-trivial example. In
              particular,
              `foo[1, 2:4, None, ..., :-3:-1, :]` will be encoded as
              
              ```
              begin = [1, 2, x, x, 0, x] # x denotes don't care (usually 0)
              end = [2, 4, x, x, -3, x]
              strides = [1, 1, x, x, -1, 1]
              begin_mask = 1&amp;lt;&amp;lt;4 | 1 &amp;lt;&amp;lt; 5 = 48
              end_mask = 1&amp;lt;&amp;lt;5 = 32
              ellipsis_mask = 1&amp;lt;&amp;lt;3 = 8
              new_axis_mask = 1&amp;lt;&amp;lt;2 4
              shrink_axis_mask = 1&amp;lt;&amp;lt;0
              ```
              
              In this case if `foo.shape` is (5, 5, 5, 5, 5, 5) the final shape of
              the slice becomes (2, 1, 5, 5, 2, 5).
              Let us walk step by step through each argument specification.
              
              1.  The first argument in the example slice is turned into `begin = 1` and
              `end = begin + 1 = 2`. To disambiguate from the original spec `2:4` we
              also set the appropriate bit in `shrink_axis_mask`.
              
              2. `2:4` is contributes 2, 4, 1 to begin, end, and stride. All masks have
              zero bits contributed.
              
              3. None is a synonym for `tf.newaxis`. This means insert a dimension of size 1
              dimension in the final shape. Dummy values are contributed to begin,
              end and stride, while the new_axis_mask bit is set.
              
              4. `...` grab the full ranges from as many dimensions as needed to
              fully specify a slice for every dimension of the input shape.
              
              5. `:-3:-1` shows the use of negative indices. A negative index `i` associated
              with a dimension that has shape `s` is converted to a positive index
              `s + i`. So `-1` becomes `s-1` (i.e. the last element). This conversion
              is done internally so begin, end and strides receive x, -3, and -1.
              The appropriate begin_mask bit is set to indicate the start range is the
              full range (ignoring the x).
              
              6. `:` indicates that the entire contents of the corresponding dimension
              is selected. This is equivalent to `::` or `0::1`. begin, end, and strides
              receive 0, 0, and 1, respectively. The appropriate bits in `begin_mask` and
              `end_mask` are also set.
              
              *Requirements*:
                `0 != strides[i] for i in [0, m)`
                `ellipsis_mask must be a power of two (only one ellipsis)`
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StridedSliceAssign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Assign `value` to the sliced l-value reference of `ref`.
            </summary>
            <param name="reference">
            </param>
            <param name="begin">
            </param>
            <param name="end">
            </param>
            <param name="strides">
            </param>
            <param name="value">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StridedSliceAssign'.
            </param>
            <param name="begin_mask">
              Optional argument
            </param>
            <param name="end_mask">
              Optional argument
            </param>
            <param name="ellipsis_mask">
              Optional argument
            </param>
            <param name="new_axis_mask">
              Optional argument
            </param>
            <param name="shrink_axis_mask">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The values of `value` are assigned to the positions in the variable
              `ref` that are selected by the slice parameters. The slice parameters
              `begin, `end`, `strides`, etc. work exactly as in `StridedSlice`.
              
              NOTE this op currently does not support broadcasting and so `value`'s
              shape must be exactly the shape produced by the slice of `ref`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StridedSliceGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Returns the gradient of `StridedSlice`.
            </summary>
            <param name="shape">
            </param>
            <param name="begin">
            </param>
            <param name="end">
            </param>
            <param name="strides">
            </param>
            <param name="dy">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StridedSliceGrad'.
            </param>
            <param name="begin_mask">
              Optional argument
            </param>
            <param name="end_mask">
              Optional argument
            </param>
            <param name="ellipsis_mask">
              Optional argument
            </param>
            <param name="new_axis_mask">
              Optional argument
            </param>
            <param name="shrink_axis_mask">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Since `StridedSlice` cuts out pieces of its `input` which is size
              `shape`, its gradient will have the same shape (which is passed here
              as `shape`). The gradient will be zero in any element that the slice
              does not select.
              
              Arguments are the same as StridedSliceGrad with the exception that
              `dy` is the input gradient to be propagated and `shape` is the
              shape of `StridedSlice`'s `input`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StringJoin(TensorFlow.TFOutput[],System.String,System.String)">
            <summary>
              Joins the strings in the given list of string tensors into one tensor;
            </summary>
            <param name="inputs">
              A list of string tensors.  The tensors must all have the same shape,
              or be scalars.  Scalars may be mixed in; these will be broadcast to the shape
              of non-scalar inputs.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StringJoin'.
            </param>
            <param name="separator">
              Optional argument
              string, an optional join separator.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              with the given separator (default is an empty separator).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StringSplit(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Split elements of `input` based on `delimiter` into a `SparseTensor`.
            </summary>
            <param name="input">
              1-D. Strings to split.
            </param>
            <param name="delimiter">
              0-D. Delimiter characters (bytes), or empty string.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StringSplit'.
            </param>
            <param name="skip_empty">
              Optional argument
              A `bool`. If `True`, skip the empty strings from the result.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              indices: A dense matrix of int64 representing the indices of the sparse tensor.
              values: A vector of strings corresponding to the splited values.
              shape: a length-2 vector of int64 representing the shape of the sparse
              tensor, where the first value is N and the second value is the maximum number
              of tokens in a single input entry.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Let N be the size of source (typically N will be the batch size). Split each
              element of `input` based on `delimiter` and return a `SparseTensor`
              containing the splitted tokens. Empty tokens are ignored.
              
              `delimiter` can be empty, or a string of split characters. If `delimiter` is an
               empty string, each element of `input` is split into individual single-byte
               character strings, including splitting of UTF-8 multibyte sequences. Otherwise
               every character of `delimiter` is a potential split point.
              
              For example:
                N = 2, input[0] is 'hello world' and input[1] is 'a b c', then the output
                will be
              
                indices = [0, 0;
                           0, 1;
                           1, 0;
                           1, 1;
                           1, 2]
                shape = [2, 3]
                values = ['hello', 'world', 'a', 'b', 'c']
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StringToHashBucket(TensorFlow.TFOutput,System.Int64,System.String)">
            <summary>
              Converts each string in the input Tensor to its hash mod by a number of buckets.
            </summary>
            <param name="string_tensor">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToHashBucket'.
            </param>
            <param name="num_buckets">
              The number of buckets.
            </param>
            <returns>
              A Tensor of the same shape as the input `string_tensor`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The hash function is deterministic on the content of the string within the
              process.
              
              Note that the hash function may change from time to time.
              This functionality will be deprecated and it's recommended to use
              `tf.string_to_hash_bucket_fast()` or `tf.string_to_hash_bucket_strong()`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StringToHashBucketFast(TensorFlow.TFOutput,System.Int64,System.String)">
            <summary>
              Converts each string in the input Tensor to its hash mod by a number of buckets.
            </summary>
            <param name="input">
              The strings to assign a hash bucket.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToHashBucketFast'.
            </param>
            <param name="num_buckets">
              The number of buckets.
            </param>
            <returns>
              A Tensor of the same shape as the input `string_tensor`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The hash function is deterministic on the content of the string within the
              process and will never change. However, it is not suitable for cryptography.
              This function may be used when CPU time is scarce and inputs are trusted or
              unimportant. There is a risk of adversaries constructing inputs that all hash
              to the same bucket. To prevent this problem, use a strong hash function with
              `tf.string_to_hash_bucket_strong`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StringToHashBucketStrong(TensorFlow.TFOutput,System.Int64,System.Int64[],System.String)">
            <summary>
              Converts each string in the input Tensor to its hash mod by a number of buckets.
            </summary>
            <param name="input">
              The strings to assign a hash bucket.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToHashBucketStrong'.
            </param>
            <param name="num_buckets">
              The number of buckets.
            </param>
            <param name="key">
              The key for the keyed hash function passed as a list of two uint64
              elements.
            </param>
            <returns>
              A Tensor of the same shape as the input `string_tensor`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The hash function is deterministic on the content of the string within the
              process. The hash function is a keyed hash function, where attribute `key`
              defines the key of the hash function. `key` is an array of 2 elements.
              
              A strong hash is important when inputs may be malicious, e.g. URLs with
              additional components. Adversaries could try to make their inputs hash to the
              same bucket for a denial-of-service attack or to skew the results. A strong
              hash prevents this by making it difficult, if not infeasible, to compute inputs
              that hash to the same bucket. This comes at a cost of roughly 4x higher compute
              time than `tf.string_to_hash_bucket_fast`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.StringToNumber(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Converts each string in the input Tensor to the specified numeric type.
            </summary>
            <param name="string_tensor">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToNumber'.
            </param>
            <param name="out_type">
              Optional argument
              The numeric type to interpret each string in `string_tensor` as.
            </param>
            <returns>
              A Tensor of the same shape as the input `string_tensor`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              (Note that int32 overflow results in an error while float overflow
              results in a rounded value.)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Sub(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns x - y element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Sub'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              *NOTE*: `Sub` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Substr(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Return substrings from `Tensor` of strings.
            </summary>
            <param name="input">
              Tensor of strings
            </param>
            <param name="pos">
              Scalar defining the position of first character in each substring
            </param>
            <param name="len">
              Scalar defining the number of characters to include in each substring
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Substr'.
            </param>
            <returns>
              Tensor of substrings
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              For each string in the input `Tensor`, creates a substring starting at index
              `pos` with a total length of `len`.
              
              If `len` defines a substring that would extend beyond the length of the input
              string, then as many characters as possible are used.
              
              If `pos` is negative or specifies a character index larger than any of the input
              strings, then an `InvalidArgumentError` is thrown.
              
              `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
              Op creation.
              
              *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
              broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
              
              ---
              
              Examples
              
              Using scalar `pos` and `len`:
              
              ```python
              input = [b'Hello', b'World']
              position = 1
              length = 3
              
              output = [b'ell', b'orl']
              ```
              
              Using `pos` and `len` with same shape as `input`:
              
              ```python
              input = [[b'ten', b'eleven', b'twelve'],
                       [b'thirteen', b'fourteen', b'fifteen'],
                       [b'sixteen', b'seventeen', b'eighteen']]
              position = [[1, 2, 3],
                          [1, 2, 3],
                          [1, 2, 3]]
              length =   [[2, 3, 4],
                          [4, 3, 2],
                          [5, 5, 5]]
              
              output = [[b'en', b'eve', b'lve'],
                        [b'hirt', b'urt', b'te'],
                        [b'ixtee', b'vente', b'hteen']]
              ```
              
              Broadcasting `pos` and `len` onto `input`:
              
              ```
              input = [[b'ten', b'eleven', b'twelve'],
                       [b'thirteen', b'fourteen', b'fifteen'],
                       [b'sixteen', b'seventeen', b'eighteen'],
                       [b'nineteen', b'twenty', b'twentyone']]
              position = [1, 2, 3]
              length =   [1, 2, 3]
              
              output = [[b'e', b'ev', b'lve'],
                        [b'h', b'ur', b'tee'],
                        [b'i', b've', b'hte'],
                        [b'i', b'en', b'nty']]
              ```
              
              Broadcasting `input` onto `pos` and `len`:
              
              ```
              input = b'thirteen'
              position = [1, 5, 7]
              length =   [3, 2, 1]
              
              output = [b'hir', b'ee', b'n']
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Sum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the sum of elements across dimensions of a tensor.
            </summary>
            <param name="input">
              The tensor to reduce.
            </param>
            <param name="reduction_indices">
              The dimensions to reduce. Must be in the range
              `[-rank(input), rank(input))`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Sum'.
            </param>
            <param name="keep_dims">
              Optional argument
              If true, retain reduced dimensions with length 1.
            </param>
            <returns>
              The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Reduces `input` along the dimensions given in `reduction_indices`. Unless
              `keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in
              `reduction_indices`. If `keep_dims` is true, the reduced dimensions are
              retained with length 1.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.SummaryWriter(System.String,System.String,System.String)">
            <summary>
              Returns a handle to be used to access a summary writer.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'SummaryWriter'.
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <returns>
              the summary writer resource. Scalar handle.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The summary writer is an in-graph resource which can be used by ops to write
              summaries to event files.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Svd(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">
            <summary>
              Computes the singular value decompositions of one or more matrices.
            </summary>
            <param name="input">
              A tensor of shape `[..., M, N]` whose inner-most 2 dimensions
              form matrices of size `[M, N]`. Let `P` be the minimum of `M` and `N`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Svd'.
            </param>
            <param name="compute_uv">
              Optional argument
              If true, left and right singular vectors will be
              computed and returned in `u` and `v`, respectively.
              If false, `u` and `v` are not set and should never referenced.
            </param>
            <param name="full_matrices">
              Optional argument
              If true, compute full-sized `u` and `v`. If false
              (the default), compute only the leading `P` singular vectors.
              Ignored if `compute_uv` is `False`.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              s: Singular values. Shape is `[..., P]`.
              u: Left singular vectors. If `full_matrices` is `False` then shape is
              `[..., M, P]`; if `full_matrices` is `True` then shape is
              `[..., M, M]`. Undefined if `compute_uv` is `False`.
              v: Left singular vectors. If `full_matrices` is `False` then shape is
              `[..., N, P]`. If `full_matrices` is `True` then shape is `[..., N, N]`.
              Undefined if `compute_uv` is false.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Computes the SVD of each inner matrix in `input` such that
              `input[..., :, :] = u[..., :, :] * diag(s[..., :, :]) * transpose(v[..., :, :])`
              
              ```python
              # a is a tensor containing a batch of matrices.
              # s is a tensor of singular values for each matrix.
              # u is the tensor containing of left singular vectors for each matrix.
              # v is the tensor containing of right singular vectors for each matrix.
              s, u, v = svd(a)
              s, _, _ = svd(a, compute_uv=False)
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Switch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Forwards `data` to the output port determined by `pred`.
            </summary>
            <param name="data">
              The tensor to be forwarded to the appropriate output.
            </param>
            <param name="pred">
              A scalar that specifies which output port will receive data.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Switch'.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              output_false: If `pred` is false, data will be forwarded to this output.
              output_true: If `pred` is true, data will be forwarded to this output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              If `pred` is true, the `data` input is forwarded to `output_true`. Otherwise,
              the data goes to `output_false`.
              
              See also `RefSwitch` and `Merge`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TakeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that contains `count` elements from the `input_dataset`.
            </summary>
            <param name="input_dataset">
            </param>
            <param name="count">
              A scalar representing the number of elements from the `input_dataset`
              that should be taken. A value of `-1` indicates that all of `input_dataset`
              is taken.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TakeDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TakeManySparseFromTensorsMap(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.String)">
            <summary>
              Read `SparseTensors` from a `SparseTensorsMap` and concatenate them.
            </summary>
            <param name="sparse_handles">
              1-D, The `N` serialized `SparseTensor` objects.
              Shape: `[N]`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TakeManySparseFromTensorsMap'.
            </param>
            <param name="container">
              Optional argument
              The container name for the `SparseTensorsMap` read by this op.
            </param>
            <param name="shared_name">
              Optional argument
              The shared name for the `SparseTensorsMap` read by this op.
              It should not be blank; rather the `shared_name` or unique Operation name
              of the Op that created the original `SparseTensorsMap` should be used.
            </param>
            <param name="dtype">
              The `dtype` of the `SparseTensor` objects stored in the
              `SparseTensorsMap`.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              sparse_indices: 2-D.  The `indices` of the minibatch `SparseTensor`.
              sparse_values: 1-D.  The `values` of the minibatch `SparseTensor`.
              sparse_shape: 1-D.  The `shape` of the minibatch `SparseTensor`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              The input `sparse_handles` must be an `int64` matrix of shape `[N, 1]` where
              `N` is the minibatch size and the rows correspond to the output handles of
              `AddSparseToTensorsMap` or `AddManySparseToTensorsMap`.  The ranks of the
              original `SparseTensor` objects that went into the given input ops must all
              match.  When the final `SparseTensor` is created, it has rank one
              higher than the ranks of the incoming `SparseTensor` objects
              (they have been concatenated along a new row dimension on the left).
              
              The output `SparseTensor` object's shape values for all dimensions but the
              first are the max across the input `SparseTensor` objects' shape values
              for the corresponding dimensions.  Its first shape value is `N`, the minibatch
              size.
              
              The input `SparseTensor` objects' indices are assumed ordered in
              standard lexicographic order.  If this is not the case, after this
              step run `SparseReorder` to restore index ordering.
              
              For example, if the handles represent an input, which is a `[2, 3]` matrix
              representing two original `SparseTensor` objects:
              
              ```
                  index = [ 0]
                          [10]
                          [20]
                  values = [1, 2, 3]
                  shape = [50]
              ```
              
              and
              
              ```
                  index = [ 2]
                          [10]
                  values = [4, 5]
                  shape = [30]
              ```
              
              then the final `SparseTensor` will be:
              
              ```
                  index = [0  0]
                          [0 10]
                          [0 20]
                          [1  2]
                          [1 10]
                  values = [1, 2, 3, 4, 5]
                  shape = [2 50]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Tan(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes tan of x element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Tan'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Tanh(TensorFlow.TFOutput,System.String)">
            <summary>
              Computes hyperbolic tangent of `x` element-wise.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Tanh'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TanhGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the gradient for the tanh of `x` wrt its input.
            </summary>
            <param name="y">
            </param>
            <param name="dy">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TanhGrad'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Specifically, `grad = dy * (1 - y*y)`, where `y = tanh(x)`, and `dy`
              is the corresponding input gradient.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TemporaryVariable(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String)">
            <summary>
              Returns a tensor that may be mutated, but only persists within a single step.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TemporaryVariable'.
            </param>
            <param name="var_name">
              Optional argument
              Overrides the name used for the temporary variable resource. Default
              value is the name of the 'TemporaryVariable' op (which is guaranteed unique).
            </param>
            <param name="shape">
              The shape of the variable tensor.
            </param>
            <param name="dtype">
              The type of elements in the variable tensor.
            </param>
            <returns>
              A reference to the variable tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This is an experimental op for internal use only and it is possible to use this
              op in unsafe ways.  DO NOT USE unless you fully understand the risks.
              
              It is the caller's responsibility to ensure that 'ref' is eventually passed to a
              matching 'DestroyTemporaryVariable' op after all other uses have completed.
              
              Outputs a ref to the tensor state so it may be read or modified.
              
                E.g.
                    var = state_ops._temporary_variable([1, 2], types.float_)
                    var_name = var.op.name
                    var = state_ops.assign(var, [[4.0, 5.0]])
                    var = state_ops.assign_add(var, [[6.0, 7.0]])
                    final = state_ops._destroy_temporary_variable(var, var_name=var_name)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayCloseV2(TensorFlow.TFOutput,System.String)">
            <summary>
              Deprecated. Use TensorArrayCloseV3
            </summary>
            <param name="handle">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayCloseV2'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayCloseV3(TensorFlow.TFOutput,System.String)">
            <summary>
              Delete the TensorArray from its resource container.
            </summary>
            <param name="handle">
              The handle to a TensorArray (output of TensorArray or TensorArrayGrad).
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayCloseV3'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              This enables the user to close and release the resource in the middle
              of a step/run.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayConcatV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">
            <summary>
              Deprecated. Use TensorArrayConcatV3
            </summary>
            <param name="handle">
            </param>
            <param name="flow_in">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayConcatV2'.
            </param>
            <param name="element_shape_except0">
              Optional argument
            </param>
            <param name="dtype">
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              value: 
              lengths: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayConcatV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">
            <summary>
              Concat the elements from the TensorArray into value `value`.
            </summary>
            <param name="handle">
              The handle to a TensorArray.
            </param>
            <param name="flow_in">
              A float scalar that enforces proper chaining of operations.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayConcatV3'.
            </param>
            <param name="element_shape_except0">
              Optional argument
              The expected shape of an element, if known,
              excluding the first dimension. Used to validate the shapes of
              TensorArray elements. If this shape is not fully specified, concatenating
              zero-size TensorArrays is an error.
            </param>
            <param name="dtype">
              The type of the elem that is returned.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              value: All of the elements in the TensorArray, concatenated along the first
              axis.
              lengths: A vector of the row sizes of the original T elements in the
              value output.  In the example above, this would be the values:
              `(n1, n2, ..., n(T-1))`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Takes `T` elements of shapes
              
                ```
                (n0 x d0 x d1 x ...), (n1 x d0 x d1 x ...), ..., (n(T-1) x d0 x d1 x ...)
                ```
              
              and concatenates them into a Tensor of shape:
              
                ```(n0 + n1 + ... + n(T-1) x d0 x d1 x ...)```
              
              All elements must have the same shape (excepting the first dimension).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayGatherV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">
            <summary>
              Deprecated. Use TensorArrayGatherV3
            </summary>
            <param name="handle">
            </param>
            <param name="indices">
            </param>
            <param name="flow_in">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGatherV2'.
            </param>
            <param name="element_shape">
              Optional argument
            </param>
            <param name="dtype">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayGatherV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">
            <summary>
              Gather specific elements from the TensorArray into output `value`.
            </summary>
            <param name="handle">
              The handle to a TensorArray.
            </param>
            <param name="indices">
              The locations in the TensorArray from which to read tensor elements.
            </param>
            <param name="flow_in">
              A float scalar that enforces proper chaining of operations.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGatherV3'.
            </param>
            <param name="element_shape">
              Optional argument
              The expected shape of an element, if known. Used to
              validate the shapes of TensorArray elements. If this shape is not
              fully specified, gathering zero-size TensorArrays is an error.
            </param>
            <param name="dtype">
              The type of the elem that is returned.
            </param>
            <returns>
              All of the elements in the TensorArray, concatenated along a new
              axis (the new dimension 0).
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              All elements selected by `indices` must have the same shape.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">
            <summary>
              Deprecated. Use TensorArrayGradV3
            </summary>
            <param name="handle">
            </param>
            <param name="flow_in">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGradV2'.
            </param>
            <param name="source">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayGradV3(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">
            <summary>
              Creates a TensorArray for storing the gradients of values in the given handle.
            </summary>
            <param name="handle">
              The handle to the forward TensorArray.
            </param>
            <param name="flow_in">
              A float scalar that enforces proper chaining of operations.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGradV3'.
            </param>
            <param name="source">
              The gradient source string, used to decide which gradient TensorArray
              to return.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              grad_handle: 
              flow_out: 
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              If the given TensorArray gradient already exists, returns a reference to it.
              
              Locks the size of the original TensorArray by disabling its dynamic size flag.
              
              **A note about the input flow_in:**
              
              The handle flow_in forces the execution of the gradient lookup to occur
              only after certain other operations have occurred.  For example, when
              the forward TensorArray is dynamically sized, writes to this TensorArray
              may resize the object.  The gradient TensorArray is statically sized based
              on the size of the forward TensorArray when this operation executes.
              Furthermore, the size of the forward TensorArray is frozen by this call.
              As a result, the flow is used to ensure that the call to generate the gradient
              TensorArray only happens after all writes are executed.
              
              In the case of dynamically sized TensorArrays, gradient computation should
              only be performed on read operations that have themselves been chained via
              flow to occur only after all writes have executed. That way the final size
              of the forward TensorArray is known when this operation is called.
              
              **A note about the source attribute:**
              
              TensorArray gradient calls use an accumulator TensorArray object.  If
              multiple gradients are calculated and run in the same session, the multiple
              gradient nodes may accidentally flow through the same accumulator TensorArray.
              This double counts and generally breaks the TensorArray gradient flow.
              
              The solution is to identify which gradient call this particular
              TensorArray gradient is being called in.  This is performed by identifying
              a unique string (e.g. "gradients", "gradients_1", ...) from the input
              gradient Tensor's name.  This string is used as a suffix when creating
              the TensorArray gradient object here (the attribute `source`).
              
              The attribute `source` is added as a suffix to the forward TensorArray's
              name when performing the creation / lookup, so that each separate gradient
              calculation gets its own TensorArray accumulator.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayReadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Deprecated. Use TensorArrayReadV3
            </summary>
            <param name="handle">
            </param>
            <param name="index">
            </param>
            <param name="flow_in">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayReadV2'.
            </param>
            <param name="dtype">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayReadV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">
            <summary>
              Read an element from the TensorArray into output `value`.
            </summary>
            <param name="handle">
              The handle to a TensorArray.
            </param>
            <param name="index">
            </param>
            <param name="flow_in">
              A float scalar that enforces proper chaining of operations.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayReadV3'.
            </param>
            <param name="dtype">
              The type of the elem that is returned.
            </param>
            <returns>
              The tensor that is read from the TensorArray.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayScatterV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Deprecated. Use TensorArrayScatterV3
            </summary>
            <param name="handle">
            </param>
            <param name="indices">
            </param>
            <param name="value">
            </param>
            <param name="flow_in">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayScatterV2'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayScatterV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Scatter the data from the input value into specific TensorArray elements.
            </summary>
            <param name="handle">
              The handle to a TensorArray.
            </param>
            <param name="indices">
              The locations at which to write the tensor elements.
            </param>
            <param name="value">
              The concatenated tensor to write to the TensorArray.
            </param>
            <param name="flow_in">
              A float scalar that enforces proper chaining of operations.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayScatterV3'.
            </param>
            <returns>
              A float scalar that enforces proper chaining of operations.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              `indices` must be a vector, its length must match the first dim of `value`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArraySizeV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Deprecated. Use TensorArraySizeV3
            </summary>
            <param name="handle">
            </param>
            <param name="flow_in">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySizeV2'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArraySizeV3(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Get the current size of the TensorArray.
            </summary>
            <param name="handle">
              The handle to a TensorArray (output of TensorArray or TensorArrayGrad).
            </param>
            <param name="flow_in">
              A float scalar that enforces proper chaining of operations.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySizeV3'.
            </param>
            <returns>
              The current size of the TensorArray.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArraySplitV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Deprecated. Use TensorArraySplitV3
            </summary>
            <param name="handle">
            </param>
            <param name="value">
            </param>
            <param name="lengths">
            </param>
            <param name="flow_in">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySplitV2'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArraySplitV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Split the data from the input value into TensorArray elements.
            </summary>
            <param name="handle">
              The handle to a TensorArray.
            </param>
            <param name="value">
              The concatenated tensor to write to the TensorArray.
            </param>
            <param name="lengths">
              The vector of lengths, how to split the rows of value into the
              TensorArray.
            </param>
            <param name="flow_in">
              A float scalar that enforces proper chaining of operations.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySplitV3'.
            </param>
            <returns>
              A float scalar that enforces proper chaining of operations.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Assuming that `lengths` takes on values
              
                ```(n0, n1, ..., n(T-1))```
              
              and that `value` has shape
              
                ```(n0 + n1 + ... + n(T-1) x d0 x d1 x ...)```,
              
              this splits values into a TensorArray with T tensors.
              
              TensorArray index t will be the subtensor of values with starting position
              
                ```(n0 + n1 + ... + n(t-1), 0, 0, ...)```
              
              and having size
              
                ```nt x d0 x d1 x ...```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayV2(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)">
            <summary>
              Deprecated. Use TensorArrayV3
            </summary>
            <param name="size">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayV2'.
            </param>
            <param name="element_shape">
              Optional argument
            </param>
            <param name="dynamic_size">
              Optional argument
            </param>
            <param name="clear_after_read">
              Optional argument
            </param>
            <param name="tensor_array_name">
              Optional argument
            </param>
            <param name="dtype">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayV3(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)">
            <summary>
              An array of Tensors of given size.
            </summary>
            <param name="size">
              The size of the array.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayV3'.
            </param>
            <param name="element_shape">
              Optional argument
              The expected shape of an element, if known. Used to
              validate the shapes of TensorArray elements. If this shape is not
              fully specified, gathering zero-size TensorArrays is an error.
            </param>
            <param name="dynamic_size">
              Optional argument
              A boolean that determines whether writes to the TensorArray
              are allowed to grow the size.  By default, this is not allowed.
            </param>
            <param name="clear_after_read">
              Optional argument
              If true (default), Tensors in the TensorArray are cleared
              after being read.  This disables multiple read semantics but allows early
              release of memory.
            </param>
            <param name="identical_element_shapes">
              Optional argument
              If true (default is false), then all
              elements in the TensorArray will be expected to have have identical shapes.
              This allows certain behaviors, like dynamically checking for
              consistent shapes on write, and being able to fill in properly
              shaped zero tensors on stack -- even if the element_shape attribute
              is not fully defined.
            </param>
            <param name="tensor_array_name">
              Optional argument
              Overrides the name used for the temporary tensor_array
              resource. Default value is the name of the 'TensorArray' op (which
              is guaranteed unique).
            </param>
            <param name="dtype">
              The type of the elements on the tensor_array.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              handle: The handle to the TensorArray.
              flow: A scalar used to control gradient flow.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              Write data via Write and read via Read or Pack.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayWriteV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Deprecated. Use TensorArrayGradV3
            </summary>
            <param name="handle">
            </param>
            <param name="index">
            </param>
            <param name="value">
            </param>
            <param name="flow_in">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayWriteV2'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorArrayWriteV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Push an element onto the tensor_array.
            </summary>
            <param name="handle">
              The handle to a TensorArray.
            </param>
            <param name="index">
              The position to write to inside the TensorArray.
            </param>
            <param name="value">
              The tensor to write to the TensorArray.
            </param>
            <param name="flow_in">
              A float scalar that enforces proper chaining of operations.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayWriteV3'.
            </param>
            <returns>
              A float scalar that enforces proper chaining of operations.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorDataset(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that emits `components` as a tuple of tensors once.
            </summary>
            <param name="components">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorDataset'.
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorSliceDataset(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that emits each dim-0 slice of `components` once.
            </summary>
            <param name="components">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorSliceDataset'.
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorSummary(TensorFlow.TFOutput,System.String,System.String[],System.String,System.String)">
            <summary>
              Outputs a `Summary` protocol buffer with a tensor.
            </summary>
            <param name="tensor">
              A tensor to serialize.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorSummary'.
            </param>
            <param name="description">
              Optional argument
              A json-encoded SummaryDescription proto.
            </param>
            <param name="labels">
              Optional argument
              An unused list of strings.
            </param>
            <param name="display_name">
              Optional argument
              An unused string.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This op is being phased out in favor of TensorSummaryV2, which lets callers pass
              a tag as well as a serialized SummaryMetadata proto string that contains
              plugin-specific data. We will keep this op to maintain backwards compatibility.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TensorSummaryV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Outputs a `Summary` protocol buffer with a tensor and per-plugin data.
            </summary>
            <param name="tag">
              A string attached to this summary. Used for organization in TensorBoard.
            </param>
            <param name="tensor">
              A tensor to serialize.
            </param>
            <param name="serialized_summary_metadata">
              A serialized SummaryMetadata proto. Contains plugin
              data.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorSummaryV2'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TextLineDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Creates a dataset that emits the lines of one or more text files.
            </summary>
            <param name="filenames">
              A scalar or a vector containing the name(s) of the file(s) to be
              read.
            </param>
            <param name="compression_type">
              A scalar containing either (i) the empty string (no
              compression), (ii) "ZLIB", or (iii) "GZIP".
            </param>
            <param name="buffer_size">
              A scalar containing the number of bytes to buffer.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TextLineDataset'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TextLineReader(System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              A Reader that outputs the lines of a file delimited by '\n'.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TextLineReader'.
            </param>
            <param name="skip_header_lines">
              Optional argument
              Number of lines to skip from the beginning of every file.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.
            </param>
            <returns>
              The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TextLineReaderV2(System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              A Reader that outputs the lines of a file delimited by '\n'.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TextLineReaderV2'.
            </param>
            <param name="skip_header_lines">
              Optional argument
              Number of lines to skip from the beginning of every file.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.
            </param>
            <returns>
              The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TFRecordDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Creates a dataset that emits the records from one or more TFRecord files.
            </summary>
            <param name="filenames">
              A scalar or vector containing the name(s) of the file(s) to be
              read.
            </param>
            <param name="compression_type">
              A scalar containing either (i) the empty string (no
              compression), (ii) "ZLIB", or (iii) "GZIP".
            </param>
            <param name="buffer_size">
              A scalar representing the number of bytes to buffer. A value of
              0 means no buffering will be performed.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TFRecordDataset'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TFRecordReader(System.String,System.String,System.String,System.String)">
            <summary>
              A Reader that outputs the records from a TensorFlow Records file.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TFRecordReader'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.
            </param>
            <param name="compression_type">
              Optional argument
            </param>
            <returns>
              The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.TFRecordReaderV2(System.String,System.String,System.String,System.String)">
            <summary>
              A Reader that outputs the records from a TensorFlow Records file.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TFRecordReaderV2'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.
            </param>
            <param name="compression_type">
              Optional argument
            </param>
            <returns>
              The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ThreadUnsafeUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Generates labels for candidate sampling with a learned unigram distribution.
            </summary>
            <param name="true_classes">
              A batch_size * num_true matrix, in which each row contains the
              IDs of the num_true target_classes in the corresponding original label.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ThreadUnsafeUnigramCandidateSampler'.
            </param>
            <param name="seed">
              Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              An second seed to avoid seed collision.
            </param>
            <param name="num_true">
              Number of true labels per context.
            </param>
            <param name="num_sampled">
              Number of candidates to randomly sample.
            </param>
            <param name="unique">
              If unique is true, we sample with rejection, so that all sampled
              candidates in a batch are unique. This requires some approximation to
              estimate the post-rejection sampling probabilities.
            </param>
            <param name="range_max">
              The sampler will sample integers from the interval [0, range_max).
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              sampled_candidates: A vector of length num_sampled, in which each element is
              the ID of a sampled candidate.
              true_expected_count: A batch_size * num_true matrix, representing
              the number of times each candidate is expected to occur in a batch
              of sampled candidates. If unique=true, then this is a probability.
              sampled_expected_count: A vector of length num_sampled, for each sampled
              candidate representing the number of times the candidate is expected
              to occur in a batch of sampled candidates.  If unique=true, then this is a
              probability.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              See explanations of candidate sampling and the data formats at
              go/candidate-sampling.
              
              For each batch, this op picks a single set of sampled candidate labels.
              
              The advantages of sampling candidates per-batch are simplicity and the
              possibility of efficient dense matrix multiplication. The disadvantage is that
              the sampled candidates must be chosen independently of the context and of the
              true labels.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Tile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Constructs a tensor by tiling a given tensor.
            </summary>
            <param name="input">
              1-D or higher.
            </param>
            <param name="multiples">
              1-D. Length must be the same as the number of dimensions in `input`
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Tile'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation creates a new tensor by replicating `input` `multiples` times.
              The output tensor's i'th dimension has `input.dims(i) * multiples[i]` elements,
              and the values of `input` are replicated `multiples[i]` times along the 'i'th
              dimension. For example, tiling `[a b c d]` by `[2]` produces
              `[a b c d a b c d]`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TileGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns the gradient of `Tile`.
            </summary>
            <param name="input">
            </param>
            <param name="multiples">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TileGrad'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Since `Tile` takes an input and repeats the input `multiples` times
              along each dimension, `TileGrad` takes in `multiples` and aggregates
              each repeated tile of `input` into `output`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TopK(TensorFlow.TFOutput,System.Int64,System.Nullable{System.Boolean},System.String)">
            <summary>
              Finds values and indices of the `k` largest elements for the last dimension.
            </summary>
            <param name="input">
              1-D or higher with last dimension at least `k`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TopK'.
            </param>
            <param name="sorted">
              Optional argument
              If true the resulting `k` elements will be sorted by the values in
              descending order.
            </param>
            <param name="k">
              Number of top elements to look for along the last dimension (along each
              row for matrices).
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              values: The `k` largest elements along each last dimensional slice.
              indices: The indices of `values` within the last dimension of `input`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              If the input is a vector (rank-1), finds the `k` largest entries in the vector
              and outputs their values and indices as vectors.  Thus `values[j]` is the
              `j`-th largest entry in `input`, and its index is `indices[j]`.
              
              For matrices (resp. higher rank input), computes the top `k` entries in each
              row (resp. vector along the last dimension).  Thus,
              
                  values.shape = indices.shape = input.shape[:-1] + [k]
              
              If two elements are equal, the lower-index element appears first.
              
              If `k` varies dynamically, use `TopKV2` below.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TopKV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">
            <summary>
              Finds values and indices of the `k` largest elements for the last dimension.
            </summary>
            <param name="input">
              1-D or higher with last dimension at least `k`.
            </param>
            <param name="k">
              0-D.  Number of top elements to look for along the last dimension (along each
              row for matrices).
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TopKV2'.
            </param>
            <param name="sorted">
              Optional argument
              If true the resulting `k` elements will be sorted by the values in
              descending order.
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              values: The `k` largest elements along each last dimensional slice.
              indices: The indices of `values` within the last dimension of `input`.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              If the input is a vector (rank-1), finds the `k` largest entries in the vector
              and outputs their values and indices as vectors.  Thus `values[j]` is the
              `j`-th largest entry in `input`, and its index is `indices[j]`.
              
              For matrices (resp. higher rank input), computes the top `k` entries in each
              row (resp. vector along the last dimension).  Thus,
              
                  values.shape = indices.shape = input.shape[:-1] + [k]
              
              If two elements are equal, the lower-index element appears first.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Transpose(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Shuffle dimensions of x according to a permutation.
            </summary>
            <param name="x">
            </param>
            <param name="perm">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Transpose'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:
                `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TruncateDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns x / y element-wise for integer types.
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TruncateDiv'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Truncation designates that negative numbers will round fractional quantities
              toward zero. I.e. -7 / 5 = -1. This matches C semantics but it is different
              than Python semantics. See `FloorDiv` for a division function that matches
              Python Semantics.
              
              *NOTE*: `TruncateDiv` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Outputs random values from a truncated normal distribution.
            </summary>
            <param name="shape">
              The shape of the output tensor.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TruncatedNormal'.
            </param>
            <param name="seed">
              Optional argument
              If either `seed` or `seed2` are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              A second seed to avoid seed collision.
            </param>
            <param name="dtype">
              The type of the output.
            </param>
            <returns>
              A tensor of the specified shape filled with random truncated normal
              values.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The generated values follow a normal distribution with mean 0 and standard
              deviation 1, except that values whose magnitude is more than 2 standard
              deviations from the mean are dropped and re-picked.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.TruncateMod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Returns element-wise remainder of division. This emulates C semantics in that
            </summary>
            <param name="x">
            </param>
            <param name="y">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'TruncateMod'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              the result here is consistent with a truncating divide. E.g. `truncate(x / y) *
              y + truncate_mod(x, y) = x`.
              
              *NOTE*: `TruncateMod` supports broadcasting. More about broadcasting
              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.UniformCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">
            <summary>
              Generates labels for candidate sampling with a uniform distribution.
            </summary>
            <param name="true_classes">
              A batch_size * num_true matrix, in which each row contains the
              IDs of the num_true target_classes in the corresponding original label.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'UniformCandidateSampler'.
            </param>
            <param name="seed">
              Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.
            </param>
            <param name="seed2">
              Optional argument
              An second seed to avoid seed collision.
            </param>
            <param name="num_true">
              Number of true labels per context.
            </param>
            <param name="num_sampled">
              Number of candidates to randomly sample.
            </param>
            <param name="unique">
              If unique is true, we sample with rejection, so that all sampled
              candidates in a batch are unique. This requires some approximation to
              estimate the post-rejection sampling probabilities.
            </param>
            <param name="range_max">
              The sampler will sample integers from the interval [0, range_max).
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              sampled_candidates: A vector of length num_sampled, in which each element is
              the ID of a sampled candidate.
              true_expected_count: A batch_size * num_true matrix, representing
              the number of times each candidate is expected to occur in a batch
              of sampled candidates. If unique=true, then this is a probability.
              sampled_expected_count: A vector of length num_sampled, for each sampled
              candidate representing the number of times the candidate is expected
              to occur in a batch of sampled candidates.  If unique=true, then this is a
              probability.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              See explanations of candidate sampling and the data formats at
              go/candidate-sampling.
              
              For each batch, this op picks a single set of sampled candidate labels.
              
              The advantages of sampling candidates per-batch are simplicity and the
              possibility of efficient dense matrix multiplication. The disadvantage is that
              the sampled candidates must be chosen independently of the context and of the
              true labels.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Unique(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Finds unique elements in a 1-D tensor.
            </summary>
            <param name="x">
              1-D.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Unique'.
            </param>
            <param name="out_idx">
              Optional argument
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              y: 1-D.
              idx: 1-D.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              This operation returns a tensor `y` containing all of the unique elements of `x`
              sorted in the same order that they occur in `x`. This operation also returns a
              tensor `idx` the same size as `x` that contains the index of each value of `x`
              in the unique output `y`. In other words:
              
              `y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`
              
              For example:
              
              ```
              # tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]
              y, idx = unique(x)
              y ==&amp;gt; [1, 2, 4, 7, 8]
              idx ==&amp;gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.UniqueV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Finds unique elements in a 1-D tensor.
            </summary>
            <param name="x">
              A `Tensor`.
            </param>
            <param name="axis">
              A `Tensor` of type `int64` (default: 0). The axis of the Tensor to
              find the unique elements.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'UniqueV2'.
            </param>
            <param name="out_idx">
              Optional argument
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              y: A `Tensor`. Unique elements along the `axis` of `Tensor` x.
              idx: A 1-D Tensor. Has the same type as x that contains the index of each
              value of x in the output y.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              This operation returns a tensor `y` containing all of the unique elements of `x`
              sorted in the same order that they occur in `x`. This operation also returns a
              tensor `idx` the same size as `x` that contains the index of each value of `x`
              in the unique output `y`. In other words:
              
              `y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`
              
              For example:
              
              ```
              # tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]
              y, idx = unique(x)
              y ==&amp;gt; [1, 2, 4, 7, 8]
              idx ==&amp;gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.UniqueWithCounts(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Finds unique elements in a 1-D tensor.
            </summary>
            <param name="x">
              1-D.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'UniqueWithCounts'.
            </param>
            <param name="out_idx">
              Optional argument
            </param>
            <returns>
              Returns a tuple with multiple values, as follows:
              y: 1-D.
              idx: 1-D.
              count: 1-D.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
            </returns>
            <remarks>
              This operation returns a tensor `y` containing all of the unique elements of `x`
              sorted in the same order that they occur in `x`. This operation also returns a
              tensor `idx` the same size as `x` that contains the index of each value of `x`
              in the unique output `y`. Finally, it returns a third tensor `count` that
              contains the count of each element of `y` in `x`. In other words:
              
              `y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`
              
              For example:
              
              ```
              # tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]
              y, idx, count = unique_with_counts(x)
              y ==&amp;gt; [1, 2, 4, 7, 8]
              idx ==&amp;gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
              count ==&amp;gt; [2, 1, 3, 1, 2]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Unpack(TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.String)">
            <summary>
              Unpacks a given dimension of a rank-`R` tensor into `num` rank-`(R-1)` tensors.
            </summary>
            <param name="value">
              1-D or higher, with `axis` dimension size equal to `num`.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Unpack'.
            </param>
            <param name="axis">
              Optional argument
              Dimension along which to unpack.  Negative values wrap around, so the
              valid range is `[-R, R)`.
            </param>
            <param name="num">
            </param>
            <returns>
              The list of tensors unpacked from `value`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Unpacks `num` tensors from `value` by chipping it along the `axis` dimension.
              For example, given a tensor of shape `(A, B, C, D)`;
              
              If `axis == 0` then the i'th tensor in `output` is the slice `value[i, :, :, :]`
                and each tensor in `output` will have shape `(B, C, D)`. (Note that the
                dimension unpacked along is gone, unlike `split`).
              
              If `axis == 1` then the i'th tensor in `output` is the slice `value[:, i, :, :]`
                and each tensor in `output` will have shape `(A, C, D)`.
              Etc.
              
              This is the opposite of `pack`.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.UnsortedSegmentMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the Max along segments of a tensor.
            </summary>
            <param name="data">
            </param>
            <param name="segment_ids">
              A 1-D tensor whose rank is equal to the rank of `data`'s
              first dimension.
            </param>
            <param name="num_segments">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentMax'.
            </param>
            <returns>
              Has same shape as data, except for dimension 0 which
              has size `num_segments`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Read @{$math_ops#segmentation$the section on segmentation} for an explanation of
              segments.
              
              This operator is similar to the [unsorted segment sum operator](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).
              Instead of computing the sum over segments, it computes the maximum
              such that:
              
              \\(output_i = \max_j data_j\\) where max is over `j` such
              that `segment_ids[j] == i`.
              
              If the maximum is empty for a given segment ID `i`, it outputs the smallest possible value for specific numeric type,
               `output[i] = numeric_limits&amp;lt;T&amp;gt;::min()`.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/UnsortedSegmentMax.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.UnsortedSegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes the sum along segments of a tensor.
            </summary>
            <param name="data">
            </param>
            <param name="segment_ids">
              A tensor whose shape is a prefix of `data.shape`.
            </param>
            <param name="num_segments">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentSum'.
            </param>
            <returns>
              Has same shape as data, except for the first `segment_ids.rank`
              dimensions, which are replaced with a single dimension which has size
              `num_segments`.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Read @{$math_ops#segmentation$the section on segmentation} for an explanation of
              segments.
              
              Computes a tensor such that
              `(output[i] = sum_{j...} data[j...]` where the sum is over tuples `j...` such
              that `segment_ids[j...] == i`.  Unlike `SegmentSum`, `segment_ids`
              need not be sorted and need not cover all values in the full
              range of valid values.
              
              If the sum is empty for a given segment ID `i`, `output[i] = 0`.
              If the given segment ID `i` is negative, the value is dropped and will not be
              added to the sum of the segment.
              
              `num_segments` should equal the number of distinct segment IDs.
              
              &amp;lt;div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;"&amp;gt;
              &amp;lt;img style="width:100%" src="https://www.tensorflow.org/images/UnsortedSegmentSum.png" alt&amp;gt;
              &amp;lt;/div&amp;gt;
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Unstage(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">
            <summary>
              Op is similar to a lightweight Dequeue.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Unstage'.
            </param>
            <param name="capacity">
              Optional argument
            </param>
            <param name="memory_limit">
              Optional argument
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="dtypes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The basic functionality is similar to dequeue with many fewer
              capabilities and options.  This Op is optimized for performance.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.VarHandleOp(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String)">
            <summary>
              Creates a handle to a Variable resource.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'VarHandleOp'.
            </param>
            <param name="container">
              Optional argument
              the container this variable is placed in.
            </param>
            <param name="shared_name">
              Optional argument
              the name by which this variable is referred to.
            </param>
            <param name="dtype">
              the type of this variable. Must agree with the dtypes
              of all ops using this variable.
            </param>
            <param name="shape">
              The (possibly partially specified) shape of this variable.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Variable(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String,System.String)">
            <summary>
              Use VariableV2 instead.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Variable'.
            </param>
            <param name="container">
              Optional argument
            </param>
            <param name="shared_name">
              Optional argument
            </param>
            <param name="shape">
            </param>
            <param name="dtype">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.VariableShape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
              Returns the shape of the variable pointed to by `resource`.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'VariableShape'.
            </param>
            <param name="out_type">
              Optional argument
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation returns a 1-D integer tensor representing the shape of `input`.
              
              For example:
              
              ```
              # 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
              shape(t) ==&amp;gt; [2, 2, 3]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.VariableV2(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String,System.String)">
            <summary>
              Holds state in the form of a tensor that persists across steps.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'VariableV2'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this variable is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this variable is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.
            </param>
            <param name="shape">
              The shape of the variable tensor.
            </param>
            <param name="dtype">
              The type of elements in the variable tensor.
            </param>
            <returns>
              A reference to the variable tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              Outputs a ref to the tensor state so it may be read or modified.
              TODO(zhifengc/mrry): Adds a pointer to a more detail document
              about sharing states in tensorflow.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.VarIsInitializedOp(TensorFlow.TFOutput,System.String)">
            <summary>
              Checks whether a resource handle-based variable has been initialized.
            </summary>
            <param name="resource">
              the input resource handle.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'VarIsInitializedOp'.
            </param>
            <returns>
              a scalar boolean which is true if the variable has been
              initialized.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Where(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns locations of nonzero / true values in a tensor.
            </summary>
            <param name="input">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Where'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation returns the coordinates of true elements in `input`. The
              coordinates are returned in a 2-D tensor where the first dimension (rows)
              represents the number of true elements, and the second dimension (columns)
              represents the coordinates of the true elements. Keep in mind, the shape of
              the output tensor can vary depending on how many true values there are in
              `input`. Indices are output in row-major order.
              
              For example:
              
              ```
              # 'input' tensor is [[True, False]
              #                    [True, False]]
              # 'input' has two true values, so output has two coordinates.
              # 'input' has rank of 2, so coordinates have two indices.
              where(input) ==&amp;gt; [[0, 0],
                                [1, 0]]
              
              # `input` tensor is [[[True, False]
              #                     [True, False]]
              #                    [[False, True]
              #                     [False, True]]
              #                    [[False, False]
              #                     [False, True]]]
              # 'input' has 5 true values, so output has 5 coordinates.
              # 'input' has rank of 3, so coordinates have three indices.
              where(input) ==&amp;gt; [[0, 0, 0],
                                [0, 1, 0],
                                [1, 0, 1],
                                [1, 1, 1],
                                [2, 1, 1]]
              
              # `input` tensor is [[[1.5,  0.0]
              #                     [-0.5, 0.0]]
              #                    [[0.0,  0.25]
              #                     [0.0,  0.75]]
              #                    [[0.0,  0.0]
              #                     [0.0,  0.01]]]
              # 'input' has 5 nonzero values, so output has 5 coordinates.
              # 'input' has rank of 3, so coordinates have three indices.
              where(input) ==&amp;gt; [[0, 0, 0],
                                [0, 1, 0],
                                [1, 0, 1],
                                [1, 1, 1],
                                [2, 1, 1]]
              
              # `input` tensor is [[[1.5 + 0.0j, 0.0  + 0.0j]
              #                     [0.0 + 0.5j, 0.0  + 0.0j]]
              #                    [[0.0 + 0.0j, 0.25 + 1.5j]
              #                     [0.0 + 0.0j, 0.75 + 0.0j]]
              #                    [[0.0 + 0.0j, 0.0  + 0.0j]
              #                     [0.0 + 0.0j, 0.01 + 0.0j]]]
              # 'input' has 5 nonzero magnitude values, so output has 5 coordinates.
              # 'input' has rank of 3, so coordinates have three indices.
              where(input) ==&amp;gt; [[0, 0, 0],
                                [0, 1, 0],
                                [1, 0, 1],
                                [1, 1, 1],
                                [2, 1, 1]]
              ```
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.WholeFileReader(System.String,System.String,System.String)">
            <summary>
              A Reader that outputs the entire contents of a file as a value.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'WholeFileReader'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.
            </param>
            <returns>
              The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              To use, enqueue filenames in a Queue.  The output of ReaderRead will
              be a filename (key) and the contents of that file (value).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.WholeFileReaderV2(System.String,System.String,System.String)">
            <summary>
              A Reader that outputs the entire contents of a file as a value.
            </summary>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'WholeFileReaderV2'.
            </param>
            <param name="container">
              Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.
            </param>
            <param name="shared_name">
              Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.
            </param>
            <returns>
              The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              To use, enqueue filenames in a Queue.  The output of ReaderRead will
              be a filename (key) and the contents of that file (value).
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.WriteAudioSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)">
            <summary>
              Writes a `Summary` protocol buffer with audio.
            </summary>
            <param name="writer">
              A handle to a summary writer.
            </param>
            <param name="step">
              The step to write the summary for.
            </param>
            <param name="tag">
              Scalar. Used to build the `tag` attribute of the summary values.
            </param>
            <param name="tensor">
              2-D of shape `[batch_size, frames]`.
            </param>
            <param name="sample_rate">
              The sample rate of the signal in hertz.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteAudioSummary'.
            </param>
            <param name="max_outputs">
              Optional argument
              Max number of batch elements to generate audio for.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The summary has up to `max_outputs` summary values containing audio. The
              audio is built from `tensor` which must be 3-D with shape `[batch_size,
              frames, channels]` or 2-D with shape `[batch_size, frames]`. The values are
              assumed to be in the range of `[-1.0, 1.0]` with a sample rate of `sample_rate`.
              
              The `tag` argument is a scalar `Tensor` of type `string`.  It is used to
              build the `tag` of the summary values:
              
              *  If `max_outputs` is 1, the summary value tag is '*tag*/audio'.
              *  If `max_outputs` is greater than 1, the summary value tags are
                 generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.WriteFile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Writes contents to the file at input filename. Creates file and recursively
            </summary>
            <param name="filename">
              scalar. The name of the file to which we write the contents.
            </param>
            <param name="contents">
              scalar. The content to be written to the output file.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteFile'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              creates directory if not existing.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.WriteGraphSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Writes a `GraphDef` protocol buffer to a `SummaryWriter`.
            </summary>
            <param name="writer">
              Handle of `SummaryWriter`.
            </param>
            <param name="step">
              The step to write the summary for.
            </param>
            <param name="tensor">
              A scalar string of the serialized tf.GraphDef proto.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteGraphSummary'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.WriteHistogramSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Writes a `Summary` protocol buffer with a histogram.
            </summary>
            <param name="writer">
              A handle to a summary writer.
            </param>
            <param name="step">
              The step to write the summary for.
            </param>
            <param name="tag">
              Scalar.  Tag to use for the `Summary.Value`.
            </param>
            <param name="values">
              Any shape. Values to use to build the histogram.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteHistogramSummary'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The generated
              [`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)
              has one summary value containing a histogram for `values`.
              
              This op reports an `InvalidArgument` error if any value is not finite.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.WriteImageSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)">
            <summary>
              Writes a `Summary` protocol buffer with images.
            </summary>
            <param name="writer">
              A handle to a summary writer.
            </param>
            <param name="step">
              The step to write the summary for.
            </param>
            <param name="tag">
              Scalar. Used to build the `tag` attribute of the summary values.
            </param>
            <param name="tensor">
              4-D of shape `[batch_size, height, width, channels]` where
              `channels` is 1, 3, or 4.
            </param>
            <param name="bad_color">
              Color to use for pixels with non-finite values.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteImageSummary'.
            </param>
            <param name="max_images">
              Optional argument
              Max number of batch elements to generate images for.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The summary has up to `max_images` summary values containing images. The
              images are built from `tensor` which must be 4-D with shape `[batch_size,
              height, width, channels]` and where `channels` can be:
              
              *  1: `tensor` is interpreted as Grayscale.
              *  3: `tensor` is interpreted as RGB.
              *  4: `tensor` is interpreted as RGBA.
              
              The images have the same number of channels as the input tensor. For float
              input, the values are normalized one image at a time to fit in the range
              `[0, 255]`.  `uint8` values are unchanged.  The op uses two different
              normalization algorithms:
              
              *  If the input values are all positive, they are rescaled so the largest one
                 is 255.
              
              *  If any input value is negative, the values are shifted so input value 0.0
                 is at 127.  They are then rescaled so that either the smallest value is 0,
                 or the largest one is 255.
              
              The `tag` argument is a scalar `Tensor` of type `string`.  It is used to
              build the `tag` of the summary values:
              
              *  If `max_images` is 1, the summary value tag is '*tag*/image'.
              *  If `max_images` is greater than 1, the summary value tags are
                 generated sequentially as '*tag*/image/0', '*tag*/image/1', etc.
              
              The `bad_color` argument is the color to use in the generated images for
              non-finite input values.  It is a `unit8` 1-D tensor of length `channels`.
              Each element must be in the range `[0, 255]` (It represents the value of a
              pixel in the output image).  Non-finite values in the input tensor are
              replaced by this tensor in the output image.  The default value is the color
              red.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.WriteScalarSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Writes a `Summary` protocol buffer with scalar values.
            </summary>
            <param name="writer">
              A handle to a summary writer.
            </param>
            <param name="step">
              The step to write the summary for.
            </param>
            <param name="tag">
              Tag for the summary.
            </param>
            <param name="value">
              Value for the summary.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteScalarSummary'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The input `tag` and `value` must have the scalars.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.WriteSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Outputs a `Summary` protocol buffer with a tensor.
            </summary>
            <param name="writer">
              A handle to a summary writer.
            </param>
            <param name="step">
              The step to write the summary for.
            </param>
            <param name="tensor">
              A tensor to serialize.
            </param>
            <param name="tag">
              The summary's tag.
            </param>
            <param name="summary_metadata">
              Serialized SummaryMetadata protocol buffer containing
              plugin-related metadata for this summary.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteSummary'.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ZerosLike(TensorFlow.TFOutput,System.String)">
            <summary>
              Returns a tensor of zeros with the same shape and type as x.
            </summary>
            <param name="x">
              a tensor of type T.
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ZerosLike'.
            </param>
            <returns>
              a tensor of the same shape and type as x but filled with zeros.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Zeta(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Compute the Hurwitz zeta function \\(\zeta(x, q)\\).
            </summary>
            <param name="x">
            </param>
            <param name="q">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Zeta'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The Hurwitz zeta function is defined as:
              
              
              \\(\zeta(x, q) = \sum_{n=0}^{\infty} (q + n)^{-x}\\)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ZipDataset(TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">
            <summary>
              Creates a dataset that zips together `input_datasets`.
            </summary>
            <param name="input_datasets">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'ZipDataset'.
            </param>
            <param name="output_types">
            </param>
            <param name="output_shapes">
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Const(TensorFlow.TFTensor,System.String)">
            <summary>
            Creates a constant operation from a TFTensor or constant
            </summary>
            <param name="value">Value.</param>
            <param name="operName">Oper name.</param>
            <remarks>
            Since TFTensor have implicit conversion operators, you can call this method with
            a constant like this: graph.Const (23)
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReduceSum(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)">
            <summary>
            Computes the sum of elements across dimensions of a tensor.
            </summary>
            <returns>The reduced tensor.</returns>
            <param name="input">The tensor to reduce. Should have numeric type.</param>
            <param name="axis">The dimensions to reduce. If not se (the default), reduces all dimensions.</param>
            <param name="keep_dims">If set to <c>true</c> retains reduced dimensions with length 1.</param>
            <param name="operName">A name for the operation, optional.</param>
            <remarks>
              Reduces input_tensor along the dimensions given in axis.
            Unless keep_dims is true, the rank of the tensor is reduced by 1 for each
            entry in axis. If keep_dims is true, the reduced dimensions
            are retained with length 1.
            
            If axis has no entries, all dimensions are reduced, and a
            tensor with a single element is returned.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReduceProd(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)">
            <summary>
            Computes the product of elements across dimensions of a tensor.
            </summary>
            <returns>The reduced tensor.</returns>
            <param name="input">The tensor to reduce. Should have numeric type.</param>
            <param name="axis">The dimensions to reduce. If not se (the default), reduces all dimensions.</param>
            <param name="keep_dims">If set to <c>true</c> retains reduced dimensions with length 1.</param>
            <param name="operName">A name for the operation, optional.</param>
            <remarks>
              Reduces input_tensor along the dimensions given in axis.
            Unless keep_dims is true, the rank of the tensor is reduced by 1 for each
            entry in axis. If keep_dims is true, the reduced dimensions
            are retained with length 1.
            
            If axis has no entries, all dimensions are reduced, and a
            tensor with a single element is returned.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ReduceMean(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)">
            <summary>
            Computes the mean of elements across dimensions of a tensor.
            </summary>
            <returns>The reduced tensor.</returns>
            <param name="input">The tensor to reduce. Should have numeric type.</param>
            <param name="axis">The dimensions to reduce. If not set (the default), reduces all dimensions.</param>
            <param name="keep_dims">If set to <c>true</c> retains reduced dimensions with length 1.</param>
            <param name="operName">A name for the operation, optional.</param>
            <remarks>
            <para>
              Reduces input_tensor along the dimensions given in axis.
            Unless keep_dims is true, the rank of the tensor is reduced by 1 for each
            entry in axis. If keep_dims is true, the reduced dimensions
            are retained with length 1.</para>
            
            <para>
            If axis has no entries, all dimensions are reduced, and a
            tensor with a single element is returned.</para>
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,TensorFlow.TFOperation@,TensorFlow.TFOutput@,System.Boolean,System.String)">
            <summary>
            Variable node, with a starting initial value.
            </summary>
            <param name="initialValue">Initial value.</param>
            <param name="init">Returns the operation that initializes the value of the variable.</param>
            <param name="value">Returns the value of the variable.</param>
            <param name="trainable">If true, this add the variable to the graph's TrainableVariables, this collection is intended to be used by the Optimizer classes.</param>
            <param name="operName">Operation name, optional.</param>
            <returns>The returning Variable contains the variable, with three nodes with the operations making up the variable assignment.</returns>
            <remarks>
            Variables need to be initialized before the main execution so you will typically want to
            run the session on the variable
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.AddInitVariable(TensorFlow.TFOperation)">
            <summary>
            Registers a specified variable as an initialization variable.
            </summary>
            <param name="variable">Variable to register.</param>
            <remarks>
            <para>
            This is a convenience method to track the variables that need to be initialized in the graph,
            you can retrieve the list of all those variables by calling the <see cref="M:TensorFlow.TFGraph.GetGlobalVariablesInitializer"/>
            which will return this list and clear the state at that point.
            </para>
            <para>
            You typically use this method from helper methods to register all the variables that you want
            initialized, and a higher level method will retrieve all these variables and initialize them
            at their convenience.
            </para>
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.GetGlobalVariablesInitializer">
            <summary>
            Gets the list of all registered global variables.
            </summary>
            <returns>The array of variables that should be initialized.</returns>
            <remarks>
            After this method is invoked the list of pending initialization variables
            is cleared.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,TensorFlow.TFOutput@,System.Boolean,System.String)">
            <summary>
            Variable node, with a starting initial value.  Convenience that registers the init variable to a global queue.
            </summary>
            <param name="initialValue">Initial value.</param>
            <param name="value">Returns the value of the variable.</param>
            <param name="trainable">If true, this add the variable to the graph's TrainableVariables, this collection is intended to be used by the Optimizer classes.</param>
            <param name="operName">Operation name, optional.</param>
            <returns>The returning Variable contains the variable, with three nodes with the operations making up the variable assignment.</returns>
            <remarks>
            Variables need to be initialized before the main execution so you will typically want to
            run the session on the variable.
            
            The init sequence for the variable is stored in the graph, you must manually initialize 
            those by running the session on the global variables.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,System.Boolean,System.String)">
            <summary>
            Variable node, with a starting initial value.  Convenience that registers the init variable to a global queue.
            </summary>
            <param name="initialValue">Initial value.</param>
            <param name="trainable">If true, this add the variable to the graph's TrainableVariables, this collection is intended to be used by the Optimizer classes.</param>
            <param name="operName">Operation name, optional.</param>
            <returns>The returning Variable contains the variable, with three nodes with the operations making up the variable assignment.</returns>
            <remarks>
            Variables need to be initialized before the main execution so you will typically want to
            run the session on the variable.
            
            The init sequence for the variable is stored in the graph, you must manually initialize 
            those by running the session on the global variables.
            </remarks>
        </member>
        <member name="P:TensorFlow.TFGraph.Seed">
             <summary>
             Gets or sets the graph random seed, see remarks for details.
             </summary>
             <value>The seed.</value>
             <remarks>
              Operations that rely on a random seed actually derive it from two seeds:
              the graph-level and operation-level seeds.This sets the graph-level seed.
            
             Its interactions with operation-level seeds is as follows:
             1. If neither the graph-level nor the operation seed is set:
                A random seed is used for this op.
             2. If the graph-level seed is set, but the operation seed is not:
                The system deterministically picks an operation seed in conjunction
                with the graph-level seed so that it gets a unique random sequence.
             3. If the graph-level seed is not set, but the operation seed is set:
                A default graph-level seed and the specified operation seed are used to
                determine the random sequence.
             4. If both the graph-level and the operation seed are set:
                Both seeds are used in conjunction to determine the random sequence.
             </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.GetRandomSeeds(System.Nullable{System.Int32},System.Int32@,System.Int32@)">
            <summary>
            Returns the graph and local seeds based on an optionally set incoming seed value.
            </summary>
            <param name="operationSeed">The seed value that might be set.</param>
            <param name="graphSeed">Returned graph seed.</param>
            <param name="localSeed">Returned local seed.</param>
            <remarks>
            This helper function returns two seeds derived from graph-level and op-level seeds.
            Many random operations internally use the two seeds to allow user to change 
            the seed globally for a graph, or for only specific operations.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Dropout(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFShape,System.Nullable{System.Int32},System.String)">
            <summary>
            Computes dropout. 
            </summary>
            <param name="x">A tensor.</param>
            <param name="keep_prob">A scalar Tensor with the same type as x. The probability that each element is kept.</param>
            <param name="noise_shape">A 1-D Tensor of type int32, representing the shape for randomly generated keep/drop flags.</param>
            <param name="seed">Integer seed used for the random distribution, using the TensorFlow SetRandomSeed .</param>
            <param name="operName">Operation name, optional.</param>
            <remarks>
            With probability keep_prob, outputs the input element scaled up by 1 / keep_prob, 
            otherwise outputs 0. The scaling is so that the expected sum is unchanged.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Dropout(TensorFlow.TFOutput,System.Double,TensorFlow.TFShape,System.Nullable{System.Int32},System.String)">
            <summary>
            Computes dropout. 
            </summary>
            <param name="x">A tensor.</param>
            <param name="keep_prob">A scalar Tensor with the same type as x. The probability that each element is kept.</param>
            <param name="noise_shape">A 1-D Tensor of type int32, representing the shape for randomly generated keep/drop flags.</param>
            <param name="seed">Integer seed used for the random distribution, using the TensorFlow SetRandomSeed .</param>
            <param name="operName">Operation name, optional.</param>
            <remarks>
            With probability keep_prob, outputs the input element scaled up by 1 / keep_prob, 
            otherwise outputs 0. The scaling is so that the expected sum is unchanged.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ClipByValue(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
            Clips tensor values to a specified min and max.
            </summary>
            <remarks>
            Given a tensor <paramref name="x"/>, this operation returns a tensor of the same type and shape
            as <paramref name="x"/> with its values clipped to <paramref name="clip_value_min"/> and <paramref name="clip_value_max"/>.
            Any values less than <paramref name="clip_value_min"/> are set to <paramref name="clip_value_min"/>. Any values greater than 
            <paramref name="clip_value_max"/> are set to <paramref name="clip_value_max"/>.
            </remarks>
            <param name="x">The tensor.</param>
            <param name="clip_value_min">The minimum value to clip by. A 0 - D(scalar) tensor, or a tensor with the same shape as <paramref name="x"/>.</param>
            <param name="clip_value_max">The minimum value to clip by. A 0 - D(scalar) tensor, or a tensor with the same shape as <paramref name="x"/>.</param>
            <param name="operName">Operation name, optional.</param>
            <returns>A clipped <see cref="T:TensorFlow.TFOutput">tensor</see>.</returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ClipByNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.String)">
            <summary>
            Clips tensor values to a maximum L2-norm.
            </summary>
            <remarks>
            <para>
            Given a tensor <paramref name="x"/>, and a maximum clip value <paramref name="clip_norm"/>, this operation normalizes 
            <paramref name="x"/> so that its L2-norm is less than or equal to <paramref name="clip_norm"/>, along the dimensions 
            given in <paramref name="axes"/>. Specifically, in the default case where all dimensions are used for calculation, if
            the L2-norm of <paramref name="x"/> is already less than or equal to <paramref name="clip_norm"/>, then <paramref name="x"/>
            is not modified. If the L2-norm is greater than <paramref name="clip_norm"/>, then this operation returns a tensor of 
            the same type and shape as <paramref name="x"/> with its values set to: <c>t* clip_norm / l2norm(t)</c></para>
            </remarks>
            <param name="x">The tensor.</param>
            <param name="clip_norm">The minimum value to clip by. A 0 - D(scalar) tensor, or a tensor with the same shape as <paramref name="x"/>.</param>
            <param name="axes">The minimum value to clip by. A 0 - D(scalar) tensor, or a tensor with the same shape as <paramref name="x"/>.</param>
            <param name="operName">Operation name, optional.</param>
            <returns>A clipped <see cref="T:TensorFlow.TFOutput">tensor</see>.</returns>
        </member>
        <member name="M:TensorFlow.TFGraph.GlobalNorm(TensorFlow.TFOutput[],System.String)">
            <summary>
            Computes the global norm of multiple tensors.
            </summary>
            <remarks>
            <para>
             Given a tuple or list of tensors <paramref name="tensors"/>, this operation returns the global norm of the elements in all tensors 
             in <paramref name="tensors"/>. The global norm is computed as: <c>global_norm = sqrt(sum([l2norm(t)**2 for t in t_list]))</c>. Any 
             entries in <paramref name="tensors"/> that are of type None are ignored.</para>
            </remarks>
            <param name="tensors">The input tensors.</param>
            <param name="operName">Operation name, optional.</param>
            <returns>A clipped <see cref="T:TensorFlow.TFOutput">tensor</see>.</returns>
        </member>
        <member name="M:TensorFlow.TFGraph.ClipByAverageNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
            Clips tensor values to a maximum average L2-norm.
            </summary>
            <remarks>
            Given a tensor <paramref name="x"/>, and a maximum clip value <paramref name="clip_norm"/>, this operation 
            normalizes <paramref name="x"/> so that its its average L2-norm is less than or equal to <paramref name="clip_norm"/>.
            Specifically, if the average L2-norm is already less than or equal to <paramref name="clip_norm"/>, then <paramref name="x"/>
            is not modified. If the average L2-norm is greater than <paramref name="clip_norm"/>, then this operation returns a tensor of the same
            type and shape as <paramref name="x"/> with its values set to: <c>t* clip_norm / l2norm_avg(t)</c>. In this case, 
            the average L2-norm of the output tensor is <paramref name="clip_norm"/>.
            </remarks>
            <param name="x">The input tensor.</param>
            <param name="clip_norm">A maximum clipping value.</param>
            <param name="operName">Name of the oper.</param>
        </member>
        <member name="M:TensorFlow.TFGraph.SigmoidCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">
            <summary>
              Computes sigmoid cross entropy given `logits`.
            </summary>
            
            <remarks>
               Measures the probability error in discrete classification tasks in which each
               class is independent and not mutually exclusive.For instance, one could
               perform multilabel classification where a picture can contain both an elephant
               and a dog at the same time.
            </remarks>
            
        </member>
        <member name="M:TensorFlow.TFGraph.Transpose(TensorFlow.TFOutput,System.String)">
            <summary>
              Shuffle dimensions of x according to a permutation.
            </summary>
            <param name="x">
            </param>
            <param name="operName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'Transpose'.
            </param>
            <returns>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:
                `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Cond(TensorFlow.TFOutput,System.Func{TensorFlow.TFOutput},System.Func{TensorFlow.TFOutput},System.String)">
            <summary>
              Returns <paramref name="true_fn"/> if the predicate <paramref name="pred"/> is <c>true</c> else <paramref name="false_fn"/>.
            </summary>
            <param name="pred">A scalar determining whether to return the result of true_fn or false_fn.</param>
            <param name="true_fn">The callable to be performed if pred is true.</param>
            <param name="false_fn">The callable to be performed if pred is false.</param>
            <param name="operName">Optional name prefix for the returned tensors.</param>
            <returns>TFOutput.</returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Where(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFOutput},System.String)">
            <summary>
              Return elements from x or y depending on condition.
            </summary>
            
            <param name="condition">LabeledTensor of type `bool`.</param>
            <param name="x">LabeledTensor for values where condition is true.</param>
            <param name="y">LabeledTensor for values where condition is false.</param>
            <param name="name">Optional op name.</param>
            
            <returns>The labeled tensor with values according to condition.</returns>
            
        </member>
        <member name="M:TensorFlow.TFGraph.Stack(TensorFlow.TFOutput[],System.Nullable{System.Int32},System.String)">
            <summary>
            Stacks a list of rank-`R` tensors into one rank-`(R+1)` tensor.
            </summary>
            <remarks>
             Packs the list of tensors in <paramref name="values"/> into a tensor with rank one higher than
             each tensor in <paramref name="values"/>, by packing them along the <paramref name="axis"/> dimension.
             Given a list of length <c>N</c> of tensors of shape <c>(A, B, C)</c>: if <c>axis == 0</c> then the 
             <c>output</c> tensor will have the shape <c>(N, A, B, C)</c>; if <c>axis == 1</c> then the <c>output</c>
             tensor will have the shape <c>(A, N, B, C)</c>; etc.
            </remarks>
            
        </member>
        <member name="M:TensorFlow.TFGraph.Range(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFDataType},System.String)">
            <summary>
            Creates a sequence of numbers.
            </summary>
            <remarks>
            Creates a sequence of numbers that begins at `start` and extends by increments of `delta` up to but not including 
            `limit`. The dtype of the resulting tensor is inferred from the inputs unless it is provided explicitly.
            </remarks>
            <param name="start">A 0 - D `Tensor` (scalar).Acts as first entry in the range if `limit` is not None; otherwise, acts as range limit and first entry defaults to 0.</param>
            <param name="limit">A 0 - D `Tensor` (scalar).Upper limit of sequence, exclusive. If None, defaults to the value of `start` while the first entry of the range defaults to 0.</param>
            <param name="delta">A 0 - D `Tensor` (scalar).Number that increments `start`. Defaults to 1.</param>
            <param name="dataType">The type of the elements of the resulting tensor.</param>
            <param name="operName">A name for the operation.Defaults to "range".</param>
        </member>
        <member name="M:TensorFlow.TFGraph.Zeros(TensorFlow.TFShape,TensorFlow.TFDataType,System.String)">
            <summary>
            Outputs Zero values based on shape of tensor
            </summary>
            <param name="shape">Shape of the output tensor</param>
            <param name="dtype">Optional Type of the Zero value. Default: Double</param>
            <param name="operName">Operation name, optional.</param>
            <returns></returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Ones(TensorFlow.TFShape,TensorFlow.TFDataType,System.String)">
            <summary>
            Outputs One values based on shape of tensor
            </summary>
            <param name="shape">Shape of the output tensor</param>
            <param name="dtype">Optional Type of the Zero value. Default: Double</param>
            <param name="operName">Operation name, optional.</param>
            <returns></returns>
        </member>
        <member name="M:TensorFlow.TFGraph.Constant(System.Object,TensorFlow.TFShape,TensorFlow.TFDataType,System.String)">
            <summary>
            Create a constant tensor based on a shape
            Used by Zeros and Ones
            </summary>
            <param name="value">Value for tensor</param>
            <param name="tfshape">Shape of the tensor</param>
            <param name="dtype">Optional Type of the Zero value. Default: Double</param>
            <param name="operName">Operation name, optional.</param>
            <returns></returns>
            see https://github.com/tensorflow/tensorflow/blob/r1.1/tensorflow/python/framework/constant_op.py
        </member>
        <member name="M:TensorFlow.TFGraph.RandomNormal(TensorFlow.TFShape,System.Double,System.Double,System.Nullable{System.Int32},System.String)">
            <summary>
            Outputs random values from a normal distribution
            </summary>
            <returns>A tensor of the specified shape filled with random normal values.</returns>
            <param name="shape">Shape of the output tensor.</param>
            <param name="mean">The mean of the standard distribution.</param>
            <param name="stddev">The standard deviation of the normal distribution.</param>
            <param name="seed">Integer seed used for the random distribution, using the TensorFlow SetRandomSeed .</param>
            <param name="operName">Operation name, optional.</param>
        </member>
        <member name="M:TensorFlow.TFGraph.RandomUniform(TensorFlow.TFShape,System.Double,System.Double,System.Nullable{System.Int32},System.String)">
            <summary>
            Randoms the uniform.
            </summary>
            <returns>The uniform.</returns>
            <param name="shape">Shape.</param>
            <param name="minval">Minval.</param>
            <param name="maxval">Maxval.</param>
            <param name="seed">Seed.</param>
            <param name="operName">Oper name.</param>
        </member>
        <member name="M:TensorFlow.TFGraph.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TensorFlow.TFGraph"/> class.
            </summary>
        </member>
        <member name="M:TensorFlow.TFGraph.SetTensorShape(TensorFlow.TFOutput,System.Int64[],TensorFlow.TFStatus)">
            <summary>
            Sets the tensor shape of the tensor referenced by <paramref name="output"/> to the shape described by <paramref name="dims"/>.
            </summary>
            <param name="output">The tensor on which this method will operate in the graph.</param>
            <param name="dims">The tensor shape, specified as an array of dimensions.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="M:TensorFlow.TFGraph.GetTensorNumDims(TensorFlow.TFOutput,TensorFlow.TFStatus)">
            <summary>
            Returns the number of dimensions of the Tensor referenced by output
            </summary>
            <returns>The number of dimensions of the tensor.</returns>
            <param name="output">The tensor to probe.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="M:TensorFlow.TFGraph.GetTensorShape(TensorFlow.TFOutput,TensorFlow.TFStatus)">
             <summary>
             Returns the shape of a tensor specified in <paramref name="output"/>.
             </summary>
            
             <returns>The tensor shape.    If the number of dimensions in the shape is unknown or the shape is, a scalar, the values in the array will be zero. Otherwise, each element of will be set corresponding to the size of the dimension. An  unknown dimension is represented by -1.</returns>
             <param name="output">The tensor that you want to look up.  </param>
             <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="M:TensorFlow.TFGraph.ToGraphDef(TensorFlow.TFBuffer,TensorFlow.TFStatus)">
            <summary>
            Write out a serialized representation of the graph (as a GraphDef protocol buffer message) into <paramref name="outputGraphDef"/>.
            </summary>
            <param name="outputGraphDef">Target buffer where the graphs is serialized into.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="M:TensorFlow.TFGraph.Import(TensorFlow.TFBuffer,System.String,TensorFlow.TFStatus)">
            <summary>
            Import a serialized graph into this graph, using the specified prefix.
            </summary>
            <returns>The import.</returns>
            <param name="graphDef">A buffer containing the serialized graph.</param>
            <param name="prefix">A prefix that will be prepended to names of nodes in the <paramref name="graphDef"/> when they are imported into the graph.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="M:TensorFlow.TFGraph.Import(TensorFlow.TFBuffer,TensorFlow.TFImportGraphDefOptions,TensorFlow.TFStatus)">
            <summary>
            Import a serialized graph into this graph, using the specified importing options.
            </summary>
            <returns>The import.</returns>
            <param name="graphDef">A buffer containing the serialized graph.</param>
            <param name="options">Importing graph options.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="M:TensorFlow.TFGraph.Import(System.Byte[],System.String,TensorFlow.TFStatus)">
            <summary>
            Import a serialized graph held in a byte array into this graph, using the specified prefix.
            </summary>
            <returns>The import.</returns>
            <param name="buffer">A byte array containing the serialized graph.</param>
            <param name="prefix">A prefix that will be prepended to names of nodes in the graph when they are imported into the graph.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>		
        </member>
        <member name="M:TensorFlow.TFGraph.Import(System.Byte[],TensorFlow.TFImportGraphDefOptions,TensorFlow.TFStatus)">
            <summary>
            Import a serialized graph held in a byte array into this graph, using the specified import options.
            </summary>
            <returns>The import.</returns>
            <param name="buffer">A byte array containing the serialized graph.</param>
            <param name="options">Importing graph options.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="P:TensorFlow.TFGraph.Item(System.String)">
            <summary>
            Gets the <see cref="T:TensorFlow.TFGraph"/> with the specified name, or null if the named operation does not exist in the graph.
            </summary>
            <param name="name">Name to lookup.</param>
        </member>
        <member name="M:TensorFlow.TFGraph.GetEnumerator">
            <summary>
            Returns the enumerator that returns all the TFOperations in a graph.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="M:TensorFlow.TFGraph.GetShape(TensorFlow.TFOutput,TensorFlow.TFStatus)">
            <summary>
             Returns the tensor shape for the specific output pparameters as an array of longs.
            </summary>
            <returns>null for single dimension, .</returns>
            <param name="output">The output operation to probe.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="P:TensorFlow.TFGraph.CurrentNameScope">
            <summary>
            Returns the current name scope in use, to change this, use the WithScope method.
            </summary>
            <value>The current name scope.</value>
        </member>
        <member name="M:TensorFlow.TFGraph.WithScope(System.String)">
            <summary>
            Creates a new namescope by setting the scope to the description provided.
            </summary>
            <returns>A new scope that will remain in use until the return TFScope is disposed.</returns>
            <param name="nameScopeDesc">The namescope description, if the value is null, this
            will reset the toplevel namescope to be the empty value. </param>
            <remarks>
            <para>
            To more easily name your operations and group then, you can use the
            WithScope method to set a current name scope that alter the complete name
            of an operation added to the graph.
            </para>
            <para>
            The graph starts with a scope set to the empty string, you can introduce new
            scopes by calling WithScope, and can be conveniently used with the C# using
            statement, like this:
            </para>
            <code>
            Assert (graph.CurrentNamescope, "");
            using (var nested = graph.WithScope ("nested")){
               Assert (graph.CurrentNameScope, "nested");
               using (var inner = graph.WithScope ("inner")){
                   Assert (graph.CurrentNameScope, "nested/inner");
               }
            }
            </code>
            </remarks>
        </member>
        <member name="P:TensorFlow.TFGraph.CurrentDependencies">
            <summary>
            Returns the current variable dependencies in use. New tensors and operations will be created
            with an added input dependency to the operations specified in this property. To change this, 
            use the WithDependencies method.
            </summary>
            <value>The current input dependencies to be used for new tensors and operations.</value>
        </member>
        <member name="M:TensorFlow.TFGraph.WithDependencies(TensorFlow.TFOperation[])">
            <summary>
            Adds new dependencies for new tensors and operations created while the context is active.
            </summary>
        </member>
        <member name="M:TensorFlow.TFGraph.ImportGraphDef(TensorFlow.TFBuffer,TensorFlow.TFImportGraphDefOptions,TensorFlow.TFOutput[],TensorFlow.TFStatus)">
            <summary>
            Imports a graph serialized into the graph
            </summary>
            <param name="graphDef">Serialized graph definition (in protocol buffer format).</param>
            <param name="options">Import options.</param>
            <param name="returnOutputs">Array large enough to contain all the return options.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="T:TensorFlow.TFGraph.WhileConstructor">
            <summary>
            Signature of the method that will be invoked by the TFGraph.While method to construct a while loop
            </summary>
            <remarks>
            <para>
            The method should build up the condition on the conditionGraph and the body of the while 
            loop in the provided bodyGraph.   It should set the condOutput to the value used as the
            condition output and the array of values in bodyOutputs to the final outputs as well as the
            name to be used, if not set, one will be assigned.
            </para>
            <para>
            The conditionGraph represents the while condition and the inputs are the current values of the
            input variables (condInputs).   The output should be a scalar boolean.
            </para>
            <para>
            The loop body graph is in bodyGraph, The inputs are the current values of the loop
            variables. The outputs are the updated values of the loop variables.
            </para>
            <para>
            You can use the passed status record problems with it.
            </para>
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.While(TensorFlow.TFOutput[],TensorFlow.TFGraph.WhileConstructor,TensorFlow.TFStatus)">
            <summary>
            Constructs a while loop with the specified inputs and a callback that composes the while loop
            </summary>
            <param name="inputs">Inputs.</param>
            <param name="constructor">Callback method that fills out the various while loop parameters.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
            <returns>
            An array of TFOutputs from creating the While loop, or null if there is an error creating the 
            while loop, or if the constructor raised an exception when it was invoked.
            </returns>
        </member>
        <member name="M:TensorFlow.TFGraph.AddGradients(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFStatus)">
            <summary>
            Adds a gradient: the operations needed to compute the partial derivatives of sum of <paramref name="y"/>` wrt to <paramref name="x"/>.
            </summary>
            <returns>The partial derivatives, the size of the array is the same as the length of the <paramref name="y"/> array.</returns>
            <param name="y">The y elements.</param>
            <param name="x">The x elements.</param>
            <param name="dx">Initial gradients, which represent the symbolic partial derivatives of some loss function `L` w.r.t. <paramref name="y"/> ).   
            If the parameter is null, the implementation will use dx for 'OnesLike' for all shapes in <paramref name="y"/></param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
            <remarks>
            d(y[0] + y[1]+ ...)/dx[0], d(y[0] + y[1] + ...)/dx[1]z...
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.ToFunction(System.String,System.String,TensorFlow.TFOperation[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String[],System.Boolean,TensorFlow.TFStatus)">
            <summary>
            Creates a TFFunction from a TFGraph
            </summary>
            <returns>The function.</returns>
            <param name="functionName">Name of the new function.  Should match the operation name (OpDef.name) regexp [A-Z][A-Za-z0-9_.\\-/]*.  If appendHashToFunctioName is false, the name must be unique (at least those registered in graphs where this function will be used).</param>
            <param name="description">Optional, human readable description of this function.</param>
            <param name="operations">Array of operations to become the body of the function or null.  
                If no array is given , all the
                operations in function body will become part of the function
                except operations referenced in inputs. These operations
                must have a single output (these operations are typically
                placeholders created for the sole purpose of representing
                an input).
            
                If an array is given, all operations
                in it will become part of the function. In particular, no
                automatic skipping of dummy input operations is performed.
            </param>
            <param name="inputs">Array that specify the inputs to the function, or null.  The names used for function inputs are normalized
                names of the operations (usually placeholders) pointed to by
                inputs.  These operation names should start with a letter.
                Normalization will convert all letters to lowercase and
                non-alphanumeric characters to '_' to make resulting names match
                the "[a-z][a-z0-9_]*" pattern for operation argument names.
                `inputs` cannot contain the same tensor twice.</param>
            <param name="outputs">rray that specify the inputs to the function, or null.   This can contain the same tensor twice.</param>
            <param name="outputNames">The names of the function's outputs.   The array either has the same elements of outputs, or be null.   Names must match "[a-z][a-z0-9_]*" regexp, if null is passed, the names are generated automatically.</param>
            <param name="appendHashToFunctionName">If set to <c>true</c> appends hash to functionName, otherwise it will use the specified name in functionName.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
            <remarks>
            <para>
              This method converts the graph whose operations (or a subset of its operations) will be converted
              into a TFFunction.
            </para>
            <para>
              Note that when the same TF_Output is listed as both an input and an output,
              the corresponding function's output will equal to this input,
              instead of the original node's output.
            </para>
            <para>
            Callers must also satisfy the following constraints:
            </para>
            <para>
              <paramref name="inputs"/> cannot refer to TFOutputs within a control flow context. For
              example, one cannot use the output of "switch" node as input.
            </para>
            <para>
              <paramref name="inputs"/> and <paramref name="outputs"/> cannot have reference types. Reference types are
              not exposed through C API and are being replaced with Resources. We support
              reference types inside function's body to support legacy code. Do not
              use them in new code.
            </para>
            <para>
              Every node in the function's body must have all of its inputs (including
              control inputs). In other words, for every node in the body, each input
              must be either listed in <paramref name="inputs"/> or must come from another node in
              the body. In particular, it is an error to have a control edge going from
              a node outside of the body into a node in the body. This applies to control
              edges going from nodes referenced in <paramref name="inputs"/> to nodes in the body when
              the former nodes are not in the body (automatically skipped or not
              included in explicitly specified body).
            </para>
            </remarks>
        </member>
        <member name="M:TensorFlow.TFGraph.Versions(TensorFlow.TFBuffer,TensorFlow.TFStatus)">
            <summary>
            Returns the serialized VersionDef proto for this graph.
            </summary>
            <returns>The versions.</returns>
            <param name="outputVersionDef">The buffer where the serialized protocol buffer will be stored.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="T:TensorFlow.QueueBase">
            <summary>
            Base class for queue implementations.
            Port of Python implementation https://github.com/tensorflow/tensorflow/blob/r1.3/tensorflow/python/ops/data_flow_ops.py
            </summary>
        </member>
        <member name="M:TensorFlow.QueueBase.#ctor(TensorFlow.TFSession)">
            <summary>
            A queue is a TensorFlow data structure that stores tensors across
            multiple steps, and exposes operations that enqueue and dequeue
            tensors.
            Each queue element is a tuple of one or more tensors, where each
            tuple component has a static dtype, and may have a static shape.The
            queue implementations support versions of enqueue and dequeue that
            handle single elements, versions that support enqueuing and
            dequeuing a batch of elements at once.
            </summary>
            <param name="session">Session instance</param>
        </member>
        <member name="P:TensorFlow.QueueBase.Session">
            <summary>
            The session that this QueueBased was created for.
            </summary>
            <value>The session.</value>
        </member>
        <member name="M:TensorFlow.QueueBase.Enqueue(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">
            <summary>
              Enqueues a tuple of one or more tensors in this queue.
            </summary>
            <param name="components">
              One or more tensors from which the enqueued tensors should be taken.
            </param>
            <param name="operationName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueV2'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is full, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The components input has k elements, which correspond to the components of
              tuples stored in the given queue.
            </remarks>
        </member>
        <member name="M:TensorFlow.QueueBase.Dequeue(System.Nullable{System.Int64},System.String)">
            <summary>
              Dequeues a tuple of one or more tensors from this queue.
            </summary>
            <param name="operationName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueV2'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is empty, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <returns>
              One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation has k outputs, where k is the number of components
              in the tuples stored in the given queue, and output i is the ith
              component of the dequeued tuple.
            </remarks>
        </member>
        <member name="M:TensorFlow.QueueBase.GetSize(System.String)">
            <summary>
            Gets the size of this queue.
            </summary>
            <param name="operationName"></param>
            <returns>queue size</returns>
        </member>
        <member name="T:TensorFlow.PaddingFIFOQueue">
            <summary>
            A FIFOQueue that supports batching variable-sized tensors by padding.
            Port of Python implementation https://github.com/tensorflow/tensorflow/blob/b46340f40fe5e2ec9bfcd385b07cfb914055fb51/tensorflow/python/ops/data_flow_ops.py#L697
            </summary>
        </member>
        <member name="M:TensorFlow.PaddingFIFOQueue.#ctor(TensorFlow.TFSession,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int32},System.String,System.String)">
            <summary>
            Creates a queue that dequeues elements in a first-in first-out order.
            A `PaddingFIFOQueue` has bounded capacity; supports multiple concurrent
            producers and consumers; and provides exactly-once delivery.
            A `PaddingFIFOQueue` holds a list of up to `capacity` elements.Each
            element is a fixed-length tuple of tensors whose dtypes are
            described by `dtypes`, and whose shapes are described by the `shapes`
            </summary>
            <param name="session"></param>
            <param name="componentTypes">The type of each component in a tuple.</param>
            <param name="shapes">
              Optional argument
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types.
              Shapes of fixed rank but variable size are allowed by setting
              any shape dimension to -1.  In this case, the inputs' shape may vary along
              the given dimension, and DequeueMany will pad the given dimension with
              zeros up to the maximum shape of all elements in the given batch.
              If the length of this attr is 0, different queue elements may have
              different ranks and shapes, but only one element may be dequeued at a time.</param>
            <param name="capacity"> Optional argument. The upper bound on the number of elements in this queue. Negative numbers mean no limit.</param>
            <param name="container"> Optional argument. If non-empty, this queue is placed in the given container. Otherwise, a default container is used.</param>
            <param name="operationName"> If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddingFIFOQueueV2'.</param>
        </member>
        <member name="M:TensorFlow.PaddingFIFOQueue.Enqueue(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">
            <summary>
              Enqueues a tuple of one or more tensors in this queue.
            </summary>
            <param name="components">
              One or more tensors from which the enqueued tensors should be taken.
            </param>
            <param name="operationName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueV2'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is full, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The components input has k elements, which correspond to the components of
              tuples stored in the given queue.
              
              N.B. If the queue is full, this operation will block until the given
              element has been enqueued (or 'timeout_ms' elapses, if specified).
            </remarks>
        </member>
        <member name="M:TensorFlow.PaddingFIFOQueue.EnqueueExecute(TensorFlow.TFOutput[],TensorFlow.TFTensor[],System.Nullable{System.Int64},System.String)">
            <summary>
              Enqueues a tuple of one or more tensors in this queue and runs the session.
            </summary>
            <param name="components">
              One or more tensors from which the enqueued tensors should be taken.
            </param>
            <param name="operationName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueV2'.
            </param>
            <param name="inputValues">
              Values to enqueue
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is full, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <returns>
              Returns the description of the operation
            </returns>
            <remarks>
              The components input has k elements, which correspond to the components of
              tuples stored in the given queue.
            </remarks>
        </member>
        <member name="M:TensorFlow.PaddingFIFOQueue.Dequeue(System.Nullable{System.Int64},System.String)">
            <summary>
              Dequeues a tuple of one or more tensors from the given queue.
            </summary>
            <param name="operationName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueV2'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is empty, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <returns>
              One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation has k outputs, where k is the number of components
              in the tuples stored in the given queue, and output i is the ith
              component of the dequeued tuple.
            </remarks>
        </member>
        <member name="M:TensorFlow.PaddingFIFOQueue.DequeueExecute(System.Nullable{System.Int64},System.String)">
            <summary>
              Dequeues a tuple of one or more tensors from this queue and runs the session.
            </summary>
            <param name="operationName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueV2'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is empty, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <returns>
              One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
            </returns>
            <remarks>
              This operation has k outputs, where k is the number of components
              in the tuples stored in the given queue, and output i is the ith
              component of the dequeued tuple.
            </remarks>
        </member>
        <member name="M:TensorFlow.PaddingFIFOQueue.DequeueExecute``1(System.Nullable{System.Int64},System.String)">
            <summary>
              Dequeues elements from this queue and cast all elements to specific T type. It can be use when all elements in the queue of the same T type
            </summary>
            <param name="operationName">
              If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueV2'.
            </param>
            <param name="timeout_ms">
              Optional argument
              If the queue is empty, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.
            </param>
            <returns>
              
            </returns>
        </member>
        <member name="M:TensorFlow.PaddingFIFOQueue.GetSize(System.String)">
            <summary>
            Gets the size of this queue.
            </summary>
            <param name="operationName">If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueSizeV2'.</param>
            <returns>queue size</returns>
        </member>
        <member name="M:TensorFlow.PaddingFIFOQueue.GetSizeExecute(System.String)">
            <summary>
            Uses provided session instance to obtain the size of this queue
            </summary>
            <param name="operationName">If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueSizeV2'.</param>
            <returns>number of elements in the queue</returns>
        </member>
        <member name="T:TensorFlow.TFTensor">
             <summary>
             TFTensor holds a multi-dimensional array of elements of a single data type.
             </summary>
             <remarks>
             <para>
             You can create tensors with the various constructors in this class, or using
             the implicit conversions from various data types into a TFTensor.
            </para>
             <para>
             The implicit conversions for basic types produce tensors of one dimesion with
             a single element, while the implicit conversion from an array, expects a multi-dimensional
             array that is converted into a tensor of the right dimensions.
             </para>
             <para>
             The special "String" tensor data type that you will find in TensorFlow documentation
             really represents a byte array.   You can create string tensors by using the <see cref="M:TensorFlow.TFTensor.CreateString"/> 
             method that takes a byte array buffer as input.
             </para>
             </remarks>
        </member>
        <member name="T:TensorFlow.TFTensor.Deallocator">
            <summary>
            Signature that methods must conform to to be used to release memory that was passed to a manually allocated TFTensor
            </summary>
        </member>
        <member name="M:TensorFlow.TFTensor.FromBuffer(TensorFlow.TFShape,System.SByte[],System.Int32,System.Int32)">
            <summary>
            Creates a new tensor from a portion of an array of sbytes
            </summary>
            <param name="shape">Represents the tensor shape.</param>
            <param name="data">The linear array of data, the data is shuffled to fit in the tensor with the specified dimensions.</param>
            <param name="start">The offset into the provided data array where the data resides.</param>
            <param name="count">The number of bytes to copy from count into the tensor.</param>
            <remarks>
            Use the FromBuffer method to create a tensor that has the specified dimensions
            and is initialized with data from the data array.   The data is copied starting
            at the start offset, for count bytes and is laid out into the tensor following the
            specified dimensions.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFTensor.FromBuffer(TensorFlow.TFShape,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a new tensor from a portion of an array of bytes
            </summary>
            <param name="shape">Represents the tensor shape.</param>
            <param name="data">The linear array of data, the data is shuffled to fit in the tensor with the specified dimensions.</param>
            <param name="start">The offset into the provided data array where the data resides.</param>
            <param name="count">The number of bytes to copy from count into the tensor.</param>
            <remarks>
            Use the FromBuffer method to create a tensor that has the specified dimensions
            and is initialized with data from the data array.   The data is copied starting
            at the start offset, for count bytes and is laid out into the tensor following the
            specified dimensions.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFTensor.FromBuffer(TensorFlow.TFShape,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Creates a new tensor from a portion of an array of shorts
            </summary>
            <param name="shape">Represents the tensor shape.</param>
            <param name="data">The linear array of data, the data is shuffled to fit in the tensor with the specified dimensions.</param>
            <param name="start">The offset into the provided data array where the data resides.</param>
            <param name="count">The number of bytes to copy from count into the tensor.</param>
            <remarks>
            Use the FromBuffer method to create a tensor that has the specified dimensions
            and is initialized with data from the data array.   The data is copied starting
            at the start offset, for count bytes and is laid out into the tensor following the
            specified dimensions.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFTensor.FromBuffer(TensorFlow.TFShape,System.UInt16[],System.Int32,System.Int32)">
            <summary>
            Creates a new tensor from a portion of an array of ushorts
            </summary>
            <param name="shape">Represents the tensor shape.</param>
            <param name="data">The linear array of data, the data is shuffled to fit in the tensor with the specified dimensions.</param>
            <param name="start">The offset into the provided data array where the data resides.</param>
            <param name="count">The number of bytes to copy from count into the tensor.</param>
            <remarks>
            Use the FromBuffer method to create a tensor that has the specified dimensions
            and is initialized with data from the data array.   The data is copied starting
            at the start offset, for count bytes and is laid out into the tensor following the
            specified dimensions.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFTensor.FromBuffer(TensorFlow.TFShape,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Creates a new tensor from a portion of an array of ints
            </summary>
            <param name="shape">Represents the tensor shape.</param>
            <param name="data">The linear array of data, the data is shuffled to fit in the tensor with the specified dimensions.</param>
            <param name="start">The offset into the provided data array where the data resides.</param>
            <param name="count">The number of bytes to copy from count into the tensor.</param>
            <remarks>
            Use the FromBuffer method to create a tensor that has the specified dimensions
            and is initialized with data from the data array.   The data is copied starting
            at the start offset, for count bytes and is laid out into the tensor following the
            specified dimensions.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFTensor.FromBuffer(TensorFlow.TFShape,System.Single[],System.Int32,System.Int32)">
            <summary>
            Creates a new tensor from a portion of an array of floats
            </summary>
            <param name="shape">Represents the tensor shape.</param>
            <param name="data">The linear array of data, the data is shuffled to fit in the tensor with the specified dimensions.</param>
            <param name="start">The offset into the provided data array where the data resides.</param>
            <param name="count">The number of bytes to copy from count into the tensor.</param>
            <remarks>
            Use the FromBuffer method to create a tensor that has the specified dimensions
            and is initialized with data from the data array.   The data is copied starting
            at the start offset, for count bytes and is laid out into the tensor following the
            specified dimensions.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFTensor.FromBuffer(TensorFlow.TFShape,System.Double[],System.Int32,System.Int32)">
            <summary>
            Creates a new tensor from a portion of an array of doubles
            </summary>
            <param name="shape">Represents the tensor shape.</param>
            <param name="data">The linear array of data, the data is shuffled to fit in the tensor with the specified dimensions.</param>
            <param name="start">The offset into the provided data array where the data resides.</param>
            <param name="count">The number of bytes to copy from count into the tensor.</param>
            <remarks>
            Use the FromBuffer method to create a tensor that has the specified dimensions
            and is initialized with data from the data array.   The data is copied starting
            at the start offset, for count bytes and is laid out into the tensor following the
            specified dimensions.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFTensor.FromBuffer(TensorFlow.TFShape,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Creates a new tensor from a portion of an array of longs
            </summary>
            <param name="shape">Represents the tensor shape.</param>
            <param name="data">The linear array of data, the data is shuffled to fit in the tensor with the specified dimensions.</param>
            <param name="start">The offset into the provided data array where the data resides.</param>
            <param name="count">The number of bytes to copy from count into the tensor.</param>
            <remarks>
            Use the FromBuffer method to create a tensor that has the specified dimensions
            and is initialized with data from the data array.   The data is copied starting
            at the start offset, for count bytes and is laid out into the tensor following the
            specified dimensions.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFTensor.FromBuffer(TensorFlow.TFShape,System.Numerics.Complex[],System.Int32,System.Int32)">
            <summary>
            Creates a new tensor from a portion of an array of Complex numbers
            </summary>
            <param name="shape">Represents the tensor shape.</param>
            <param name="data">The linear array of data, the data is shuffled to fit in the tensor with the specified dimensions.</param>
            <param name="start">The offset into the provided data array where the data resides.</param>
            <param name="count">The number of bytes to copy from count into the tensor.</param>
            <remarks>
            Use the FromBuffer method to create a tensor that has the specified dimensions
            and is initialized with data from the data array.   The data is copied starting
            at the start offset, for count bytes and is laid out into the tensor following the
            specified dimensions.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Array)">
            <summary>
            Creates a constant tensor from an array, the shape reflects the shape of the C# array and the underlying type reflects the C# type.
            </summary>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Int32)">
            <summary>
            Creates a constant tensor with a single dimension from an integer value.
            </summary>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Boolean)">
            <summary>
            Creates a constant tensor with a single dimension from a boolean value.
            </summary>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.SByte)">
            <summary>
            Creates a constant tensor with a single dimension from an sbyte value.
            </summary>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Int16)">
            <summary>
            Creates a constant tensor with a single dimension from a short value.
            </summary>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.UInt16)">
            <summary>
            Creates a constant tensor with a single dimension from an ushort value.
            </summary>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Byte)">
            <summary>
            Creates a constant tensor with a single dimension from an byte value.
            </summary>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Numerics.Complex)">
            <summary>
            Creates a constant tensor with a single dimension from a Complex value.
            </summary>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Single)">
            <summary>
            Creates a constant tensor with a single dimension from a float value.
            </summary>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Double)">
            <summary>
            Creates a constant tensor with a single dimension from a double value.
            </summary>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Int64)">
            <summary>
            Creates a constant tensor with a single dimension from a long value.
            </summary>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Boolean[])">
            <summary>
            Creates a 1 dimensional tensor from an array of booleans.
            </summary>
            <param name="data">Data.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.SByte[])">
            <summary>
            Creates a 1 dimensional tensor from an array of sbytes.
            </summary>
            <param name="data">Data.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Byte[])">
            <summary>
            Creates a 1 dimensional tensor from an array of bytes.
            </summary>
            <param name="data">Data.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Int16[])">
            <summary>
            Creates a 1 dimensional tensor from an array of shorts.
            </summary>
            <param name="data">Data.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.UInt16[])">
            <summary>
            Creates a 1 dimensional tensor from an array of ushorts
            </summary>
            <param name="data">Data.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Int32[])">
            <summary>
            Creates a 1 dimensional tensor from an array of ints.
            </summary>
            <param name="data">Data.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Single[])">
            <summary>
            Creates a 1 dimensional tensor from an array of floats.
            </summary>
            <param name="data">Data.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Double[])">
            <summary>
            Creates a 1 dimensional tensor from an array of doubles.
            </summary>
            <param name="data">Data.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Int64[])">
            <summary>
            Creates a 1 dimensional tensor from an array of longs.
            </summary>
            <param name="data">Data.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(System.Numerics.Complex[])">
            <summary>
            Creates a 1 dimensional tensor from an array of complex numbers.
            </summary>
            <param name="data">Data.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.CreateString(System.Byte[])">
            <summary>
            Creates a single-dimension tensor from a byte buffer.  This is different than creating a tensor from a byte array that produces a tensor with as many elements as the byte array.
            </summary>
        </member>
        <member name="M:TensorFlow.TFTensor.op_Implicit(System.Int32)~TensorFlow.TFTensor">
            <summary>
            Converts an integer into a 1-dimensional, 1-valued tensor.
            </summary>
            <returns>The tensor representing the integer value.</returns>
            <param name="value">Value to initialize the tensor with.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.op_Implicit(System.Boolean)~TensorFlow.TFTensor">
            <summary>
            Converts a boolean into a 1-dimensional, 1-valued tensor.
            </summary>
            <returns>The tensor representing the integer value.</returns>
            <param name="value">Value to initialize the tensor with.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.op_Implicit(System.Int64)~TensorFlow.TFTensor">
            <summary>
            Converts a long into a 1-dimensional, 1-valued tensor.
            </summary>
            <returns>The tensor representing the long value.</returns>
            <param name="value">Value to initialize the tensor with.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.op_Implicit(System.Double)~TensorFlow.TFTensor">
            <summary>
            Converts a double into a 1-dimensional, 1-valued tensor.
            </summary>
            <returns>The tensor representing the double value.</returns>
            <param name="value">Value to initialize the tensor with.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.op_Implicit(System.Single)~TensorFlow.TFTensor">
            <summary>
            Converts a float into a 1-dimensional, 1-valued tensor.
            </summary>
            <returns>The tensor representing the float value.</returns>
            <param name="value">Value to initialize the tensor with.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.op_Implicit(System.Numerics.Complex)~TensorFlow.TFTensor">
            <summary>
            Converts a Complex number into a 1-dimensional, 1-valued tensor.
            </summary>
            <returns>The tensor representing the complex value.</returns>
            <param name="value">Value to initialize the tensor with.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.op_Implicit(System.Byte)~TensorFlow.TFTensor">
            <summary>
            Converts a byte into a 1-dimensional, 1-valued tensor.
            </summary>
            <returns>The tensor representing the byte value.</returns>
            <param name="value">Value to initialize the tensor with.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.op_Implicit(System.Array)~TensorFlow.TFTensor">
            <summary>
            Converts a C# array into a tensor.
            </summary>
            <returns>The tensor containing the data.</returns>
            <param name="array">single dimension, or multi-dimensional array.</param>
            <remarks>
            This implicit conversion can convert single or multidimensional arrays of
            booleans, sbytes, byte, shorts, ushorts, ints, longs, doubles, floats and
            complex numbers into a tensor with the same dimensional shape as the provided
            array.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(TensorFlow.TFDataType,System.Int64[],System.IntPtr,System.UIntPtr,TensorFlow.TFTensor.Deallocator,System.IntPtr)">
            <summary>
            Low-level tensor constructor that creates a tensor from a buffer pointed to by an IntPtr.
            </summary>
            <param name="dataType">Specifies the data type held by the tensor, as well as how to interpret the provided data.</param>
            <param name="dims">Describes the tensor shape, an array that indicates .</param>
            <param name="data">Pointer to the raw data that will be used to initialize the tensor.</param>
            <param name="dataSize">The size of the data being passed in.</param>
            <param name="deallocator">Deallocator method, it is invoked when the tensor is destroyed to release the data pointed to by <paramref name="data"/>.   On platforms like iOS (or other static compilation platforms), yiou must annotate the method specified in the deallocator with a <see cref="T:TensorFlow.MonoPInvokeCallbackAttribute"/>.</param>
            <param name="deallocatorData">An optional argument of data that is passed to the deallocator method when the tensor is destroyed, you can use this to pass context information.</param>
        </member>
        <member name="M:TensorFlow.TFTensor.#ctor(TensorFlow.TFDataType,System.Int64[],System.Int32)">
            <summary>
            Low-level: Creates an empty tensor of the specified type and shape, with the specified number of elements
            </summary>
            <param name="dataType">Data type.</param>
            <param name="dims">Tensor shape.</param>
            <param name="size">Size in bytes of the tensor, this will be the actual memory allocated.</param>
            <remarks>
            It is the responsibility of the caller to ensure that the size is correct given the data type size
            and the tensor dimension specified in dims.
            </remarks>
        </member>
        <member name="P:TensorFlow.TFTensor.TensorType">
            <summary>
            Returns the data type for the tensor.
            </summary>
            <value>The type of the tensor.</value>
        </member>
        <member name="P:TensorFlow.TFTensor.NumDims">
            <summary>
            Returns the number of dimensions in the tensor.
            </summary>
            <remarks>
            For single-dimension tensors the return is 1, 2 dimensions is 2 and so on.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFTensor.GetTensorDimension(System.Int32)">
            <summary>
            Returns the number of elements on a specific dimension in the tensor.
            </summary>
            <returns>The tensor dimension.</returns>
            <param name="dimIndex">Dimension that you are querying.</param>
            <remarks>
            If you have a tensor of 3 elements by 5, represented by [3 5],
            the GetTensorDimension(0) will return 3, the GetTensorDimension(1)
            will return 5.
            </remarks>
        </member>
        <member name="P:TensorFlow.TFTensor.Data">
            <summary>
            Returns a pointer to the raw data in the tensor.
            </summary>
            <remarks>
            The contents of the Data must be interpreted according to the type of the
            data as described by the DataType property.   The amount of data
            is given by the the TensorByteSize property.
            </remarks>
        </member>
        <member name="P:TensorFlow.TFTensor.Shape">
            <summary>
            Returns the tensor shape, this is an array whose size determines the number of dimensions on the tensor, and each element is the size of the dimension
            </summary>
            <remarks>
                An array of size 0 is used for constants, an array of size 1 is used
                for single-dimension arrays, where the dimension is the value of the
                first element.   And so on.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFTensor.TypeFromTensorType(TensorFlow.TFDataType)">
            <summary>
            Converts a <see cref="T:TensorFlow.TFDataType"/> to a system type.
            </summary>
            <param name="type">The <see cref="T:TensorFlow.TFDataType"/> to be converted.</param>
            <returns>The system type corresponding to the given <paramref name="type"/>.</returns>
        </member>
        <member name="M:TensorFlow.TFTensor.TensorTypeFromType(System.Type)">
            <summary>
            Converts a system type to a <see cref="T:TensorFlow.TFDataType"/>.
            </summary>
            <param name="type">The system type to be converted.</param>
            <returns>The <see cref="T:TensorFlow.TFDataType"/> corresponding to the given type.</returns>
        </member>
        <member name="M:TensorFlow.TFTensor.GetValue(System.Boolean)">
            <summary>
            Returns the value of the Tensor as a C# type if possible, or null if the data type can not be represented in C#
            </summary>
            <param name="jagged">
            The default is set to false, which returns .NET multi-dimensional arrays for multi-dimensional
            tensors.    This is useful to feed the data back as a TFTensor created from an array.   Set to
            true if you want to get arrays pointing to arrays, which are slightly more convenient to work
            with from C#
            </param>
            <remarks>
            Jagged arrays create various intermediate arrays, while multi-dimensional arrays are more
            efficient memory-wise.
            </remarks>
            <returns>The value encodes the contents of the tensor, and could include simple values, arrays and multi-dimensional values.</returns>
        </member>
        <member name="M:TensorFlow.TFTensor.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:TensorFlow.TFTensor"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:TensorFlow.TFTensor"/>.</returns>
        </member>
        <member name="T:TensorFlow.TFCore">
            <summary>
            Contains TensorFlow fundamental methods and utility functions.
            </summary>
        </member>
        <member name="P:TensorFlow.TFCore.Version">
            <summary>
            Returns the version of the TensorFlow runtime in use.
            </summary>
            <value>The version.</value>
        </member>
        <member name="M:TensorFlow.TFCore.GetDataTypeSize(TensorFlow.TFDataType)">
            <summary>
            Gets the size in bytes of the specified TensorFlow data type.
            </summary>
            <returns>The data type size.</returns>
            <param name="dt">Dt.</param>
        </member>
        <member name="M:TensorFlow.TFCore.GetAllOpList">
            <summary>
            Retrieves the ProtocolBuffer describing all of the available operations in
            the TensorFlow library in current use.
            </summary>
            <returns>The buffer contains a ProtocolBuffer encoded payload, you need a ProtocolBuffer reader to process the contents.</returns>
        </member>
        <member name="T:TensorFlow.TFDisposable">
            <summary>
            Base class for many TensorFlow data types that provides a common idiom to dispose and
            release resources associated with the native data types.   Generally, you do not need to use this.
            </summary>
            <remarks>
            <para>
            This implements the Dispose pattern in a reusable form for TensorFlow types.
            </para>
            <para>
            Subclasses invoke the constructor with the handle that this will wrap, and must
            override the NativeDispose method (internal) to release the associated resource.
            </para>
            </remarks>
        </member>
        <member name="P:TensorFlow.TFDisposable.Handle">
            <summary>
            Returns the opaque handle to the object that this TFDisposable owns.
            </summary>
            <value>The handle.</value>
        </member>
        <member name="M:TensorFlow.TFDisposable.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TensorFlow.TFDisposable"/> class.
            </summary>
        </member>
        <member name="M:TensorFlow.TFDisposable.#ctor(System.IntPtr)">
            <summary>
            Initializes a new instance of the <see cref="T:TensorFlow.TFDisposable"/> class
            from the handle that it will wrap.   
            </summary>
        </member>
        <member name="M:TensorFlow.TFDisposable.Dispose">
            <summary>
            Releases all resource used by the <see cref="T:TensorFlow.TFDisposable"/> object.
            </summary>
            <remarks>Call Dispose when you are finished using the <see cref="T:TensorFlow.TFDisposable"/>. The
            Dispose method leaves the <see cref="T:TensorFlow.TFDisposable"/> in an unusable state. After
            calling Dispose, you must release all references to the <see cref="T:TensorFlow.TFDisposable"/> so
            the garbage collector can reclaim the memory that the <see cref="T:TensorFlow.TFDisposable"/> was occupying.</remarks>
        </member>
        <member name="M:TensorFlow.TFDisposable.Dispose(System.Boolean)">
            <summary>
            Dispose the specified object
            </summary>
            <param name="disposing">If set to <c>true</c> it means that this method was called from Dispose, otherwise from the finalizer.</param>
        </member>
        <member name="T:TensorFlow.TFException">
            <summary>
            TensorFlow Exception
            </summary>
        </member>
        <member name="M:TensorFlow.TFException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:TensorFlow.TFException"/> class with a message.
            </summary>
            <param name="message">Message.</param>
        </member>
        <member name="T:TensorFlow.TFStatus">
            <summary>
            Used to track the result of TensorFlow operations.
            </summary>
            <remarks>
            <para>
            TFStatus is used to track the status of a call to some TensorFlow
            operations.   Instances of this object are passed to various
            TensorFlow operations and you can use the <see cref="P:TensorFlow.TFStatus.Ok"/>
            to quickly check if the operation succeeded, or get more detail from the
            <see cref="P:TensorFlow.TFStatus.StatusCode"/> and a human-readable text
            using the <see cref="P:TensorFlow.TFStatus.StatusMessage"/> property.
            </para>
            <para>
            The convenience <see cref="M:TensorFlow.TFStatus.Raise"/> can be used
            to raise a <see cref="P:TensorFlow.TFException"/> if the status of the
            operation did not succeed.
            </para>
            </remarks>
        </member>
        <member name="F:TensorFlow.TFStatus.Default">
            <summary>
            Per-thread global status that you can use if you do not need to create a new instance of this object.
            </summary>
            <remarks>
            This is provided as a convenience for APIs that take a TFStatus.   While the TFStatus is usually an
            optional parameter, when it is made optional, API calls that fail raise an exception.   Use this 
            property to pass a TFStatus without having to allocate a new one.   The problem with this of course
            is that you risk having multiple parts of your code override this thread-global variable.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFStatus.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TensorFlow.TFStatus"/> class.
            </summary>
        </member>
        <member name="M:TensorFlow.TFStatus.SetStatusCode(TensorFlow.TFCode,System.String)">
            <summary>
            Sets the status code on this TFStatus.
            </summary>
            <param name="code">Code.</param>
            <param name="msg">Message.</param>
        </member>
        <member name="P:TensorFlow.TFStatus.StatusCode">
            <summary>
            Gets the status code for the status code.
            </summary>
            <value>The status code as an enumeration.</value>
        </member>
        <member name="P:TensorFlow.TFStatus.StatusMessage">
            <summary>
            Gets a human-readable status message.
            </summary>
            <value>The status message.</value>
        </member>
        <member name="M:TensorFlow.TFStatus.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:TensorFlow.TFStatus"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:TensorFlow.TFStatus"/>.</returns>
        </member>
        <member name="P:TensorFlow.TFStatus.Ok">
            <summary>
            Gets a value indicating whether this <see cref="T:TensorFlow.TFStatus"/> state has been set to ok.
            </summary>
            <value><c>true</c> if ok; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:TensorFlow.TFStatus.Error">
            <summary>
            Gets a value indicating whether this <see cref="T:TensorFlow.TFStatus"/> state has been set to an error.
            </summary>
            <value><c>true</c> if error; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:TensorFlow.TFStatus.Raise">
            <summary>
            Convenience method that raises an exception if the current status is an error.
            </summary>
            <remarks>
            You can use this method as a convenience to raise an exception after you
            invoke an operation if the operation did not succeed.
            </remarks>
        </member>
        <member name="T:TensorFlow.TFSessionOptions">
            <summary>
            The session options object holds configuration options that you want to use during your session, like the TensorFlow target or the configuration.
            </summary>
        </member>
        <member name="M:TensorFlow.TFSessionOptions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:TensorFlow.TFSessionOptions"/> class.
            </summary>
        </member>
        <member name="M:TensorFlow.TFSessionOptions.SetTarget(System.String)">
            <summary>
            Sets the target in options.
            </summary>
            <param name="target">target can be empty, a single entry, or a comma separated list of entries.
            Each entry is in one of the following formats: "local", ip:port, host:port.</param>
            
        </member>
        <member name="M:TensorFlow.TFSessionOptions.SetConfig(System.IntPtr,System.Int32,TensorFlow.TFStatus)">
            <summary>
            Sets the configuration information for the session.
            </summary>
            <param name="protoData">Serialized protocol buffer for the tensorflow.ConfigProto message.</param>
            <param name="length">Length of the buffer.</param>
            <param name="status">If config was not parsed successfully as a ConfigProto, the error is recorded here.</param>
            <remarks>
            The configuration option is a Protocol Buffer representing the tensorflow.ConfigProto
            </remarks>
        </member>
        <member name="T:TensorFlow.TFFunction">
            <summary>
            A grouping of operations with defined inputs and outputs.
            Once created and added to graphs, functions can be invoked by creating an
            operation whose operation type matches the function name.
            </summary>
        </member>
        <member name="M:TensorFlow.TFFunction.ToFunctionDef(TensorFlow.TFBuffer,TensorFlow.TFStatus)">
            <summary>
            Write out a serialized representation of the function as a FunctionDef protocol message to the provided <paramref name="outputFuncDef"/>
            </summary>
            <param name="outputFuncDef">An allocated buffer where the function will be serialized.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="M:TensorFlow.TFFunction.ImportFunctionDef(System.Byte[],TensorFlow.TFStatus)">
            <summary>
            Construct and return the function whose FunctionDef representation is
            serialized in <paramref name="proto"/> proto
            </summary>
            <returns>The function definition, or null on failure.</returns>
            <param name="proto">Array containing the serialized FunctionDef in a protocol buffer.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="T:TensorFlow.TFDependencies">
            <summary>
            TFGraph variable dependencies handle.
            </summary>
            <remarks>
            Instances of this class, when disposed, restore <see cref="P:TensorFlow.TFGraph.CurrentDependencies"/>
            to the value it had before the <see cref="M:TensorFlow.TFGraph.WithDependencies(TensorFlow.TFOperation[])"/> method
            was called.
            </remarks>
            <seealso cref="T:System.IDisposable" />
        </member>
        <member name="M:TensorFlow.TFDependencies.Dispose">
            <summary>
            Pops the variable dependencies to the previous dependencies in use.
            </summary>
            <remarks>Call <see cref="M:TensorFlow.TFDependencies.Dispose"/> when you are finished using the <see cref="T:TensorFlow.TFDependencies"/>
            to restore the previous variable dependencies in use in the <see cref="T:TensorFlow.TFGraph"/>.
            </remarks>
        </member>
        <member name="T:TensorFlow.TFScope">
            <summary>
            TFGraph name scope handle
            </summary>
            <remarks>
            Instances of this class when disposed restore the CurrentNameScope to the
            value they had when the TFGraph.WithScope method was called.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFScope.Dispose">
            <summary>
            Pops the name space to the previous namescope in use.
            </summary>
            <remarks>Call <see cref="M:TensorFlow.TFScope.Dispose"/> when you are finished using the <see cref="T:TensorFlow.TFScope"/>
            to restore the previous name scope in use in the <see cref="T:TensorFlow.TFGraph"/>.
            </remarks>
        </member>
        <member name="T:TensorFlow.TFOperationDesc">
            <summary>
            Low-level TensorFlow operation builder
            </summary>
            <remarks>
            <para>This is the low-level API that is used to create operations by manually specificying all
            the parameters of an operation (inputs, outputs, attribute descriptions) that can then
            be attached into a graph.
            </para>
            <para>
            Generally, you will instead be using the methods surfaced in <see cref="T:TensorFlow.TFGraph"/> 
            that surfaces a C# high-level API that has already been bound to the built-in TensorFlow
            nodes.
            </para>
            <para>
            You create instances bound to a graph, add inputs, attributes and so on, and when you are done
            you can call the <see cref="M:TensorFlow.TFOperationDesc.FinishOperation(TensorFlow.TFStatus)"/> method that will turn this TFOperationDesc 
            into a <see cref="T:TensorFlow.TFOperation"/>.
            </para>
            </remarks>
        </member>
        <member name="M:TensorFlow.TFOperationDesc.SetDevice(System.String)">
            <summary>
            Specifies the device for the operation, if one is not provided, the operation is unconstrained.
            </summary>
            <returns>This instance, allows for chaining operation invocations.</returns>
            <param name="device">The device to constraint to in this operation.</param>
        </member>
        <member name="M:TensorFlow.TFOperationDesc.AddInput(TensorFlow.TFOutput)">
            <summary>
            Adds the specified input to the operation
            </summary>
            <returns>The input.</returns>
            <param name="input">Input.</param>
        </member>
        <member name="M:TensorFlow.TFOperationDesc.AddInputs(TensorFlow.TFOutput[])">
            <summary>
            Adds a series of inputs to the operation.
            </summary>
            <param name="inputs">Inputs, this is a params array for your convenience.</param>
        </member>
        <member name="M:TensorFlow.TFOperationDesc.AddControlInput(TensorFlow.TFOperation)">
            <summary>
            Ensure that the operation does not execute before the control operation does.
            </summary>
            <param name="control">Operation that must be executed before running this operation.</param>
            <remarks>
            <para>
            A control input is an Operation that must be executed before running the operation 
            currently being built.  
            </para>
            <para>
            For example, an Assert operation may be added as a control input for this operation. 
            The Assert now behaves as a pre-condition that will always verify itself before
            running the operation.
            </para>
            </remarks>
        </member>
        <member name="M:TensorFlow.TFOperationDesc.FinishOperation(TensorFlow.TFStatus)">
            <summary>
            Turns the operation description into an actual operation in the graph.
            </summary>
            <returns>The operation on success, or null on error.</returns>
            <param name="status">Optional status, on failure the operation is not added to the graph.  If you pass null (the default), this operation throws on error conditions.</param>
        </member>
        <member name="T:TensorFlow.TFOperation">
            <summary>
            Represents a computation node in the graph.  Tensorflow operations are attached to a <see cref="T:Tensorflow.TFGraph"/>.
            </summary>
            <remarks>
            TFOperations are usually created by  invoking one of the methods in 
            <see cref="T:Tensorflow.TFGraph"/>, but they can also be constructed
            manually using the low-level <see cref="T:Tensorflow.TFOperationDesc"/> API.
            </remarks>
        </member>
        <member name="P:TensorFlow.TFOperation.Handle">
            <summary>
            Gets the handle to the unmanaged TF_Operation object.
            </summary>
            <value>The handle.</value>
        </member>
        <member name="P:TensorFlow.TFOperation.Name">
            <summary>
            The name for this operation/
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:TensorFlow.TFOperation.NumOutputs">
            <summary>
            Gets the number of outputs on this operation.
            </summary>
            <value>The number outputs.</value>
        </member>
        <member name="P:TensorFlow.TFOperation.NumInputs">
            <summary>
            Gets the number of inputs for this operation.
            </summary>
            <value>The number inputs.</value>
        </member>
        <member name="M:TensorFlow.TFOperation.ToNodeDef(TensorFlow.TFStatus)">
            <summary>
            Encodes the TFOperation as a protocol buffer payload
            </summary>
            <returns>The buffer with the encoded operation in the protocol buffer format.</returns>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
            <remarks>
            </remarks>
        </member>
        <member name="P:TensorFlow.TFOperation.Item(System.Int32)">
            <summary>
            Returns the handle to the idx-th output of the operation.
            </summary>
            <param name="idx">Index of the output in the operation.</param>
        </member>
        <member name="T:TensorFlow.TFImportGraphDefOptions">
            <summary>
            Contains options that are used to control how graph importing works.
            </summary>
        </member>
        <member name="M:TensorFlow.TFImportGraphDefOptions.AddInputMapping(System.String,System.Int32,TensorFlow.TFOutput)">
            <summary>
            Adds an input mapping from a source name and index to a destination output
            </summary>
            <param name="srcName">Source name.</param>
            <param name="srcIndex">Source index (in the source).</param>
            <param name="dst">Replacement value for the srcName:srcIndex.</param>
            <remarks>
            Set any imported nodes with input `src_name:src_index` to have that input
            replaced with `dst`. `src_name` refers to a node in the graph to be imported,
            `dst` references a node already existing in the graph being imported into.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFImportGraphDefOptions.AddControlDependency(TensorFlow.TFOperation)">
            <summary>
            Cause the imported graph to have a control dependency on the provided operation.
            </summary>
            <param name="operation">This operation should exist in the graph being imported to.</param>
        </member>
        <member name="M:TensorFlow.TFImportGraphDefOptions.AddReturnOutput(System.String,System.Int32)">
            <summary>
            Add an output in the graph definition to be returned via the return outputs parameter.
            </summary>
            <param name="operName">Operation name.</param>
            <param name="index">Operation index.</param>
            <remarks>
            If the output is remapped via an input
            mapping, the corresponding existing tensor in graph will be returned.
            </remarks>
        </member>
        <member name="P:TensorFlow.TFImportGraphDefOptions.NumReturnOutputs">
            <summary>
            Gets the number return outputs added via AddReturnOutput.
            </summary>
            <value>The number return outputs.</value>
        </member>
        <member name="M:TensorFlow.TFImportGraphDefOptions.RemapControlDependency(System.String,TensorFlow.TFOperation)">
            <summary>
            Sets any imported nodes with a given control input to have it replaced with an operation
            </summary>
            <param name="srcName">Node in the graph to be imported.</param>
            <param name="destination">References an operation that already exists in the graph being imported.</param>
            <remarks>
            Set any imported nodes with control input <paramref name="srcName"/> to have that input
            replaced with <paramref name="destination"/>. 
            </remarks>
        </member>
        <member name="M:TensorFlow.TFImportGraphDefOptions.SetUniquifyNames(System.Boolean)">
            <summary>
            Set whether to uniquify imported operation names.
            </summary>
            <param name="uniquifyNames">If set to <c>true</c> imported operation names will be modified if their name already exists in the graph.
            If set to <c>false</c> conflicting names will be treated as an error.
            </param>
            <remarks>
             Note that this option has no effect if a prefix is set, since the prefix will guarantee all names are
             Defaults to false.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFImportGraphDefOptions.SetUniquifyPrefix(System.Boolean)">
            <summary>
            Sets the uniquify prefix.  This option has no effect if no prefix is specified.
            </summary>
            <param name="uniquifyPrefix">If set to <c>true</c> the specified prefix will be modified if it already exists as an
            operation name or prefix in the graph. 
            If set to <c>false</c> a conflicting prefix will be treated as an error.
            </param>
        </member>
        <member name="T:TensorFlow.TFSession">
            <summary>
            Drives the execution of a graph
            </summary>
            <remarks>
            <para>
            This creates a new context to execute a TFGraph.   You can use the 
            constructor to create an empty session, or you can load an existing
            model using the <see cref="M:TensorFlow.TFSession.FromSavedModel(TensorFlow.TFSessionOptions,TensorFlow.TFBuffer,System.String,System.String[],TensorFlow.TFGraph,TensorFlow.TFBuffer,TensorFlow.TFStatus)"/> static method in this class.
            </para>
            <para>
            To execute operations with the graph, call the <see cref="M:TensorFlow.TFSession.GetRunner"/>  method
            which returns an object that you can use to build the operation by providing
            the inputs, requesting the operations that you want to execute and the desired outputs.
            </para>
            <para>
            The <see cref="M:TensorFlow.TFSession.GetRunner"/> method is a high-level helper function that wraps a
            call to the <see cref="M:TensorFlow.TFSession.Run(TensorFlow.TFOutput[],TensorFlow.TFTensor[],TensorFlow.TFOutput[],TensorFlow.TFOperation[],TensorFlow.TFBuffer,TensorFlow.TFBuffer,TensorFlow.TFStatus)"/> method which just takes too many parameters that must
            be kept in sync.
            </para>
            </remarks>
        </member>
        <member name="P:TensorFlow.TFSession.Graph">
            <summary>
            Gets the graph associated with this TensorFlow session.
            </summary>
            <value>The graph.</value>
        </member>
        <member name="M:TensorFlow.TFSession.#ctor(TensorFlow.TFGraph,TensorFlow.TFSessionOptions,TensorFlow.TFStatus)">
            <summary>
            Creates a new execution session associated with the specified session graph with some configuration options.
            </summary>
            <param name="graph">The Graph to which this session is associated.</param>
            <param name="sessionOptions">Session options.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="M:TensorFlow.TFSession.#ctor(TensorFlow.TFGraph,TensorFlow.TFStatus)">
            <summary>
            Creates a new execution session associated with the specified session graph.
            </summary>
            <param name="graph">The Graph to which this session is associated.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="M:TensorFlow.TFSession.#ctor(TensorFlow.TFStatus)">
            <summary>
            Creates a new execution session with an empty graph
            </summary>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
            <remarks>
            The created graph can be retrieved using the Graph property on the session.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFSession.ListDevices(TensorFlow.TFStatus)">
            <summary>
            Lists available devices in this session.
            </summary>
        </member>
        <member name="M:TensorFlow.TFSession.FromSavedModel(TensorFlow.TFSessionOptions,TensorFlow.TFBuffer,System.String,System.String[],TensorFlow.TFGraph,TensorFlow.TFBuffer,TensorFlow.TFStatus)">
            <summary>
            Creates a session and graph from a saved session model
            </summary>
            <returns>On success, this populates the provided <paramref name="graph"/> with the contents of the graph stored in the specified model and <paramref name="metaGraphDef"/> with the MetaGraphDef of the loaded model.</returns>
            <param name="sessionOptions">Session options to use for the new session.</param>
            <param name="runOptions">Options to use to initialize the state (can be null).</param>
            <param name="exportDir">must be set to the path of the exported SavedModel.</param>
            <param name="tags">must include the set of tags used to identify one MetaGraphDef in the SavedModel.</param>
            <param name="graph">This must be a newly created graph.</param>
            <param name="metaGraphDef">On success, this will be populated on return with the contents of the MetaGraphDef (can be null).</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
            <remarks>
            This function creates a new session using the specified <paramref name="sessionOptions"/> and then initializes
            the state (restoring tensors and other assets) using <paramref name="runOptions"/>
            </remarks>
        </member>
        <member name="M:TensorFlow.TFSession.CloseSession(TensorFlow.TFStatus)">
            <summary>
            Closes the session.  Contacts any other processes associated with the session, if applicable.
            </summary>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
            <remarks>
            Can not be called after calling DeleteSession.
            </remarks>
        </member>
        <member name="T:TensorFlow.TFSession.Runner">
            <summary>
            Use the runner class to easily configure inputs, outputs and targets to be passed to the session runner.
            </summary>
            <remarks>
            <para>
            The runner has a simple API that allows developers to call the AddTarget, AddInput, AddOutput and Fetch
            to construct the parameters that will be passed to the TFSession.Run method.
            </para>
            <para>
            Instances of this class are created by calling the GetRunner method on the TFSession.
            </para>
            <para>
            The various methods in this class return an instance to the Runner itsel, to allow
            to easily construct chains of execution like this:
            </para>
            <code>
            var result = session.GetRunner ().AddINput (myInput).Fetch (MyOutput).Run ();
            </code>
            <para>
            You do not need to chain the operations, this works just the same:
            </para>
            <code>
            runner = session.GetRunner ();
            runner.AddInput(myInput);
            runner.Fetch(myOutput);
            var results = runner.Run();
            </code>
            </remarks>
        </member>
        <member name="M:TensorFlow.TFSession.Runner.AddInput(TensorFlow.TFOutput,TensorFlow.TFTensor)">
            <summary>
            Adds an input to the session
            </summary>
            <returns>An instance to the runner, so you can easily chain the operations together.</returns>
            <param name="input">Incoming port.</param>
            <param name="value">Value to assing to the incoming port.</param>
        </member>
        <member name="M:TensorFlow.TFSession.Runner.AddInput(System.String,TensorFlow.TFTensor)">
            <summary>
            Adds an input to the session specified by name, with an optional index in the operation (separated by a colon).
            </summary>
            <returns>An instance to the runner, so you can easily chain the operations together.</returns>
            <param name="input">Incoming port, with an optional index separated by a colon.</param>
            <param name="value">Value to assing to the incoming port.</param>
        </member>
        <member name="M:TensorFlow.TFSession.Runner.AddTarget(TensorFlow.TFOperation[])">
            <summary>
            Adds the specified operations as the ones to be retrieved.
            </summary>
            <returns>An instance to the runner, so you can easily chain the operations together.</returns>
            <param name="targets">One or more targets.</param>
        </member>
        <member name="M:TensorFlow.TFSession.Runner.AddTarget(System.String[])">
            <summary>
            Adds the specified operation names as the ones to be retrieved.
            </summary>
            <returns>An instance to the runner, so you can easily chain the operations together.</returns>
            <param name="targetNames">One or more target names.</param>
        </member>
        <member name="M:TensorFlow.TFSession.Runner.Fetch(System.String,System.Int32)">
            <summary>
            Makes the Run method return the index-th output of the tensor referenced by operation.
            </summary>
            <returns>The instance of runner, to allow chaining operations.</returns>
            <param name="operation">The name of the operation in the graph.</param>
            <param name="index">The index of the output in the operation.</param>
        </member>
        <member name="M:TensorFlow.TFSession.Runner.Fetch(System.String)">
            <summary>
            Makes the Run method return the output of the tensor referenced by operation, the operation string can contain the output index.
            </summary>
            <returns>The instance of runner, to allow chaining operations.</returns>
            <param name="operation">The name of the operation in the graph, which might be a simple name, or it might be name:index, 
            where the index is the .</param>
        </member>
        <member name="M:TensorFlow.TFSession.Runner.Fetch(TensorFlow.TFOutput)">
            <summary>
            Makes the Run method return the output of the tensor referenced by output
            </summary>
            <returns>The instance of runner, to allow chaining operations.</returns>
            <param name="output">The output referencing a specified tensor.</param>
        </member>
        <member name="M:TensorFlow.TFSession.Runner.Fetch(TensorFlow.TFOutput[])">
            <summary>
            Makes the Run method return the output of all the tensor referenced by outputs.
            </summary>
            <returns>The instance of runner, to allow chaining operations.</returns>
            <param name="outputs">The outputs referencing a specified tensor.</param>
        </member>
        <member name="M:TensorFlow.TFSession.Runner.Fetch(System.String[])">
            <summary>
            Makes the Run method return the output of all the tensor referenced by outputs.
            </summary>
            <returns>The instance of runner, to allow chaining operations.</returns>
            <param name="outputs">The output sreferencing a specified tensor.</param>
        </member>
        <member name="F:TensorFlow.TFSession.Runner.RunMetadata">
            <summary>
            Protocol buffer encoded block containing the metadata passed to the <see cref="M:TensorFlow.TFSession.Run"/> method.
            </summary>
        </member>
        <member name="F:TensorFlow.TFSession.Runner.RunOptions">
            <summary>
            Protocol buffer encoded block containing the run options passed to the <see cref="M:TensorFlow.TFSession.Run"/> method.
            </summary>
        </member>
        <member name="M:TensorFlow.TFSession.Runner.Run(TensorFlow.TFStatus)">
            <summary>
             Execute the graph fragments necessary to compute all requested fetches.
            </summary>
            <returns>One TFTensor for each call to Fetch that you made, in the order that you made them.</returns>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="M:TensorFlow.TFSession.Runner.Run(TensorFlow.TFOutput,TensorFlow.TFStatus)">
            <summary>
            Run the specified operation, by adding it implicity to the output, single return value
            </summary>
            <param name="operation">The output of the operation.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
            <remarks>
            This method is a convenience method, and when you call it, it will clear any 
            calls that you might have done to Fetch() and use the specified operation to Fetch
            instead.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFSession.GetRunner">
            <summary>
            Gets a new runner, this provides a simpler API to prepare the inputs to run on a session
            </summary>
            <returns>The runner.</returns>
            <remarks>
            The runner has a simple API that allows developers to call the AddTarget, AddInput, AddOutput and Fetch
            to construct the parameters that will be passed to the TFSession.Run method.
            
            The Run method will return an array of TFTensor values, one for each invocation to the Fetch method.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFSession.Run(TensorFlow.TFOutput[],TensorFlow.TFTensor[],TensorFlow.TFOutput[],TensorFlow.TFOperation[],TensorFlow.TFBuffer,TensorFlow.TFBuffer,TensorFlow.TFStatus)">
            <summary>
            Executes a pipeline given the specified inputs, inputValues, outputs, targetOpers, runMetadata and runOptions.   
            A simpler API is available by calling the <see cref="M:GetRunner"/> method which performs all the bookkeeping
            necessary.
            </summary>
            <returns>An array of tensors fetched from the requested outputs.</returns>
            <param name="inputs">Inputs nodes.</param>
            <param name="inputValues">Input values.</param>
            <param name="outputs">Output nodes.</param>
            <param name="targetOpers">Target operations to execute.</param>
            <param name="runMetadata">Run metadata.</param>
            <param name="runOptions">Run options.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="T:TensorFlow.TFSession.PartialRunToken">
            <summary>
            Token returned from using one of the Partial Run Setup methods from <see cref="T:TensorFlow.TFSession"/>,
            and use this token subsequently for other invocations.
            </summary>
            <remarks>
            Calling Dispose on this object will release the resources associated with setting up 
            a partial run.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFSession.PartialRunSetup(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOperation[],TensorFlow.TFStatus)">
            <summary>
            Prepares the session for a partial run.
            </summary>
            <returns>A token that can be used to call <see cref="M:TensorFlow.TFSession.PartialRun(TensorFlow.TFSession.PartialRunToken,TensorFlow.TFOutput[],TensorFlow.TFTensor[],TensorFlow.TFOutput[],TensorFlow.TFOperation[],TensorFlow.TFStatus)"/> repeatedly.   To complete your partial run, you should call Dispose on the resulting method.</returns>
            <param name="inputs">Inputs.</param>
            <param name="outputs">Outputs.</param>
            <param name="targetOpers">Target operations to run.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
        </member>
        <member name="T:TensorFlow.TFLibrary">
            <summary>
            Represents a dynamically loaded library of TensorFlow operations, use to load and consume TensorFlow operations from an external library.
            </summary>
            <remarks>
            Use the static method <see cref="M:Tensorflow.TFLibrary.FromFile"/> to load a dynamic library.
            Once that function returns
            </remarks>
        </member>
        <member name="M:TensorFlow.TFLibrary.FromFile(System.String,TensorFlow.TFStatus)">
            <summary>
            Load the library specified by and register the operations and
            kernels present in that library.
            </summary>
            <returns>Handle to the loaded library.</returns>
            <param name="libraryFile">Name of the library to load, this is a platform specific name.</param>
            <param name="status">Status buffer, if specified a status code will be left here, if not specified, a <see cref="T:TensorFlow.TFException"/> exception is raised if there is an error.</param>
            <remarks>
            The provided <paramref name="libraryFile"/> is passed to the operating system dynamic loader
            and it will load the library using the operating system defined search paths and rules to load this.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFLibrary.GetOpList">
            <summary>
            Retrieves the ProtocolBuffer describing the available operations in
            the loaded TensorFlow library.
            </summary>
            <returns>The buffer contains a ProtocolBuffer encoded payload, you need a ProtocolBuffer reader to process the contents.</returns>
        </member>
        <member name="T:TensorFlow.TFDataType">
            <summary>
            The data type for a specific tensor.
            </summary>
            <remarks>
            Tensors have uniform data types, all the elements of the tensor are of this
            type and they dictate how TensorFlow will treat the data stored.   
            </remarks>
        </member>
        <member name="F:TensorFlow.TFDataType.Unknown">
            <summary>
            The TFDataType has not been set
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.Float">
            <summary>
            Single precission floatint point, 32-bits (C# float)
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.Double">
            <summary>
            Double precission floatint point, 64-bits (C# double)
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.Int32">
            <summary>
            32-bit signed integers (C# int)
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.UInt8">
            <summary>
            8 bit unsigned integers (C# byte)
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.Int16">
            <summary>
            16-bit signed integers (C# short)
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.Int8">
            <summary>
            8-bit signed integers (C# sbyte)
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.String">
            <summary>
            Binary blob
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.Complex64">
            <summary>
            Single precission complex numbers (32-bit floats)
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.Complex">
            <summary>
            32-bit float based complex numbers
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.Int64">
            <summary>
            64-bit signed integers (C# long)
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.Bool">
            <summary>
            8-bit boolean (C# bool)
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.QInt8">
            <summary>
            Quantized 8-bit signed integer
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.QUInt8">
            <summary>
            Quantized 8-bit unsigned integer
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.QInt32">
            <summary>
            Quantized 32-bit signed integer
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.BFloat16">
            <summary>
            Float32 truncated to 16 bits.  Only for cast operations.
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.QInt16">
            <summary>
            Quantized 16-bit signed integer
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.QUInt16">
            <summary>
            Quantized 16-bit unsigned integer
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.UInt16">
            <summary>
            16-bit unsigned integers (C# long)
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.Complex128">
            <summary>
            Double precission complex numbers (32-bit floats)
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.Half">
            <summary>
            Half floats - 16-bit half precision floating point.
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.Resource">
            <summary>
            Handle to a mutable resource.
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.Variant">
            <summary>
            Variant data type
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.UInt32">
            <summary>
            32-bit unsigned integers
            </summary>
        </member>
        <member name="F:TensorFlow.TFDataType.UInt64">
            <summary>
            64-bit unsigned integers
            </summary>
        </member>
        <member name="T:TensorFlow.TFCode">
            <summary>
            Status code for invoking a tensorflow operation.
            </summary>
        </member>
        <member name="F:TensorFlow.TFCode.Ok">
            <summary>
            Not an error; returned on success
            </summary>
        </member>
        <member name="F:TensorFlow.TFCode.Cancelled">
            <summary>
            The operation was cancelled (typically by the caller).
            </summary>
        </member>
        <member name="F:TensorFlow.TFCode.Unknown">
            <summary>
            Unknown error.  An example of where this error may be returned is
            if a Status value received from another address space belongs to
            an error-space that is not known in this address space.  Also
            errors raised by APIs that do not return enough error information
            may be converted to this error.
            </summary>
        </member>
        <member name="F:TensorFlow.TFCode.InvalidArgument">
            <summary>
            Client specified an invalid argument.  Note that this differs
            from FailedPrecondition.  InvalidArgumentindicates arguments
            that are problematic regardless of the state of the system
            (e.g., a malformed file name).
            </summary>
        </member>
        <member name="F:TensorFlow.TFCode.DeadlineExceeded">
            <summary>
            Deadline expired before operation could complete.  For operations
            that change the state of the system, this error may be returned
            even if the operation has completed successfully.  For example, a
            successful response from a server could have been delayed long
            enough for the deadline to expire.
            </summary>
        </member>
        <member name="F:TensorFlow.TFCode.NotFound">
            <summary>
            Some requested entity (e.g., file or directory) was not found.
            For privacy reasons, this code may be returned when the client
            does not have the access right to the entity.
            </summary>
        </member>
        <member name="F:TensorFlow.TFCode.AlreadyExists">
            <summary>
            Some entity that we attempted to create (e.g., file or directory) already exists.
            </summary>
        </member>
        <member name="F:TensorFlow.TFCode.PermissionDenied">
            <summary>
            The caller does not have permission to execute the specified
            operation.  PermissionDenied must not be used for rejections
            caused by exhausting some resource (use ResourceExhausted
            instead for those errors).  PermissionDeniedmust not be
            used if the caller can not be identified (use Unauthenticated
            instead for those errors).
            </summary>
        </member>
        <member name="F:TensorFlow.TFCode.Unauthenticated">
            <summary>
            The request does not have valid authentication credentials for the
            operation.
            </summary>
        </member>
        <member name="F:TensorFlow.TFCode.ResourceExhausted">
            <summary>
            Some resource has been exhausted, perhaps a per-user quota, or
            perhaps the entire file system is out of space.
            </summary>
        </member>
        <member name="F:TensorFlow.TFCode.FailedPrecondition">
             <summary>
             Operation was rejected because the system is not in a state
             required for the operation's execution.  For example, directory
             to be deleted may be non-empty, an rmdir operation is applied to
             a non-directory, etc.
            
             A litmus test that may help a service implementor in deciding
             between FailedPrecondition, Aborted, and Unavailable:
             
              (a) Use Unavailableif the client can retry just the failing call.
              (b) Use Aborted if the client should retry at a higher-level
                  (e.g., restarting a read-modify-write sequence).
              (c) Use FailedPrecondition if the client should not retry until
                  the system state has been explicitly fixed.  E.g., if an "rmdir"
                  fails because the directory is non-empty, FailedPrecondition
                  should be returned since the client should not retry unless
                  they have first fixed up the directory by deleting files from it.
              (d) Use FailedPrecondition if the client performs conditional
                  REST Get/Update/Delete on a resource and the resource on the
                  server does not match the condition. E.g., conflicting
                  read-modify-write on the same resource.
             </summary>
        </member>
        <member name="F:TensorFlow.TFCode.Aborted">
             <summary>
             The operation was aborted, typically due to a concurrency issue
             like sequencer check failures, transaction aborts, etc.
            
             See litmus test above for deciding between FailedPrecondition,
             Aborted and Unavailable
             </summary>
        </member>
        <member name="F:TensorFlow.TFCode.OutOfRange">
             <summary>
             Operation tried to iterate past the valid input range.  E.g., seeking or
             reading past end of file.
            
             Unlike InvalidArgument, this error indicates a problem that may
             be fixed if the system state changes. For example, a 32-bit file
             system will generate InvalidArgument if asked to read at an
             offset that is not in the range [0,2^32-1], but it will generate
             OutOfRange if asked to read from an offset past the current
             file size.
            
             There is a fair bit of overlap between FailedPrecondition and
             OutOfRange.  We recommend using OutOfRane (the more specific
             error) when it applies so that callers who are iterating through
             a space can easily look for an OutOfRange error to detect when
             they are done.
             </summary>
        </member>
        <member name="F:TensorFlow.TFCode.Unimplemented">
            <summary>
            Operation is not implemented or not supported/enabled in this service.
            </summary>
        </member>
        <member name="F:TensorFlow.TFCode.Internal">
            <summary>
            Internal errors.  Means some invariants expected by underlying
            system has been broken.  If you see one of these errors,
            something is very broken.
            </summary>
        </member>
        <member name="F:TensorFlow.TFCode.Unavailable">
             <summary>
             The service is currently unavailable.  This is a most likely a
             transient condition and may be corrected by retrying with
             a backoff.
            
             See litmus test above for deciding between FailedPrecondition,
             Aborted, and Unavailable.
             </summary>
        </member>
        <member name="F:TensorFlow.TFCode.DataLoss">
            <summary>
            Unrecoverable data loss or corruption.
            </summary>
        </member>
        <member name="T:TensorFlow.TFInput">
            <summary>
            Represents a specific input of an operation.
            </summary>
        </member>
        <member name="F:TensorFlow.TFInput.Operation">
            <summary>
            The operation that this input is for
            </summary>
        </member>
        <member name="F:TensorFlow.TFInput.Index">
            <summary>
            The index of the output within the Operation
            </summary>
        </member>
        <member name="T:TensorFlow.TFOutput">
            <summary>
            Represents a specific output of an operation on a tensor.
            </summary>
            <remarks>
            <para>
            TFOutput objects represent one of the outputs of an operation in the graph
            (TFGraph).  Outputs have a data type, and eventually a shape that you can 
            retrieve by calling the <see cref="M:TensorFlow.TFGraph.GetShape"/> method.
            </para>
            <para>
            These can be passed as an input argument to a function for adding operations 
            to a graph, or to the TFSession's Run and GetRunner method as values to be
            fetched.
            </para>
            </remarks>
        </member>
        <member name="F:TensorFlow.TFOutput.Index">
            <summary>
            The index of the output within the operation.
            </summary>
        </member>
        <member name="P:TensorFlow.TFOutput.NumConsumers">
            <summary>
            Gets the number consumers.
            </summary>
            <value>The number consumers.</value>
            <remarks>
            This number can change when new operations are added to the graph.
            </remarks>
        </member>
        <member name="P:TensorFlow.TFOutput.OutputType">
            <summary>
            Gets the type of the output.
            </summary>
            <value>The type of the output.</value>
        </member>
        <member name="M:TensorFlow.TFOutput.#ctor(TensorFlow.TFOperation,System.Int32)">
            <summary>
            Initializes a new TFOutput instance.
            </summary>
            <param name="operation">The operation to which to attach the output.</param>
            <param name="index">The index of the output within the operation, if not specified, it defaults to zero.</param>
        </member>
        <member name="M:TensorFlow.TFOutput.#ctor(TensorFlow.TFOutput,System.Int32)">
            <summary>
            Initializes a new TFOutput instance from another TFOutput
            </summary>
            <param name="output">The other TFOutput that is having its operation attached.</param>
            <param name="index">The index of the output within the operation, if not specified, it defaults to zero.</param>
        </member>
        <member name="P:TensorFlow.TFOutput.OutputConsumers">
            <summary>
            Get list of all current consumers of a specific output of an operation
            </summary>	
            <value>The output consumers.</value>
            <remarks>
            A concurrent modification of the graph can increase the number of consumers of
            an operation.
            This can return null if the TFOutput does not point to a valid object.
            </remarks>
        </member>
        <member name="P:TensorFlow.TFOutput.Operation">
            <summary>
            The associated operation.
            </summary>
            <value>The operation.</value>
        </member>
        <member name="M:TensorFlow.TFOutput.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:TensorFlow.TFOutput"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:TensorFlow.TFOutput"/>.</returns>
        </member>
        <member name="T:TensorFlow.TFAttributeType">
            <summary>
            Low-level: Enumeration describing the types of a metadata attribute
            </summary>
        </member>
        <member name="F:TensorFlow.TFAttributeType.String">
            <summary>
            The type of the attribute is a string
            </summary>
        </member>
        <member name="F:TensorFlow.TFAttributeType.Int">
            <summary>
            The type of the attribute is an int.
            </summary>
        </member>
        <member name="F:TensorFlow.TFAttributeType.Float">
            <summary>
            The type of the attribute is a float
            </summary>
        </member>
        <member name="F:TensorFlow.TFAttributeType.Bool">
            <summary>
            The type of the attribute is a bool.
            </summary>
        </member>
        <member name="F:TensorFlow.TFAttributeType.Type">
            <summary>
            The type of the attribute is a type.
            </summary>
        </member>
        <member name="F:TensorFlow.TFAttributeType.Shape">
            <summary>
            The type of the attribute is a tensor shape
            </summary>
        </member>
        <member name="F:TensorFlow.TFAttributeType.Tensor">
            <summary>
            The type of the attribute is a tensor
            </summary>
        </member>
        <member name="F:TensorFlow.TFAttributeType.Placeholder">
            <summary>
            The type of the attribute is a placeholder
            </summary>
        </member>
        <member name="F:TensorFlow.TFAttributeType.Func">
            <summary>
            The type of the attribute is a function
            </summary>
        </member>
        <member name="T:TensorFlow.TFAttributeMetadata">
            <summary>
            Low-level: this describes the tensorflow type information for an attribute in the low-level attributes used by operations.
            </summary>
            <remarks>
            This is a low-level operation returned by the <see cref="M:TensorFlow.TFOperation.GetAttributeMetadata"/>.
            This is included for completeness, but is not generally used from C#, as you have access to the high-level
            bindings in the <see cref="T:TensorFlow.TFGraph"/> type.
            </remarks>
        </member>
        <member name="M:TensorFlow.TFAttributeMetadata.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:TensorFlow.TFAttributeMetadata"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:TensorFlow.TFAttributeMetadata"/>.</returns>
        </member>
        <member name="T:TensorFlow.TFShape">
            <summary>
            Represents the shape of a tensor
            </summary>
            <remarks>
            <para>
            The shapes can be created by calling the constructor with the number of dimensions
            in the shape.   The null value is used to specify that the shape is unknown,
            an empty array is used to create a scalar, and other values are used to specify
            the number of dimensions.
            </para>
            <para>
            For the Unknown case, you can use <see cref="P:TensorFlor.TFShape.Unknown"/>, for
            scalars, you can use the <see cref="P:TensorFlor.TFShape.Scalar"/> shape.
            </para>
            <para>
            To create a 2-element vector, use:
            new TFShape (2)
            </para>
            <para>
            To create a 2x3 matrix, use:
            new TFShape (2, 3)
            </para>
            <para>
            To create a shape with an unknown number of elements, you can pass the value
            -1.  This is typically used to indicate the shape of tensors that represent a
            variable-sized batch of values.
            </para>
            <para>
            To create a matrix with 4 columns and an unknown number of rows:
            var batch = new TFShape (-1, 4)
            </para>
            </remarks>
        </member>
        <member name="P:TensorFlow.TFShape.Unknown">
            <summary>
            Represents an unknown number of dimensions in the tensor.
            </summary>
            <value>The unknown.</value>
        </member>
        <member name="P:TensorFlow.TFShape.Scalar">
            <summary>
            This shape is used to represent scalar values.
            </summary>
            <value>The scalar.</value>
        </member>
        <member name="M:TensorFlow.TFShape.#ctor(System.Int64[])">
            <summary>
            Initializes a new instance of the <see cref="T:TensorFlow.TFShape"/> class.
            </summary>
            <param name="args">This is a params argument, so you can provide multiple values to it.  
            A null value means that this is an unknown shape, a single value is used to create a vector,
            two values are used to create a 2-D matrix and so on.
            </param>
            <remarks>
            
            </remarks>
        </member>
        <member name="M:TensorFlow.TFShape.GetLength(System.Int32)">
            <summary>
            Gets the length of the specified dimension in the tensor
            </summary>
            <returns>The length, -1 for shapes that have an unknown dimension.</returns>
            <param name="dimension">Dimension.</param>
        </member>
        <member name="P:TensorFlow.TFShape.NumDimensions">
            <summary>
            Number of dimensions represented by this shape.
            </summary>
            <value>The number dimensions, -1 if the number of dimensions is unknown, 0 if the shape represent a scalar, 1 for a vector, 2 for a matrix and so on..</value>
        </member>
        <member name="P:TensorFlow.TFShape.IsFullySpecified">
            <summary>
            Gets a value indicating whether all the dimensions in the <see cref="T:TensorFlow.TFShape"/> are fully specified.
            </summary>
            <value><c>true</c> if is fully specified; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:TensorFlow.TFShape.ToArray">
            <summary>
            Returns the shape as an array
            </summary>
            <returns>null if the shape represents an unknown shape, otherwise an array with N elements, one per dimension, and each element can be either -1 (if the dimension size is unspecified) or the size of the dimension.</returns>
        </member>
        <member name="M:TensorFlow.TFShape.ToIntArray">
            <summary>
            Returns the shape as an array
            </summary>
            <returns>null if the shape represents an unknown shape, otherwise an array with N elements, one per dimension, and each element can be either -1 (if the dimension size is unspecified) or the size of the dimension.</returns>
        </member>
        <member name="P:TensorFlow.TFShape.IsLongArray">
            <summary>
            Gets a value indicating whether one of the dimensions <see cref="T:TensorFlow.TFShape"/> in the shape is larger than Int32.MaxValue.
            </summary>
            <value><c>true</c> if is long array; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:TensorFlow.TFShape.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:TensorFlow.TFShape"/>.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current <see cref="T:TensorFlow.TFShape"/>.</returns>
        </member>
        <member name="P:TensorFlow.TFShape.Item(System.Int32)">
            <summary>
            Gets the dimensions for the specified index.
            </summary>
            <param name="idx">Index.</param>
        </member>
        <member name="M:TensorFlow.TFShape.AsTensor">
            <summary>
            Returns the shape as a 1-dimensional tensor with each element corresponding to the specified shape dimension.
            </summary>
            <returns>The tensor.</returns>
        </member>
        <member name="M:TensorFlow.TFShape.op_Addition(TensorFlow.TFShape,TensorFlow.TFShape)">
            <summary>
            Adds a <see cref="T:TensorFlow.TFShape"/> to a <see cref="T:TensorFlow.TFShape"/>, yielding a shape made up of the concatenation of the first and the second shapes.
            </summary>
            <param name="left">The first <see cref="T:TensorFlow.TFShape"/> to add.</param>
            <param name="right">The second <see cref="T:TensorFlow.TFShape"/> to add.</param>
            <returns>The <see cref="T:TensorFlow.TFShape"/> that is the sum of the values of <c>left</c> and <c>right</c>.</returns>
        </member>
        <member name="M:TensorFlow.TFShape.op_Implicit(TensorFlow.TFShape)~TensorFlow.TFTensor">
            <summary>
            Performs an implicit conversion from <see cref="T:TensorFlow.TFShape"/> to <see cref="T:TensorFlow.TFTensor"/>.
            </summary>
            <param name="shape">The shape.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="T:TensorFlow.Variable">
            <summary>
            The Variable class holds the TFOutput nodes that are used to initialize, read and assign a value to a variable.   
            </summary>
            <remarks>
            A variable maintains state in the graph across calls to `run()`. You add a
            variable to the graph by constructing an instance of the class `Variable`.
            
            The `Variable()` constructor requires an initial value for the variable,
            which can be a `Tensor` of any type and shape. The initial value defines the
            type and shape of the variable. After construction, the type and shape of
            the variable are fixed. The value can be changed using one of the assign
            methods.
            
            When a variable is created a VarHandleOp is created which is returned as 
            the VariableOp property, an assign operation is created that can be accessed
            using the assignHandle and you can read the value of the variable using the
            ReadHandle.
            
            When you launch the graph, variables have to be explicitly initialized before
            you can run Ops that use their value. You can initialize a variable by
            running its *initializer op*, restoring the variable from a save file, or
            simply running an `assign` Op that assigns a value to the variable. In fact,
            the variable *initializer op* is just an `assign` Op that assigns the
            variable's initial value to the variable itself.
            
            There is an implicit conversion from the Variable into the VarHandleOp if
            used.
            </remarks>
        </member>
        <member name="P:TensorFlow.Variable.Read">
            <summary>
            Returns the ReadVariableOp that is used to fetch the value of the variable from the graph.
            </summary>
            <value>The read op.</value>
        </member>
        <member name="P:TensorFlow.Variable.Assign">
            <summary>
            Returns the AssignVariableOp that is used to assign the initial value to the variable from the graph.
            </summary>
            <value>The assign op.</value>
        </member>
        <member name="P:TensorFlow.Variable.VariableOp">
            <summary>
            Returns the VarHandleOp that was created using the shape of the initial value.
            </summary>
            <value>The variable op.</value>
        </member>
        <member name="M:TensorFlow.Variable.op_Implicit(TensorFlow.Variable)~TensorFlow.TFOutput">
            <summary>
            Returns the VarHandleOp (the VariableOp property).
            </summary>
            <returns>The variable handle created for the variable.</returns>
            <param name="variable">Variable reference.</param>
            <remarks>
            This implicit operator exists to preserve the compatibility with code that
            created Variables and expected the result to be the VariableOp.
            </remarks>
        </member>
    </members>
</doc>
