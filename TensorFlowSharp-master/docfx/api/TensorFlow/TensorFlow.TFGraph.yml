### YamlMime:ManagedReference
items:
- uid: TensorFlow.TFGraph
  id: TFGraph
  children:
  - TensorFlow.TFGraph.#ctor
  - TensorFlow.TFGraph.Abort(System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Abs(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.AccumulateNV2(TensorFlow.TFOutput[],TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.AccumulatorApplyGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.AccumulatorNumAccumulated(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.AccumulatorSetGlobalStep(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.AccumulatorTakeGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.Acos(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Acosh(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Add(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.AddGradients(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFStatus)
  - TensorFlow.TFGraph.AddGradients(System.String,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFStatus)
  - TensorFlow.TFGraph.AddInitVariable(TensorFlow.TFOperation)
  - TensorFlow.TFGraph.AddManySparseToTensorsMap(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  - TensorFlow.TFGraph.AddN(TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.AddSparseToTensorsMap(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  - TensorFlow.TFGraph.AddV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.AdjustContrast(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.AdjustContrastv2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.AdjustHue(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.AdjustSaturation(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.All(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.AllCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.AllToAll(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,System.String)
  - TensorFlow.TFGraph.Angle(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.AnonymousIterator(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.Any(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyAdam(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyAdaMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyAddSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyPowerSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ApproximateEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String)
  - TensorFlow.TFGraph.ArgMax(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.ArgMin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.Asin(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Asinh(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Assert(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Assign(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.AssignAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.AssignAddVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.AssignSub(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.AssignSubVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.AssignVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.AsString(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.Atan(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Atan2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Atanh(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.AudioSpectrogram(TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.AudioSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.AudioSummaryV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.AvgPool(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  - TensorFlow.TFGraph.AvgPool3D(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  - TensorFlow.TFGraph.AvgPool3DGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  - TensorFlow.TFGraph.AvgPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  - TensorFlow.TFGraph.Barrier(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.BarrierClose(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.BarrierIncompleteSize(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BarrierInsertMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.BarrierReadySize(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BarrierTakeMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Batch(TensorFlow.TFOutput[],System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{System.Int64},System.Int64[],System.String,System.String,System.String,System.String)
  - TensorFlow.TFGraph.BatchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.BatchDatasetV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.BatchMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.BatchNormWithGlobalNormalization(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Boolean,System.String)
  - TensorFlow.TFGraph.BatchNormWithGlobalNormalizationGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Boolean,System.String)
  - TensorFlow.TFGraph.BatchToSpace(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.BatchToSpaceND(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BesselI0e(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BesselI1e(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Betainc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BiasAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.BiasAddGrad(TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.BiasAddV1(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BigQueryReader(System.String,System.String,System.String,System.String[],System.Int64,System.String,System.String,System.String,System.String)
  - TensorFlow.TFGraph.Bincount(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Bitcast(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.BitwiseAnd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BitwiseOr(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BitwiseXor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BoostedTreesBucketize(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.BoostedTreesCalculateBestGainsPerFeature(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.BoostedTreesCenterBias(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BoostedTreesCreateEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BoostedTreesCreateQuantileStreamResource(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.BoostedTreesDeserializeEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BoostedTreesEnsembleResourceHandleOp(System.String,System.String,System.String)
  - TensorFlow.TFGraph.BoostedTreesExampleDebugOutputs(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)
  - TensorFlow.TFGraph.BoostedTreesGetEnsembleStates(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BoostedTreesMakeQuantileSummaries(TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BoostedTreesMakeStatsSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.Int64,System.String)
  - TensorFlow.TFGraph.BoostedTreesPredict(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)
  - TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceAddSummaries(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceFlush(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceGetBucketBoundaries(TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceHandleOp(System.String,System.String,System.String)
  - TensorFlow.TFGraph.BoostedTreesSerializeEnsemble(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BoostedTreesTrainingPredict(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)
  - TensorFlow.TFGraph.BoostedTreesUpdateEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.BroadcastArgs(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BroadcastGradientArgs(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.BroadcastTo(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Bucketize(TensorFlow.TFOutput,System.Single[],System.String)
  - TensorFlow.TFGraph.CacheDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.Cast(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Ceil(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.CheckNumerics(TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.Cholesky(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.CholeskyGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ClipByAverageNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ClipByNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.String)
  - TensorFlow.TFGraph.ClipByValue(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.CollectiveBcastRecv(TensorFlow.TFDataType,System.Int64,System.Int64,System.Int64,TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.CollectiveBcastSend(TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.CollectivePermute(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.CollectiveReduce(TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,System.String,System.String,System.Int64[],System.String)
  - TensorFlow.TFGraph.CompareAndBitpack(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Complex(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.ComplexAbs(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.ComputeAccidentalHits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Concat(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.ConcatenateDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.ConcatOffset(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.ConcatV2(TensorFlow.TFOutput[],TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Cond(TensorFlow.TFOutput,System.Func{TensorFlow.TFOutput},System.Func{TensorFlow.TFOutput},System.String)
  - TensorFlow.TFGraph.ConditionalAccumulator(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String,System.String)
  - TensorFlow.TFGraph.ConfigureDistributedTPU(System.String,System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Conj(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ConjugateTranspose(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Const(TensorFlow.TFTensor,System.String)
  - TensorFlow.TFGraph.Const(TensorFlow.TFTensor,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.Constant(System.Object,TensorFlow.TFShape,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.ConsumeMutexLock(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ControlTrigger(System.String)
  - TensorFlow.TFGraph.Conv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  - TensorFlow.TFGraph.Conv2DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  - TensorFlow.TFGraph.Conv2DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  - TensorFlow.TFGraph.Conv3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  - TensorFlow.TFGraph.Conv3DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Int64[],System.String)
  - TensorFlow.TFGraph.Conv3DBackpropFilterV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  - TensorFlow.TFGraph.Conv3DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Int64[],System.String)
  - TensorFlow.TFGraph.Conv3DBackpropInputV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  - TensorFlow.TFGraph.Copy(TensorFlow.TFOutput,System.String,System.String[],System.String)
  - TensorFlow.TFGraph.CopyHost(TensorFlow.TFOutput,System.String,System.String[],System.String)
  - TensorFlow.TFGraph.Cos(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Cosh(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.CountUpTo(TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.CropAndResize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Single},System.String)
  - TensorFlow.TFGraph.CropAndResizeGradBoxes(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.CropAndResizeGradImage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String)
  - TensorFlow.TFGraph.Cross(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.CrossReplicaSum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.CTCBeamSearchDecoder(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.CTCGreedyDecoder(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.CTCLoss(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.CudnnRNN(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.CudnnRNNBackprop(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.CudnnRNNBackpropV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.CudnnRNNCanonicalToParams(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.CudnnRNNParamsSize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.CudnnRNNParamsToCanonical(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.CudnnRNNV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Cumprod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Cumsum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.CurrentDependencies
  - TensorFlow.TFGraph.CurrentNameScope
  - TensorFlow.TFGraph.DataFormatDimMap(TensorFlow.TFOutput,System.String,System.String,System.String)
  - TensorFlow.TFGraph.DataFormatVecPermute(TensorFlow.TFOutput,System.String,System.String,System.String)
  - TensorFlow.TFGraph.DatasetToGraph(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.DatasetToSingleElement(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.DebugGradientIdentity(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.DebugGradientRefIdentity(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.DebugIdentity(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.DebugNanCount(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.DebugNumericSummary(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.DecodeAndCropJpeg(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Single},System.String,System.String)
  - TensorFlow.TFGraph.DecodeBase64(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.DecodeBmp(TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.DecodeCompressed(TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.DecodeCSV(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  - TensorFlow.TFGraph.DecodeGif(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.DecodeJpeg(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Single},System.String,System.String)
  - TensorFlow.TFGraph.DecodeJSONExample(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.DecodePng(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.DecodeProtoV2(TensorFlow.TFOutput,System.String,System.String[],TensorFlow.TFDataType[],System.String,System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.DecodeRaw(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.DecodeWav(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.DeepCopy(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.DeleteSessionTensor(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.DenseToDenseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.DenseToSparseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.DepthToSpace(TensorFlow.TFOutput,System.Int64,System.String,System.String)
  - TensorFlow.TFGraph.DepthwiseConv2dNative(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  - TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  - TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  - TensorFlow.TFGraph.Dequantize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.DeserializeIterator(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.DeserializeManySparse(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.DeserializeSparse(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.DestroyResourceOp(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.DestroyTemporaryVariable(TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.Diag(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.DiagPart(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Digamma(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Dilation2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  - TensorFlow.TFGraph.Dilation2DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  - TensorFlow.TFGraph.Dilation2DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  - TensorFlow.TFGraph.Div(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.DivNoNan(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.DrawBoundingBoxes(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Dropout(TensorFlow.TFOutput,System.Double,TensorFlow.TFShape,System.Nullable{System.Int32},System.String)
  - TensorFlow.TFGraph.Dropout(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFShape,System.Nullable{System.Int32},System.String)
  - TensorFlow.TFGraph.DynamicPartition(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.DynamicStitch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.EditDistance(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Elu(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.EluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Empty(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.EmptyTensorList(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.EncodeBase64(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.EncodeJpeg(TensorFlow.TFOutput,System.String,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.EncodePng(TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.EncodeProto(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String[],System.String,System.String,System.String)
  - TensorFlow.TFGraph.EncodeWav(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.EnqueueTPUEmbeddingIntegerBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Nullable{System.Int64},System.String[],System.String)
  - TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseTensorBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Int64[],System.Nullable{System.Int64},System.String[],System.String)
  - TensorFlow.TFGraph.EnsureShape(TensorFlow.TFOutput,TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.Enter(TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Equal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Erf(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Erfc(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Exit(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Exp(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ExpandDims(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ExperimentalDirectedInterleaveDataset(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.ExperimentalIgnoreErrorsDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.ExperimentalIteratorGetDevice(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ExperimentalThreadPoolDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.ExperimentalThreadPoolHandle(System.Int64,System.String,System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.ExperimentalUniqueDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.Expm1(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ExtractGlimpse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ExtractImagePatches(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.Int64[],System.String,System.String)
  - TensorFlow.TFGraph.ExtractJpegShape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.ExtractVolumePatches(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  - TensorFlow.TFGraph.Fact(System.String)
  - TensorFlow.TFGraph.FakeParam(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.FakeQuantWithMinMaxArgs(TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.FakeQuantWithMinMaxArgsGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.FakeQuantWithMinMaxVars(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.FakeQuantWithMinMaxVarsGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannel(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.FakeQueue(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.FFT(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.FFT2D(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.FFT3D(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.FIFOQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.FIFOQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.Fill(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.FilterByLastComponentDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.FixedLengthRecordDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.FixedLengthRecordReader(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.FixedLengthRecordReaderV2(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String,System.String)
  - TensorFlow.TFGraph.FixedUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Single[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Floor(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.FloorDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.FloorMod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.FractionalAvgPool(TensorFlow.TFOutput,System.Single[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.FractionalAvgPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.FractionalMaxPool(TensorFlow.TFOutput,System.Single[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.FractionalMaxPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Functions
  - TensorFlow.TFGraph.FusedBatchNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.FusedBatchNormGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.FusedBatchNormGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.FusedBatchNormV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.FusedPadConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Int64[],System.String,System.String)
  - TensorFlow.TFGraph.FusedResizeAndPadConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Int64[],System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Gather(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.GatherNd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.GatherV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.GcsConfigureBlockCache(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.GcsConfigureCredentials(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.GenerateBigQueryReaderPartitions(System.String,System.String,System.String,System.String[],System.Int64,System.Int64,System.String,System.String)
  - TensorFlow.TFGraph.GenerateVocabRemapping(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.GetEnumerator
  - TensorFlow.TFGraph.GetGlobalVariablesInitializer
  - TensorFlow.TFGraph.GetRandomSeeds(System.Nullable{System.Int32},System.Int32@,System.Int32@)
  - TensorFlow.TFGraph.GetSessionHandle(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.GetSessionHandleV2(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.GetSessionTensor(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.GetShape(TensorFlow.TFOutput,TensorFlow.TFStatus)
  - TensorFlow.TFGraph.GetTensorNumDims(TensorFlow.TFOutput,TensorFlow.TFStatus)
  - TensorFlow.TFGraph.GetTensorShape(TensorFlow.TFOutput,TensorFlow.TFStatus)
  - TensorFlow.TFGraph.GlobalNorm(TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.Greater(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.GreaterEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.GuaranteeConst(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.HashTable(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.HashTableV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.HistogramFixedWidth(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.HistogramSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.HostConst(TensorFlow.TFTensor,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.HSVToRGB(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Identity(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.IdentityN(TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.IdentityReader(System.String,System.String,System.String)
  - TensorFlow.TFGraph.IdentityReaderV2(System.String,System.String,System.String)
  - TensorFlow.TFGraph.IFFT(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.IFFT2D(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.IFFT3D(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Igamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Igammac(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.IgammaGradA(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Imag(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.ImageSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},TensorFlow.TFTensor,System.String)
  - TensorFlow.TFGraph.ImmutableConst(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String)
  - TensorFlow.TFGraph.Import(System.Byte[],System.String,TensorFlow.TFStatus)
  - TensorFlow.TFGraph.Import(System.Byte[],TensorFlow.TFImportGraphDefOptions,TensorFlow.TFStatus)
  - TensorFlow.TFGraph.Import(TensorFlow.TFBuffer,System.String,TensorFlow.TFStatus)
  - TensorFlow.TFGraph.Import(TensorFlow.TFBuffer,TensorFlow.TFImportGraphDefOptions,TensorFlow.TFStatus)
  - TensorFlow.TFGraph.ImportGraphDef(TensorFlow.TFBuffer,TensorFlow.TFImportGraphDefOptions,TensorFlow.TFOutput[],TensorFlow.TFStatus)
  - TensorFlow.TFGraph.InfeedDequeue(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.InfeedDequeueTuple(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.InfeedEnqueue(TensorFlow.TFOutput,TensorFlow.TFShape,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.InfeedEnqueueTuple(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.InitializeTable(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.InitializeTableFromTextFile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.InitializeTableFromTextFileV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.InitializeTableV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.InplaceAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.InplaceSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.InplaceUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.InTopK(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.InTopKV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Inv(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Invert(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.InvertPermutation(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.InvGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.IRFFT(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.IRFFT2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.IRFFT3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.IsBoostedTreesEnsembleInitialized(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.IsBoostedTreesQuantileStreamResourceInitialized(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.IsFinite(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.IsInf(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.IsNan(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.IsVariableInitialized(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Item(System.String)
  - TensorFlow.TFGraph.Iterator(System.String,System.String,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.IteratorFromStringHandle(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.IteratorGetNext(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.IteratorGetNextAsOptional(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.IteratorGetNextSync(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.IteratorToStringHandle(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.L2Loss(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LearnedUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.LeftShift(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Less(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LessEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Lgamma(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LinSpace(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ListDiff(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.LMDBReader(System.String,System.String,System.String)
  - TensorFlow.TFGraph.LoadAndRemapMatrix(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingADAMParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingADAMParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingCenteredRMSPropParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingMDLAdagradLightParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.LoadTPUEmbeddingStochasticGradientDescentParameters(TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.Log(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Log1p(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LogicalAnd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LogicalNot(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LogicalOr(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LogMatrixDeterminant(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LogSoftmax(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LogUniformCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.LookupTableExport(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.LookupTableExportV2(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.LookupTableFind(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LookupTableFindV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LookupTableImport(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LookupTableImportV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LookupTableInsert(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LookupTableInsertV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LookupTableSize(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LookupTableSizeV2(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LoopCond(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.LowerBound(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.LRN(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  - TensorFlow.TFGraph.LRNGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  - TensorFlow.TFGraph.MakeIterator(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MapClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.MapIncompleteSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.MapPeek(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.MapSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.MapStage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.MapUnstage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.MapUnstageNoKey(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.MatchingFiles(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.MatrixBandPart(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MatrixDeterminant(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MatrixDiag(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MatrixDiagPart(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MatrixExponential(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MatrixInverse(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.MatrixLogarithm(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MatrixSetDiag(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MatrixSolve(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.MatrixSolveLs(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.MatrixTriangularSolve(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Max(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Maximum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MaxPool(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  - TensorFlow.TFGraph.MaxPool3D(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  - TensorFlow.TFGraph.MaxPool3DGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  - TensorFlow.TFGraph.MaxPool3DGradGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  - TensorFlow.TFGraph.MaxPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  - TensorFlow.TFGraph.MaxPoolGradGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  - TensorFlow.TFGraph.MaxPoolGradGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  - TensorFlow.TFGraph.MaxPoolGradGradWithArgmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  - TensorFlow.TFGraph.MaxPoolGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  - TensorFlow.TFGraph.MaxPoolGradWithArgmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  - TensorFlow.TFGraph.MaxPoolV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  - TensorFlow.TFGraph.MaxPoolWithArgmax(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.Mean(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Merge(TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.MergeSummary(TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.MergeV2Checkpoints(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Mfcc(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Min(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Minimum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MirrorPad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.MirrorPadGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.Mod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ModelDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.Mul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MultiDeviceIterator(System.String[],System.String,System.String,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.MultiDeviceIteratorFromStringHandle(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.MultiDeviceIteratorGetNextFromShard(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.MultiDeviceIteratorInit(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MultiDeviceIteratorToStringHandle(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Multinomial(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.MutableDenseHashTable(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.Nullable{System.Int64},System.Nullable{System.Single},System.String)
  - TensorFlow.TFGraph.MutableDenseHashTableV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.Nullable{System.Int64},System.Nullable{System.Single},System.String)
  - TensorFlow.TFGraph.MutableHashTable(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.MutableHashTableOfTensors(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.MutableHashTableOfTensorsV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.MutableHashTableV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.MutexLock(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.MutexV2(System.String,System.String,System.String)
  - TensorFlow.TFGraph.Neg(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.NegTrain(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64,System.String)
  - TensorFlow.TFGraph.NextIteration(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.NonMaxSuppression(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String)
  - TensorFlow.TFGraph.NonMaxSuppressionV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.NonMaxSuppressionV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.NonMaxSuppressionV4(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.NonMaxSuppressionWithOverlaps(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.NoOp(System.String)
  - TensorFlow.TFGraph.NotEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.NthElement(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.NumFunctions
  - TensorFlow.TFGraph.OneHot(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Ones(TensorFlow.TFShape,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.OnesLike(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.OptimizeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.OptionalFromValue(TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.OptionalGetValue(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.OptionalHasValue(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.OptionalNone(System.String)
  - TensorFlow.TFGraph.OrderedMapClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.OrderedMapIncompleteSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.OrderedMapPeek(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.OrderedMapSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.OrderedMapStage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.OrderedMapUnstage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.OrderedMapUnstageNoKey(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.OutfeedDequeue(TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.OutfeedDequeueTuple(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.OutfeedEnqueue(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.OutfeedEnqueueTuple(TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.Pack(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Pad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.PaddedBatchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.PaddedBatchDatasetV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.PaddingFIFOQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.PaddingFIFOQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.PadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ParallelConcat(TensorFlow.TFOutput[],TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.ParallelDynamicStitch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.ParameterizedTruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.ParseExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.ParseSequenceExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String[],System.String[],System.String[],System.String[],System.String[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},TensorFlow.TFDataType[],TensorFlow.TFDataType[],TensorFlow.TFShape[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.ParseSingleExample(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String[],System.String[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.ParseSingleSequenceExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFDataType[],TensorFlow.TFShape[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.ParseTensor(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.Placeholder(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.PlaceholderV2(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.PlaceholderWithDefault(TensorFlow.TFOutput,TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.Polygamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.PopulationCount(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Pow(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.PrefetchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.PreventGradient(TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.Print(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.PrintV2(TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.PriorityQueue(TensorFlow.TFShape[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.PriorityQueueV2(TensorFlow.TFShape[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.Prod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Qr(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.QuantizeAndDequantize(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  - TensorFlow.TFGraph.QuantizeAndDequantizeV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.QuantizedAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.QuantizedAvgPool(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  - TensorFlow.TFGraph.QuantizedBatchNormWithGlobalNormalization(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Single,System.Boolean,System.String)
  - TensorFlow.TFGraph.QuantizedBiasAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.QuantizedConcat(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.QuantizedConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{TensorFlow.TFDataType},System.Int64[],System.String)
  - TensorFlow.TFGraph.QuantizedInstanceNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  - TensorFlow.TFGraph.QuantizedMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.QuantizedMaxPool(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  - TensorFlow.TFGraph.QuantizedMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.QuantizeDownAndShrinkRange(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.QuantizedRelu(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.QuantizedRelu6(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.QuantizedReluX(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.QuantizedReshape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.QuantizedResizeBilinear(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.QuantizeV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.String)
  - TensorFlow.TFGraph.QueueClose(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.QueueCloseV2(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.QueueDequeue(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.QueueDequeueMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.QueueDequeueManyV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.QueueDequeueUpTo(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.QueueDequeueUpToV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.QueueDequeueV2(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.QueueEnqueue(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.QueueEnqueueMany(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.QueueEnqueueManyV2(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.QueueEnqueueV2(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.QueueIsClosed(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.QueueIsClosedV2(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.QueueSize(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.QueueSizeV2(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RandomCrop(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.RandomGamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.RandomGammaGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RandomNormal(TensorFlow.TFShape,System.Double,System.Double,System.Nullable{System.Int32},System.String)
  - TensorFlow.TFGraph.RandomPoisson(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.RandomPoissonV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.RandomShuffle(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.RandomShuffleQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.RandomShuffleQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.RandomStandardNormal(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.RandomUniform(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.RandomUniform(TensorFlow.TFShape,System.Double,System.Double,System.Nullable{System.Int32},System.String)
  - TensorFlow.TFGraph.RandomUniformInt(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Range(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Range(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.RangeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.Rank(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderNumRecordsProduced(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderNumRecordsProducedV2(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderNumWorkUnitsCompleted(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderNumWorkUnitsCompletedV2(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderRead(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderReadUpTo(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderReadUpToV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderReadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderReset(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderResetV2(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderRestoreState(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderRestoreStateV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderSerializeState(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReaderSerializeStateV2(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReadFile(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReadVariableOp(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.Real(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.RealDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Reciprocal(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReciprocalGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RecordInput(System.String,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RecvTPUEmbeddingActivations(System.Int64,System.String,System.String)
  - TensorFlow.TFGraph.ReduceJoin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String,System.String)
  - TensorFlow.TFGraph.ReduceMean(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ReduceProd(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ReduceSum(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.RefEnter(TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.RefExit(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RefIdentity(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RefMerge(TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.RefNextIteration(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RefSelect(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.RefSwitch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RegexFullMatch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RegexReplace(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Relu(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Relu6(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Relu6Grad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RemoteFusedGraphExecute(TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.String,System.String)
  - TensorFlow.TFGraph.RepeatDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.RequantizationRange(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Requantize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.Reshape(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ResizeArea(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResizeBicubic(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResizeBicubicGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResizeBilinear(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResizeBilinearGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResizeNearestNeighbor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResizeNearestNeighborGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyAdam(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyAdaMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyAddSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyPowerSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceCountUpTo(TensorFlow.TFOutput,System.Int64,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.ResourceGather(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceScatterAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ResourceScatterDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ResourceScatterMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ResourceScatterMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ResourceScatterMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ResourceScatterNdAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceScatterNdUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceScatterSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ResourceScatterUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ResourceSparseApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceSparseApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceSparseApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceSparseApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceSparseApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceSparseApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceSparseApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceSparseApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceSparseApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceSparseApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ResourceStridedSliceAssign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Restore(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.RestoreSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.RestoreV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingCenteredRMSPropParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingMDLAdagradLightParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.RetrieveTPUEmbeddingStochasticGradientDescentParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  - TensorFlow.TFGraph.Reverse(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ReverseSequence(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.ReverseV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RFFT(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RFFT2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RFFT3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RGBToHSV(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RightShift(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Rint(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Roll(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Round(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Rpc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Rsqrt(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.RsqrtGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SampleDistortedBoundingBox(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Single},System.Single[],System.Single[],System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SampleDistortedBoundingBoxV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Single[],System.Single[],System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Save(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.SaveSlices(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.SaveV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.ScalarSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ScatterAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ScatterDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ScatterMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ScatterMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ScatterMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ScatterNd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ScatterNdAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ScatterNdNonAliasingAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ScatterNdSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ScatterNdUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ScatterSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ScatterUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SdcaFprint(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SdcaOptimizer(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.String,System.Single,System.Single,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SdcaShrinkL1(TensorFlow.TFOutput[],System.Single,System.Single,System.String)
  - TensorFlow.TFGraph.Seed
  - TensorFlow.TFGraph.SegmentMax(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SegmentMean(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SegmentMin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SegmentProd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Select(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SelfAdjointEig(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SelfAdjointEigV2(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Selu(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SeluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SendTPUEmbeddingGradients(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String,System.String)
  - TensorFlow.TFGraph.SerializeIterator(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SerializeManySparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.SerializeSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.SerializeTensor(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SetSize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SetTensorShape(TensorFlow.TFOutput,System.Int64[],TensorFlow.TFStatus)
  - TensorFlow.TFGraph.Shape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.ShapeN(TensorFlow.TFOutput[],System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.ShardedFilename(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ShardedFilespec(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ShuffleAndRepeatDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.ShuffleDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ShutdownDistributedTPU(System.String)
  - TensorFlow.TFGraph.Sigmoid(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SigmoidCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SigmoidGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Sign(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Sin(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Sinh(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Size(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.SkipDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.Skipgram(System.String,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Single},System.String)
  - TensorFlow.TFGraph.Slice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Snapshot(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Softmax(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SoftmaxCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Softplus(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SoftplusGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Softsign(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SoftsignGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SpaceToBatch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.SpaceToBatchND(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SpaceToDepth(TensorFlow.TFOutput,System.Int64,System.String,System.String)
  - TensorFlow.TFGraph.SparseAccumulatorApplyGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Boolean,System.String)
  - TensorFlow.TFGraph.SparseAccumulatorTakeGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.SparseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseAddGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseConcat(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.Int64,System.String)
  - TensorFlow.TFGraph.SparseConditionalAccumulator(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String,System.String)
  - TensorFlow.TFGraph.SparseCross(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.Boolean,System.Int64,System.Int64,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.SparseDenseCwiseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseDenseCwiseDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseDenseCwiseMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseFillEmptyRows(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseFillEmptyRowsGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseReduceMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseReduceMaxSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseReduceSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseReduceSumSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseReorder(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseReshape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSegmentMean(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSegmentMeanGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSegmentMeanWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSegmentSqrtN(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSegmentSqrtNGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSegmentSqrtNWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSegmentSumWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSliceGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSoftmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSoftmaxCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSparseMaximum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSparseMinimum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseSplit(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.SparseTensorDenseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseTensorDenseMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseTensorSliceDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SparseToDense(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.SparseToSparseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Split(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.SplitV(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.Sqrt(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SqrtGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Square(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.SquaredDifference(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Squeeze(TensorFlow.TFOutput,System.Int64[],System.String)
  - TensorFlow.TFGraph.Stack(TensorFlow.TFDataType,System.String,System.String)
  - TensorFlow.TFGraph.Stack(TensorFlow.TFOutput[],System.Nullable{System.Int32},System.String)
  - TensorFlow.TFGraph.StackClose(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.StackCloseV2(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.StackPop(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.StackPopV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.StackPush(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.StackPushV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.StackV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String)
  - TensorFlow.TFGraph.Stage(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.StageClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.StagePeek(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.StageSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.StatelessMultinomial(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.StatelessRandomNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.StatelessRandomUniform(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.StatelessTruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.StaticRegexFullMatch(TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.StaticRegexReplace(TensorFlow.TFOutput,System.String,System.String,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.StopGradient(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.StridedSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.StridedSliceAssign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.StridedSliceGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.StringFormat(TensorFlow.TFOutput[],System.String,System.String,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.StringJoin(TensorFlow.TFOutput[],System.String,System.String)
  - TensorFlow.TFGraph.StringLength(TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.StringSplit(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.StringSplitV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.StringStrip(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.StringToHashBucket(TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.StringToHashBucketFast(TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.StringToHashBucketStrong(TensorFlow.TFOutput,System.Int64,System.Int64[],System.String)
  - TensorFlow.TFGraph.StringToNumber(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.Sub(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Sum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Svd(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.Switch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TakeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.TakeManySparseFromTensorsMap(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.String)
  - TensorFlow.TFGraph.Tan(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Tanh(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TanhGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TemporaryVariable(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String)
  - TensorFlow.TFGraph.TensorArrayCloseV2(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorArrayCloseV3(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorArrayConcatV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.TensorArrayConcatV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.TensorArrayGatherV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.TensorArrayGatherV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  - TensorFlow.TFGraph.TensorArrayGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.TensorArrayGradV3(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.TensorArrayGradWithShape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  - TensorFlow.TFGraph.TensorArrayReadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.TensorArrayReadV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.TensorArrayScatterV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorArrayScatterV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorArraySizeV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorArraySizeV3(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorArraySplitV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorArraySplitV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorArrayV2(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)
  - TensorFlow.TFGraph.TensorArrayV3(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)
  - TensorFlow.TFGraph.TensorArrayWriteV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorArrayWriteV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorDataset(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.TensorListElementShape(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.TensorListFromTensor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorListGather(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.TensorListGetItem(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.TensorListLength(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorListPopBack(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.TensorListPushBack(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorListReserve(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.TensorListScatter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorListSetItem(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TensorListStack(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.TensorSliceDataset(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.TensorSummary(TensorFlow.TFOutput,System.String,System.String[],System.String,System.String)
  - TensorFlow.TFGraph.TensorSummaryV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TextLineDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TextLineReader(System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.TextLineReaderV2(System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.TFRecordDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TFRecordReader(System.String,System.String,System.String,System.String)
  - TensorFlow.TFGraph.TFRecordReaderV2(System.String,System.String,System.String,System.String)
  - TensorFlow.TFGraph.ThreadUnsafeUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Tile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TileGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Timestamp(System.String)
  - TensorFlow.TFGraph.ToFunction(System.String,System.String,TensorFlow.TFOperation[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String[],System.Boolean,TensorFlow.TFStatus)
  - TensorFlow.TFGraph.ToGraphDef(TensorFlow.TFBuffer,TensorFlow.TFStatus)
  - TensorFlow.TFGraph.TopK(TensorFlow.TFOutput,System.Int64,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.TopKV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  - TensorFlow.TFGraph.ToString
  - TensorFlow.TFGraph.TPUEmbeddingActivations(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.String)
  - TensorFlow.TFGraph.TPUReplicatedInput(TensorFlow.TFOutput[],System.String)
  - TensorFlow.TFGraph.TPUReplicatedOutput(TensorFlow.TFOutput,System.Int64,System.String)
  - TensorFlow.TFGraph.Transpose(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Transpose(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TruncateDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.TruncateMod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.TryEvaluateConstant(TensorFlow.TFOutput,TensorFlow.TFTensor@)
  - TensorFlow.TFGraph.TryRpc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Unbatch(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String,System.String,System.String)
  - TensorFlow.TFGraph.UnbatchGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  - TensorFlow.TFGraph.UnicodeScript(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.UniformCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.Unique(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.UniqueV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.UniqueWithCounts(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.UniqueWithCountsV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.Unpack(TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.String)
  - TensorFlow.TFGraph.UnravelIndex(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.UnsortedSegmentMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.UnsortedSegmentMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.UnsortedSegmentProd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.UnsortedSegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Unstage(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  - TensorFlow.TFGraph.UpperBound(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.VarHandleOp(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String)
  - TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,System.Boolean,System.String)
  - TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,TensorFlow.TFOutput@,System.Boolean,System.String)
  - TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,TensorFlow.TFOperation@,TensorFlow.TFOutput@,System.Boolean,System.String)
  - TensorFlow.TFGraph.Variable(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String,System.String)
  - TensorFlow.TFGraph.VariableShape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  - TensorFlow.TFGraph.VariableV2(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String,System.String)
  - TensorFlow.TFGraph.VarIsInitializedOp(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Versions(TensorFlow.TFBuffer,TensorFlow.TFStatus)
  - TensorFlow.TFGraph.Where(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFOutput},System.String)
  - TensorFlow.TFGraph.Where(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.While(TensorFlow.TFOutput[],TensorFlow.TFGraph.WhileConstructor,TensorFlow.TFStatus)
  - TensorFlow.TFGraph.WholeFileReader(System.String,System.String,System.String)
  - TensorFlow.TFGraph.WholeFileReaderV2(System.String,System.String,System.String)
  - TensorFlow.TFGraph.WindowDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  - TensorFlow.TFGraph.WithDependencies(TensorFlow.TFOperation[])
  - TensorFlow.TFGraph.WithScope(System.String)
  - TensorFlow.TFGraph.WorkerHeartbeat(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.WriteFile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Xdivy(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Xlogy(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Zeros(TensorFlow.TFShape,TensorFlow.TFDataType,System.String)
  - TensorFlow.TFGraph.ZerosLike(TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.Zeta(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  - TensorFlow.TFGraph.ZipDataset(TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  langs:
  - csharp
  name: TFGraph
  nameWithType: TFGraph
  fullName: TensorFlow.TFGraph
  type: Class
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Represents a computation graph.  Graphs may be shared between sessions and are thread safe.
  remarks: "<p>\n            Graphs consist of operations (represented by TFOperation objects), these can be named, or \n            the runtime will automatically assign a name.\n            </p>\n    <p>\n            For debugging purposes, you might want to group operations together, for this, call the\n            WithScope method with your new scope, which will create a new namespace for your object names.\n            </p>\n    <p>\n            For example, if you call WithScope (\"demo\"), and add an operation named \"add\" inside the\n            scope, the full name of the operation will be \"demo/add\", if you create a new scope inside, say\n            \"hot\", and add a \"sub\" operation there the result will be \"demo/hot/sub\".\n            </p>"
  syntax:
    content: 'public class TFGraph : TensorFlow.TFDisposableThreadSafe'
  inheritance:
  - System.Object
  - TensorFlow.TFDisposable
  - TensorFlow.TFDisposableThreadSafe
  implements: []
  inheritedMembers:
  - TensorFlow.TFDisposable.Dispose
  - TensorFlow.TFDisposable.Handle
  - TensorFlow.TFDisposableThreadSafe.Dispose(System.Boolean)
- uid: TensorFlow.TFGraph.#ctor
  id: '#ctor'
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TFGraph()
  nameWithType: TFGraph.TFGraph()
  fullName: TFGraph.TFGraph()
  type: Constructor
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Initializes a new instance of the <xref href="TensorFlow.TFGraph"></xref> class.
  syntax:
    content: public TFGraph ();
    parameters: []
  overload: TensorFlow.TFGraph.#ctor*
  exceptions: []
- uid: TensorFlow.TFGraph.Abort(System.String,System.Nullable{System.Boolean},System.String)
  id: Abort(System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Abort(String, Nullable<Boolean>, String)
  nameWithType: TFGraph.Abort(String, Nullable<Boolean>, String)
  fullName: TFGraph.Abort(String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Raise a exception to abort the process when called.
  remarks: "If exit_without_error is true, the process will exit normally,\n              otherwise it will exit with a SIGABORT signal.\n              \n              Returns nothing but an exception."
  syntax:
    content: public TensorFlow.TFOperation Abort (string error_msg = null, Nullable<bool> exit_without_error = null, string operName = null);
    parameters:
    - id: error_msg
      type: System.String
      description: >-
        Optional argument
                      A string which is the message associated with the exception.
    - id: exit_without_error
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Abort'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.Abort*
  exceptions: []
- uid: TensorFlow.TFGraph.Abs(TensorFlow.TFOutput,System.String)
  id: Abs(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Abs(TFOutput, String)
  nameWithType: TFGraph.Abs(TFOutput, String)
  fullName: TFGraph.Abs(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the absolute value of a tensor.
  remarks: >-
    Given a tensor <code>x</code>, this operation returns a tensor containing the absolute
                  value of each element in <code>x</code>. For example, if x is an input element and y is
                  an output element, this operation computes \\(y = |x|\\).
  syntax:
    content: public TensorFlow.TFOutput Abs (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Abs'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Abs*
  exceptions: []
- uid: TensorFlow.TFGraph.AccumulateNV2(TensorFlow.TFOutput[],TensorFlow.TFShape,System.String)
  id: AccumulateNV2(TensorFlow.TFOutput[],TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AccumulateNV2(TFOutput[], TFShape, String)
  nameWithType: TFGraph.AccumulateNV2(TFOutput[], TFShape, String)
  fullName: TFGraph.AccumulateNV2(TFOutput[], TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the element-wise sum of a list of tensors.
  remarks: "<code>tf.accumulate_n_v2</code> performs the same operation as <code>tf.add_n</code>, but does not\n              wait for all of its inputs to be ready before beginning to sum. This can\n              save memory if inputs are ready at different times, since minimum temporary\n              storage is proportional to the output size rather than the inputs size.\n              \n              Unlike the original <code>accumulate_n</code>, <code>accumulate_n_v2</code> is differentiable.\n              \n              Returns a <code>Tensor</code> of same shape and type as the elements of <code>inputs</code>."
  syntax:
    content: public TensorFlow.TFOutput AccumulateNV2 (TensorFlow.TFOutput[] inputs, TensorFlow.TFShape shape, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: A list of <code>Tensor</code> objects, each with same shape and type.
    - id: shape
      type: TensorFlow.TFShape
      description: Shape of elements of <code>inputs</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulateNV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AccumulateNV2*
  exceptions: []
- uid: TensorFlow.TFGraph.AccumulatorApplyGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: AccumulatorApplyGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.AccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.AccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies a gradient to a given accumulator.
  remarks: Does not add if local_step is lesser than the accumulator's global_step.
  syntax:
    content: public TensorFlow.TFOperation AccumulatorApplyGradient (TensorFlow.TFOutput handle, TensorFlow.TFOutput local_step, TensorFlow.TFOutput gradient, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a accumulator.
    - id: local_step
      type: TensorFlow.TFOutput
      description: The local_step value at which the gradient was computed.
    - id: gradient
      type: TensorFlow.TFOutput
      description: A tensor of the gradient to be accumulated.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorApplyGradient'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.AccumulatorApplyGradient*
  exceptions: []
- uid: TensorFlow.TFGraph.AccumulatorNumAccumulated(TensorFlow.TFOutput,System.String)
  id: AccumulatorNumAccumulated(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AccumulatorNumAccumulated(TFOutput, String)
  nameWithType: TFGraph.AccumulatorNumAccumulated(TFOutput, String)
  fullName: TFGraph.AccumulatorNumAccumulated(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the number of gradients aggregated in the given accumulators.
  syntax:
    content: public TensorFlow.TFOutput AccumulatorNumAccumulated (TensorFlow.TFOutput handle, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to an accumulator.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorNumAccumulated'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The number of gradients aggregated in the given accumulator.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AccumulatorNumAccumulated*
  exceptions: []
- uid: TensorFlow.TFGraph.AccumulatorSetGlobalStep(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: AccumulatorSetGlobalStep(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AccumulatorSetGlobalStep(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AccumulatorSetGlobalStep(TFOutput, TFOutput, String)
  fullName: TFGraph.AccumulatorSetGlobalStep(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Updates the accumulator with a new value for global_step.
  remarks: >-
    Logs warning if the accumulator's value is already higher than
                  new_global_step.
  syntax:
    content: public TensorFlow.TFOperation AccumulatorSetGlobalStep (TensorFlow.TFOutput handle, TensorFlow.TFOutput new_global_step, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to an accumulator.
    - id: new_global_step
      type: TensorFlow.TFOutput
      description: The new global_step value to set.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorSetGlobalStep'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.AccumulatorSetGlobalStep*
  exceptions: []
- uid: TensorFlow.TFGraph.AccumulatorTakeGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: AccumulatorTakeGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.AccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.AccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Extracts the average gradient in the given ConditionalAccumulator.
  remarks: >-
    The op blocks until sufficient (i.e., more than num_required)
                  gradients have been accumulated.  If the accumulator has already
                  aggregated more than num_required gradients, it returns the average of
                  the accumulated gradients.  Also automatically increments the recorded
                  global_step in the accumulator by 1, and resets the aggregate to 0.
  syntax:
    content: public TensorFlow.TFOutput AccumulatorTakeGradient (TensorFlow.TFOutput handle, TensorFlow.TFOutput num_required, TensorFlow.TFDataType dtype, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to an accumulator.
    - id: num_required
      type: TensorFlow.TFOutput
      description: Number of gradients required before we return an aggregate.
    - id: dtype
      type: TensorFlow.TFDataType
      description: >-
        The data type of accumulated gradients. Needs to correspond to the type
                      of the accumulator.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AccumulatorTakeGradient'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The average of the accumulated gradients.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AccumulatorTakeGradient*
  exceptions: []
- uid: TensorFlow.TFGraph.Acos(TensorFlow.TFOutput,System.String)
  id: Acos(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Acos(TFOutput, String)
  nameWithType: TFGraph.Acos(TFOutput, String)
  fullName: TFGraph.Acos(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes acos of x element-wise.
  syntax:
    content: public TensorFlow.TFOutput Acos (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Acos'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Acos*
  exceptions: []
- uid: TensorFlow.TFGraph.Acosh(TensorFlow.TFOutput,System.String)
  id: Acosh(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Acosh(TFOutput, String)
  nameWithType: TFGraph.Acosh(TFOutput, String)
  fullName: TFGraph.Acosh(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes inverse hyperbolic cosine of x element-wise.
  syntax:
    content: public TensorFlow.TFOutput Acosh (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Acosh'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Acosh*
  exceptions: []
- uid: TensorFlow.TFGraph.Add(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Add(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Add(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Add(TFOutput, TFOutput, String)
  fullName: TFGraph.Add(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns x + y element-wise.
  remarks: >-
    *NOTE*: <code>Add</code> supports broadcasting. <code>AddN</code> does not. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput Add (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Add'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Add*
  exceptions: []
- uid: TensorFlow.TFGraph.AddGradients(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFStatus)
  id: AddGradients(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AddGradients(TFOutput[], TFOutput[], TFOutput[], TFStatus)
  nameWithType: TFGraph.AddGradients(TFOutput[], TFOutput[], TFOutput[], TFStatus)
  fullName: TFGraph.AddGradients(TFOutput[], TFOutput[], TFOutput[], TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Adds a gradient: the operations needed to compute the partial derivatives of sum of <code>y</code>` wrt to <code>x</code>.'
  remarks: d(y[0] + y[1]+ ...)/dx[0], d(y[0] + y[1] + ...)/dx[1]z...
  syntax:
    content: public TensorFlow.TFOutput[] AddGradients (TensorFlow.TFOutput[] y, TensorFlow.TFOutput[] x, TensorFlow.TFOutput[] dx = null, TensorFlow.TFStatus status = null);
    parameters:
    - id: y
      type: TensorFlow.TFOutput[]
      description: The y elements.
    - id: x
      type: TensorFlow.TFOutput[]
      description: The x elements.
    - id: dx
      type: TensorFlow.TFOutput[]
      description: "Initial gradients, which represent the symbolic partial derivatives of some loss function `L` w.r.t. <code>y</code> ).   \n            If the parameter is null, the implementation will use dx for 'OnesLike' for all shapes in <code>y</code>"
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
    return:
      type: TensorFlow.TFOutput[]
      description: The partial derivatives, the size of the array is the same as the length of the <code>y</code> array.
  overload: TensorFlow.TFGraph.AddGradients*
  exceptions: []
- uid: TensorFlow.TFGraph.AddGradients(System.String,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFStatus)
  id: AddGradients(System.String,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AddGradients(String, TFOutput[], TFOutput[], TFOutput[], TFStatus)
  nameWithType: TFGraph.AddGradients(String, TFOutput[], TFOutput[], TFOutput[], TFStatus)
  fullName: TFGraph.AddGradients(String, TFOutput[], TFOutput[], TFOutput[], TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Adds a gradient: the operations needed to compute the partial derivatives of sum of <code>y</code>` wrt to <code>x</code>.'
  remarks: d(y[0] + y[1]+ ...)/dx[0], d(y[0] + y[1] + ...)/dx[1]z...
  syntax:
    content: public TensorFlow.TFOutput[] AddGradients (string prefix, TensorFlow.TFOutput[] y, TensorFlow.TFOutput[] x, TensorFlow.TFOutput[] dx = null, TensorFlow.TFStatus status = null);
    parameters:
    - id: prefix
      type: System.String
      description: "names the scope into which all gradients operations are being added.  This must be unique within \n            the provided graph otherwise this operation will fail.  If the value is null, the default prefixing behaviour takes\n            place, see AddGradients for more details."
    - id: y
      type: TensorFlow.TFOutput[]
      description: The y elements.
    - id: x
      type: TensorFlow.TFOutput[]
      description: The x elements.
    - id: dx
      type: TensorFlow.TFOutput[]
      description: "Initial gradients, which represent the symbolic partial derivatives of some loss function `L` w.r.t. <code>y</code> ).   \n            If the parameter is null, the implementation will use dx for 'OnesLike' for all shapes in <code>y</code>"
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
    return:
      type: TensorFlow.TFOutput[]
      description: The partial derivatives, the size of the array is the same as the length of the <code>y</code> array.
  overload: TensorFlow.TFGraph.AddGradients*
  exceptions: []
- uid: TensorFlow.TFGraph.AddInitVariable(TensorFlow.TFOperation)
  id: AddInitVariable(TensorFlow.TFOperation)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AddInitVariable(TFOperation)
  nameWithType: TFGraph.AddInitVariable(TFOperation)
  fullName: TFGraph.AddInitVariable(TFOperation)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Registers a specified variable as an initialization variable.
  remarks: >-
    <p>
                This is a convenience method to track the variables that need to be initialized in the graph,
                you can retrieve the list of all those variables by calling the <xref href="TensorFlow.TFGraph.GetGlobalVariablesInitializer"></xref>
                which will return this list and clear the state at that point.
                </p>
        <p>
                You typically use this method from helper methods to register all the variables that you want
                initialized, and a higher level method will retrieve all these variables and initialize them
                at their convenience.
                </p>
  syntax:
    content: public void AddInitVariable (TensorFlow.TFOperation variable);
    parameters:
    - id: variable
      type: TensorFlow.TFOperation
      description: Variable to register.
  overload: TensorFlow.TFGraph.AddInitVariable*
  exceptions: []
- uid: TensorFlow.TFGraph.AddManySparseToTensorsMap(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  id: AddManySparseToTensorsMap(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AddManySparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)
  nameWithType: TFGraph.AddManySparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)
  fullName: TFGraph.AddManySparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Add an <code>N</code>-minibatch <code>SparseTensor</code> to a <code>SparseTensorsMap</code>, return <code>N</code> handles.
  remarks: "A <code>SparseTensor</code> of rank <code>R</code> is represented by three tensors: <code>sparse_indices</code>,\n              <code>sparse_values</code>, and <code>sparse_shape</code>, where\n              \n               <pre><code>\n               sparse_indices.shape[1] == sparse_shape.shape[0] == R\n               </code></pre>\n              \n              An <code>N</code>-minibatch of <code>SparseTensor</code> objects is represented as a <code>SparseTensor</code>\n              having a first <code>sparse_indices</code> column taking values between <code>[0, N)</code>, where\n              the minibatch size <code>N == sparse_shape[0]</code>.\n              \n              The input <code>SparseTensor</code> must have rank <code>R</code> greater than 1, and the first\n              dimension is treated as the minibatch dimension.  Elements of the <code>SparseTensor</code>\n              must be sorted in increasing order of this first dimension.  The stored\n              <code>SparseTensor</code> objects pointed to by each row of the output <code>sparse_handles</code>\n              will have rank <code>R-1</code>.\n              \n              The <code>SparseTensor</code> values can then be read out as part of a minibatch by passing\n              the given keys as vector elements to <code>TakeManySparseFromTensorsMap</code>.  To ensure\n              the correct <code>SparseTensorsMap</code> is accessed, ensure that the same\n              <code>container</code> and <code>shared_name</code> are passed to that Op.  If no <code>shared_name</code>\n              is provided here, instead use the *name* of the Operation created by calling\n              <code>AddManySparseToTensorsMap</code> as the <code>shared_name</code> passed to\n              <code>TakeManySparseFromTensorsMap</code>.  Ensure the Operations are colocated."
  syntax:
    content: public TensorFlow.TFOutput AddManySparseToTensorsMap (TensorFlow.TFOutput sparse_indices, TensorFlow.TFOutput sparse_values, TensorFlow.TFOutput sparse_shape, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: sparse_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  The <code>indices</code> of the minibatch <code>SparseTensor</code>.
                      <code>sparse_indices[:, 0]</code> must be ordered values in <code>[0, N)</code>.
    - id: sparse_values
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>values</code> of the minibatch <code>SparseTensor</code>.
    - id: sparse_shape
      type: TensorFlow.TFOutput
      description: >-
        1-D.  The <code>shape</code> of the minibatch <code>SparseTensor</code>.
                      The minibatch size <code>N == sparse_shape[0]</code>.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      The container name for the <code>SparseTensorsMap</code> created by this op.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      The shared name for the <code>SparseTensorsMap</code> created by this op.
                      If blank, the new Operation's unique name is used.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AddManySparseToTensorsMap'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        1-D.  The handles of the <code>SparseTensor</code> now stored in the
                      <code>SparseTensorsMap</code>.  Shape: <code>[N]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AddManySparseToTensorsMap*
  exceptions: []
- uid: TensorFlow.TFGraph.AddN(TensorFlow.TFOutput[],System.String)
  id: AddN(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AddN(TFOutput[], String)
  nameWithType: TFGraph.AddN(TFOutput[], String)
  fullName: TFGraph.AddN(TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Add all input tensors element wise.
  syntax:
    content: public TensorFlow.TFOutput AddN (TensorFlow.TFOutput[] inputs, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: Must all be the same size and shape.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AddN'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AddN*
  exceptions: []
- uid: TensorFlow.TFGraph.AddSparseToTensorsMap(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  id: AddSparseToTensorsMap(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AddSparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)
  nameWithType: TFGraph.AddSparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)
  fullName: TFGraph.AddSparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Add a <code>SparseTensor</code> to a <code>SparseTensorsMap</code> return its handle.
  remarks: "A <code>SparseTensor</code> is represented by three tensors: <code>sparse_indices</code>,\n              <code>sparse_values</code>, and <code>sparse_shape</code>.\n              \n              This operator takes the given <code>SparseTensor</code> and adds it to a container\n              object (a <code>SparseTensorsMap</code>).  A unique key within this container is generated\n              in the form of an <code>int64</code>, and this is the value that is returned.\n              \n              The <code>SparseTensor</code> can then be read out as part of a minibatch by passing\n              the key as a vector element to <code>TakeManySparseFromTensorsMap</code>.  To ensure\n              the correct <code>SparseTensorsMap</code> is accessed, ensure that the same\n              <code>container</code> and <code>shared_name</code> are passed to that Op.  If no <code>shared_name</code>\n              is provided here, instead use the *name* of the Operation created by calling\n              <code>AddSparseToTensorsMap</code> as the <code>shared_name</code> passed to\n              <code>TakeManySparseFromTensorsMap</code>.  Ensure the Operations are colocated."
  syntax:
    content: public TensorFlow.TFOutput AddSparseToTensorsMap (TensorFlow.TFOutput sparse_indices, TensorFlow.TFOutput sparse_values, TensorFlow.TFOutput sparse_shape, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: sparse_indices
      type: TensorFlow.TFOutput
      description: 2-D.  The <code>indices</code> of the <code>SparseTensor</code>.
    - id: sparse_values
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>values</code> of the <code>SparseTensor</code>.
    - id: sparse_shape
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>shape</code> of the <code>SparseTensor</code>.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      The container name for the <code>SparseTensorsMap</code> created by this op.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      The shared name for the <code>SparseTensorsMap</code> created by this op.
                      If blank, the new Operation's unique name is used.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AddSparseToTensorsMap'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        0-D.  The handle of the <code>SparseTensor</code> now stored in the
                      <code>SparseTensorsMap</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AddSparseToTensorsMap*
  exceptions: []
- uid: TensorFlow.TFGraph.AddV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: AddV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AddV2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AddV2(TFOutput, TFOutput, String)
  fullName: TFGraph.AddV2(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns x + y element-wise.
  remarks: >-
    *NOTE*: <code>Add</code> supports broadcasting. <code>AddN</code> does not. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput AddV2 (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AddV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AddV2*
  exceptions: []
- uid: TensorFlow.TFGraph.AdjustContrast(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: AdjustContrast(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AdjustContrast(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.AdjustContrast(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.AdjustContrast(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated. Disallowed in GraphDef version &gt;= 2.
  syntax:
    content: public TensorFlow.TFOutput AdjustContrast (TensorFlow.TFOutput images, TensorFlow.TFOutput contrast_factor, TensorFlow.TFOutput min_value, TensorFlow.TFOutput max_value, string operName = null);
    parameters:
    - id: images
      type: TensorFlow.TFOutput
      description: To be added.
    - id: contrast_factor
      type: TensorFlow.TFOutput
      description: To be added.
    - id: min_value
      type: TensorFlow.TFOutput
      description: To be added.
    - id: max_value
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustContrast'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AdjustContrast*
  exceptions: []
- uid: TensorFlow.TFGraph.AdjustContrastv2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: AdjustContrastv2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AdjustContrastv2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AdjustContrastv2(TFOutput, TFOutput, String)
  fullName: TFGraph.AdjustContrastv2(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Adjust the contrast of one or more images.
  remarks: "<code>images</code> is a tensor of at least 3 dimensions.  The last 3 dimensions are\n              interpreted as <code>[height, width, channels]</code>.  The other dimensions only\n              represent a collection of images, such as <code>[batch, height, width, channels].</code>\n              \n              Contrast is adjusted independently for each channel of each image.\n              \n              For each channel, the Op first computes the mean of the image pixels in the\n              channel and then adjusts each component of each pixel to\n              <code>(x - mean) * contrast_factor + mean</code>."
  syntax:
    content: public TensorFlow.TFOutput AdjustContrastv2 (TensorFlow.TFOutput images, TensorFlow.TFOutput contrast_factor, string operName = null);
    parameters:
    - id: images
      type: TensorFlow.TFOutput
      description: Images to adjust.  At least 3-D.
    - id: contrast_factor
      type: TensorFlow.TFOutput
      description: A float multiplier for adjusting contrast.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustContrastv2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The contrast-adjusted image or images.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AdjustContrastv2*
  exceptions: []
- uid: TensorFlow.TFGraph.AdjustHue(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: AdjustHue(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AdjustHue(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AdjustHue(TFOutput, TFOutput, String)
  fullName: TFGraph.AdjustHue(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Adjust the hue of one or more images.
  remarks: "<code>images</code> is a tensor of at least 3 dimensions.  The last dimension is\n              interpretted as channels, and must be three.\n              \n              The input image is considered in the RGB colorspace. Conceptually, the RGB\n              colors are first mapped into HSV. A delta is then applied all the hue values,\n              and then remapped back to RGB colorspace."
  syntax:
    content: public TensorFlow.TFOutput AdjustHue (TensorFlow.TFOutput images, TensorFlow.TFOutput delta, string operName = null);
    parameters:
    - id: images
      type: TensorFlow.TFOutput
      description: Images to adjust.  At least 3-D.
    - id: delta
      type: TensorFlow.TFOutput
      description: A float delta to add to the hue.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustHue'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The hue-adjusted image or images.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AdjustHue*
  exceptions: []
- uid: TensorFlow.TFGraph.AdjustSaturation(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: AdjustSaturation(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AdjustSaturation(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AdjustSaturation(TFOutput, TFOutput, String)
  fullName: TFGraph.AdjustSaturation(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Adjust the saturation of one or more images.
  remarks: "<code>images</code> is a tensor of at least 3 dimensions.  The last dimension is\n              interpretted as channels, and must be three.\n              \n              The input image is considered in the RGB colorspace. Conceptually, the RGB\n              colors are first mapped into HSV. A scale is then applied all the saturation\n              values, and then remapped back to RGB colorspace."
  syntax:
    content: public TensorFlow.TFOutput AdjustSaturation (TensorFlow.TFOutput images, TensorFlow.TFOutput scale, string operName = null);
    parameters:
    - id: images
      type: TensorFlow.TFOutput
      description: Images to adjust.  At least 3-D.
    - id: scale
      type: TensorFlow.TFOutput
      description: A float scale to add to the saturation.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AdjustSaturation'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The hue-adjusted image or images.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AdjustSaturation*
  exceptions: []
- uid: TensorFlow.TFGraph.All(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: All(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: All(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.All(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.All(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the "logical and" of elements across dimensions of a tensor.
  remarks: >-
    Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
                  <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
                  <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
                  retained with length 1.
  syntax:
    content: public TensorFlow.TFOutput All (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable<bool> keep_dims = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The tensor to reduce.
    - id: reduction_indices
      type: TensorFlow.TFOutput
      description: >-
        The dimensions to reduce. Must be in the range
                      <code>[-rank(input), rank(input))</code>.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, retain reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'All'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The reduced tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.All*
  exceptions: []
- uid: TensorFlow.TFGraph.AllCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: AllCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AllCandidateSampler(TFOutput, Int64, Int64, Boolean, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.AllCandidateSampler(TFOutput, Int64, Int64, Boolean, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.AllCandidateSampler(TFOutput, Int64, Int64, Boolean, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generates labels for candidate sampling with a learned unigram distribution.
  remarks: "See explanations of candidate sampling and the data formats at\n              go/candidate-sampling.\n              \n              For each batch, this op picks a single set of sampled candidate labels.\n              \n              The advantages of sampling candidates per-batch are simplicity and the\n              possibility of efficient dense matrix multiplication. The disadvantage is that\n              the sampled candidates must be chosen independently of the context and of the\n              true labels."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> AllCandidateSampler (TensorFlow.TFOutput true_classes, long num_true, long num_sampled, bool unique, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: true_classes
      type: TensorFlow.TFOutput
      description: >-
        A batch_size * num_true matrix, in which each row contains the
                      IDs of the num_true target_classes in the corresponding original label.
    - id: num_true
      type: System.Int64
      description: Number of true labels per context.
    - id: num_sampled
      type: System.Int64
      description: Number of candidates to produce.
    - id: unique
      type: System.Boolean
      description: >-
        If unique is true, we sample with rejection, so that all sampled
                      candidates in a batch are unique. This requires some approximation to
                      estimate the post-rejection sampling probabilities.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either seed or seed2 are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      An second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AllCandidateSampler'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sampled_candidates: A vector of length num_sampled, in which each element is
                      the ID of a sampled candidate.
                      true_expected_count: A batch_size * num_true matrix, representing
                      the number of times each candidate is expected to occur in a batch
                      of sampled candidates. If unique=true, then this is a probability.
                      sampled_expected_count: A vector of length num_sampled, for each sampled
                      candidate representing the number of times the candidate is expected
                      to occur in a batch of sampled candidates.  If unique=true, then this is a
                      probability.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.AllCandidateSampler*
  exceptions: []
- uid: TensorFlow.TFGraph.AllToAll(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,System.String)
  id: AllToAll(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AllToAll(TFOutput, TFOutput, Int64, Int64, Int64, String)
  nameWithType: TFGraph.AllToAll(TFOutput, TFOutput, Int64, Int64, Int64, String)
  fullName: TFGraph.AllToAll(TFOutput, TFOutput, Int64, Int64, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An Op to exchange data across TPU replicas. On each replica, the input is
  remarks: "split into <code>split_count</code> blocks along <code>split_dimension</code> and send to the other\n              replicas given group_assignment. After receiving <code>split_count</code> - 1 blocks from\n              other replicas, we concatenate the blocks along <code>concat_dimension</code> as the\n              output.\n              \n              For example, suppose there are 2 TPU replicas:\n              replica 0 receives input: <code>[[A, B]]</code>\n              replica 1 receives input: <code>[[C, D]]</code>\n              \n              group_assignment=<code>[[0, 1]]</code>\n              concat_dimension=0\n              split_dimension=1\n              split_count=2\n              \n              replica 0's output: <code>[[A], [C]]</code>\n              replica 1's output: <code>[[B], [D]]</code>"
  syntax:
    content: public TensorFlow.TFOutput AllToAll (TensorFlow.TFOutput input, TensorFlow.TFOutput group_assignment, long concat_dimension, long split_dimension, long split_count, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The local input to the sum.
    - id: group_assignment
      type: TensorFlow.TFOutput
      description: >-
        An int32 tensor with shape
                      [num_groups, num_replicas_per_group]. <code>group_assignment[i]</code> represents the
                      replica ids in the ith subgroup.
    - id: concat_dimension
      type: System.Int64
      description: The dimension number to concatenate.
    - id: split_dimension
      type: System.Int64
      description: The dimension number to split.
    - id: split_count
      type: System.Int64
      description: >-
        The number of splits, this number must equal to the sub-group
                      size(group_assignment.get_shape()[1])
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AllToAll'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The exchanged result.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AllToAll*
  exceptions: []
- uid: TensorFlow.TFGraph.Angle(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: Angle(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Angle(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Angle(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Angle(TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the argument of a complex number.
  remarks: "Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of\n              type <code>float</code> that is the argument of each element in <code>input</code>. All elements in\n              <code>input</code> must be complex numbers of the form \\\\(a + bj\\\\), where *a*\n              is the real part and *b* is the imaginary part.\n              \n              The argument returned by this operation is of the form \\\\(atan2(b, a)\\\\).\n              \n              For example:\n              \n               <pre><code>\n              # tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\n              tf.angle(input) ==&gt; [2.0132, 1.056]\n               </code></pre>\n              \n              @compatibility(numpy)\n              Equivalent to np.angle.\n              @end_compatibility"
  syntax:
    content: public TensorFlow.TFOutput Angle (TensorFlow.TFOutput input, Nullable<TensorFlow.TFDataType> Tout = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: Tout
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Angle'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Angle*
  exceptions: []
- uid: TensorFlow.TFGraph.AnonymousIterator(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: AnonymousIterator(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AnonymousIterator(TFDataType[], TFShape[], String)
  nameWithType: TFGraph.AnonymousIterator(TFDataType[], TFShape[], String)
  fullName: TFGraph.AnonymousIterator(TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A container for an iterator resource.
  syntax:
    content: public TensorFlow.TFOutput AnonymousIterator (TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AnonymousIterator'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A handle to the iterator that can be passed to a "MakeIterator" or
                      "IteratorGetNext" op. In contrast to Iterator, AnonymousIterator prevents
                      resource sharing by name, and does not keep a reference to the resource
                      container.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AnonymousIterator*
  exceptions: []
- uid: TensorFlow.TFGraph.Any(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: Any(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Any(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Any(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Any(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the "logical or" of elements across dimensions of a tensor.
  remarks: >-
    Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
                  <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
                  <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
                  retained with length 1.
  syntax:
    content: public TensorFlow.TFOutput Any (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable<bool> keep_dims = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The tensor to reduce.
    - id: reduction_indices
      type: TensorFlow.TFOutput
      description: >-
        The dimensions to reduce. Must be in the range
                      <code>[-rank(input), rank(input))</code>.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, retain reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Any'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The reduced tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Any*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the adadelta scheme.
  remarks: >-
    accum = rho() * accum + (1 - rho()) * grad.square();
                  update = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;
                  update_accum = rho() * update_accum + (1 - rho()) * update.square();
                  var -= update;
  syntax:
    content: public TensorFlow.TFOutput ApplyAdadelta (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput accum_update, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum_update
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: rho
      type: TensorFlow.TFOutput
      description: Decay factor. Must be a scalar.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Constant factor. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, updating of the var, accum and update_accum tensors will be protected by
                      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdadelta'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyAdadelta*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: ApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the adagrad scheme.
  remarks: >-
    accum += grad * grad
                  var -= lr * grad * (1 / sqrt(accum))
  syntax:
    content: public TensorFlow.TFOutput ApplyAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, Nullable<bool> update_slots = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: update_slots
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdagrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyAdagrad*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the proximal adagrad scheme.
  syntax:
    content: public TensorFlow.TFOutput ApplyAdagradDA (TensorFlow.TFOutput var, TensorFlow.TFOutput gradient_accumulator, TensorFlow.TFOutput gradient_squared_accumulator, TensorFlow.TFOutput grad, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput global_step, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: gradient_accumulator
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: gradient_squared_accumulator
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: global_step
      type: TensorFlow.TFOutput
      description: Training step number. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, updating of the var and accum tensors will be protected by
                      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdagradDA'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyAdagradDA*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyAdam(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: ApplyAdam(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the Adam algorithm.
  remarks: >-
    $$lr_t := \text{learning\_rate} * \sqrt{1 - beta_2^t} / (1 - beta_1^t)$$
                  $$m_t := beta_1 * m_{t-1} + (1 - beta_1) * g$$
                  $$v_t := beta_2 * v_{t-1} + (1 - beta_2) * g * g$$
                  $$variable := variable - lr_t * m_t / (\sqrt{v_t} + \epsilon)$$
  syntax:
    content: public TensorFlow.TFOutput ApplyAdam (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput v, TensorFlow.TFOutput beta1_power, TensorFlow.TFOutput beta2_power, TensorFlow.TFOutput lr, TensorFlow.TFOutput beta1, TensorFlow.TFOutput beta2, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, Nullable<bool> use_nesterov = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: m
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: v
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: beta1_power
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: beta2_power
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: beta1
      type: TensorFlow.TFOutput
      description: Momentum factor. Must be a scalar.
    - id: beta2
      type: TensorFlow.TFOutput
      description: Momentum factor. Must be a scalar.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Ridge term. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var, m, and v tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: use_nesterov
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, uses the nesterov update.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdam'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyAdam*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyAdaMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ApplyAdaMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the AdaMax algorithm.
  remarks: >-
    m_t &lt;- beta1 * m_{t-1} + (1 - beta1) * g
                  v_t &lt;- max(beta2 * v_{t-1}, abs(g))
                  variable &lt;- variable - learning_rate / (1 - beta1^t) * m_t / (v_t + epsilon)
  syntax:
    content: public TensorFlow.TFOutput ApplyAdaMax (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput v, TensorFlow.TFOutput beta1_power, TensorFlow.TFOutput lr, TensorFlow.TFOutput beta1, TensorFlow.TFOutput beta2, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: m
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: v
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: beta1_power
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: beta1
      type: TensorFlow.TFOutput
      description: Momentum factor. Must be a scalar.
    - id: beta2
      type: TensorFlow.TFOutput
      description: Momentum factor. Must be a scalar.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Ridge term. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var, m, and v tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAdaMax'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyAdaMax*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyAddSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ApplyAddSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the AddSign update.
  remarks: >-
    m_t &lt;- beta1 * m_{t-1} + (1 - beta1) * g
                  update &lt;- (alpha + sign_decay * sign(g) *sign(m)) * g
                  variable &lt;- variable - lr_t * update
  syntax:
    content: public TensorFlow.TFOutput ApplyAddSign (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput lr, TensorFlow.TFOutput alpha, TensorFlow.TFOutput sign_decay, TensorFlow.TFOutput beta, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: m
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: alpha
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: sign_decay
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: beta
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and m tensors is
                      protected by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyAddSign'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyAddSign*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the centered RMSProp algorithm.
  remarks: "The centered RMSProp algorithm uses an estimate of the centered second moment\n              (i.e., the variance) for normalization, as opposed to regular RMSProp, which\n              uses the (uncentered) second moment. This often helps with training, but is\n              slightly more expensive in terms of computation and memory.\n              \n              Note that in dense implementation of this algorithm, mg, ms, and mom will\n              update even if the grad is zero, but in this sparse implementation, mg, ms,\n              and mom will not update in iterations during which the grad is zero.\n              \n              mean_square = decay * mean_square + (1-decay) * gradient ** 2\n              mean_grad = decay * mean_grad + (1-decay) * gradient\n              \n              Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n              \n              mg &lt;- rho * mg_{t-1} + (1-rho) * grad\n              ms &lt;- rho * ms_{t-1} + (1-rho) * grad * grad\n              mom &lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)\n              var &lt;- var - mom"
  syntax:
    content: public TensorFlow.TFOutput ApplyCenteredRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput mg, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: mg
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: ms
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: mom
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: rho
      type: TensorFlow.TFOutput
      description: Decay rate. Must be a scalar.
    - id: momentum
      type: TensorFlow.TFOutput
      description: To be added.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Ridge term. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var, mg, ms, and mom tensors is
                      protected by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyCenteredRMSProp'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyCenteredRMSProp*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the Ftrl-proximal scheme.
  remarks: >-
    accum_new = accum + grad * grad
                  linear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
                  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
                  var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
                  accum = accum_new
  syntax:
    content: public TensorFlow.TFOutput ApplyFtrl (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput lr_power, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: linear
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regulariation. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regulariation. Must be a scalar.
    - id: lr_power
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyFtrl'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyFtrl*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the Ftrl-proximal scheme.
  remarks: >-
    grad_with_shrinkage = grad + 2 * l2_shrinkage * var
                  accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
                  linear += grad_with_shrinkage +
                  (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
                  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
                  var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
                  accum = accum_new
  syntax:
    content: public TensorFlow.TFOutput ApplyFtrlV2 (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput l2_shrinkage, TensorFlow.TFOutput lr_power, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: linear
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regulariation. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 shrinkage regulariation. Must be a scalar.
    - id: l2_shrinkage
      type: TensorFlow.TFOutput
      description: To be added.
    - id: lr_power
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyFtrlV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyFtrlV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ApplyGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' by subtracting 'alpha' * 'delta' from it.
  syntax:
    content: public TensorFlow.TFOutput ApplyGradientDescent (TensorFlow.TFOutput var, TensorFlow.TFOutput alpha, TensorFlow.TFOutput delta, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: alpha
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: delta
      type: TensorFlow.TFOutput
      description: The change.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, the subtraction will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyGradientDescent'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyGradientDescent*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: ApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the momentum scheme. Set use_nesterov = True if you
  remarks: "want to use Nesterov momentum.\n              \n              accum = accum * momentum + grad\n              var -= lr * accum"
  syntax:
    content: public TensorFlow.TFOutput ApplyMomentum (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, TensorFlow.TFOutput momentum, Nullable<bool> use_locking = null, Nullable<bool> use_nesterov = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: momentum
      type: TensorFlow.TFOutput
      description: Momentum. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: use_nesterov
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, the tensor passed to compute grad will be
                      var - lr * momentum * accum, so in the end, the var you get is actually
                      var - lr * momentum * accum.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyMomentum'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyMomentum*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyPowerSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ApplyPowerSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the AddSign update.
  remarks: >-
    m_t &lt;- beta1 * m_{t-1} + (1 - beta1) * g
                  update &lt;- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g
                  variable &lt;- variable - lr_t * update
  syntax:
    content: public TensorFlow.TFOutput ApplyPowerSign (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput lr, TensorFlow.TFOutput logbase, TensorFlow.TFOutput sign_decay, TensorFlow.TFOutput beta, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: m
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: logbase
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: sign_decay
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: beta
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and m tensors is
                      protected by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyPowerSign'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyPowerSign*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.
  remarks: >-
    accum += grad * grad
                  prox_v = var - lr * grad * (1 / sqrt(accum))
                  var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
  syntax:
    content: public TensorFlow.TFOutput ApplyProximalAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, updating of the var and accum tensors will be protected by
                      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyProximalAdagrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyProximalAdagrad*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' as FOBOS algorithm with fixed learning rate.
  remarks: >-
    prox_v = var - alpha * delta
                  var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
  syntax:
    content: public TensorFlow.TFOutput ApplyProximalGradientDescent (TensorFlow.TFOutput var, TensorFlow.TFOutput alpha, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput delta, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: alpha
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: delta
      type: TensorFlow.TFOutput
      description: The change.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the subtraction will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyProximalGradientDescent'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyProximalGradientDescent*
  exceptions: []
- uid: TensorFlow.TFGraph.ApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the RMSProp algorithm.
  remarks: "Note that in dense implementation of this algorithm, ms and mom will\n              update even if the grad is zero, but in this sparse implementation, ms\n              and mom will not update in iterations during which the grad is zero.\n              \n              mean_square = decay * mean_square + (1-decay) * gradient ** 2\n              Delta = learning_rate * gradient / sqrt(mean_square + epsilon)\n              \n              ms &lt;- rho * ms_{t-1} + (1-rho) * grad * grad\n              mom &lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\n              var &lt;- var - mom"
  syntax:
    content: public TensorFlow.TFOutput ApplyRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: ms
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: mom
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: rho
      type: TensorFlow.TFOutput
      description: Decay rate. Must be a scalar.
    - id: momentum
      type: TensorFlow.TFOutput
      description: To be added.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Ridge term. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var, ms, and mom tensors is protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApplyRMSProp'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApplyRMSProp*
  exceptions: []
- uid: TensorFlow.TFGraph.ApproximateEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String)
  id: ApproximateEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ApproximateEqual(TFOutput, TFOutput, Nullable<Single>, String)
  nameWithType: TFGraph.ApproximateEqual(TFOutput, TFOutput, Nullable<Single>, String)
  fullName: TFGraph.ApproximateEqual(TFOutput, TFOutput, Nullable<Single>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the truth value of abs(x-y) &lt; tolerance element-wise.
  syntax:
    content: public TensorFlow.TFOutput ApproximateEqual (TensorFlow.TFOutput x, TensorFlow.TFOutput y, Nullable<float> tolerance = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: tolerance
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ApproximateEqual'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ApproximateEqual*
  exceptions: []
- uid: TensorFlow.TFGraph.ArgMax(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: ArgMax(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ArgMax(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.ArgMax(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.ArgMax(TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the index with the largest value across dimensions of a tensor.
  remarks: Note that in case of ties the identity of the return value is not guaranteed.
  syntax:
    content: public TensorFlow.TFOutput ArgMax (TensorFlow.TFOutput input, TensorFlow.TFOutput dimension, Nullable<TensorFlow.TFDataType> output_type = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dimension
      type: TensorFlow.TFOutput
      description: >-
        int32 or int64, must be in the range <code>[-rank(input), rank(input))</code>.
                      Describes which dimension of the input Tensor to reduce across. For vectors,
                      use dimension = 0.
    - id: output_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ArgMax'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ArgMax*
  exceptions: []
- uid: TensorFlow.TFGraph.ArgMin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: ArgMin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ArgMin(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.ArgMin(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.ArgMin(TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the index with the smallest value across dimensions of a tensor.
  remarks: Note that in case of ties the identity of the return value is not guaranteed.
  syntax:
    content: public TensorFlow.TFOutput ArgMin (TensorFlow.TFOutput input, TensorFlow.TFOutput dimension, Nullable<TensorFlow.TFDataType> output_type = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dimension
      type: TensorFlow.TFOutput
      description: >-
        int32 or int64, must be in the range <code>[-rank(input), rank(input))</code>.
                      Describes which dimension of the input Tensor to reduce across. For vectors,
                      use dimension = 0.
    - id: output_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ArgMin'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ArgMin*
  exceptions: []
- uid: TensorFlow.TFGraph.Asin(TensorFlow.TFOutput,System.String)
  id: Asin(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Asin(TFOutput, String)
  nameWithType: TFGraph.Asin(TFOutput, String)
  fullName: TFGraph.Asin(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes asin of x element-wise.
  syntax:
    content: public TensorFlow.TFOutput Asin (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Asin'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Asin*
  exceptions: []
- uid: TensorFlow.TFGraph.Asinh(TensorFlow.TFOutput,System.String)
  id: Asinh(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Asinh(TFOutput, String)
  nameWithType: TFGraph.Asinh(TFOutput, String)
  fullName: TFGraph.Asinh(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes inverse hyperbolic sine of x element-wise.
  syntax:
    content: public TensorFlow.TFOutput Asinh (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Asinh'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Asinh*
  exceptions: []
- uid: TensorFlow.TFGraph.Assert(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  id: Assert(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Assert(TFOutput, TFOutput[], Nullable<Int64>, String)
  nameWithType: TFGraph.Assert(TFOutput, TFOutput[], Nullable<Int64>, String)
  fullName: TFGraph.Assert(TFOutput, TFOutput[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Asserts that the given condition is true.
  remarks: >-
    If <code>condition</code> evaluates to false, print the list of tensors in <code>data</code>.
                  <code>summarize</code> determines how many entries of the tensors to print.
  syntax:
    content: public TensorFlow.TFOperation Assert (TensorFlow.TFOutput condition, TensorFlow.TFOutput[] data, Nullable<long> summarize = null, string operName = null);
    parameters:
    - id: condition
      type: TensorFlow.TFOutput
      description: The condition to evaluate.
    - id: data
      type: TensorFlow.TFOutput[]
      description: The tensors to print out when condition is false.
    - id: summarize
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Print this many entries of each tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Assert'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.Assert*
  exceptions: []
- uid: TensorFlow.TFGraph.Assign(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: Assign(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Assign(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.Assign(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.Assign(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update 'ref' by assigning 'value' to it.
  remarks: >-
    This operation outputs "ref" after the assignment is done.
                  This makes it easier to chain operations that need to use the reset value.
  syntax:
    content: public TensorFlow.TFOutput Assign (TensorFlow.TFOutput reference, TensorFlow.TFOutput value, Nullable<bool> validate_shape = null, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node. May be uninitialized.
    - id: value
      type: TensorFlow.TFOutput
      description: The value to be assigned to the variable.
    - id: validate_shape
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, the operation will validate that the shape
                      of 'value' matches the shape of the Tensor being assigned to.  If false,
                      'ref' will take on the shape of 'value'.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the assignment will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Assign'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        = Same as "ref".  Returned as a convenience for operations that want
                      to use the new value after the variable has been reset.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Assign*
  exceptions: []
- uid: TensorFlow.TFGraph.AssignAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: AssignAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AssignAdd(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.AssignAdd(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.AssignAdd(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update 'ref' by adding 'value' to it.
  remarks: >-
    This operation outputs "ref" after the update is done.
                  This makes it easier to chain operations that need to use the reset value.
  syntax:
    content: public TensorFlow.TFOutput AssignAdd (TensorFlow.TFOutput reference, TensorFlow.TFOutput value, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: value
      type: TensorFlow.TFOutput
      description: The value to be added to the variable.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the addition will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignAdd'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        = Same as "ref".  Returned as a convenience for operations that want
                      to use the new value after the variable has been updated.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AssignAdd*
  exceptions: []
- uid: TensorFlow.TFGraph.AssignAddVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: AssignAddVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AssignAddVariableOp(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AssignAddVariableOp(TFOutput, TFOutput, String)
  fullName: TFGraph.AssignAddVariableOp(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Adds a value to the current value of a variable.
  remarks: >-
    Any ReadVariableOp with a control dependency on this op is guaranteed to
                  see the incremented value or a subsequent newer one.
  syntax:
    content: public TensorFlow.TFOperation AssignAddVariableOp (TensorFlow.TFOutput resource, TensorFlow.TFOutput value, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: handle to the resource in which to store the variable.
    - id: value
      type: TensorFlow.TFOutput
      description: the value by which the variable will be incremented.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignAddVariableOp'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.AssignAddVariableOp*
  exceptions: []
- uid: TensorFlow.TFGraph.AssignSub(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: AssignSub(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AssignSub(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.AssignSub(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.AssignSub(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update 'ref' by subtracting 'value' from it.
  remarks: >-
    This operation outputs "ref" after the update is done.
                  This makes it easier to chain operations that need to use the reset value.
  syntax:
    content: public TensorFlow.TFOutput AssignSub (TensorFlow.TFOutput reference, TensorFlow.TFOutput value, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: value
      type: TensorFlow.TFOutput
      description: The value to be subtracted to the variable.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the subtraction will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignSub'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        = Same as "ref".  Returned as a convenience for operations that want
                      to use the new value after the variable has been updated.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AssignSub*
  exceptions: []
- uid: TensorFlow.TFGraph.AssignSubVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: AssignSubVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AssignSubVariableOp(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AssignSubVariableOp(TFOutput, TFOutput, String)
  fullName: TFGraph.AssignSubVariableOp(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Subtracts a value from the current value of a variable.
  remarks: >-
    Any ReadVariableOp with a control dependency on this op is guaranteed to
                  see the decremented value or a subsequent newer one.
  syntax:
    content: public TensorFlow.TFOperation AssignSubVariableOp (TensorFlow.TFOutput resource, TensorFlow.TFOutput value, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: handle to the resource in which to store the variable.
    - id: value
      type: TensorFlow.TFOutput
      description: the value by which the variable will be incremented.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignSubVariableOp'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.AssignSubVariableOp*
  exceptions: []
- uid: TensorFlow.TFGraph.AssignVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: AssignVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AssignVariableOp(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AssignVariableOp(TFOutput, TFOutput, String)
  fullName: TFGraph.AssignVariableOp(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Assigns a new value to a variable.
  remarks: >-
    Any ReadVariableOp with a control dependency on this op is guaranteed to return
                  this value or a subsequent newer value of the variable.
  syntax:
    content: public TensorFlow.TFOperation AssignVariableOp (TensorFlow.TFOutput resource, TensorFlow.TFOutput value, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: handle to the resource in which to store the variable.
    - id: value
      type: TensorFlow.TFOutput
      description: the value to set the new tensor to use.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AssignVariableOp'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.AssignVariableOp*
  exceptions: []
- uid: TensorFlow.TFGraph.AsString(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String,System.String)
  id: AsString(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AsString(TFOutput, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, String, String)
  nameWithType: TFGraph.AsString(TFOutput, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, String, String)
  fullName: TFGraph.AsString(TFOutput, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts each entry in the given tensor to strings.  Supports many numeric
  remarks: types and boolean.
  syntax:
    content: public TensorFlow.TFOutput AsString (TensorFlow.TFOutput input, Nullable<long> precision = null, Nullable<bool> scientific = null, Nullable<bool> shortest = null, Nullable<long> width = null, string fill = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: precision
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The post-decimal precision to use for floating point numbers.
                      Only used if precision &gt; -1.
    - id: scientific
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Use scientific notation for floating point numbers.
    - id: shortest
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Use shortest representation (either scientific or standard) for
                      floating point numbers.
    - id: width
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Pad pre-decimal numbers to this width.
                      Applies to both floating point and integer numbers.
                      Only used if width &gt; -1.
    - id: fill
      type: System.String
      description: >-
        Optional argument
                      The value to pad if width &gt; -1.  If empty, pads with spaces.
                      Another typical value is '0'.  String cannot be longer than 1 character.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AsString'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AsString*
  exceptions: []
- uid: TensorFlow.TFGraph.Atan(TensorFlow.TFOutput,System.String)
  id: Atan(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Atan(TFOutput, String)
  nameWithType: TFGraph.Atan(TFOutput, String)
  fullName: TFGraph.Atan(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes atan of x element-wise.
  syntax:
    content: public TensorFlow.TFOutput Atan (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Atan'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Atan*
  exceptions: []
- uid: TensorFlow.TFGraph.Atan2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Atan2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Atan2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Atan2(TFOutput, TFOutput, String)
  fullName: TFGraph.Atan2(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes arctangent of <code>y/x</code> element-wise, respecting signs of the arguments.
  remarks: >-
    This is the angle \( \theta \in [-\pi, \pi] \) such that
                  \[ x = r \cos(\theta) \]
                  and
                  \[ y = r \sin(\theta) \]
                  where \(r = \sqrt(x^2 + y^2) \).
  syntax:
    content: public TensorFlow.TFOutput Atan2 (TensorFlow.TFOutput y, TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Atan2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Atan2*
  exceptions: []
- uid: TensorFlow.TFGraph.Atanh(TensorFlow.TFOutput,System.String)
  id: Atanh(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Atanh(TFOutput, String)
  nameWithType: TFGraph.Atanh(TFOutput, String)
  fullName: TFGraph.Atanh(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes inverse hyperbolic tangent of x element-wise.
  syntax:
    content: public TensorFlow.TFOutput Atanh (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Atanh'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Atanh*
  exceptions: []
- uid: TensorFlow.TFGraph.AudioSpectrogram(TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)
  id: AudioSpectrogram(TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AudioSpectrogram(TFOutput, Int64, Int64, Nullable<Boolean>, String)
  nameWithType: TFGraph.AudioSpectrogram(TFOutput, Int64, Int64, Nullable<Boolean>, String)
  fullName: TFGraph.AudioSpectrogram(TFOutput, Int64, Int64, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Produces a visualization of audio data over time.
  remarks: "Spectrograms are a standard way of representing audio information as a series of\n              slices of frequency information, one slice for each window of time. By joining\n              these together into a sequence, they form a distinctive fingerprint of the sound\n              over time.\n              \n              This op expects to receive audio data as an input, stored as floats in the range\n              -1 to 1, together with a window width in samples, and a stride specifying how\n              far to move the window between slices. From this it generates a three\n              dimensional output. The lowest dimension has an amplitude value for each\n              frequency during that time slice. The next dimension is time, with successive\n              frequency slices. The final dimension is for the channels in the input, so a\n              stereo audio input would have two here for example.\n              \n              This means the layout when converted and saved as an image is rotated 90 degrees\n              clockwise from a typical spectrogram. Time is descending down the Y axis, and\n              the frequency decreases from left to right.\n              \n              Each value in the result represents the square root of the sum of the real and\n              imaginary parts of an FFT on the current window of samples. In this way, the\n              lowest dimension represents the power of each frequency in the current window,\n              and adjacent windows are concatenated in the next dimension.\n              \n              To get a more intuitive and visual look at what this operation does, you can run\n              tensorflow/examples/wav_to_spectrogram to read in an audio file and save out the\n              resulting spectrogram as a PNG image."
  syntax:
    content: public TensorFlow.TFOutput AudioSpectrogram (TensorFlow.TFOutput input, long window_size, long stride, Nullable<bool> magnitude_squared = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Float representation of audio data.
    - id: window_size
      type: System.Int64
      description: >-
        How wide the input window is in samples. For the highest efficiency
                      this should be a power of two, but other values are accepted.
    - id: stride
      type: System.Int64
      description: How widely apart the center of adjacent sample windows should be.
    - id: magnitude_squared
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Whether to return the squared magnitude or just the
                      magnitude. Using squared magnitude can avoid extra calculations.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AudioSpectrogram'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        3D representation of the audio frequencies as an image.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AudioSpectrogram*
  exceptions: []
- uid: TensorFlow.TFGraph.AudioSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Nullable{System.Int64},System.String)
  id: AudioSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AudioSummary(TFOutput, TFOutput, Single, Nullable<Int64>, String)
  nameWithType: TFGraph.AudioSummary(TFOutput, TFOutput, Single, Nullable<Int64>, String)
  fullName: TFGraph.AudioSummary(TFOutput, TFOutput, Single, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs a <code>Summary</code> protocol buffer with audio.
  remarks: "The summary has up to <code>max_outputs</code> summary values containing audio. The\n              audio is built from <code>tensor</code> which must be 3-D with shape <code>[batch_size,\n              frames, channels]</code> or 2-D with shape <code>[batch_size, frames]</code>. The values are\n              assumed to be in the range of <code>[-1.0, 1.0]</code> with a sample rate of <code>sample_rate</code>.\n              \n              The <code>tag</code> argument is a scalar <code>Tensor</code> of type <code>string</code>.  It is used to\n              build the <code>tag</code> of the summary values:\n              \n              *  If <code>max_outputs</code> is 1, the summary value tag is '*tag*/audio'.\n              *  If <code>max_outputs</code> is greater than 1, the summary value tags are\n              generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc."
  syntax:
    content: public TensorFlow.TFOutput AudioSummary (TensorFlow.TFOutput tag, TensorFlow.TFOutput tensor, float sample_rate, Nullable<long> max_outputs = null, string operName = null);
    parameters:
    - id: tag
      type: TensorFlow.TFOutput
      description: Scalar. Used to build the <code>tag</code> attribute of the summary values.
    - id: tensor
      type: TensorFlow.TFOutput
      description: 2-D of shape <code>[batch_size, frames]</code>.
    - id: sample_rate
      type: System.Single
      description: The sample rate of the signal in hertz.
    - id: max_outputs
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Max number of batch elements to generate audio for.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AudioSummary'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Scalar. Serialized <code>Summary</code> protocol buffer.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AudioSummary*
  exceptions: []
- uid: TensorFlow.TFGraph.AudioSummaryV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  id: AudioSummaryV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AudioSummaryV2(TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.AudioSummaryV2(TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.AudioSummaryV2(TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs a <code>Summary</code> protocol buffer with audio.
  remarks: "The summary has up to <code>max_outputs</code> summary values containing audio. The\n              audio is built from <code>tensor</code> which must be 3-D with shape <code>[batch_size,\n              frames, channels]</code> or 2-D with shape <code>[batch_size, frames]</code>. The values are\n              assumed to be in the range of <code>[-1.0, 1.0]</code> with a sample rate of <code>sample_rate</code>.\n              \n              The <code>tag</code> argument is a scalar <code>Tensor</code> of type <code>string</code>.  It is used to\n              build the <code>tag</code> of the summary values:\n              \n              *  If <code>max_outputs</code> is 1, the summary value tag is '*tag*/audio'.\n              *  If <code>max_outputs</code> is greater than 1, the summary value tags are\n              generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc."
  syntax:
    content: public TensorFlow.TFOutput AudioSummaryV2 (TensorFlow.TFOutput tag, TensorFlow.TFOutput tensor, TensorFlow.TFOutput sample_rate, Nullable<long> max_outputs = null, string operName = null);
    parameters:
    - id: tag
      type: TensorFlow.TFOutput
      description: Scalar. Used to build the <code>tag</code> attribute of the summary values.
    - id: tensor
      type: TensorFlow.TFOutput
      description: 2-D of shape <code>[batch_size, frames]</code>.
    - id: sample_rate
      type: TensorFlow.TFOutput
      description: The sample rate of the signal in hertz.
    - id: max_outputs
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Max number of batch elements to generate audio for.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AudioSummaryV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Scalar. Serialized <code>Summary</code> protocol buffer.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AudioSummaryV2*
  exceptions: []
- uid: TensorFlow.TFGraph.AvgPool(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  id: AvgPool(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AvgPool(TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.AvgPool(TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.AvgPool(TFOutput, Int64[], Int64[], String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Performs average pooling on the input.
  remarks: >-
    Each entry in <code>output</code> is the mean of the corresponding size <code>ksize</code>
                  window in <code>value</code>.
  syntax:
    content: public TensorFlow.TFOutput AvgPool (TensorFlow.TFOutput value, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);
    parameters:
    - id: value
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: ksize
      type: System.Int64[]
      description: The size of the sliding window for each dimension of <code>value</code>.
    - id: strides
      type: System.Int64[]
      description: The stride of the sliding window for each dimension of <code>value</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, in_channels, in_height, in_width].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPool'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The average pooled output tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AvgPool*
  exceptions: []
- uid: TensorFlow.TFGraph.AvgPool3D(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  id: AvgPool3D(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AvgPool3D(TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.AvgPool3D(TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.AvgPool3D(TFOutput, Int64[], Int64[], String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Performs 3D average pooling on the input.
  syntax:
    content: public TensorFlow.TFOutput AvgPool3D (TensorFlow.TFOutput input, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.
    - id: ksize
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The size of the window for each dimension of
                      the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The stride of the sliding window for each
                      dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      The data format of the input and output data. With the
                      default format "NDHWC", the data is stored in the order of:
                      [batch, in_depth, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCDHW", the data storage order is:
                      [batch, in_channels, in_depth, in_height, in_width].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPool3D'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The average pooled output tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AvgPool3D*
  exceptions: []
- uid: TensorFlow.TFGraph.AvgPool3DGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  id: AvgPool3DGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AvgPool3DGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.AvgPool3DGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.AvgPool3DGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes gradients of average pooling function.
  syntax:
    content: public TensorFlow.TFOutput AvgPool3DGrad (TensorFlow.TFOutput orig_input_shape, TensorFlow.TFOutput grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);
    parameters:
    - id: orig_input_shape
      type: TensorFlow.TFOutput
      description: The original input dimensions.
    - id: grad
      type: TensorFlow.TFOutput
      description: Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.
    - id: ksize
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The size of the window for each dimension of
                      the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The stride of the sliding window for each
                      dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      The data format of the input and output data. With the
                      default format "NDHWC", the data is stored in the order of:
                      [batch, in_depth, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCDHW", the data storage order is:
                      [batch, in_channels, in_depth, in_height, in_width].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPool3DGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The backprop for input.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AvgPool3DGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.AvgPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  id: AvgPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: AvgPoolGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.AvgPoolGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.AvgPoolGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes gradients of the average pooling function.
  syntax:
    content: public TensorFlow.TFOutput AvgPoolGrad (TensorFlow.TFOutput orig_input_shape, TensorFlow.TFOutput grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);
    parameters:
    - id: orig_input_shape
      type: TensorFlow.TFOutput
      description: 1-D.  Shape of the original input to <code>avg_pool</code>.
    - id: grad
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, height, width, channels]</code>.  Gradients w.r.t.
                      the output of <code>avg_pool</code>.
    - id: ksize
      type: System.Int64[]
      description: The size of the sliding window for each dimension of the input.
    - id: strides
      type: System.Int64[]
      description: The stride of the sliding window for each dimension of the input.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, in_channels, in_height, in_width].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'AvgPoolGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D.  Gradients w.r.t. the input of <code>avg_pool</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.AvgPoolGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.Barrier(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  id: Barrier(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Barrier(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.Barrier(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.Barrier(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Defines a barrier that persists across different graph executions.
  remarks: "A barrier represents a key-value map, where each key is a string, and\n              each value is a tuple of tensors.\n              \n              At runtime, the barrier contains 'complete' and 'incomplete'\n              elements. A complete element has defined tensors for all components of\n              its value tuple, and may be accessed using BarrierTakeMany. An\n              incomplete element has some undefined components in its value tuple,\n              and may be updated using BarrierInsertMany."
  syntax:
    content: public TensorFlow.TFOutput Barrier (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable<long> capacity = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a value.
    - id: shapes
      type: TensorFlow.TFShape[]
      description: >-
        Optional argument
                      The shape of each component in a value. Each shape must be 1 in the
                      first dimension. The length of this attr must be the same as the length of
                      component_types.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The capacity of the barrier.  The default capacity is MAX_INT32,
                      which is the largest capacity of the underlying queue.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this barrier is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this barrier will be shared under the given name
                      across multiple sessions.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Barrier'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to the barrier.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Barrier*
  exceptions: []
- uid: TensorFlow.TFGraph.BarrierClose(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: BarrierClose(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BarrierClose(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.BarrierClose(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.BarrierClose(TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Closes the given barrier.
  remarks: >-
    This operation signals that no more new elements will be inserted in the
                  given barrier. Subsequent InsertMany that try to introduce a new key will fail.
                  Subsequent InsertMany operations that just add missing components to already
                  existing elements will continue to succeed. Subsequent TakeMany operations will
                  continue to succeed if sufficient completed elements remain in the barrier.
                  Subsequent TakeMany operations that would block will fail immediately.
  syntax:
    content: public TensorFlow.TFOperation BarrierClose (TensorFlow.TFOutput handle, Nullable<bool> cancel_pending_enqueues = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a barrier.
    - id: cancel_pending_enqueues
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, all pending enqueue requests that are
                      blocked on the barrier's queue will be canceled. InsertMany will fail, even
                      if no new key is introduced.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierClose'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.BarrierClose*
  exceptions: []
- uid: TensorFlow.TFGraph.BarrierIncompleteSize(TensorFlow.TFOutput,System.String)
  id: BarrierIncompleteSize(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BarrierIncompleteSize(TFOutput, String)
  nameWithType: TFGraph.BarrierIncompleteSize(TFOutput, String)
  fullName: TFGraph.BarrierIncompleteSize(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the number of incomplete elements in the given barrier.
  syntax:
    content: public TensorFlow.TFOutput BarrierIncompleteSize (TensorFlow.TFOutput handle, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a barrier.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierIncompleteSize'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The number of incomplete elements (i.e. those with some of their value
                      components not set) in the barrier.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BarrierIncompleteSize*
  exceptions: []
- uid: TensorFlow.TFGraph.BarrierInsertMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  id: BarrierInsertMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BarrierInsertMany(TFOutput, TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.BarrierInsertMany(TFOutput, TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.BarrierInsertMany(TFOutput, TFOutput, TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: For each key, assigns the respective value to the specified component.
  remarks: >-
    If a key is not found in the barrier, this operation will create a new
                  incomplete element. If a key is found in the barrier, and the element
                  already has a value at component_index, this operation will fail with
                  INVALID_ARGUMENT, and leave the barrier in an undefined state.
  syntax:
    content: public TensorFlow.TFOperation BarrierInsertMany (TensorFlow.TFOutput handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, long component_index, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a barrier.
    - id: keys
      type: TensorFlow.TFOutput
      description: A one-dimensional tensor of keys, with length n.
    - id: values
      type: TensorFlow.TFOutput
      description: >-
        An any-dimensional tensor of values, which are associated with the
                      respective keys. The 0th dimension must have length n.
    - id: component_index
      type: System.Int64
      description: The component of the barrier elements that is being assigned.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierInsertMany'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.BarrierInsertMany*
  exceptions: []
- uid: TensorFlow.TFGraph.BarrierReadySize(TensorFlow.TFOutput,System.String)
  id: BarrierReadySize(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BarrierReadySize(TFOutput, String)
  nameWithType: TFGraph.BarrierReadySize(TFOutput, String)
  fullName: TFGraph.BarrierReadySize(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the number of complete elements in the given barrier.
  syntax:
    content: public TensorFlow.TFOutput BarrierReadySize (TensorFlow.TFOutput handle, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a barrier.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierReadySize'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The number of complete elements (i.e. those with all of their value
                      components set) in the barrier.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BarrierReadySize*
  exceptions: []
- uid: TensorFlow.TFGraph.BarrierTakeMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  id: BarrierTakeMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BarrierTakeMany(TFOutput, TFOutput, TFDataType[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, String)
  nameWithType: TFGraph.BarrierTakeMany(TFOutput, TFOutput, TFDataType[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, String)
  fullName: TFGraph.BarrierTakeMany(TFOutput, TFOutput, TFDataType[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Takes the given number of completed elements from a barrier.
  remarks: "This operation concatenates completed-element component tensors along\n              the 0th dimension to make a single component tensor.\n              \n              Elements come out of the barrier when they are complete, and in the order\n              in which they were placed into the barrier.  The indices output provides\n              information about the batch in which each element was originally inserted\n              into the barrier."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[]> BarrierTakeMany (TensorFlow.TFOutput handle, TensorFlow.TFOutput num_elements, TensorFlow.TFDataType[] component_types, Nullable<bool> allow_small_batch = null, Nullable<bool> wait_for_incomplete = null, Nullable<long> timeout_ms = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a barrier.
    - id: num_elements
      type: TensorFlow.TFOutput
      description: >-
        A single-element tensor containing the number of elements to
                      take.
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a value.
    - id: allow_small_batch
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Allow to return less than num_elements items if barrier is
                      already closed.
    - id: wait_for_incomplete
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: timeout_ms
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If the queue is empty, this operation will block for up to
                      timeout_ms milliseconds.
                      Note: This option is not supported yet.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BarrierTakeMany'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[]}
      description: >-
        Returns a tuple with multiple values, as follows:
                      indices: A one-dimensional tensor of indices, with length num_elems.
                      These indices refer to the batch in which the values were placed into the
                      barrier (starting with MIN_LONG and increasing with each BarrierInsertMany).
                      keys: A one-dimensional tensor of keys, with length num_elements.
                      values: One any-dimensional tensor per component in a barrier element. All
                      values have length num_elements in the 0th dimension.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.BarrierTakeMany*
  exceptions: []
- uid: TensorFlow.TFGraph.Batch(TensorFlow.TFOutput[],System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{System.Int64},System.Int64[],System.String,System.String,System.String,System.String)
  id: Batch(TensorFlow.TFOutput[],System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{System.Int64},System.Int64[],System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Batch(TFOutput[], Int64, Int64, Int64, Int64, Nullable<Int64>, Int64[], String, String, String, String)
  nameWithType: TFGraph.Batch(TFOutput[], Int64, Int64, Int64, Int64, Nullable<Int64>, Int64[], String, String, String, String)
  fullName: TFGraph.Batch(TFOutput[], Int64, Int64, Int64, Int64, Nullable<Int64>, Int64[], String, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Batches all input tensors nondeterministically.
  remarks: "When many instances of this Op are being run concurrently with the same\n              container/shared_name in the same device, some will output zero-shaped Tensors\n              and others will output Tensors of size up to max_batch_size.\n              \n              All Tensors in in_tensors are batched together (so, for example, labels and\n              features should be batched with a single instance of this operation.\n              \n              Each invocation of batch emits an <code>id</code> scalar which will be used to identify\n              this particular invocation when doing unbatch or its gradient.\n              \n              Each op which emits a non-empty batch will also emit a non-empty batch_index\n              Tensor, which, is a [K, 3] matrix where each row contains the invocation's id,\n              start, and length of elements of each set of Tensors present in batched_tensors.\n              \n              Batched tensors are concatenated along the first dimension, and all tensors in\n              in_tensors must have the first dimension of the same size.\n              \n              in_tensors: The tensors to be batched.\n              num_batch_threads: Number of scheduling threads for processing batches of work.\n              Determines the number of batches processed in parallel.\n              max_batch_size: Batch sizes will never be bigger than this.\n              batch_timeout_micros: Maximum number of microseconds to wait before outputting\n              an incomplete batch.\n              allowed_batch_sizes: Optional list of allowed batch sizes. If left empty, does\n              nothing. Otherwise, supplies a list of batch sizes, causing the op to pad\n              batches up to one of those sizes. The entries must increase monotonically, and\n              the final entry must equal max_batch_size.\n              grad_timeout_micros: The timeout to use for the gradient. See Unbatch.\n              batched_tensors: Either empty tensors or a batch of concatenated Tensors.\n              batch_index: If out_tensors is non-empty, has information to invert it.\n              container: Controls the scope of sharing of this batch.\n              id: always contains a scalar with a unique ID for this invocation of Batch.\n              shared_name: Concurrently running instances of batch in the same device with the\n              same container and shared_name will batch their elements together. If left\n              empty, the op name will be used as the shared name.\n              T: the types of tensors to be batched."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput> Batch (TensorFlow.TFOutput[] in_tensors, long num_batch_threads, long max_batch_size, long batch_timeout_micros, long grad_timeout_micros, Nullable<long> max_enqueued_batches = null, long[] allowed_batch_sizes = null, string container = null, string shared_name = null, string batching_queue = null, string operName = null);
    parameters:
    - id: in_tensors
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: num_batch_threads
      type: System.Int64
      description: To be added.
    - id: max_batch_size
      type: System.Int64
      description: To be added.
    - id: batch_timeout_micros
      type: System.Int64
      description: To be added.
    - id: grad_timeout_micros
      type: System.Int64
      description: To be added.
    - id: max_enqueued_batches
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: allowed_batch_sizes
      type: System.Int64[]
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: batching_queue
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Batch'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      batched_tensors:
                      batch_index:
                      id:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.Batch*
  exceptions: []
- uid: TensorFlow.TFGraph.BatchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: BatchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BatchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.BatchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.BatchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that batches <code>batch_size</code> elements from <code>input_dataset</code>.
  syntax:
    content: public TensorFlow.TFOutput BatchDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput batch_size, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: batch_size
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing the number of elements to accumulate in a
                      batch.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BatchDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.BatchDatasetV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: BatchDatasetV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BatchDatasetV2(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.BatchDatasetV2(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.BatchDatasetV2(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that batches <code>batch_size</code> elements from <code>input_dataset</code>.
  syntax:
    content: public TensorFlow.TFOutput BatchDatasetV2 (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput batch_size, TensorFlow.TFOutput drop_remainder, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: batch_size
      type: TensorFlow.TFOutput
      description: A scalar representing the number of elements to accumulate in a batch.
    - id: drop_remainder
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing whether the last batch should be dropped in case its size
                      is smaller than desired.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchDatasetV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BatchDatasetV2*
  exceptions: []
- uid: TensorFlow.TFGraph.BatchMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: BatchMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BatchMatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.BatchMatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.BatchMatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Multiplies slices of two tensors in batches.
  remarks: "Multiplies all slices of <code>Tensor</code><code>x</code> and <code>y</code> (each slice can be\n              viewed as an element of a batch), and arranges the individual results\n              in a single output tensor of the same batch size. Each of the\n              individual slices can optionally be adjointed (to adjoint a matrix\n              means to transpose and conjugate it) before multiplication by setting\n              the <code>adj_x</code> or <code>adj_y</code> flag to <code>True</code>, which are by default <code>False</code>.\n              \n              The input tensors <code>x</code> and <code>y</code> are 2-D or higher with shape <code>[..., r_x, c_x]</code>\n              and <code>[..., r_y, c_y]</code>.\n              \n              The output tensor is 2-D or higher with shape <code>[..., r_o, c_o]</code>, where:\n              \n              r_o = c_x if adj_x else r_x\n              c_o = r_y if adj_y else c_y\n              \n              It is computed as:\n              \n              output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])"
  syntax:
    content: public TensorFlow.TFOutput BatchMatMul (TensorFlow.TFOutput x, TensorFlow.TFOutput y, Nullable<bool> adj_x = null, Nullable<bool> adj_y = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: 2-D or higher with shape <code>[..., r_x, c_x]</code>.
    - id: y
      type: TensorFlow.TFOutput
      description: 2-D or higher with shape <code>[..., r_y, c_y]</code>.
    - id: adj_x
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, adjoint the slices of <code>x</code>. Defaults to <code>False</code>.
    - id: adj_y
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, adjoint the slices of <code>y</code>. Defaults to <code>False</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchMatMul'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        3-D or higher with shape <code>[..., r_o, c_o]</code>
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BatchMatMul*
  exceptions: []
- uid: TensorFlow.TFGraph.BatchNormWithGlobalNormalization(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Boolean,System.String)
  id: BatchNormWithGlobalNormalization(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)
  nameWithType: TFGraph.BatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)
  fullName: TFGraph.BatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Batch normalization.
  remarks: This op is deprecated. Prefer <code>tf.nn.batch_normalization</code>.
  syntax:
    content: public TensorFlow.TFOutput BatchNormWithGlobalNormalization (TensorFlow.TFOutput t, TensorFlow.TFOutput m, TensorFlow.TFOutput v, TensorFlow.TFOutput beta, TensorFlow.TFOutput gamma, float variance_epsilon, bool scale_after_normalization, string operName = null);
    parameters:
    - id: t
      type: TensorFlow.TFOutput
      description: A 4D input Tensor.
    - id: m
      type: TensorFlow.TFOutput
      description: >-
        A 1D mean Tensor with size matching the last dimension of t.
                      This is the first output from tf.nn.moments,
                      or a saved moving average thereof.
    - id: v
      type: TensorFlow.TFOutput
      description: >-
        A 1D variance Tensor with size matching the last dimension of t.
                      This is the second output from tf.nn.moments,
                      or a saved moving average thereof.
    - id: beta
      type: TensorFlow.TFOutput
      description: >-
        A 1D beta Tensor with size matching the last dimension of t.
                      An offset to be added to the normalized tensor.
    - id: gamma
      type: TensorFlow.TFOutput
      description: >-
        A 1D gamma Tensor with size matching the last dimension of t.
                      If "scale_after_normalization" is true, this tensor will be multiplied
                      with the normalized tensor.
    - id: variance_epsilon
      type: System.Single
      description: A small float number to avoid dividing by 0.
    - id: scale_after_normalization
      type: System.Boolean
      description: >-
        A bool indicating whether the resulted tensor
                      needs to be multiplied with gamma.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchNormWithGlobalNormalization'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BatchNormWithGlobalNormalization*
  exceptions: []
- uid: TensorFlow.TFGraph.BatchNormWithGlobalNormalizationGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Boolean,System.String)
  id: BatchNormWithGlobalNormalizationGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BatchNormWithGlobalNormalizationGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)
  nameWithType: TFGraph.BatchNormWithGlobalNormalizationGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)
  fullName: TFGraph.BatchNormWithGlobalNormalizationGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gradients for batch normalization.
  remarks: This op is deprecated. See <code>tf.nn.batch_normalization</code>.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> BatchNormWithGlobalNormalizationGrad (TensorFlow.TFOutput t, TensorFlow.TFOutput m, TensorFlow.TFOutput v, TensorFlow.TFOutput gamma, TensorFlow.TFOutput backprop, float variance_epsilon, bool scale_after_normalization, string operName = null);
    parameters:
    - id: t
      type: TensorFlow.TFOutput
      description: A 4D input Tensor.
    - id: m
      type: TensorFlow.TFOutput
      description: >-
        A 1D mean Tensor with size matching the last dimension of t.
                      This is the first output from tf.nn.moments,
                      or a saved moving average thereof.
    - id: v
      type: TensorFlow.TFOutput
      description: >-
        A 1D variance Tensor with size matching the last dimension of t.
                      This is the second output from tf.nn.moments,
                      or a saved moving average thereof.
    - id: gamma
      type: TensorFlow.TFOutput
      description: >-
        A 1D gamma Tensor with size matching the last dimension of t.
                      If "scale_after_normalization" is true, this Tensor will be multiplied
                      with the normalized Tensor.
    - id: backprop
      type: TensorFlow.TFOutput
      description: 4D backprop Tensor.
    - id: variance_epsilon
      type: System.Single
      description: A small float number to avoid dividing by 0.
    - id: scale_after_normalization
      type: System.Boolean
      description: >-
        A bool indicating whether the resulted tensor
                      needs to be multiplied with gamma.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchNormWithGlobalNormalizationGrad'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      dx: 4D backprop tensor for input.
                      dm: 1D backprop tensor for mean.
                      dv: 1D backprop tensor for variance.
                      db: 1D backprop tensor for beta.
                      dg: 1D backprop tensor for gamma.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.BatchNormWithGlobalNormalizationGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.BatchToSpace(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  id: BatchToSpace(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BatchToSpace(TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.BatchToSpace(TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.BatchToSpace(TFOutput, TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: BatchToSpace for 4-D tensors of type T.
  remarks: "This is a legacy version of the more general BatchToSpaceND.\n              \n              Rearranges (permutes) data from batch into blocks of spatial data, followed by\n              cropping. This is the reverse transformation of SpaceToBatch. More specifically,\n              this op outputs a copy of the input tensor where values from the <code>batch</code>\n              dimension are moved in spatial blocks to the <code>height</code> and <code>width</code> dimensions,\n              followed by cropping along the <code>height</code> and <code>width</code> dimensions."
  syntax:
    content: public TensorFlow.TFOutput BatchToSpace (TensorFlow.TFOutput input, TensorFlow.TFOutput crops, long block_size, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: >-
        4-D tensor with shape
                      <code>[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
                      depth]</code>. Note that the batch size of the input tensor must be divisible by
                      <code>block_size * block_size</code>.
    - id: crops
      type: TensorFlow.TFOutput
      description: "2-D tensor of non-negative integers with shape <code>[2, 2]</code>. It specifies\n              how many elements to crop from the intermediate result across the spatial\n              dimensions as follows:\n              \n              crops = [[crop_top, crop_bottom], [crop_left, crop_right]]"
    - id: block_size
      type: System.Int64
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchToSpace'.
    return:
      type: TensorFlow.TFOutput
      description: "4-D with shape <code>[batch, height, width, depth]</code>, where:\n              \n              height = height_pad - crop_top - crop_bottom\n              width = width_pad - crop_left - crop_right\n              \n              The attr <code>block_size</code> must be greater than one. It indicates the block size.\n              \n              Some examples:\n              \n              (1) For the following input of shape <code>[4, 1, 1, 1]</code> and block_size of 2:\n              \n               <pre><code>\n              [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[1, 2, 2, 1]</code> and value:\n              \n               <pre><code>\n              x = [[[[1], [2]], [[3], [4]]]]\n               </code></pre>\n              \n              (2) For the following input of shape <code>[4, 1, 1, 3]</code> and block_size of 2:\n              \n               <pre><code>\n              [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[1, 2, 2, 3]</code> and value:\n              \n               <pre><code>\n              x = [[[[1, 2, 3], [4, 5, 6]],\n              [[7, 8, 9], [10, 11, 12]]]]\n               </code></pre>\n              \n              (3) For the following input of shape <code>[4, 2, 2, 1]</code> and block_size of 2:\n              \n               <pre><code>\n              x = [[[[1], [3]], [[9], [11]]],\n              [[[2], [4]], [[10], [12]]],\n              [[[5], [7]], [[13], [15]]],\n              [[[6], [8]], [[14], [16]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[1, 4, 4, 1]</code> and value:\n              \n               <pre><code>\n              x = [[[1],   [2],  [3],  [4]],\n              [[5],   [6],  [7],  [8]],\n              [[9],  [10], [11],  [12]],\n              [[13], [14], [15],  [16]]]\n               </code></pre>\n              \n              (4) For the following input of shape <code>[8, 1, 2, 1]</code> and block_size of 2:\n              \n               <pre><code>\n              x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],\n              [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[2, 2, 4, 1]</code> and value:\n              \n               <pre><code>\n              x = [[[[1], [3]], [[5], [7]]],\n              [[[2], [4]], [[10], [12]]],\n              [[[5], [7]], [[13], [15]]],\n              [[[6], [8]], [[14], [16]]]]\n               </code></pre>\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.BatchToSpace*
  exceptions: []
- uid: TensorFlow.TFGraph.BatchToSpaceND(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: BatchToSpaceND(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BatchToSpaceND(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.BatchToSpaceND(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.BatchToSpaceND(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: BatchToSpace for N-D tensors of type T.
  remarks: >-
    This operation reshapes the "batch" dimension 0 into <code>M + 1</code> dimensions of shape
                  <code>block_shape + [batch]</code>, interleaves these blocks back into the grid defined by
                  the spatial dimensions <code>[1, ..., M]</code>, to obtain a result with the same rank as
                  the input.  The spatial dimensions of this intermediate result are then
                  optionally cropped according to <code>crops</code> to produce the output.  This is the
                  reverse of SpaceToBatch.  See below for a precise description.
  syntax:
    content: public TensorFlow.TFOutput BatchToSpaceND (TensorFlow.TFOutput input, TensorFlow.TFOutput block_shape, TensorFlow.TFOutput crops, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: >-
        N-D with shape <code>input_shape = [batch] + spatial_shape + remaining_shape</code>,
                      where spatial_shape has M dimensions.
    - id: block_shape
      type: TensorFlow.TFOutput
      description: 1-D with shape <code>[M]</code>, all values must be &gt;= 1.
    - id: crops
      type: TensorFlow.TFOutput
      description: "2-D with shape <code>[M, 2]</code>, all values must be &gt;= 0.\n              <code>crops[i] = [crop_start, crop_end]</code> specifies the amount to crop from input\n              dimension <code>i + 1</code>, which corresponds to spatial dimension <code>i</code>.  It is\n              required that\n              <code>crop_start[i] + crop_end[i] &lt;= block_shape[i] * input_shape[i + 1]</code>.\n              \n              This operation is equivalent to the following steps:\n              \n              1. Reshape <code>input</code> to <code>reshaped</code> of shape:\n              [block_shape[0], ..., block_shape[M-1],\n              batch / prod(block_shape),\n              input_shape[1], ..., input_shape[N-1]]\n              \n              2. Permute dimensions of <code>reshaped</code> to produce <code>permuted</code> of shape\n              [batch / prod(block_shape),\n              \n              input_shape[1], block_shape[0],\n              ...,\n              input_shape[M], block_shape[M-1],\n              \n              input_shape[M+1], ..., input_shape[N-1]]\n              \n              3. Reshape <code>permuted</code> to produce <code>reshaped_permuted</code> of shape\n              [batch / prod(block_shape),\n              \n              input_shape[1] * block_shape[0],\n              ...,\n              input_shape[M] * block_shape[M-1],\n              \n              input_shape[M+1],\n              ...,\n              input_shape[N-1]]\n              \n              4. Crop the start and end of dimensions <code>[1, ..., M]</code> of\n              <code>reshaped_permuted</code> according to <code>crops</code> to produce the output of shape:\n              [batch / prod(block_shape),\n              \n              input_shape[1] * block_shape[0] - crops[0,0] - crops[0,1],\n              ...,\n              input_shape[M] * block_shape[M-1] - crops[M-1,0] - crops[M-1,1],\n              \n              input_shape[M+1], ..., input_shape[N-1]]\n              \n              Some examples:\n              \n              (1) For the following input of shape <code>[4, 1, 1, 1]</code>, <code>block_shape = [2, 2]</code>, and\n              <code>crops = [[0, 0], [0, 0]]</code>:\n              \n               <pre><code>\n              [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[1, 2, 2, 1]</code> and value:\n              \n               <pre><code>\n              x = [[[[1], [2]], [[3], [4]]]]\n               </code></pre>\n              \n              (2) For the following input of shape <code>[4, 1, 1, 3]</code>, <code>block_shape = [2, 2]</code>, and\n              <code>crops = [[0, 0], [0, 0]]</code>:\n              \n               <pre><code>\n              [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[1, 2, 2, 3]</code> and value:\n              \n               <pre><code>\n              x = [[[[1, 2, 3], [4, 5, 6]],\n              [[7, 8, 9], [10, 11, 12]]]]\n               </code></pre>\n              \n              (3) For the following input of shape <code>[4, 2, 2, 1]</code>, <code>block_shape = [2, 2]</code>, and\n              <code>crops = [[0, 0], [0, 0]]</code>:\n              \n               <pre><code>\n              x = [[[[1], [3]], [[9], [11]]],\n              [[[2], [4]], [[10], [12]]],\n              [[[5], [7]], [[13], [15]]],\n              [[[6], [8]], [[14], [16]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[1, 4, 4, 1]</code> and value:\n              \n               <pre><code>\n              x = [[[1],   [2],  [3],  [4]],\n              [[5],   [6],  [7],  [8]],\n              [[9],  [10], [11],  [12]],\n              [[13], [14], [15],  [16]]]\n               </code></pre>\n              \n              (4) For the following input of shape <code>[8, 1, 3, 1]</code>, <code>block_shape = [2, 2]</code>, and\n              <code>crops = [[0, 0], [2, 0]]</code>:\n              \n               <pre><code>\n              x = [[[[0], [1], [3]]], [[[0], [9], [11]]],\n              [[[0], [2], [4]]], [[[0], [10], [12]]],\n              [[[0], [5], [7]]], [[[0], [13], [15]]],\n              [[[0], [6], [8]]], [[[0], [14], [16]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[2, 2, 4, 1]</code> and value:\n              \n               <pre><code>\n              x = [[[[1],   [2],  [3],  [4]],\n              [[5],   [6],  [7],  [8]]],\n              [[[9],  [10], [11],  [12]],\n              [[13], [14], [15],  [16]]]]\n               </code></pre>"
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BatchToSpaceND'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BatchToSpaceND*
  exceptions: []
- uid: TensorFlow.TFGraph.BesselI0e(TensorFlow.TFOutput,System.String)
  id: BesselI0e(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BesselI0e(TFOutput, String)
  nameWithType: TFGraph.BesselI0e(TFOutput, String)
  fullName: TFGraph.BesselI0e(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the Bessel i0e function of <code>x</code> element-wise.
  remarks: "Exponentially scaled modified Bessel function of order 0 defined as\n              <code>bessel_i0e(x) = exp(-abs(x)) bessel_i0(x)</code>.\n              \n              This function is faster and numerically stabler than <code>bessel_i0(x)</code>."
  syntax:
    content: public TensorFlow.TFOutput BesselI0e (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BesselI0e'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BesselI0e*
  exceptions: []
- uid: TensorFlow.TFGraph.BesselI1e(TensorFlow.TFOutput,System.String)
  id: BesselI1e(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BesselI1e(TFOutput, String)
  nameWithType: TFGraph.BesselI1e(TFOutput, String)
  fullName: TFGraph.BesselI1e(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the Bessel i1e function of <code>x</code> element-wise.
  remarks: "Exponentially scaled modified Bessel function of order 0 defined as\n              <code>bessel_i1e(x) = exp(-abs(x)) bessel_i1(x)</code>.\n              \n              This function is faster and numerically stabler than <code>bessel_i1(x)</code>."
  syntax:
    content: public TensorFlow.TFOutput BesselI1e (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BesselI1e'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BesselI1e*
  exceptions: []
- uid: TensorFlow.TFGraph.Betainc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Betainc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Betainc(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.Betainc(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.Betainc(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Compute the regularized incomplete beta integral \\(I_x(a, b)\\).
  remarks: "The regularized incomplete beta integral is defined as:\n              \n              \n              \\\\(I_x(a, b) = \\frac{B(x; a, b)}{B(a, b)}\\\\)\n              \n              where\n              \n              \n              \\\\(B(x; a, b) = \\int_0^x t^{a-1} (1 - t)^{b-1} dt\\\\)\n              \n              \n              is the incomplete beta function and \\\\(B(a, b)\\\\) is the *complete*\n              beta function."
  syntax:
    content: public TensorFlow.TFOutput Betainc (TensorFlow.TFOutput a, TensorFlow.TFOutput b, TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: a
      type: TensorFlow.TFOutput
      description: To be added.
    - id: b
      type: TensorFlow.TFOutput
      description: To be added.
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Betainc'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Betainc*
  exceptions: []
- uid: TensorFlow.TFGraph.BiasAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  id: BiasAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BiasAdd(TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.BiasAdd(TFOutput, TFOutput, String, String)
  fullName: TFGraph.BiasAdd(TFOutput, TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Adds <code>bias</code> to <code>value</code>.
  remarks: >-
    This is a special case of <code>tf.add</code> where <code>bias</code> is restricted to be 1-D.
                  Broadcasting is supported, so <code>value</code> may have any number of dimensions.
  syntax:
    content: public TensorFlow.TFOutput BiasAdd (TensorFlow.TFOutput value, TensorFlow.TFOutput bias, string data_format = null, string operName = null);
    parameters:
    - id: value
      type: TensorFlow.TFOutput
      description: Any number of dimensions.
    - id: bias
      type: TensorFlow.TFOutput
      description: 1-D with size the last dimension of <code>value</code>.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the bias tensor will be added to the last dimension
                      of the value tensor.
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, in_channels, in_height, in_width].
                      The tensor will be added to "in_channels", the third-to-the-last
                      dimension.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BiasAdd'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Broadcasted sum of <code>value</code> and <code>bias</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BiasAdd*
  exceptions: []
- uid: TensorFlow.TFGraph.BiasAddGrad(TensorFlow.TFOutput,System.String,System.String)
  id: BiasAddGrad(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BiasAddGrad(TFOutput, String, String)
  nameWithType: TFGraph.BiasAddGrad(TFOutput, String, String)
  fullName: TFGraph.BiasAddGrad(TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: The backward operation for "BiasAdd" on the "bias" tensor.
  remarks: >-
    It accumulates all the values from out_backprop into the feature dimension.
                  For NHWC data format, the feature dimension is the last. For NCHW data format,
                  the feature dimension is the third-to-last.
  syntax:
    content: public TensorFlow.TFOutput BiasAddGrad (TensorFlow.TFOutput out_backprop, string data_format = null, string operName = null);
    parameters:
    - id: out_backprop
      type: TensorFlow.TFOutput
      description: Any number of dimensions.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the bias tensor will be added to the last dimension
                      of the value tensor.
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, in_channels, in_height, in_width].
                      The tensor will be added to "in_channels", the third-to-the-last
                      dimension.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BiasAddGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        1-D with size the feature dimension of <code>out_backprop</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BiasAddGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.BiasAddV1(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: BiasAddV1(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BiasAddV1(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BiasAddV1(TFOutput, TFOutput, String)
  fullName: TFGraph.BiasAddV1(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Adds <code>bias</code> to <code>value</code>.
  remarks: "This is a deprecated version of BiasAdd and will be soon removed.\n              \n              This is a special case of <code>tf.add</code> where <code>bias</code> is restricted to be 1-D.\n              Broadcasting is supported, so <code>value</code> may have any number of dimensions."
  syntax:
    content: public TensorFlow.TFOutput BiasAddV1 (TensorFlow.TFOutput value, TensorFlow.TFOutput bias, string operName = null);
    parameters:
    - id: value
      type: TensorFlow.TFOutput
      description: Any number of dimensions.
    - id: bias
      type: TensorFlow.TFOutput
      description: 1-D with size the last dimension of <code>value</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BiasAddV1'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Broadcasted sum of <code>value</code> and <code>bias</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BiasAddV1*
  exceptions: []
- uid: TensorFlow.TFGraph.BigQueryReader(System.String,System.String,System.String,System.String[],System.Int64,System.String,System.String,System.String,System.String)
  id: BigQueryReader(System.String,System.String,System.String,System.String[],System.Int64,System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BigQueryReader(String, String, String, String[], Int64, String, String, String, String)
  nameWithType: TFGraph.BigQueryReader(String, String, String, String[], Int64, String, String, String, String)
  fullName: TFGraph.BigQueryReader(String, String, String, String[], Int64, String, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A Reader that outputs rows from a BigQuery table as tensorflow Examples.
  syntax:
    content: public TensorFlow.TFOutput BigQueryReader (string project_id, string dataset_id, string table_id, string[] columns, long timestamp_millis, string container = null, string shared_name = null, string test_end_point = null, string operName = null);
    parameters:
    - id: project_id
      type: System.String
      description: GCP project ID.
    - id: dataset_id
      type: System.String
      description: BigQuery Dataset ID.
    - id: table_id
      type: System.String
      description: Table to read.
    - id: columns
      type: System.String[]
      description: List of columns to read. Leave empty to read all columns.
    - id: timestamp_millis
      type: System.Int64
      description: >-
        Table snapshot timestamp in millis since epoch. Relative
                      (negative or zero) snapshot times are not allowed. For more details, see
                      'Table Decorators' in BigQuery docs.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: test_end_point
      type: System.String
      description: >-
        Optional argument
                      Do not use. For testing purposes only.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BigQueryReader'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to reference the Reader.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BigQueryReader*
  exceptions: []
- uid: TensorFlow.TFGraph.Bincount(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Bincount(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Bincount(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.Bincount(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.Bincount(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Counts the number of occurrences of each value in an integer array.
  remarks: "Outputs a vector with length <code>size</code> and the same dtype as <code>weights</code>. If\n              <code>weights</code> are empty, then index <code>i</code> stores the number of times the value <code>i</code> is\n              counted in <code>arr</code>. If <code>weights</code> are non-empty, then index <code>i</code> stores the sum of\n              the value in <code>weights</code> at each index where the corresponding value in <code>arr</code> is\n              <code>i</code>.\n              \n              Values in <code>arr</code> outside of the range [0, size) are ignored."
  syntax:
    content: public TensorFlow.TFOutput Bincount (TensorFlow.TFOutput arr, TensorFlow.TFOutput size, TensorFlow.TFOutput weights, string operName = null);
    parameters:
    - id: arr
      type: TensorFlow.TFOutput
      description: int32 <code>Tensor</code>.
    - id: size
      type: TensorFlow.TFOutput
      description: non-negative int32 scalar <code>Tensor</code>.
    - id: weights
      type: TensorFlow.TFOutput
      description: >-
        is an int32, int64, float32, or float64 <code>Tensor</code> with the same
                      shape as <code>arr</code>, or a length-0 <code>Tensor</code>, in which case it acts as all weights
                      equal to 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Bincount'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        1D <code>Tensor</code> with length equal to <code>size</code>. The counts or summed weights for
                      each value in the range [0, size).
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Bincount*
  exceptions: []
- uid: TensorFlow.TFGraph.Bitcast(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: Bitcast(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Bitcast(TFOutput, TFDataType, String)
  nameWithType: TFGraph.Bitcast(TFOutput, TFDataType, String)
  fullName: TFGraph.Bitcast(TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Bitcasts a tensor from one type to another without copying data.
  remarks: "Given a tensor <code>input</code>, this operation returns a tensor that has the same buffer\n              data as <code>input</code> with datatype <code>type</code>.\n              \n              If the input datatype <code>T</code> is larger than the output datatype <code>type</code> then the\n              shape changes from [...] to [..., sizeof(<code>T</code>)/sizeof(<code>type</code>)].\n              \n              If <code>T</code> is smaller than <code>type</code>, the operator requires that the rightmost\n              dimension be equal to sizeof(<code>type</code>)/sizeof(<code>T</code>). The shape then goes from\n              [..., sizeof(<code>type</code>)/sizeof(<code>T</code>)] to [...].\n              \n              *NOTE*: Bitcast is implemented as a low-level cast, so machines with different\n              endian orderings will give different results."
  syntax:
    content: public TensorFlow.TFOutput Bitcast (TensorFlow.TFOutput input, TensorFlow.TFDataType type, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: type
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Bitcast'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Bitcast*
  exceptions: []
- uid: TensorFlow.TFGraph.BitwiseAnd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: BitwiseAnd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BitwiseAnd(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BitwiseAnd(TFOutput, TFOutput, String)
  fullName: TFGraph.BitwiseAnd(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Elementwise computes the bitwise AND of <code>x</code> and <code>y</code>.
  remarks: >-
    The result will have those bits set, that are set in both <code>x</code> and <code>y</code>. The
                  computation is performed on the underlying representations of <code>x</code> and <code>y</code>.
  syntax:
    content: public TensorFlow.TFOutput BitwiseAnd (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BitwiseAnd'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BitwiseAnd*
  exceptions: []
- uid: TensorFlow.TFGraph.BitwiseOr(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: BitwiseOr(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BitwiseOr(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BitwiseOr(TFOutput, TFOutput, String)
  fullName: TFGraph.BitwiseOr(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Elementwise computes the bitwise OR of <code>x</code> and <code>y</code>.
  remarks: >-
    The result will have those bits set, that are set in <code>x</code>, <code>y</code> or both. The
                  computation is performed on the underlying representations of <code>x</code> and <code>y</code>.
  syntax:
    content: public TensorFlow.TFOutput BitwiseOr (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BitwiseOr'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BitwiseOr*
  exceptions: []
- uid: TensorFlow.TFGraph.BitwiseXor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: BitwiseXor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BitwiseXor(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BitwiseXor(TFOutput, TFOutput, String)
  fullName: TFGraph.BitwiseXor(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Elementwise computes the bitwise XOR of <code>x</code> and <code>y</code>.
  remarks: >-
    The result will have those bits set, that are different in <code>x</code> and <code>y</code>. The
                  computation is performed on the underlying representations of <code>x</code> and <code>y</code>.
  syntax:
    content: public TensorFlow.TFOutput BitwiseXor (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BitwiseXor'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BitwiseXor*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesBucketize(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  id: BoostedTreesBucketize(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesBucketize(TFOutput[], TFOutput[], String)
  nameWithType: TFGraph.BoostedTreesBucketize(TFOutput[], TFOutput[], String)
  fullName: TFGraph.BoostedTreesBucketize(TFOutput[], TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Bucketize each feature based on bucket boundaries.
  remarks: >-
    An op that returns a list of float tensors, where each tensor represents the
                  bucketized values for a single feature.
  syntax:
    content: public TensorFlow.TFOutput[] BoostedTreesBucketize (TensorFlow.TFOutput[] float_values, TensorFlow.TFOutput[] bucket_boundaries, string operName = null);
    parameters:
    - id: float_values
      type: TensorFlow.TFOutput[]
      description: float; List of Rank 1 Tensor each containing float values for a single feature.
    - id: bucket_boundaries
      type: TensorFlow.TFOutput[]
      description: >-
        float; List of Rank 1 Tensors each containing the bucket boundaries for a single
                      feature.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesBucketize'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        int; List of Rank 1 Tensors each containing the bucketized values for a single feature.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BoostedTreesBucketize*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesCalculateBestGainsPerFeature(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  id: BoostedTreesCalculateBestGainsPerFeature(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesCalculateBestGainsPerFeature(TFOutput, TFOutput[], TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.BoostedTreesCalculateBestGainsPerFeature(TFOutput, TFOutput[], TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.BoostedTreesCalculateBestGainsPerFeature(TFOutput, TFOutput[], TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Calculates gains for each feature and returns the best possible split information for the feature.
  remarks: "The split information is the best threshold (bucket id), gains and left/right node contributions per node for each feature.\n              \n              It is possible that not all nodes can be split on each feature. Hence, the list of possible nodes can differ between the features. Therefore, we return <code>node_ids_list</code> for each feature, containing the list of nodes that this feature can be used to split.\n              \n              In this manner, the output is the best split per features and per node, so that it needs to be combined later to produce the best split for each node (among all possible features).\n              \n              The length of output lists are all of the same length, <code>num_features</code>.\n              The output shapes are compatible in a way that the first dimension of all tensors of all lists are the same and equal to the number of possible split nodes for each feature."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]> BoostedTreesCalculateBestGainsPerFeature (TensorFlow.TFOutput node_id_range, TensorFlow.TFOutput[] stats_summary_list, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput tree_complexity, TensorFlow.TFOutput min_node_weight, long max_splits, string operName = null);
    parameters:
    - id: node_id_range
      type: TensorFlow.TFOutput
      description: A Rank 1 tensor (shape=[2]) to specify the range [first, last) of node ids to process within <code>stats_summary_list</code>. The nodes are iterated between the two nodes specified by the tensor, as like <code>for node_id in range(node_id_range[0], node_id_range[1])</code> (Note that the last index node_id_range[1] is exclusive).
    - id: stats_summary_list
      type: TensorFlow.TFOutput[]
      description: A list of Rank 3 tensor (#shape=[max_splits, bucket, 2]) for accumulated stats summary (gradient/hessian) per node per buckets for each feature. The first dimension of the tensor is the maximum number of splits, and thus not all elements of it will be used, but only the indexes specified by node_ids will be used.
    - id: l1
      type: TensorFlow.TFOutput
      description: l1 regularization factor on leaf weights, per instance based.
    - id: l2
      type: TensorFlow.TFOutput
      description: l2 regularization factor on leaf weights, per instance based.
    - id: tree_complexity
      type: TensorFlow.TFOutput
      description: adjustment to the gain, per leaf based.
    - id: min_node_weight
      type: TensorFlow.TFOutput
      description: mininum avg of hessians in a node before required for the node to be considered for splitting.
    - id: max_splits
      type: System.Int64
      description: the number of nodes that can be split in the whole tree. Used as a dimension of output tensors.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesCalculateBestGainsPerFeature'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]}
      description: >-
        Returns a tuple with multiple values, as follows:
                      node_ids_list: An output list of Rank 1 tensors indicating possible split node ids for each feature. The length of the list is num_features, but each tensor has different size as each feature provides different possible nodes. See above for details like shapes and sizes.
                      gains_list: An output list of Rank 1 tensors indicating the best gains for each feature to split for certain nodes. See above for details like shapes and sizes.
                      thresholds_list: An output list of Rank 1 tensors indicating the bucket id to compare with (as a threshold) for split in each node. See above for details like shapes and sizes.
                      left_node_contribs_list: A list of Rank 2 tensors indicating the contribution of the left nodes when branching from parent nodes (given by the tensor element in the output node_ids_list) to the left direction by the given threshold for each feature. This value will be used to make the left node value by adding to the parent node value. Second dimension size is 1 for 1-dimensional logits, but would be larger for multi-class problems. See above for details like shapes and sizes.
                      right_node_contribs_list: A list of Rank 2 tensors, with the same shape/conditions as left_node_contribs_list, but just that the value is for the right node.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.BoostedTreesCalculateBestGainsPerFeature*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesCenterBias(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: BoostedTreesCenterBias(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesCenterBias(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.BoostedTreesCenterBias(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.BoostedTreesCenterBias(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Calculates the prior from the training data (the bias) and fills in the first node with the logits' prior. Returns a boolean indicating whether to continue centering.
  syntax:
    content: public TensorFlow.TFOutput BoostedTreesCenterBias (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput mean_gradients, TensorFlow.TFOutput mean_hessians, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, string operName = null);
    parameters:
    - id: tree_ensemble_handle
      type: TensorFlow.TFOutput
      description: Handle to the tree ensemble.
    - id: mean_gradients
      type: TensorFlow.TFOutput
      description: A tensor with shape=[logits_dimension] with mean of gradients for a first node.
    - id: mean_hessians
      type: TensorFlow.TFOutput
      description: A tensor with shape=[logits_dimension] mean of hessians for a first node.
    - id: l1
      type: TensorFlow.TFOutput
      description: l1 regularization factor on leaf weights, per instance based.
    - id: l2
      type: TensorFlow.TFOutput
      description: l2 regularization factor on leaf weights, per instance based.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesCenterBias'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Bool, whether to continue bias centering.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BoostedTreesCenterBias*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesCreateEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: BoostedTreesCreateEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesCreateEnsemble(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.BoostedTreesCreateEnsemble(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.BoostedTreesCreateEnsemble(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a tree ensemble model and returns a handle to it.
  syntax:
    content: public TensorFlow.TFOperation BoostedTreesCreateEnsemble (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput stamp_token, TensorFlow.TFOutput tree_ensemble_serialized, string operName = null);
    parameters:
    - id: tree_ensemble_handle
      type: TensorFlow.TFOutput
      description: Handle to the tree ensemble resource to be created.
    - id: stamp_token
      type: TensorFlow.TFOutput
      description: Token to use as the initial value of the resource stamp.
    - id: tree_ensemble_serialized
      type: TensorFlow.TFOutput
      description: Serialized proto of the tree ensemble.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesCreateEnsemble'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.BoostedTreesCreateEnsemble*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesCreateQuantileStreamResource(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  id: BoostedTreesCreateQuantileStreamResource(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesCreateQuantileStreamResource(TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.BoostedTreesCreateQuantileStreamResource(TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.BoostedTreesCreateQuantileStreamResource(TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Create the Resource for Quantile Streams.
  syntax:
    content: public TensorFlow.TFOperation BoostedTreesCreateQuantileStreamResource (TensorFlow.TFOutput quantile_stream_resource_handle, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput num_streams, Nullable<long> max_elements = null, string operName = null);
    parameters:
    - id: quantile_stream_resource_handle
      type: TensorFlow.TFOutput
      description: resource; Handle to quantile stream resource.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: float; The required approximation error of the stream resource.
    - id: num_streams
      type: TensorFlow.TFOutput
      description: int; The number of streams managed by the resource that shares the same epsilon.
    - id: max_elements
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      int; The maximum number of data points that can be fed to the stream.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesCreateQuantileStreamResource'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.BoostedTreesCreateQuantileStreamResource*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesDeserializeEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: BoostedTreesDeserializeEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesDeserializeEnsemble(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.BoostedTreesDeserializeEnsemble(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.BoostedTreesDeserializeEnsemble(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deserializes a serialized tree ensemble config and replaces current tree
  remarks: ensemble.
  syntax:
    content: public TensorFlow.TFOperation BoostedTreesDeserializeEnsemble (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput stamp_token, TensorFlow.TFOutput tree_ensemble_serialized, string operName = null);
    parameters:
    - id: tree_ensemble_handle
      type: TensorFlow.TFOutput
      description: Handle to the tree ensemble.
    - id: stamp_token
      type: TensorFlow.TFOutput
      description: Token to use as the new value of the resource stamp.
    - id: tree_ensemble_serialized
      type: TensorFlow.TFOutput
      description: Serialized proto of the ensemble.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesDeserializeEnsemble'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.BoostedTreesDeserializeEnsemble*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesEnsembleResourceHandleOp(System.String,System.String,System.String)
  id: BoostedTreesEnsembleResourceHandleOp(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesEnsembleResourceHandleOp(String, String, String)
  nameWithType: TFGraph.BoostedTreesEnsembleResourceHandleOp(String, String, String)
  fullName: TFGraph.BoostedTreesEnsembleResourceHandleOp(String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a handle to a BoostedTreesEnsembleResource
  syntax:
    content: public TensorFlow.TFOutput BoostedTreesEnsembleResourceHandleOp (string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesEnsembleResourceHandleOp'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BoostedTreesEnsembleResourceHandleOp*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesExampleDebugOutputs(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)
  id: BoostedTreesExampleDebugOutputs(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesExampleDebugOutputs(TFOutput, TFOutput[], Int64, String)
  nameWithType: TFGraph.BoostedTreesExampleDebugOutputs(TFOutput, TFOutput[], Int64, String)
  fullName: TFGraph.BoostedTreesExampleDebugOutputs(TFOutput, TFOutput[], Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Debugging/model interpretability outputs for each example.
  remarks: >-
    It traverses all the trees and computes debug metrics for individual examples,
                  such as getting split feature ids and logits after each split along the decision
                  path used to compute directional feature contributions.
  syntax:
    content: public TensorFlow.TFOutput BoostedTreesExampleDebugOutputs (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput[] bucketized_features, long logits_dimension, string operName = null);
    parameters:
    - id: tree_ensemble_handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: bucketized_features
      type: TensorFlow.TFOutput[]
      description: >-
        A list of rank 1 Tensors containing bucket id for each
                      feature.
    - id: logits_dimension
      type: System.Int64
      description: >-
        scalar, dimension of the logits, to be used for constructing the protos in
                      examples_debug_outputs_serialized.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesExampleDebugOutputs'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Output rank 1 Tensor containing a proto serialized as a string for each example.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BoostedTreesExampleDebugOutputs*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesGetEnsembleStates(TensorFlow.TFOutput,System.String)
  id: BoostedTreesGetEnsembleStates(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesGetEnsembleStates(TFOutput, String)
  nameWithType: TFGraph.BoostedTreesGetEnsembleStates(TFOutput, String)
  fullName: TFGraph.BoostedTreesGetEnsembleStates(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieves the tree ensemble resource stamp token, number of trees and growing statistics.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> BoostedTreesGetEnsembleStates (TensorFlow.TFOutput tree_ensemble_handle, string operName = null);
    parameters:
    - id: tree_ensemble_handle
      type: TensorFlow.TFOutput
      description: Handle to the tree ensemble.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesGetEnsembleStates'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      stamp_token: Stamp token of the tree ensemble resource.
                      num_trees: The number of trees in the tree ensemble resource.
                      num_finalized_trees: The number of trees that were finished successfully.
                      num_attempted_layers: The number of layers we attempted to build (but not necessarily succeeded).
                      last_layer_nodes_range: Rank size 2 tensor that contains start and end ids of the nodes in the latest
                      layer.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.BoostedTreesGetEnsembleStates*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesMakeQuantileSummaries(TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: BoostedTreesMakeQuantileSummaries(TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesMakeQuantileSummaries(TFOutput[], TFOutput, TFOutput, String)
  nameWithType: TFGraph.BoostedTreesMakeQuantileSummaries(TFOutput[], TFOutput, TFOutput, String)
  fullName: TFGraph.BoostedTreesMakeQuantileSummaries(TFOutput[], TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Makes the summary of quantiles for the batch.
  remarks: >-
    An op that takes a list of tensors (one tensor per feature) and outputs the
                  quantile summaries for each tensor.
  syntax:
    content: public TensorFlow.TFOutput[] BoostedTreesMakeQuantileSummaries (TensorFlow.TFOutput[] float_values, TensorFlow.TFOutput example_weights, TensorFlow.TFOutput epsilon, string operName = null);
    parameters:
    - id: float_values
      type: TensorFlow.TFOutput[]
      description: float; List of Rank 1 Tensors each containing values for a single feature.
    - id: example_weights
      type: TensorFlow.TFOutput
      description: float; Rank 1 Tensor with weights per instance.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: float; The required maximum approximation error.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesMakeQuantileSummaries'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        float; List of Rank 2 Tensors each containing the quantile summary
                      (value, weight, min_rank, max_rank) of a single feature.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BoostedTreesMakeQuantileSummaries*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesMakeStatsSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.Int64,System.String)
  id: BoostedTreesMakeStatsSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesMakeStatsSummary(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, Int64, String)
  nameWithType: TFGraph.BoostedTreesMakeStatsSummary(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, Int64, String)
  fullName: TFGraph.BoostedTreesMakeStatsSummary(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Makes the summary of accumulated stats for the batch.
  remarks: The summary stats contains gradients and hessians accumulated into the corresponding node and bucket for each example.
  syntax:
    content: public TensorFlow.TFOutput BoostedTreesMakeStatsSummary (TensorFlow.TFOutput node_ids, TensorFlow.TFOutput gradients, TensorFlow.TFOutput hessians, TensorFlow.TFOutput[] bucketized_features_list, long max_splits, long num_buckets, string operName = null);
    parameters:
    - id: node_ids
      type: TensorFlow.TFOutput
      description: int32 Rank 1 Tensor containing node ids, which each example falls into for the requested layer.
    - id: gradients
      type: TensorFlow.TFOutput
      description: float32; Rank 2 Tensor (shape=[#examples, 1]) for gradients.
    - id: hessians
      type: TensorFlow.TFOutput
      description: float32; Rank 2 Tensor (shape=[#examples, 1]) for hessians.
    - id: bucketized_features_list
      type: TensorFlow.TFOutput[]
      description: int32 list of Rank 1 Tensors, each containing the bucketized feature (for each feature column).
    - id: max_splits
      type: System.Int64
      description: int; the maximum number of splits possible in the whole tree.
    - id: num_buckets
      type: System.Int64
      description: int; equals to the maximum possible value of bucketized feature.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesMakeStatsSummary'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        output Rank 4 Tensor (shape=[#features, #splits, #buckets, 2]) containing accumulated stats put into the corresponding node and bucket. The first index of 4th dimension refers to gradients, and the second to hessians.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BoostedTreesMakeStatsSummary*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesPredict(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)
  id: BoostedTreesPredict(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesPredict(TFOutput, TFOutput[], Int64, String)
  nameWithType: TFGraph.BoostedTreesPredict(TFOutput, TFOutput[], Int64, String)
  fullName: TFGraph.BoostedTreesPredict(TFOutput, TFOutput[], Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Runs multiple additive regression ensemble predictors on input instances and
  remarks: >-
    computes the logits. It is designed to be used during prediction.
                  It traverses all the trees and calculates the final score for each instance.
  syntax:
    content: public TensorFlow.TFOutput BoostedTreesPredict (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput[] bucketized_features, long logits_dimension, string operName = null);
    parameters:
    - id: tree_ensemble_handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: bucketized_features
      type: TensorFlow.TFOutput[]
      description: >-
        A list of rank 1 Tensors containing bucket id for each
                      feature.
    - id: logits_dimension
      type: System.Int64
      description: >-
        scalar, dimension of the logits, to be used for partial logits
                      shape.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesPredict'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Output rank 2 Tensor containing logits for each example.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BoostedTreesPredict*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceAddSummaries(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  id: BoostedTreesQuantileStreamResourceAddSummaries(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesQuantileStreamResourceAddSummaries(TFOutput, TFOutput[], String)
  nameWithType: TFGraph.BoostedTreesQuantileStreamResourceAddSummaries(TFOutput, TFOutput[], String)
  fullName: TFGraph.BoostedTreesQuantileStreamResourceAddSummaries(TFOutput, TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Add the quantile summaries to each quantile stream resource.
  remarks: >-
    An op that adds a list of quantile summaries to a quantile stream resource. Each
                  summary Tensor is rank 2, containing summaries (value, weight, min_rank, max_rank)
                  for a single feature.
  syntax:
    content: public TensorFlow.TFOperation BoostedTreesQuantileStreamResourceAddSummaries (TensorFlow.TFOutput quantile_stream_resource_handle, TensorFlow.TFOutput[] summaries, string operName = null);
    parameters:
    - id: quantile_stream_resource_handle
      type: TensorFlow.TFOutput
      description: resource handle referring to a QuantileStreamResource.
    - id: summaries
      type: TensorFlow.TFOutput[]
      description: string; List of Rank 2 Tensor each containing the summaries for a single feature.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesQuantileStreamResourceAddSummaries'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceAddSummaries*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceFlush(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: BoostedTreesQuantileStreamResourceFlush(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesQuantileStreamResourceFlush(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.BoostedTreesQuantileStreamResourceFlush(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.BoostedTreesQuantileStreamResourceFlush(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Flush the summaries for a quantile stream resource.
  remarks: An op that flushes the summaries for a quantile stream resource.
  syntax:
    content: public TensorFlow.TFOperation BoostedTreesQuantileStreamResourceFlush (TensorFlow.TFOutput quantile_stream_resource_handle, TensorFlow.TFOutput num_buckets, Nullable<bool> generate_quantiles = null, string operName = null);
    parameters:
    - id: quantile_stream_resource_handle
      type: TensorFlow.TFOutput
      description: resource handle referring to a QuantileStreamResource.
    - id: num_buckets
      type: TensorFlow.TFOutput
      description: int; approximate number of buckets unless using generate_quantiles.
    - id: generate_quantiles
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      bool; If True, the output will be the num_quantiles for each stream where the ith
                      entry is the ith quantile of the input with an approximation error of epsilon.
                      Duplicate values may be present.
                      If False, the output will be the points in the histogram that we got which roughly
                      translates to 1/epsilon boundaries and without any duplicates.
                      Default to False.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesQuantileStreamResourceFlush'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceFlush*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceGetBucketBoundaries(TensorFlow.TFOutput,System.Int64,System.String)
  id: BoostedTreesQuantileStreamResourceGetBucketBoundaries(TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesQuantileStreamResourceGetBucketBoundaries(TFOutput, Int64, String)
  nameWithType: TFGraph.BoostedTreesQuantileStreamResourceGetBucketBoundaries(TFOutput, Int64, String)
  fullName: TFGraph.BoostedTreesQuantileStreamResourceGetBucketBoundaries(TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generate the bucket boundaries for each feature based on accumulated summaries.
  remarks: >-
    An op that returns a list of float tensors for a quantile stream resource. Each
                  tensor is Rank 1 containing bucket boundaries for a single feature.
  syntax:
    content: public TensorFlow.TFOutput[] BoostedTreesQuantileStreamResourceGetBucketBoundaries (TensorFlow.TFOutput quantile_stream_resource_handle, long num_features, string operName = null);
    parameters:
    - id: quantile_stream_resource_handle
      type: TensorFlow.TFOutput
      description: resource handle referring to a QuantileStreamResource.
    - id: num_features
      type: System.Int64
      description: inferred int; number of features to get bucket boundaries for.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesQuantileStreamResourceGetBucketBoundaries'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        float; List of Rank 1 Tensors each containing the bucket boundaries for a feature.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceGetBucketBoundaries*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceHandleOp(System.String,System.String,System.String)
  id: BoostedTreesQuantileStreamResourceHandleOp(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesQuantileStreamResourceHandleOp(String, String, String)
  nameWithType: TFGraph.BoostedTreesQuantileStreamResourceHandleOp(String, String, String)
  fullName: TFGraph.BoostedTreesQuantileStreamResourceHandleOp(String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a handle to a BoostedTreesQuantileStreamResource.
  syntax:
    content: public TensorFlow.TFOutput BoostedTreesQuantileStreamResourceHandleOp (string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesQuantileStreamResourceHandleOp'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceHandleOp*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesSerializeEnsemble(TensorFlow.TFOutput,System.String)
  id: BoostedTreesSerializeEnsemble(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesSerializeEnsemble(TFOutput, String)
  nameWithType: TFGraph.BoostedTreesSerializeEnsemble(TFOutput, String)
  fullName: TFGraph.BoostedTreesSerializeEnsemble(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Serializes the tree ensemble to a proto.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> BoostedTreesSerializeEnsemble (TensorFlow.TFOutput tree_ensemble_handle, string operName = null);
    parameters:
    - id: tree_ensemble_handle
      type: TensorFlow.TFOutput
      description: Handle to the tree ensemble.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesSerializeEnsemble'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      stamp_token: Stamp token of the tree ensemble resource.
                      tree_ensemble_serialized: Serialized proto of the ensemble.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.BoostedTreesSerializeEnsemble*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesTrainingPredict(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)
  id: BoostedTreesTrainingPredict(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesTrainingPredict(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, String)
  nameWithType: TFGraph.BoostedTreesTrainingPredict(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, String)
  fullName: TFGraph.BoostedTreesTrainingPredict(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Runs multiple additive regression ensemble predictors on input instances and
  remarks: >-
    computes the update to cached logits. It is designed to be used during training.
                  It traverses the trees starting from cached tree id and cached node id and
                  calculates the updates to be pushed to the cache.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> BoostedTreesTrainingPredict (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput cached_tree_ids, TensorFlow.TFOutput cached_node_ids, TensorFlow.TFOutput[] bucketized_features, long logits_dimension, string operName = null);
    parameters:
    - id: tree_ensemble_handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: cached_tree_ids
      type: TensorFlow.TFOutput
      description: >-
        Rank 1 Tensor containing cached tree ids which is the starting
                      tree of prediction.
    - id: cached_node_ids
      type: TensorFlow.TFOutput
      description: >-
        Rank 1 Tensor containing cached node id which is the starting
                      node of prediction.
    - id: bucketized_features
      type: TensorFlow.TFOutput[]
      description: >-
        A list of rank 1 Tensors containing bucket id for each
                      feature.
    - id: logits_dimension
      type: System.Int64
      description: >-
        scalar, dimension of the logits, to be used for partial logits
                      shape.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesTrainingPredict'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      partial_logits: Rank 2 Tensor containing logits update (with respect to cached
                      values stored) for each example.
                      tree_ids: Rank 1 Tensor containing new tree ids for each example.
                      node_ids: Rank 1 Tensor containing new node ids in the new tree_ids.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.BoostedTreesTrainingPredict*
  exceptions: []
- uid: TensorFlow.TFGraph.BoostedTreesUpdateEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  id: BoostedTreesUpdateEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BoostedTreesUpdateEnsemble(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.BoostedTreesUpdateEnsemble(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.BoostedTreesUpdateEnsemble(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Updates the tree ensemble by either adding a layer to the last tree being grown
  remarks: or by starting a new tree.
  syntax:
    content: public TensorFlow.TFOperation BoostedTreesUpdateEnsemble (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput feature_ids, TensorFlow.TFOutput[] node_ids, TensorFlow.TFOutput[] gains, TensorFlow.TFOutput[] thresholds, TensorFlow.TFOutput[] left_node_contribs, TensorFlow.TFOutput[] right_node_contribs, TensorFlow.TFOutput max_depth, TensorFlow.TFOutput learning_rate, long pruning_mode, string operName = null);
    parameters:
    - id: tree_ensemble_handle
      type: TensorFlow.TFOutput
      description: Handle to the ensemble variable.
    - id: feature_ids
      type: TensorFlow.TFOutput
      description: >-
        Rank 1 tensor with ids for each feature. This is the real id of
                      the feature that will be used in the split.
    - id: node_ids
      type: TensorFlow.TFOutput[]
      description: >-
        List of rank 1 tensors representing the nodes for which this feature
                      has a split.
    - id: gains
      type: TensorFlow.TFOutput[]
      description: >-
        List of rank 1 tensors representing the gains for each of the feature's
                      split.
    - id: thresholds
      type: TensorFlow.TFOutput[]
      description: >-
        List of rank 1 tensors representing the thesholds for each of the
                      feature's split.
    - id: left_node_contribs
      type: TensorFlow.TFOutput[]
      description: >-
        List of rank 2 tensors with left leaf contribs for each of
                      the feature's splits. Will be added to the previous node values to constitute
                      the values of the left nodes.
    - id: right_node_contribs
      type: TensorFlow.TFOutput[]
      description: >-
        List of rank 2 tensors with right leaf contribs for each
                      of the feature's splits. Will be added to the previous node values to constitute
                      the values of the right nodes.
    - id: max_depth
      type: TensorFlow.TFOutput
      description: Max depth of the tree to build.
    - id: learning_rate
      type: TensorFlow.TFOutput
      description: shrinkage const for each new tree.
    - id: pruning_mode
      type: System.Int64
      description: 0-No pruning, 1-Pre-pruning, 2-Post-pruning.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BoostedTreesUpdateEnsemble'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.BoostedTreesUpdateEnsemble*
  exceptions: []
- uid: TensorFlow.TFGraph.BroadcastArgs(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: BroadcastArgs(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BroadcastArgs(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BroadcastArgs(TFOutput, TFOutput, String)
  fullName: TFGraph.BroadcastArgs(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Return the shape of s0 op s1 with broadcast.
  remarks: >-
    Given <code>s0</code> and <code>s1</code>, tensors that represent shapes, compute <code>r0</code>, the
                  broadcasted shape. <code>s0</code>, <code>s1</code> and <code>r0</code> are all integer vectors.
  syntax:
    content: public TensorFlow.TFOutput BroadcastArgs (TensorFlow.TFOutput s0, TensorFlow.TFOutput s1, string operName = null);
    parameters:
    - id: s0
      type: TensorFlow.TFOutput
      description: To be added.
    - id: s1
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BroadcastArgs'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BroadcastArgs*
  exceptions: []
- uid: TensorFlow.TFGraph.BroadcastGradientArgs(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: BroadcastGradientArgs(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BroadcastGradientArgs(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BroadcastGradientArgs(TFOutput, TFOutput, String)
  fullName: TFGraph.BroadcastGradientArgs(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Return the reduction indices for computing gradients of s0 op s1 with broadcast.
  remarks: This is typically used by gradient computations for a broadcasting operation.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> BroadcastGradientArgs (TensorFlow.TFOutput s0, TensorFlow.TFOutput s1, string operName = null);
    parameters:
    - id: s0
      type: TensorFlow.TFOutput
      description: To be added.
    - id: s1
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BroadcastGradientArgs'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      r0:
                      r1:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.BroadcastGradientArgs*
  exceptions: []
- uid: TensorFlow.TFGraph.BroadcastTo(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: BroadcastTo(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: BroadcastTo(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BroadcastTo(TFOutput, TFOutput, String)
  fullName: TFGraph.BroadcastTo(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Broadcast an array for a compatible shape.
  remarks: "Broadcasting is the process of making arrays to have compatible shapes\n              for arithmetic operations. Two shapes are compatible if for each\n              dimension pair they are either equal or one of them is one. When trying\n              to broadcast a Tensor to a shape, it starts with the trailing dimensions,\n              and works its way forward.\n              \n              For example,\n               <pre><code>\n              &gt;&gt;&gt; x = tf.constant([1, 2, 3])\n              &gt;&gt;&gt; y = tf.broadcast_to(x, [3, 3])\n              &gt;&gt;&gt; sess.run(y)\n              array([[1, 2, 3],\n              [1, 2, 3],\n              [1, 2, 3]], dtype=int32)\n               </code></pre>\n              In the above example, the input Tensor with the shape of <code>[1, 3]</code>\n              is broadcasted to output Tensor with shape of <code>[3, 3]</code>."
  syntax:
    content: public TensorFlow.TFOutput BroadcastTo (TensorFlow.TFOutput input, TensorFlow.TFOutput shape, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A Tensor to broadcast.
    - id: shape
      type: TensorFlow.TFOutput
      description: An 1-D <code>int</code> Tensor. The shape of the desired output.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'BroadcastTo'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A Tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.BroadcastTo*
  exceptions: []
- uid: TensorFlow.TFGraph.Bucketize(TensorFlow.TFOutput,System.Single[],System.String)
  id: Bucketize(TensorFlow.TFOutput,System.Single[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Bucketize(TFOutput, Single[], String)
  nameWithType: TFGraph.Bucketize(TFOutput, Single[], String)
  fullName: TFGraph.Bucketize(TFOutput, Single[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Bucketizes 'input' based on 'boundaries'.
  remarks: "For example, if the inputs are\n              boundaries = [0, 10, 100]\n              input = [[-5, 10000]\n              [150,   10]\n              [5,    100]]\n              \n              then the output will be\n              output = [[0, 3]\n              [3, 2]\n              [1, 3]]"
  syntax:
    content: public TensorFlow.TFOutput Bucketize (TensorFlow.TFOutput input, float[] boundaries, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Any shape of Tensor contains with int or float type.
    - id: boundaries
      type: System.Single[]
      description: A sorted list of floats gives the boundary of the buckets.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Bucketize'.
    return:
      type: TensorFlow.TFOutput
      description: "Same shape with 'input', each value of input replaced with bucket index.\n              \n              @compatibility(numpy)\n              Equivalent to np.digitize.\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.Bucketize*
  exceptions: []
- uid: TensorFlow.TFGraph.CacheDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: CacheDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CacheDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.CacheDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.CacheDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that caches elements from <code>input_dataset</code>.
  remarks: >-
    A CacheDataset will iterate over the input_dataset, and store tensors. If the
                  cache already exists, the cache will be used. If the cache is inappropriate
                  (e.g. cannot be opened, contains tensors of the wrong shape / size), an error
                  will the returned when used.
  syntax:
    content: public TensorFlow.TFOutput CacheDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput filename, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: filename
      type: TensorFlow.TFOutput
      description: >-
        A path on the filesystem where we should cache the dataset. Note: this
                      will be a directory.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CacheDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CacheDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.Cast(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  id: Cast(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Cast(TFOutput, TFDataType, Nullable<Boolean>, String)
  nameWithType: TFGraph.Cast(TFOutput, TFDataType, Nullable<Boolean>, String)
  fullName: TFGraph.Cast(TFOutput, TFDataType, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Cast x of type SrcT to y of DstT.
  syntax:
    content: public TensorFlow.TFOutput Cast (TensorFlow.TFOutput x, TensorFlow.TFDataType DstT, Nullable<bool> Truncate = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: DstT
      type: TensorFlow.TFDataType
      description: To be added.
    - id: Truncate
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Cast'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Cast*
  exceptions: []
- uid: TensorFlow.TFGraph.Ceil(TensorFlow.TFOutput,System.String)
  id: Ceil(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Ceil(TFOutput, String)
  nameWithType: TFGraph.Ceil(TFOutput, String)
  fullName: TFGraph.Ceil(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns element-wise smallest integer not less than x.
  syntax:
    content: public TensorFlow.TFOutput Ceil (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Ceil'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Ceil*
  exceptions: []
- uid: TensorFlow.TFGraph.CheckNumerics(TensorFlow.TFOutput,System.String,System.String)
  id: CheckNumerics(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CheckNumerics(TFOutput, String, String)
  nameWithType: TFGraph.CheckNumerics(TFOutput, String, String)
  fullName: TFGraph.CheckNumerics(TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Checks a tensor for NaN and Inf values.
  remarks: >-
    When run, reports an <code>InvalidArgument</code> error if <code>tensor</code> has any values
                  that are not a number (NaN) or infinity (Inf). Otherwise, passes <code>tensor</code> as-is.
  syntax:
    content: public TensorFlow.TFOutput CheckNumerics (TensorFlow.TFOutput tensor, string message, string operName = null);
    parameters:
    - id: tensor
      type: TensorFlow.TFOutput
      description: To be added.
    - id: message
      type: System.String
      description: Prefix of the error message.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CheckNumerics'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CheckNumerics*
  exceptions: []
- uid: TensorFlow.TFGraph.Cholesky(TensorFlow.TFOutput,System.String)
  id: Cholesky(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Cholesky(TFOutput, String)
  nameWithType: TFGraph.Cholesky(TFOutput, String)
  fullName: TFGraph.Cholesky(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the Cholesky decomposition of one or more square matrices.
  remarks: "The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions\n              form square matrices.\n              \n              The input has to be symmetric and positive definite. Only the lower-triangular\n              part of the input will be used for this operation. The upper-triangular part\n              will not be read.\n              \n              The output is a tensor of the same shape as the input\n              containing the Cholesky decompositions for all input submatrices <code>[..., :, :]</code>.\n              \n              **Note**: The gradient computation on GPU is faster for large matrices but\n              not for large batch dimensions when the submatrices are small. In this\n              case it might be faster to use the CPU."
  syntax:
    content: public TensorFlow.TFOutput Cholesky (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Shape is <code>[..., M, M]</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Cholesky'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Shape is <code>[..., M, M]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Cholesky*
  exceptions: []
- uid: TensorFlow.TFGraph.CholeskyGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: CholeskyGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CholeskyGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.CholeskyGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.CholeskyGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the reverse mode backpropagated gradient of the Cholesky algorithm.
  remarks: >-
    For an explanation see "Differentiation of the Cholesky algorithm" by
                  Iain Murray http://arxiv.org/abs/1602.07527.
  syntax:
    content: public TensorFlow.TFOutput CholeskyGrad (TensorFlow.TFOutput l, TensorFlow.TFOutput grad, string operName = null);
    parameters:
    - id: l
      type: TensorFlow.TFOutput
      description: >-
        Output of batch Cholesky algorithm l = cholesky(A). Shape is <code>[..., M, M]</code>.
                      Algorithm depends only on lower triangular part of the innermost matrices of
                      this tensor.
    - id: grad
      type: TensorFlow.TFOutput
      description: >-
        df/dl where f is some scalar function. Shape is <code>[..., M, M]</code>.
                      Algorithm depends only on lower triangular part of the innermost matrices of
                      this tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CholeskyGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Symmetrized version of df/dA . Shape is <code>[..., M, M]</code>
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CholeskyGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.ClipByAverageNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ClipByAverageNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ClipByAverageNorm(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ClipByAverageNorm(TFOutput, TFOutput, String)
  fullName: TFGraph.ClipByAverageNorm(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Clips tensor values to a maximum average L2-norm.
  remarks: "Given a tensor <code>x</code>, and a maximum clip value <code>clip_norm</code>, this operation \n            normalizes <code>x</code> so that its its average L2-norm is less than or equal to <code>clip_norm</code>.\n            Specifically, if the average L2-norm is already less than or equal to <code>clip_norm</code>, then <code>x</code>\n            is not modified. If the average L2-norm is greater than <code>clip_norm</code>, then this operation returns a tensor of the same\n            type and shape as <code>x</code> with its values set to: <code>t* clip_norm / l2norm_avg(t)</code>. In this case, \n            the average L2-norm of the output tensor is <code>clip_norm</code>."
  syntax:
    content: public TensorFlow.TFOutput ClipByAverageNorm (TensorFlow.TFOutput x, TensorFlow.TFOutput clip_norm, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: The input tensor.
    - id: clip_norm
      type: TensorFlow.TFOutput
      description: A maximum clipping value.
    - id: operName
      type: System.String
      description: Name of the oper.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.ClipByAverageNorm*
  exceptions: []
- uid: TensorFlow.TFGraph.ClipByNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.String)
  id: ClipByNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ClipByNorm(TFOutput, TFOutput, Nullable<TFOutput>, String)
  nameWithType: TFGraph.ClipByNorm(TFOutput, TFOutput, Nullable<TFOutput>, String)
  fullName: TFGraph.ClipByNorm(TFOutput, TFOutput, Nullable<TFOutput>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Clips tensor values to a maximum L2-norm.
  remarks: "<p>\n            Given a tensor <code>x</code>, and a maximum clip value <code>clip_norm</code>, this operation normalizes \n            <code>x</code> so that its L2-norm is less than or equal to <code>clip_norm</code>, along the dimensions \n            given in <code>axes</code>. Specifically, in the default case where all dimensions are used for calculation, if\n            the L2-norm of <code>x</code> is already less than or equal to <code>clip_norm</code>, then <code>x</code>\n            is not modified. If the L2-norm is greater than <code>clip_norm</code>, then this operation returns a tensor of \n            the same type and shape as <code>x</code> with its values set to: <code>t* clip_norm / l2norm(t)</code></p>"
  syntax:
    content: public TensorFlow.TFOutput ClipByNorm (TensorFlow.TFOutput x, TensorFlow.TFOutput clip_norm, Nullable<TensorFlow.TFOutput> axes = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: The tensor.
    - id: clip_norm
      type: TensorFlow.TFOutput
      description: The minimum value to clip by. A 0 - D(scalar) tensor, or a tensor with the same shape as <code>x</code>.
    - id: axes
      type: System.Nullable{TensorFlow.TFOutput}
      description: The minimum value to clip by. A 0 - D(scalar) tensor, or a tensor with the same shape as <code>x</code>.
    - id: operName
      type: System.String
      description: Operation name, optional.
    return:
      type: TensorFlow.TFOutput
      description: A clipped <xref href="TensorFlow.TFOutput"></xref>.
  overload: TensorFlow.TFGraph.ClipByNorm*
  exceptions: []
- uid: TensorFlow.TFGraph.ClipByValue(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ClipByValue(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ClipByValue(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ClipByValue(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ClipByValue(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Clips tensor values to a specified min and max.
  remarks: >-
    Given a tensor <code>t</code>, this operation returns a tensor of the same type and
                  shape as <code>t</code> with its values clipped to <code>clip_value_min</code> and <code>clip_value_max</code>.
                  Any values less than <code>clip_value_min</code> are set to <code>clip_value_min</code>. Any values
                  greater than <code>clip_value_max</code> are set to <code>clip_value_max</code>.
  syntax:
    content: public TensorFlow.TFOutput ClipByValue (TensorFlow.TFOutput t, TensorFlow.TFOutput clip_value_min, TensorFlow.TFOutput clip_value_max, string operName = null);
    parameters:
    - id: t
      type: TensorFlow.TFOutput
      description: A <code>Tensor</code>.
    - id: clip_value_min
      type: TensorFlow.TFOutput
      description: >-
        A 0-D (scalar) <code>Tensor</code>, or a <code>Tensor</code> with the same shape
                      as <code>t</code>. The minimum value to clip by.
    - id: clip_value_max
      type: TensorFlow.TFOutput
      description: >-
        A 0-D (scalar) <code>Tensor</code>, or a <code>Tensor</code> with the same shape
                      as <code>t</code>. The maximum value to clip by.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ClipByValue'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A clipped <code>Tensor</code> with the same shape as input 't'.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ClipByValue*
  exceptions: []
- uid: TensorFlow.TFGraph.CollectiveBcastRecv(TensorFlow.TFDataType,System.Int64,System.Int64,System.Int64,TensorFlow.TFShape,System.String)
  id: CollectiveBcastRecv(TensorFlow.TFDataType,System.Int64,System.Int64,System.Int64,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CollectiveBcastRecv(TFDataType, Int64, Int64, Int64, TFShape, String)
  nameWithType: TFGraph.CollectiveBcastRecv(TFDataType, Int64, Int64, Int64, TFShape, String)
  fullName: TFGraph.CollectiveBcastRecv(TFDataType, Int64, Int64, Int64, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Receives a tensor value broadcast from another device.
  syntax:
    content: public TensorFlow.TFOutput CollectiveBcastRecv (TensorFlow.TFDataType T, long group_size, long group_key, long instance_key, TensorFlow.TFShape shape, string operName = null);
    parameters:
    - id: T
      type: TensorFlow.TFDataType
      description: To be added.
    - id: group_size
      type: System.Int64
      description: To be added.
    - id: group_key
      type: System.Int64
      description: To be added.
    - id: instance_key
      type: System.Int64
      description: To be added.
    - id: shape
      type: TensorFlow.TFShape
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectiveBcastRecv'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CollectiveBcastRecv*
  exceptions: []
- uid: TensorFlow.TFGraph.CollectiveBcastSend(TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,TensorFlow.TFShape,System.String)
  id: CollectiveBcastSend(TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CollectiveBcastSend(TFOutput, Int64, Int64, Int64, TFShape, String)
  nameWithType: TFGraph.CollectiveBcastSend(TFOutput, Int64, Int64, Int64, TFShape, String)
  fullName: TFGraph.CollectiveBcastSend(TFOutput, Int64, Int64, Int64, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Broadcasts a tensor value to one or more other devices.
  syntax:
    content: public TensorFlow.TFOutput CollectiveBcastSend (TensorFlow.TFOutput input, long group_size, long group_key, long instance_key, TensorFlow.TFShape shape, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: group_size
      type: System.Int64
      description: To be added.
    - id: group_key
      type: System.Int64
      description: To be added.
    - id: instance_key
      type: System.Int64
      description: To be added.
    - id: shape
      type: TensorFlow.TFShape
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectiveBcastSend'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CollectiveBcastSend*
  exceptions: []
- uid: TensorFlow.TFGraph.CollectivePermute(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: CollectivePermute(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CollectivePermute(TFOutput, TFOutput, String)
  nameWithType: TFGraph.CollectivePermute(TFOutput, TFOutput, String)
  fullName: TFGraph.CollectivePermute(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An Op to permute tensors across replicated TPU instances. Each instance
  remarks: "supplies its own input.\n              \n              For example, suppose there are 4 TPU instances: <code>[A, B, C, D]</code>. Passing\n              source_target_pairs=<code>[[0,1],[1,2],[2,3],[3,0]]</code> gets the outputs:\n              <code>[D, A, B, C]</code>."
  syntax:
    content: public TensorFlow.TFOutput CollectivePermute (TensorFlow.TFOutput input, TensorFlow.TFOutput source_target_pairs, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: >-
        The local input to be permuted. Currently only supports float and
                      bfloat16.
    - id: source_target_pairs
      type: TensorFlow.TFOutput
      description: A tensor with shape [num_pairs, 2].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectivePermute'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The permuted input.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CollectivePermute*
  exceptions: []
- uid: TensorFlow.TFGraph.CollectiveReduce(TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,System.String,System.String,System.Int64[],System.String)
  id: CollectiveReduce(TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CollectiveReduce(TFOutput, Int64, Int64, Int64, String, String, Int64[], String)
  nameWithType: TFGraph.CollectiveReduce(TFOutput, Int64, Int64, Int64, String, String, Int64[], String)
  fullName: TFGraph.CollectiveReduce(TFOutput, Int64, Int64, Int64, String, String, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Mutually reduces multiple tensors of identical type and shape.
  syntax:
    content: public TensorFlow.TFOutput CollectiveReduce (TensorFlow.TFOutput input, long group_size, long group_key, long instance_key, string merge_op, string final_op, long[] subdiv_offsets, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: group_size
      type: System.Int64
      description: To be added.
    - id: group_key
      type: System.Int64
      description: To be added.
    - id: instance_key
      type: System.Int64
      description: To be added.
    - id: merge_op
      type: System.String
      description: To be added.
    - id: final_op
      type: System.String
      description: To be added.
    - id: subdiv_offsets
      type: System.Int64[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CollectiveReduce'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CollectiveReduce*
  exceptions: []
- uid: TensorFlow.TFGraph.CompareAndBitpack(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: CompareAndBitpack(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CompareAndBitpack(TFOutput, TFOutput, String)
  nameWithType: TFGraph.CompareAndBitpack(TFOutput, TFOutput, String)
  fullName: TFGraph.CompareAndBitpack(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Compare values of <code>input</code> to <code>threshold</code> and pack resulting bits into a <code>uint8</code>.
  remarks: "Each comparison returns a boolean <code>true</code> (if <code>input_value &gt; threshold</code>)\n              or and <code>false</code> otherwise.\n              \n              This operation is useful for Locality-Sensitive-Hashing (LSH) and other\n              algorithms that use hashing approximations of cosine and <code>L2</code> distances;\n              codes can be generated from an input via:\n              \n               <pre><code>\n              codebook_size = 50\n              codebook_bits = codebook_size * 32\n              codebook = tf.get_variable('codebook', [x.shape[-1].value, codebook_bits],\n              dtype=x.dtype,\n              initializer=tf.orthogonal_initializer())\n              codes = compare_and_threshold(tf.matmul(x, codebook), threshold=0.)\n              codes = tf.bitcast(codes, tf.int32)  # go from uint8 to int32\n              # now codes has shape x.shape[:-1] + [codebook_size]\n               </code></pre>\n              \n              **NOTE**: Currently, the innermost dimension of the tensor must be divisible\n              by 8.\n              \n              Given an <code>input</code> shaped <code>[s0, s1, ..., s_n]</code>, the output is\n              a <code>uint8</code> tensor shaped <code>[s0, s1, ..., s_n / 8]</code>."
  syntax:
    content: public TensorFlow.TFOutput CompareAndBitpack (TensorFlow.TFOutput input, TensorFlow.TFOutput threshold, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Values to compare against <code>threshold</code> and bitpack.
    - id: threshold
      type: TensorFlow.TFOutput
      description: Threshold to compare against.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CompareAndBitpack'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The bitpacked comparisons.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CompareAndBitpack*
  exceptions: []
- uid: TensorFlow.TFGraph.Complex(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: Complex(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Complex(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Complex(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Complex(TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts two real numbers to a complex number.
  remarks: "Given a tensor <code>real</code> representing the real part of a complex number, and a\n              tensor <code>imag</code> representing the imaginary part of a complex number, this\n              operation returns complex numbers elementwise of the form \\\\(a + bj\\\\), where\n              *a* represents the <code>real</code> part and *b* represents the <code>imag</code> part.\n              \n              The input tensors <code>real</code> and <code>imag</code> must have the same shape.\n              \n              For example:\n              \n               <pre><code>\n              # tensor 'real' is [2.25, 3.25]\n              # tensor <code>imag</code> is [4.75, 5.75]\n              tf.complex(real, imag) ==&gt; [[2.25 + 4.75j], [3.25 + 5.75j]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Complex (TensorFlow.TFOutput real, TensorFlow.TFOutput imag, Nullable<TensorFlow.TFDataType> Tout = null, string operName = null);
    parameters:
    - id: real
      type: TensorFlow.TFOutput
      description: To be added.
    - id: imag
      type: TensorFlow.TFOutput
      description: To be added.
    - id: Tout
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Complex'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Complex*
  exceptions: []
- uid: TensorFlow.TFGraph.ComplexAbs(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: ComplexAbs(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ComplexAbs(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.ComplexAbs(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.ComplexAbs(TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the complex absolute value of a tensor.
  remarks: >-
    Given a tensor <code>x</code> of complex numbers, this operation returns a tensor of type
                  <code>float</code> or <code>double</code> that is the absolute value of each element in <code>x</code>. All
                  elements in <code>x</code> must be complex numbers of the form \\(a + bj\\). The absolute
                  value is computed as \\( \sqrt{a^2 + b^2}\\).
  syntax:
    content: public TensorFlow.TFOutput ComplexAbs (TensorFlow.TFOutput x, Nullable<TensorFlow.TFDataType> Tout = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: Tout
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ComplexAbs'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ComplexAbs*
  exceptions: []
- uid: TensorFlow.TFGraph.ComputeAccidentalHits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: ComputeAccidentalHits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ComputeAccidentalHits(TFOutput, TFOutput, Int64, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.ComputeAccidentalHits(TFOutput, TFOutput, Int64, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.ComputeAccidentalHits(TFOutput, TFOutput, Int64, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the ids of the positions in sampled_candidates that match true_labels.
  remarks: >-
    When doing log-odds NCE, the result of this op should be passed through a
                  SparseToDense op, then added to the logits of the sampled candidates. This has
                  the effect of 'removing' the sampled labels that match the true labels by
                  making the classifier sure that they are sampled labels.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> ComputeAccidentalHits (TensorFlow.TFOutput true_classes, TensorFlow.TFOutput sampled_candidates, long num_true, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: true_classes
      type: TensorFlow.TFOutput
      description: The true_classes output of UnpackSparseLabels.
    - id: sampled_candidates
      type: TensorFlow.TFOutput
      description: The sampled_candidates output of CandidateSampler.
    - id: num_true
      type: System.Int64
      description: Number of true labels per context.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either seed or seed2 are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      An second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ComputeAccidentalHits'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      indices: A vector of indices corresponding to rows of true_candidates.
                      ids: A vector of IDs of positions in sampled_candidates that match a true_label
                      for the row with the corresponding index in indices.
                      weights: A vector of the same length as indices and ids, in which each element
                      is -FLOAT_MAX.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.ComputeAccidentalHits*
  exceptions: []
- uid: TensorFlow.TFGraph.Concat(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  id: Concat(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Concat(TFOutput, TFOutput[], String)
  nameWithType: TFGraph.Concat(TFOutput, TFOutput[], String)
  fullName: TFGraph.Concat(TFOutput, TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Concatenates tensors along one dimension.
  syntax:
    content: public TensorFlow.TFOutput Concat (TensorFlow.TFOutput concat_dim, TensorFlow.TFOutput[] values, string operName = null);
    parameters:
    - id: concat_dim
      type: TensorFlow.TFOutput
      description: >-
        0-D.  The dimension along which to concatenate.  Must be in the
                      range [0, rank(values)).
    - id: values
      type: TensorFlow.TFOutput[]
      description: >-
        The <code>N</code> Tensors to concatenate. Their ranks and types must match,
                      and their sizes must match in all dimensions except <code>concat_dim</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Concat'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A <code>Tensor</code> with the concatenation of values stacked along the
                      <code>concat_dim</code> dimension.  This tensor's shape matches that of <code>values</code> except
                      in <code>concat_dim</code> where it has the sum of the sizes.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Concat*
  exceptions: []
- uid: TensorFlow.TFGraph.ConcatenateDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: ConcatenateDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ConcatenateDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ConcatenateDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.ConcatenateDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that concatenates <code>input_dataset</code> with <code>another_dataset</code>.
  syntax:
    content: public TensorFlow.TFOutput ConcatenateDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput another_dataset, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: another_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ConcatenateDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ConcatenateDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.ConcatOffset(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  id: ConcatOffset(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ConcatOffset(TFOutput, TFOutput[], String)
  nameWithType: TFGraph.ConcatOffset(TFOutput, TFOutput[], String)
  fullName: TFGraph.ConcatOffset(TFOutput, TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes offsets of concat inputs within its output.
  remarks: "For example:\n              \n               <pre><code>\n              # 'x' is [2, 2, 7]\n              # 'y' is [2, 3, 7]\n              # 'z' is [2, 5, 7]\n              concat_offset(2, [x, y, z]) =&gt; [0, 0, 0], [0, 2, 0], [0, 5, 0]\n               </code></pre>\n              \n              This is typically used by gradient computations for a concat operation."
  syntax:
    content: public TensorFlow.TFOutput[] ConcatOffset (TensorFlow.TFOutput concat_dim, TensorFlow.TFOutput[] shape, string operName = null);
    parameters:
    - id: concat_dim
      type: TensorFlow.TFOutput
      description: The dimension along which to concatenate.
    - id: shape
      type: TensorFlow.TFOutput[]
      description: The <code>N</code> int32 vectors representing shape of tensors being concatenated.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ConcatOffset'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        The <code>N</code> int32 vectors representing the starting offset
                      of input tensors within the concatenated output.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ConcatOffset*
  exceptions: []
- uid: TensorFlow.TFGraph.ConcatV2(TensorFlow.TFOutput[],TensorFlow.TFOutput,System.String)
  id: ConcatV2(TensorFlow.TFOutput[],TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ConcatV2(TFOutput[], TFOutput, String)
  nameWithType: TFGraph.ConcatV2(TFOutput[], TFOutput, String)
  fullName: TFGraph.ConcatV2(TFOutput[], TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Concatenates tensors along one dimension.
  syntax:
    content: public TensorFlow.TFOutput ConcatV2 (TensorFlow.TFOutput[] values, TensorFlow.TFOutput axis, string operName = null);
    parameters:
    - id: values
      type: TensorFlow.TFOutput[]
      description: >-
        List of <code>N</code> Tensors to concatenate. Their ranks and types must match,
                      and their sizes must match in all dimensions except <code>concat_dim</code>.
    - id: axis
      type: TensorFlow.TFOutput
      description: >-
        0-D.  The dimension along which to concatenate.  Must be in the
                      range [-rank(values), rank(values)).
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ConcatV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A <code>Tensor</code> with the concatenation of values stacked along the
                      <code>concat_dim</code> dimension.  This tensor's shape matches that of <code>values</code> except
                      in <code>concat_dim</code> where it has the sum of the sizes.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ConcatV2*
  exceptions: []
- uid: TensorFlow.TFGraph.Cond(TensorFlow.TFOutput,System.Func{TensorFlow.TFOutput},System.Func{TensorFlow.TFOutput},System.String)
  id: Cond(TensorFlow.TFOutput,System.Func{TensorFlow.TFOutput},System.Func{TensorFlow.TFOutput},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Cond(TFOutput, Func<TFOutput>, Func<TFOutput>, String)
  nameWithType: TFGraph.Cond(TFOutput, Func<TFOutput>, Func<TFOutput>, String)
  fullName: TFGraph.Cond(TFOutput, Func<TFOutput>, Func<TFOutput>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns <code>true_fn</code> if the predicate <code>pred</code> is <code>true</code> else <code>false_fn</code>.
  syntax:
    content: public TensorFlow.TFOutput Cond (TensorFlow.TFOutput pred, Func<TensorFlow.TFOutput> true_fn, Func<TensorFlow.TFOutput> false_fn, string operName = null);
    parameters:
    - id: pred
      type: TensorFlow.TFOutput
      description: A scalar determining whether to return the result of true_fn or false_fn.
    - id: true_fn
      type: System.Func{TensorFlow.TFOutput}
      description: The callable to be performed if pred is true.
    - id: false_fn
      type: System.Func{TensorFlow.TFOutput}
      description: The callable to be performed if pred is false.
    - id: operName
      type: System.String
      description: Optional name prefix for the returned tensors.
    return:
      type: TensorFlow.TFOutput
      description: TFOutput.
  overload: TensorFlow.TFGraph.Cond*
  exceptions: []
- uid: TensorFlow.TFGraph.ConditionalAccumulator(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String,System.String)
  id: ConditionalAccumulator(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ConditionalAccumulator(TFDataType, TFShape, String, String, String, String)
  nameWithType: TFGraph.ConditionalAccumulator(TFDataType, TFShape, String, String, String, String)
  fullName: TFGraph.ConditionalAccumulator(TFDataType, TFShape, String, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A conditional accumulator for aggregating gradients.
  remarks: >-
    The accumulator accepts gradients marked with local_step greater or
                  equal to the most recent global_step known to the accumulator. The
                  average can be extracted from the accumulator, provided sufficient
                  gradients have been accumulated. Extracting the average automatically
                  resets the aggregate to 0, and increments the global_step recorded by
                  the accumulator.
  syntax:
    content: public TensorFlow.TFOutput ConditionalAccumulator (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string container = null, string shared_name = null, string reduction_type = null, string operName = null);
    parameters:
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of the value being accumulated.
    - id: shape
      type: TensorFlow.TFShape
      description: The shape of the values, can be [], in which case shape is unknown.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this accumulator is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this accumulator will be shared under the
                      given name across multiple sessions.
    - id: reduction_type
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ConditionalAccumulator'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to the accumulator.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ConditionalAccumulator*
  exceptions: []
- uid: TensorFlow.TFGraph.ConfigureDistributedTPU(System.String,System.String,System.Nullable{System.Boolean},System.String)
  id: ConfigureDistributedTPU(System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ConfigureDistributedTPU(String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.ConfigureDistributedTPU(String, String, Nullable<Boolean>, String)
  fullName: TFGraph.ConfigureDistributedTPU(String, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An op that sets up the centralized structures for a distributed TPU
  remarks: system.
  syntax:
    content: public TensorFlow.TFOutput ConfigureDistributedTPU (string embedding_config = null, string tpu_embedding_config = null, Nullable<bool> is_global_init = null, string operName = null);
    parameters:
    - id: embedding_config
      type: System.String
      description: >-
        Optional argument
                      Reserved. Do not use.
    - id: tpu_embedding_config
      type: System.String
      description: >-
        Optional argument
                      Serialized tensorflow.tpu.TPUEmbeddingConfiguration that
                      describes the embedding lookups of the program.
    - id: is_global_init
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Reserved. Do not use.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ConfigureDistributedTPU'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A serialized tensorflow.tpu.TopologyProto that describes the TPU
                      topology.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ConfigureDistributedTPU*
  exceptions: []
- uid: TensorFlow.TFGraph.Conj(TensorFlow.TFOutput,System.String)
  id: Conj(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Conj(TFOutput, String)
  nameWithType: TFGraph.Conj(TFOutput, String)
  fullName: TFGraph.Conj(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the complex conjugate of a complex number.
  remarks: "Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of\n              complex numbers that are the complex conjugate of each element in <code>input</code>. The\n              complex numbers in <code>input</code> must be of the form \\\\(a + bj\\\\), where *a* is the\n              real part and *b* is the imaginary part.\n              \n              The complex conjugate returned by this operation is of the form \\\\(a - bj\\\\).\n              \n              For example:\n              \n               <pre><code>\n              # tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\n              tf.conj(input) ==&gt; [-2.25 - 4.75j, 3.25 - 5.75j]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Conj (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Conj'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Conj*
  exceptions: []
- uid: TensorFlow.TFGraph.ConjugateTranspose(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ConjugateTranspose(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ConjugateTranspose(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ConjugateTranspose(TFOutput, TFOutput, String)
  fullName: TFGraph.ConjugateTranspose(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Shuffle dimensions of x according to a permutation and conjugate the result.
  remarks: >-
    The output <code>y</code> has the same rank as <code>x</code>. The shapes of <code>x</code> and <code>y</code> satisfy:
                  <code>y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]</code><code>y[i,j,k,...,s,t,u] == conj(x[perm[i], perm[j], perm[k],...,perm[s], perm[t], perm[u]])</code>
  syntax:
    content: public TensorFlow.TFOutput ConjugateTranspose (TensorFlow.TFOutput x, TensorFlow.TFOutput perm, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: perm
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ConjugateTranspose'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ConjugateTranspose*
  exceptions: []
- uid: TensorFlow.TFGraph.Const(TensorFlow.TFTensor,System.String)
  id: Const(TensorFlow.TFTensor,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Const(TFTensor, String)
  nameWithType: TFGraph.Const(TFTensor, String)
  fullName: TFGraph.Const(TFTensor, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a constant operation from a TFTensor or constant
  remarks: >-
    Since TFTensor have implicit conversion operators, you can call this method with
                a constant like this: graph.Const (23)
  syntax:
    content: public TensorFlow.TFOutput Const (TensorFlow.TFTensor value, string operName = null);
    parameters:
    - id: value
      type: TensorFlow.TFTensor
      description: Value.
    - id: operName
      type: System.String
      description: Oper name.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.Const*
  exceptions: []
- uid: TensorFlow.TFGraph.Const(TensorFlow.TFTensor,TensorFlow.TFDataType,System.String)
  id: Const(TensorFlow.TFTensor,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Const(TFTensor, TFDataType, String)
  nameWithType: TFGraph.Const(TFTensor, TFDataType, String)
  fullName: TFGraph.Const(TFTensor, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns a constant tensor.
  syntax:
    content: public TensorFlow.TFOutput Const (TensorFlow.TFTensor value, TensorFlow.TFDataType dtype, string operName = null);
    parameters:
    - id: value
      type: TensorFlow.TFTensor
      description: Attr <code>value</code> is the tensor to return.
    - id: dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Const'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Const*
  exceptions: []
- uid: TensorFlow.TFGraph.Constant(System.Object,TensorFlow.TFShape,TensorFlow.TFDataType,System.String)
  id: Constant(System.Object,TensorFlow.TFShape,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Constant(Object, TFShape, TFDataType, String)
  nameWithType: TFGraph.Constant(Object, TFShape, TFDataType, String)
  fullName: TFGraph.Constant(Object, TFShape, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: >-
    Create a constant tensor based on a shape
                Used by Zeros and Ones
  syntax:
    content: public TensorFlow.TFOutput Constant (object value, TensorFlow.TFShape tfshape, TensorFlow.TFDataType dtype = TensorFlow.TFDataType.Double, string operName = null);
    parameters:
    - id: value
      type: System.Object
      description: Value for tensor
    - id: tfshape
      type: TensorFlow.TFShape
      description: Shape of the tensor
    - id: dtype
      type: TensorFlow.TFDataType
      description: 'Optional Type of the Zero value. Default: Double'
    - id: operName
      type: System.String
      description: Operation name, optional.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.Constant*
  exceptions: []
- uid: TensorFlow.TFGraph.ConsumeMutexLock(TensorFlow.TFOutput,System.String)
  id: ConsumeMutexLock(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ConsumeMutexLock(TFOutput, String)
  nameWithType: TFGraph.ConsumeMutexLock(TFOutput, String)
  fullName: TFGraph.ConsumeMutexLock(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: This op consumes a lock created by <code>MutexLock</code>.
  remarks: "This op exists to consume a tensor created by <code>MutexLock</code> (other than\n              direct control dependencies).  It should be the only that consumes the tensor,\n              and will raise an error if it is not.  Its only purpose is to keep the\n              mutex lock tensor alive until it is consumed by this op.\n              \n              **NOTE**: This operation must run on the same device as its input.  This may\n              be enforced via the <code>colocate_with</code> mechanism."
  syntax:
    content: public TensorFlow.TFOperation ConsumeMutexLock (TensorFlow.TFOutput mutex_lock, string operName = null);
    parameters:
    - id: mutex_lock
      type: TensorFlow.TFOutput
      description: A tensor returned by <code>MutexLock</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ConsumeMutexLock'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ConsumeMutexLock*
  exceptions: []
- uid: TensorFlow.TFGraph.ControlTrigger(System.String)
  id: ControlTrigger(System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ControlTrigger(String)
  nameWithType: TFGraph.ControlTrigger(String)
  fullName: TFGraph.ControlTrigger(String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Does nothing. Serves as a control trigger for scheduling.
  remarks: Only useful as a placeholder for control edges.
  syntax:
    content: public TensorFlow.TFOperation ControlTrigger (string operName = null);
    parameters:
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ControlTrigger'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ControlTrigger*
  exceptions: []
- uid: TensorFlow.TFGraph.Conv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  id: Conv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Conv2D(TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  nameWithType: TFGraph.Conv2D(TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  fullName: TFGraph.Conv2D(TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes a 2-D convolution given 4-D <code>input</code> and <code>filter</code> tensors.
  remarks: "Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>\n              and a filter / kernel tensor of shape\n              <code>[filter_height, filter_width, in_channels, out_channels]</code>, this op\n              performs the following:\n              \n              1. Flattens the filter to a 2-D matrix with shape\n              <code>[filter_height * filter_width * in_channels, output_channels]</code>.\n              2. Extracts image patches from the input tensor to form a *virtual*\n              tensor of shape <code>[batch, out_height, out_width,\n              filter_height * filter_width * in_channels]</code>.\n              3. For each patch, right-multiplies the filter matrix and the image patch\n              vector.\n              \n              In detail, with the default NHWC format,\n              \n              output[b, i, j, k] =\n              sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *\n              filter[di, dj, q, k]\n              \n              Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the same\n              horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>."
  syntax:
    content: public TensorFlow.TFOutput Conv2D (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, long[] strides, string padding, Nullable<bool> use_cudnn_on_gpu = null, string data_format = null, long[] dilations = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: >-
        A 4-D tensor. The dimension order is interpreted according to the value
                      of <code>data_format</code>, see below for details.
    - id: filter
      type: TensorFlow.TFOutput
      description: >-
        A 4-D tensor of shape
                      <code>[filter_height, filter_width, in_channels, out_channels]</code>
    - id: strides
      type: System.Int64[]
      description: >-
        1-D tensor of length 4.  The stride of the sliding window for each
                      dimension of <code>input</code>. The dimension order is determined by the value of
                      <code>data_format</code>, see below for details.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: use_cudnn_on_gpu
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, height, width, channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, channels, height, width].
    - id: dilations
      type: System.Int64[]
      description: >-
        Optional argument
                      1-D tensor of length 4.  The dilation factor for each dimension of
                      <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each
                      filter element on that dimension. The dimension order is determined by the
                      value of <code>data_format</code>, see above for details. Dilations in the batch and
                      depth dimensions must be 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv2D'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A 4-D tensor. The dimension order is determined by the value of
                      <code>data_format</code>, see below for details.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Conv2D*
  exceptions: []
- uid: TensorFlow.TFGraph.Conv2DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  id: Conv2DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Conv2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  nameWithType: TFGraph.Conv2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  fullName: TFGraph.Conv2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradients of convolution with respect to the filter.
  syntax:
    content: public TensorFlow.TFOutput Conv2DBackpropFilter (TensorFlow.TFOutput input, TensorFlow.TFOutput filter_sizes, TensorFlow.TFOutput out_backprop, long[] strides, string padding, Nullable<bool> use_cudnn_on_gpu = null, string data_format = null, long[] dilations = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
    - id: filter_sizes
      type: TensorFlow.TFOutput
      description: >-
        An integer vector representing the tensor shape of <code>filter</code>,
                      where <code>filter</code> is a 4-D
                      <code>[filter_height, filter_width, in_channels, out_channels]</code> tensor.
    - id: out_backprop
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
                      Gradients w.r.t. the output of the convolution.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the input
                      of the convolution. Must be in the same order as the dimension specified with
                      format.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: use_cudnn_on_gpu
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, in_channels, in_height, in_width].
    - id: dilations
      type: System.Int64[]
      description: >-
        Optional argument
                      1-D tensor of length 4.  The dilation factor for each dimension of
                      <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each filter
                      element on that dimension. The dimension order is determined by the value of
                      <code>data_format</code>, see above for details. Dilations in the batch and depth
                      dimensions must be 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv2DBackpropFilter'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape
                      <code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
                      the <code>filter</code> input of the convolution.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Conv2DBackpropFilter*
  exceptions: []
- uid: TensorFlow.TFGraph.Conv2DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  id: Conv2DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Conv2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  nameWithType: TFGraph.Conv2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  fullName: TFGraph.Conv2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradients of convolution with respect to the input.
  syntax:
    content: public TensorFlow.TFOutput Conv2DBackpropInput (TensorFlow.TFOutput input_sizes, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, string padding, Nullable<bool> use_cudnn_on_gpu = null, string data_format = null, long[] dilations = null, string operName = null);
    parameters:
    - id: input_sizes
      type: TensorFlow.TFOutput
      description: >-
        An integer vector representing the shape of <code>input</code>,
                      where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.
    - id: filter
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape
                      <code>[filter_height, filter_width, in_channels, out_channels]</code>.
    - id: out_backprop
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
                      Gradients w.r.t. the output of the convolution.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the input
                      of the convolution. Must be in the same order as the dimension specified with
                      format.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: use_cudnn_on_gpu
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, in_channels, in_height, in_width].
    - id: dilations
      type: System.Int64[]
      description: >-
        Optional argument
                      1-D tensor of length 4.  The dilation factor for each dimension of
                      <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each filter
                      element on that dimension. The dimension order is determined by the value of
                      <code>data_format</code>, see above for details. Dilations in the batch and depth
                      dimensions must be 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv2DBackpropInput'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.  Gradient
                      w.r.t. the input of the convolution.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Conv2DBackpropInput*
  exceptions: []
- uid: TensorFlow.TFGraph.Conv3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  id: Conv3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Conv3D(TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  nameWithType: TFGraph.Conv3D(TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  fullName: TFGraph.Conv3D(TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes a 3-D convolution given 5-D <code>input</code> and <code>filter</code> tensors.
  remarks: "In signal processing, cross-correlation is a measure of similarity of\n              two waveforms as a function of a time-lag applied to one of them. This\n              is also known as a sliding dot product or sliding inner-product.\n              \n              Our Conv3D implements a form of cross-correlation."
  syntax:
    content: public TensorFlow.TFOutput Conv3D (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Shape <code>[batch, in_depth, in_height, in_width, in_channels]</code>.
    - id: filter
      type: TensorFlow.TFOutput
      description: >-
        Shape <code>[filter_depth, filter_height, filter_width, in_channels,
                      out_channels]</code>. <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The stride of the sliding window for each
                      dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      The data format of the input and output data. With the
                      default format "NDHWC", the data is stored in the order of:
                      [batch, in_depth, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCDHW", the data storage order is:
                      [batch, in_channels, in_depth, in_height, in_width].
    - id: dilations
      type: System.Int64[]
      description: >-
        Optional argument
                      1-D tensor of length 5.  The dilation factor for each dimension of
                      <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each
                      filter element on that dimension. The dimension order is determined by the
                      value of <code>data_format</code>, see above for details. Dilations in the batch and
                      depth dimensions must be 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3D'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Conv3D*
  exceptions: []
- uid: TensorFlow.TFGraph.Conv3DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Int64[],System.String)
  id: Conv3DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Conv3DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)
  nameWithType: TFGraph.Conv3DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)
  fullName: TFGraph.Conv3DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradients of 3-D convolution with respect to the filter.
  syntax:
    content: public TensorFlow.TFOutput Conv3DBackpropFilter (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, string padding, long[] dilations = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Shape <code>[batch, depth, rows, cols, in_channels]</code>.
    - id: filter
      type: TensorFlow.TFOutput
      description: >-
        Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
                      <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
    - id: out_backprop
      type: TensorFlow.TFOutput
      description: >-
        Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
                      out_channels]</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The stride of the sliding window for each
                      dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: dilations
      type: System.Int64[]
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropFilter'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Conv3DBackpropFilter*
  exceptions: []
- uid: TensorFlow.TFGraph.Conv3DBackpropFilterV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  id: Conv3DBackpropFilterV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Conv3DBackpropFilterV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  nameWithType: TFGraph.Conv3DBackpropFilterV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  fullName: TFGraph.Conv3DBackpropFilterV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradients of 3-D convolution with respect to the filter.
  syntax:
    content: public TensorFlow.TFOutput Conv3DBackpropFilterV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput filter_sizes, TensorFlow.TFOutput out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Shape <code>[batch, depth, rows, cols, in_channels]</code>.
    - id: filter_sizes
      type: TensorFlow.TFOutput
      description: >-
        An integer vector representing the tensor shape of <code>filter</code>,
                      where <code>filter</code> is a 5-D
                      <code>[filter_depth, filter_height, filter_width, in_channels, out_channels]</code>
                      tensor.
    - id: out_backprop
      type: TensorFlow.TFOutput
      description: >-
        Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
                      out_channels]</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The stride of the sliding window for each
                      dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      The data format of the input and output data. With the
                      default format "NDHWC", the data is stored in the order of:
                      [batch, in_depth, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCDHW", the data storage order is:
                      [batch, in_channels, in_depth, in_height, in_width].
    - id: dilations
      type: System.Int64[]
      description: >-
        Optional argument
                      1-D tensor of length 5.  The dilation factor for each dimension of
                      <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each
                      filter element on that dimension. The dimension order is determined by the
                      value of <code>data_format</code>, see above for details. Dilations in the batch and
                      depth dimensions must be 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropFilterV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Conv3DBackpropFilterV2*
  exceptions: []
- uid: TensorFlow.TFGraph.Conv3DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Int64[],System.String)
  id: Conv3DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Conv3DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)
  nameWithType: TFGraph.Conv3DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)
  fullName: TFGraph.Conv3DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradients of 3-D convolution with respect to the input.
  syntax:
    content: public TensorFlow.TFOutput Conv3DBackpropInput (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, string padding, long[] dilations = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Shape <code>[batch, depth, rows, cols, in_channels]</code>.
    - id: filter
      type: TensorFlow.TFOutput
      description: >-
        Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
                      <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
    - id: out_backprop
      type: TensorFlow.TFOutput
      description: >-
        Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
                      out_channels]</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The stride of the sliding window for each
                      dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: dilations
      type: System.Int64[]
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropInput'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Conv3DBackpropInput*
  exceptions: []
- uid: TensorFlow.TFGraph.Conv3DBackpropInputV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  id: Conv3DBackpropInputV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Conv3DBackpropInputV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  nameWithType: TFGraph.Conv3DBackpropInputV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  fullName: TFGraph.Conv3DBackpropInputV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradients of 3-D convolution with respect to the input.
  syntax:
    content: public TensorFlow.TFOutput Conv3DBackpropInputV2 (TensorFlow.TFOutput input_sizes, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null);
    parameters:
    - id: input_sizes
      type: TensorFlow.TFOutput
      description: >-
        An integer vector representing the tensor shape of <code>input</code>,
                      where <code>input</code> is a 5-D
                      <code>[batch, depth, rows, cols, in_channels]</code> tensor.
    - id: filter
      type: TensorFlow.TFOutput
      description: >-
        Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
                      <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.
    - id: out_backprop
      type: TensorFlow.TFOutput
      description: >-
        Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
                      out_channels]</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The stride of the sliding window for each
                      dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      The data format of the input and output data. With the
                      default format "NDHWC", the data is stored in the order of:
                      [batch, in_depth, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCDHW", the data storage order is:
                      [batch, in_channels, in_depth, in_height, in_width].
    - id: dilations
      type: System.Int64[]
      description: >-
        Optional argument
                      1-D tensor of length 5.  The dilation factor for each dimension of
                      <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each
                      filter element on that dimension. The dimension order is determined by the
                      value of <code>data_format</code>, see above for details. Dilations in the batch and
                      depth dimensions must be 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Conv3DBackpropInputV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Conv3DBackpropInputV2*
  exceptions: []
- uid: TensorFlow.TFGraph.Copy(TensorFlow.TFOutput,System.String,System.String[],System.String)
  id: Copy(TensorFlow.TFOutput,System.String,System.String[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Copy(TFOutput, String, String[], String)
  nameWithType: TFGraph.Copy(TFOutput, String, String[], String)
  fullName: TFGraph.Copy(TFOutput, String, String[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Copy Op.
  remarks: "Performs CPU-to-CPU or GPU-to-GPU deep-copying of tensor, depending on the\n              device on which the tensor is allocated.\n              N.B.: If the all downstream attached debug ops are disabled given the current\n              gRPC gating status, the output will simply forward the input tensor without\n              deep-copying. See the documentation of Debug* ops for more details.\n              \n              Unlike the CopyHost Op, this op does not have HostMemory constraint on its\n              input or output."
  syntax:
    content: public TensorFlow.TFOutput Copy (TensorFlow.TFOutput input, string tensor_name = null, string[] debug_ops_spec = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Input tensor.
    - id: tensor_name
      type: System.String
      description: >-
        Optional argument
                      The name of the input tensor.
    - id: debug_ops_spec
      type: System.String[]
      description: >-
        Optional argument
                      A list of debug op spec (op, url, gated_grpc) for attached debug
                      ops. Each element of the list has the format
                      &lt;debug_op&gt;;&lt;grpc_url&gt;;&lt;gated_grpc&gt;, wherein gated_grpc is boolean represented
                      as 0/1. E.g., "DebugIdentity;grpc://foo:3333;1",
                      "DebugIdentity;file:///tmp/tfdbg_1;0".
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Copy'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Output tensor, deep-copied from input.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Copy*
  exceptions: []
- uid: TensorFlow.TFGraph.CopyHost(TensorFlow.TFOutput,System.String,System.String[],System.String)
  id: CopyHost(TensorFlow.TFOutput,System.String,System.String[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CopyHost(TFOutput, String, String[], String)
  nameWithType: TFGraph.CopyHost(TFOutput, String, String[], String)
  fullName: TFGraph.CopyHost(TFOutput, String, String[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Copy Host Op.
  remarks: "Performs CPU-to-CPU deep-copying of tensor.\n              N.B.: If the all downstream attached debug ops are disabled given the current\n              gRPC gating status, the output will simply forward the input tensor without\n              deep-copying. See the documentation of Debug* ops for more details.\n              \n              Unlike the Copy Op, this op has HostMemory constraint on its input or output."
  syntax:
    content: public TensorFlow.TFOutput CopyHost (TensorFlow.TFOutput input, string tensor_name = null, string[] debug_ops_spec = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Input tensor.
    - id: tensor_name
      type: System.String
      description: >-
        Optional argument
                      The name of the input tensor.
    - id: debug_ops_spec
      type: System.String[]
      description: >-
        Optional argument
                      A list of debug op spec (op, url, gated_grpc) for attached debug
                      ops. Each element of the list has the format
                      &lt;debug_op&gt;;&lt;grpc_url&gt;;&lt;gated_grpc&gt;, wherein gated_grpc is boolean represented
                      as 0/1. E.g., "DebugIdentity;grpc://foo:3333;1",
                      "DebugIdentity;file:///tmp/tfdbg_1;0".
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CopyHost'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Output tensor, deep-copied from input.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CopyHost*
  exceptions: []
- uid: TensorFlow.TFGraph.Cos(TensorFlow.TFOutput,System.String)
  id: Cos(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Cos(TFOutput, String)
  nameWithType: TFGraph.Cos(TFOutput, String)
  fullName: TFGraph.Cos(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes cos of x element-wise.
  syntax:
    content: public TensorFlow.TFOutput Cos (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Cos'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Cos*
  exceptions: []
- uid: TensorFlow.TFGraph.Cosh(TensorFlow.TFOutput,System.String)
  id: Cosh(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Cosh(TFOutput, String)
  nameWithType: TFGraph.Cosh(TFOutput, String)
  fullName: TFGraph.Cosh(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes hyperbolic cosine of x element-wise.
  syntax:
    content: public TensorFlow.TFOutput Cosh (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Cosh'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Cosh*
  exceptions: []
- uid: TensorFlow.TFGraph.CountUpTo(TensorFlow.TFOutput,System.Int64,System.String)
  id: CountUpTo(TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CountUpTo(TFOutput, Int64, String)
  nameWithType: TFGraph.CountUpTo(TFOutput, Int64, String)
  fullName: TFGraph.CountUpTo(TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Increments 'ref' until it reaches 'limit'.
  syntax:
    content: public TensorFlow.TFOutput CountUpTo (TensorFlow.TFOutput reference, long limit, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: Should be from a scalar <code>Variable</code> node.
    - id: limit
      type: System.Int64
      description: >-
        If incrementing ref would bring it above limit, instead generates an
                      'OutOfRange' error.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CountUpTo'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A copy of the input before increment. If nothing else modifies the
                      input, the values produced will all be distinct.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CountUpTo*
  exceptions: []
- uid: TensorFlow.TFGraph.CropAndResize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Single},System.String)
  id: CropAndResize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CropAndResize(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Single>, String)
  nameWithType: TFGraph.CropAndResize(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Single>, String)
  fullName: TFGraph.CropAndResize(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Single>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Extracts crops from the input image tensor and resizes them.
  remarks: "Extracts crops from the input image tensor and resizes them using bilinear\n              sampling or nearest neighbor sampling (possibly with aspect ratio change) to a\n              common output size specified by <code>crop_size</code>. This is more general than the\n              <code>crop_to_bounding_box</code> op which extracts a fixed size slice from the input image\n              and does not allow resizing or aspect ratio change.\n              \n              Returns a tensor with <code>crops</code> from the input <code>image</code> at positions defined at the\n              bounding box locations in <code>boxes</code>. The cropped boxes are all resized (with\n              bilinear or nearest neighbor interpolation) to a fixed\n              <code>size = [crop_height, crop_width]</code>. The result is a 4-D tensor\n              <code>[num_boxes, crop_height, crop_width, depth]</code>. The resizing is corner aligned.\n              In particular, if <code>boxes = [[0, 0, 1, 1]]</code>, the method will give identical\n              results to using <code>tf.image.resize_bilinear()</code> or\n              <code>tf.image.resize_nearest_neighbor()</code>(depends on the <code>method</code> argument) with\n              <code>align_corners=True</code>."
  syntax:
    content: public TensorFlow.TFOutput CropAndResize (TensorFlow.TFOutput image, TensorFlow.TFOutput boxes, TensorFlow.TFOutput box_ind, TensorFlow.TFOutput crop_size, string method = null, Nullable<float> extrapolation_value = null, string operName = null);
    parameters:
    - id: image
      type: TensorFlow.TFOutput
      description: >-
        A 4-D tensor of shape <code>[batch, image_height, image_width, depth]</code>.
                      Both <code>image_height</code> and <code>image_width</code> need to be positive.
    - id: boxes
      type: TensorFlow.TFOutput
      description: >-
        A 2-D tensor of shape <code>[num_boxes, 4]</code>. The <code>i</code>-th row of the tensor
                      specifies the coordinates of a box in the <code>box_ind[i]</code> image and is specified
                      in normalized coordinates <code>[y1, x1, y2, x2]</code>. A normalized coordinate value of
                      <code>y</code> is mapped to the image coordinate at <code>y * (image_height - 1)</code>, so as the
                      <code>[0, 1]</code> interval of normalized image height is mapped to
                      <code>[0, image_height - 1]</code> in image height coordinates. We do allow <code>y1</code> &gt; <code>y2</code>, in
                      which case the sampled crop is an up-down flipped version of the original
                      image. The width dimension is treated similarly. Normalized coordinates
                      outside the <code>[0, 1]</code> range are allowed, in which case we use
                      <code>extrapolation_value</code> to extrapolate the input image values.
    - id: box_ind
      type: TensorFlow.TFOutput
      description: >-
        A 1-D tensor of shape <code>[num_boxes]</code> with int32 values in <code>[0, batch)</code>.
                      The value of <code>box_ind[i]</code> specifies the image that the <code>i</code>-th box refers to.
    - id: crop_size
      type: TensorFlow.TFOutput
      description: >-
        A 1-D tensor of 2 elements, <code>size = [crop_height, crop_width]</code>. All
                      cropped image patches are resized to this size. The aspect ratio of the image
                      content is not preserved. Both <code>crop_height</code> and <code>crop_width</code> need to be
                      positive.
    - id: method
      type: System.String
      description: >-
        Optional argument
                      A string specifying the sampling method for resizing. It can be either
                      <code>"bilinear"</code> or <code>"nearest"</code> and default to <code>"bilinear"</code>. Currently two sampling
                      methods are supported: Bilinear and Nearest Neighbor.
    - id: extrapolation_value
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      Value used for extrapolation, when applicable.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CropAndResize'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A 4-D tensor of shape <code>[num_boxes, crop_height, crop_width, depth]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CropAndResize*
  exceptions: []
- uid: TensorFlow.TFGraph.CropAndResizeGradBoxes(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  id: CropAndResizeGradBoxes(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CropAndResizeGradBoxes(TFOutput, TFOutput, TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.CropAndResizeGradBoxes(TFOutput, TFOutput, TFOutput, TFOutput, String, String)
  fullName: TFGraph.CropAndResizeGradBoxes(TFOutput, TFOutput, TFOutput, TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  syntax:
    content: public TensorFlow.TFOutput CropAndResizeGradBoxes (TensorFlow.TFOutput grads, TensorFlow.TFOutput image, TensorFlow.TFOutput boxes, TensorFlow.TFOutput box_ind, string method = null, string operName = null);
    parameters:
    - id: grads
      type: TensorFlow.TFOutput
      description: To be added.
    - id: image
      type: TensorFlow.TFOutput
      description: To be added.
    - id: boxes
      type: TensorFlow.TFOutput
      description: To be added.
    - id: box_ind
      type: TensorFlow.TFOutput
      description: To be added.
    - id: method
      type: System.String
      description: To be added.
    - id: operName
      type: System.String
      description: To be added.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.CropAndResizeGradBoxes*
  exceptions: []
- uid: TensorFlow.TFGraph.CropAndResizeGradImage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String)
  id: CropAndResizeGradImage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CropAndResizeGradImage(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String, String)
  nameWithType: TFGraph.CropAndResizeGradImage(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String, String)
  fullName: TFGraph.CropAndResizeGradImage(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  syntax:
    content: public TensorFlow.TFOutput CropAndResizeGradImage (TensorFlow.TFOutput grads, TensorFlow.TFOutput boxes, TensorFlow.TFOutput box_ind, TensorFlow.TFOutput image_size, TensorFlow.TFDataType T, string method = null, string operName = null);
    parameters:
    - id: grads
      type: TensorFlow.TFOutput
      description: To be added.
    - id: boxes
      type: TensorFlow.TFOutput
      description: To be added.
    - id: box_ind
      type: TensorFlow.TFOutput
      description: To be added.
    - id: image_size
      type: TensorFlow.TFOutput
      description: To be added.
    - id: T
      type: TensorFlow.TFDataType
      description: To be added.
    - id: method
      type: System.String
      description: To be added.
    - id: operName
      type: System.String
      description: To be added.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.CropAndResizeGradImage*
  exceptions: []
- uid: TensorFlow.TFGraph.Cross(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Cross(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Cross(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Cross(TFOutput, TFOutput, String)
  fullName: TFGraph.Cross(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Compute the pairwise cross product.
  remarks: >-
    <code>a</code> and <code>b</code> must be the same shape; they can either be simple 3-element vectors,
                  or any shape where the innermost dimension is 3. In the latter case, each pair
                  of corresponding 3-element vectors is cross-multiplied independently.
  syntax:
    content: public TensorFlow.TFOutput Cross (TensorFlow.TFOutput a, TensorFlow.TFOutput b, string operName = null);
    parameters:
    - id: a
      type: TensorFlow.TFOutput
      description: A tensor containing 3-element vectors.
    - id: b
      type: TensorFlow.TFOutput
      description: Another tensor, of same type and shape as <code>a</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Cross'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Pairwise cross product of the vectors in <code>a</code> and <code>b</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Cross*
  exceptions: []
- uid: TensorFlow.TFGraph.CrossReplicaSum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: CrossReplicaSum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CrossReplicaSum(TFOutput, TFOutput, String)
  nameWithType: TFGraph.CrossReplicaSum(TFOutput, TFOutput, String)
  fullName: TFGraph.CrossReplicaSum(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An Op to sum inputs across replicated TPU instances. Each instance supplies its
  remarks: "own input.\n              \n              For example, suppose there are 8 TPU instances: <code>[A, B, C, D, E, F, G, H]</code>.\n              Passing group_assignment=<code>[[0,2,4,6],[1,3,5,7]]</code> sets <code>A, C, E, G</code> as group 0,\n              and <code>B, D, F, H</code> as group 1. Thus we get the outputs:\n              <code>[A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H]</code>."
  syntax:
    content: public TensorFlow.TFOutput CrossReplicaSum (TensorFlow.TFOutput input, TensorFlow.TFOutput group_assignment, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The local input to the sum.
    - id: group_assignment
      type: TensorFlow.TFOutput
      description: >-
        An int32 tensor with shape
                      [num_groups, num_replicas_per_group]. <code>group_assignment[i]</code> represents the
                      replica ids in the ith subgroup.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CrossReplicaSum'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The sum of all the distributed inputs.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CrossReplicaSum*
  exceptions: []
- uid: TensorFlow.TFGraph.CTCBeamSearchDecoder(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)
  id: CTCBeamSearchDecoder(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CTCBeamSearchDecoder(TFOutput, TFOutput, Int64, Int64, Nullable<Boolean>, String)
  nameWithType: TFGraph.CTCBeamSearchDecoder(TFOutput, TFOutput, Int64, Int64, Nullable<Boolean>, String)
  fullName: TFGraph.CTCBeamSearchDecoder(TFOutput, TFOutput, Int64, Int64, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Performs beam search decoding on the logits given in input.
  remarks: >-
    A note about the attribute merge_repeated: For the beam search decoder,
                  this means that if consecutive entries in a beam are the same, only
                  the first of these is emitted.  That is, when the top path is "A B B B B",
                  "A B" is returned if merge_repeated = True but "A B B B B" is
                  returned if merge_repeated = False.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput> CTCBeamSearchDecoder (TensorFlow.TFOutput inputs, TensorFlow.TFOutput sequence_length, long beam_width, long top_paths, Nullable<bool> merge_repeated = null, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput
      description: '3-D, shape: <code>(max_time x batch_size x num_classes)</code>, the logits.'
    - id: sequence_length
      type: TensorFlow.TFOutput
      description: A vector containing sequence lengths, size <code>(batch)</code>.
    - id: beam_width
      type: System.Int64
      description: A scalar &gt;= 0 (beam search beam width).
    - id: top_paths
      type: System.Int64
      description: A scalar &gt;= 0, &lt;= beam_width (controls output size).
    - id: merge_repeated
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, merge repeated classes in output.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CTCBeamSearchDecoder'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      decoded_indices: A list (length: top_paths) of indices matrices.  Matrix j,
                      size <code>(total_decoded_outputs[j] x 2)</code>, has indices of a
                      <code>SparseTensor&lt;int64, 2&gt;</code>.  The rows store: [batch, time].
                      decoded_values: A list (length: top_paths) of values vectors.  Vector j,
                      size <code>(length total_decoded_outputs[j])</code>, has the values of a
                      <code>SparseTensor&lt;int64, 2&gt;</code>.  The vector stores the decoded classes for beam j.
                      decoded_shape: A list (length: top_paths) of shape vector.  Vector j,
                      size <code>(2)</code>, stores the shape of the decoded <code>SparseTensor[j]</code>.
                      Its values are: <code>[batch_size, max_decoded_length[j]]</code>.
                      log_probability: A matrix, shaped: <code>(batch_size x top_paths)</code>.  The
                      sequence log-probabilities.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.CTCBeamSearchDecoder*
  exceptions: []
- uid: TensorFlow.TFGraph.CTCGreedyDecoder(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: CTCGreedyDecoder(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CTCGreedyDecoder(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.CTCGreedyDecoder(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.CTCGreedyDecoder(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Performs greedy decoding on the logits given in inputs.
  remarks: "A note about the attribute merge_repeated: if enabled, when\n              consecutive logits' maximum indices are the same, only the first of\n              these is emitted.  Labeling the blank '*', the sequence \"A B B * B B\"\n              becomes \"A B B\" if merge_repeated = True and \"A B B B B\" if\n              merge_repeated = False.\n              \n              Regardless of the value of merge_repeated, if the maximum index of a given\n              time and batch corresponds to the blank, index <code>(num_classes - 1)</code>, no new\n              element is emitted."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> CTCGreedyDecoder (TensorFlow.TFOutput inputs, TensorFlow.TFOutput sequence_length, Nullable<bool> merge_repeated = null, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput
      description: '3-D, shape: <code>(max_time x batch_size x num_classes)</code>, the logits.'
    - id: sequence_length
      type: TensorFlow.TFOutput
      description: A vector containing sequence lengths, size <code>(batch_size)</code>.
    - id: merge_repeated
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, merge repeated classes in output.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CTCGreedyDecoder'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      decoded_indices: Indices matrix, size <code>(total_decoded_outputs x 2)</code>,
                      of a <code>SparseTensor&lt;int64, 2&gt;</code>.  The rows store: [batch, time].
                      decoded_values: Values vector, size: <code>(total_decoded_outputs)</code>,
                      of a <code>SparseTensor&lt;int64, 2&gt;</code>.  The vector stores the decoded classes.
                      decoded_shape: Shape vector, size <code>(2)</code>, of the decoded SparseTensor.
                      Values are: <code>[batch_size, max_decoded_length]</code>.
                      log_probability: Matrix, size <code>(batch_size x 1)</code>, containing sequence
                      log-probabilities.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.CTCGreedyDecoder*
  exceptions: []
- uid: TensorFlow.TFGraph.CTCLoss(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: CTCLoss(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CTCLoss(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.CTCLoss(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.CTCLoss(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Calculates the CTC Loss (log probability) for each batch entry.  Also calculates
  remarks: >-
    the gradient.  This class performs the softmax operation for you, so inputs
                  should be e.g. linear projections of outputs by an LSTM.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> CTCLoss (TensorFlow.TFOutput inputs, TensorFlow.TFOutput labels_indices, TensorFlow.TFOutput labels_values, TensorFlow.TFOutput sequence_length, Nullable<bool> preprocess_collapse_repeated = null, Nullable<bool> ctc_merge_repeated = null, Nullable<bool> ignore_longer_outputs_than_inputs = null, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput
      description: '3-D, shape: <code>(max_time x batch_size x num_classes)</code>, the logits.'
    - id: labels_indices
      type: TensorFlow.TFOutput
      description: >-
        The indices of a <code>SparseTensor&lt;int32, 2&gt;</code>.
                      <code>labels_indices(i, :) == [b, t]</code> means <code>labels_values(i)</code> stores the id for
                      <code>(batch b, time t)</code>.
    - id: labels_values
      type: TensorFlow.TFOutput
      description: The values (labels) associated with the given batch and time.
    - id: sequence_length
      type: TensorFlow.TFOutput
      description: A vector containing sequence lengths (batch).
    - id: preprocess_collapse_repeated
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Scalar, if true then repeated labels are
                      collapsed prior to the CTC calculation.
    - id: ctc_merge_repeated
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Scalar.  If set to false, *during* CTC calculation
                      repeated non-blank labels will not be merged and are interpreted as
                      individual labels.  This is a simplified version of CTC.
    - id: ignore_longer_outputs_than_inputs
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Scalar. If set to true, during CTC
                      calculation, items that have longer output sequences than input sequences
                      are skipped: they don't contribute to the loss term and have zero-gradient.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CTCLoss'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      loss: A vector (batch) containing log-probabilities.
                      gradient: The gradient of <code>loss</code>.  3-D, shape:
                      <code>(max_time x batch_size x num_classes)</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.CTCLoss*
  exceptions: []
- uid: TensorFlow.TFGraph.CudnnRNN(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  id: CudnnRNN(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CudnnRNN(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.CudnnRNN(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.CudnnRNN(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A RNN backed by cuDNN.
  remarks: "Computes the RNN from the input and initial states, with respect to the params\n              buffer.\n              \n              rnn_mode: Indicates the type of the RNN model.\n              input_mode: Indicate whether there is a linear projection between the input and\n              the actual computation before the first layer. 'skip_input' is only allowed\n              when input_size == num_units; 'auto_select' implies 'skip_input' when\n              input_size == num_units; otherwise, it implies 'linear_input'.\n              direction: Indicates whether a bidirectional model will be used. Should be\n              \"unidirectional\" or \"bidirectional\".\n              dropout: Dropout probability. When set to 0., dropout is disabled.\n              seed: The 1st part of a seed to initialize dropout.\n              seed2: The 2nd part of a seed to initialize dropout.\n              input: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\n              input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n              num_units].\n              input_c: For LSTM, a 3-D tensor with the shape of\n              [num_layer * dir, batch, num_units]. For other models, it is ignored.\n              params: A 1-D tensor that contains the weights and biases in an opaque layout.\n              The size must be created through CudnnRNNParamsSize, and initialized\n              separately. Note that they might not be compatible across different\n              generations. So it is a good idea to save and restore\n              output: A 3-D tensor with the shape of [seq_length, batch_size,\n              dir * num_units].\n              output_h: The same shape has input_h.\n              output_c: The same shape as input_c for LSTM. An empty tensor for other models.\n              is_training: Indicates whether this operation is used for inferenece or\n              training.\n              reserve_space: An opaque tensor that can be used in backprop calculation. It\n              is only produced if is_training is false."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> CudnnRNN (TensorFlow.TFOutput input, TensorFlow.TFOutput input_h, TensorFlow.TFOutput input_c, TensorFlow.TFOutput parameters, string rnn_mode = null, string input_mode = null, string direction = null, Nullable<float> dropout = null, Nullable<long> seed = null, Nullable<long> seed2 = null, Nullable<bool> is_training = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_h
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_c
      type: TensorFlow.TFOutput
      description: To be added.
    - id: parameters
      type: TensorFlow.TFOutput
      description: To be added.
    - id: rnn_mode
      type: System.String
      description: Optional argument
    - id: input_mode
      type: System.String
      description: Optional argument
    - id: direction
      type: System.String
      description: Optional argument
    - id: dropout
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: seed
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: seed2
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: is_training
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNN'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output:
                      output_h:
                      output_c:
                      reserve_space:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.CudnnRNN*
  exceptions: []
- uid: TensorFlow.TFGraph.CudnnRNNBackprop(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: CudnnRNNBackprop(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CudnnRNNBackprop(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.CudnnRNNBackprop(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.CudnnRNNBackprop(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Backprop step of CudnnRNN.
  remarks: "Compute the backprop of both data and weights in a RNN.\n              \n              rnn_mode: Indicates the type of the RNN model.\n              input_mode: Indicate whether there is a linear projection between the input and\n              the actual computation before the first layer. 'skip_input' is only allowed\n              when input_size == num_units; 'auto_select' implies 'skip_input' when\n              input_size == num_units; otherwise, it implies 'linear_input'.\n              direction: Indicates whether a bidirectional model will be used. Should be\n              \"unidirectional\" or \"bidirectional\".\n              dropout: Dropout probability. When set to 0., dropout is disabled.\n              seed: The 1st part of a seed to initialize dropout.\n              seed2: The 2nd part of a seed to initialize dropout.\n              input: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\n              input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n              num_units].\n              input_c: For LSTM, a 3-D tensor with the shape of\n              [num_layer * dir, batch, num_units]. For other models, it is ignored.\n              params: A 1-D tensor that contains the weights and biases in an opaque layout.\n              The size must be created through CudnnRNNParamsSize, and initialized\n              separately. Note that they might not be compatible across different\n              generations. So it is a good idea to save and restore\n              output: A 3-D tensor with the shape of [seq_length, batch_size,\n              dir * num_units].\n              output_h: The same shape has input_h.\n              output_c: The same shape as input_c for LSTM. An empty tensor for other models.\n              output_backprop: A 3-D tensor with the same shape as output in the forward pass.\n              output_h_backprop: A 3-D tensor with the same shape as output_h in the forward\n              pass.\n              output_c_backprop: A 3-D tensor with the same shape as output_c in the forward\n              pass.\n              reserve_space: The same reserve_space produced in for forward operation.\n              input_backprop: The backprop to input in the forward pass. Has the same shape\n              as input.\n              input_h_backprop: The backprop to input_h in the forward pass. Has the same\n              shape as input_h.\n              input_c_backprop: The backprop to input_c in the forward pass. Has the same\n              shape as input_c.\n              params_backprop: The backprop to the params buffer in the forward pass. Has the\n              same shape as params."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> CudnnRNNBackprop (TensorFlow.TFOutput input, TensorFlow.TFOutput input_h, TensorFlow.TFOutput input_c, TensorFlow.TFOutput parameters, TensorFlow.TFOutput output, TensorFlow.TFOutput output_h, TensorFlow.TFOutput output_c, TensorFlow.TFOutput output_backprop, TensorFlow.TFOutput output_h_backprop, TensorFlow.TFOutput output_c_backprop, TensorFlow.TFOutput reserve_space, string rnn_mode = null, string input_mode = null, string direction = null, Nullable<float> dropout = null, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_h
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_c
      type: TensorFlow.TFOutput
      description: To be added.
    - id: parameters
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_h
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_c
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_backprop
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_h_backprop
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_c_backprop
      type: TensorFlow.TFOutput
      description: To be added.
    - id: reserve_space
      type: TensorFlow.TFOutput
      description: To be added.
    - id: rnn_mode
      type: System.String
      description: Optional argument
    - id: input_mode
      type: System.String
      description: Optional argument
    - id: direction
      type: System.String
      description: Optional argument
    - id: dropout
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: seed
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: seed2
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNBackprop'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      input_backprop:
                      input_h_backprop:
                      input_c_backprop:
                      params_backprop:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.CudnnRNNBackprop*
  exceptions: []
- uid: TensorFlow.TFGraph.CudnnRNNBackpropV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: CudnnRNNBackpropV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CudnnRNNBackpropV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.CudnnRNNBackpropV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.CudnnRNNBackpropV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Backprop step of CudnnRNN.
  remarks: "Compute the backprop of both data and weights in a RNN. Takes an extra\n              \"host_reserved\" inupt than CudnnRNNBackprop, which is used to determine RNN\n              cudnnRNNAlgo_t and cudnnMathType_t.\n              \n              rnn_mode: Indicates the type of the RNN model.\n              input_mode: Indicates whether there is a linear projection between the input and\n              the actual computation before the first layer. 'skip_input' is only allowed\n              when input_size == num_units; 'auto_select' implies 'skip_input' when\n              input_size == num_units; otherwise, it implies 'linear_input'.\n              direction: Indicates whether a bidirectional model will be used. Should be\n              \"unidirectional\" or \"bidirectional\".\n              dropout: Dropout probability. When set to 0., dropout is disabled.\n              seed: The 1st part of a seed to initialize dropout.\n              seed2: The 2nd part of a seed to initialize dropout.\n              input: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\n              input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n              num_units].\n              input_c: For LSTM, a 3-D tensor with the shape of\n              [num_layer * dir, batch, num_units]. For other models, it is ignored.\n              params: A 1-D tensor that contains the weights and biases in an opaque layout.\n              The size must be created through CudnnRNNParamsSize, and initialized\n              separately. Note that they might not be compatible across different\n              generations. So it is a good idea to save and restore\n              output: A 3-D tensor with the shape of [seq_length, batch_size,\n              dir * num_units].\n              output_h: The same shape has input_h.\n              output_c: The same shape as input_c for LSTM. An empty tensor for other models.\n              output_backprop: A 3-D tensor with the same shape as output in the forward pass.\n              output_h_backprop: A 3-D tensor with the same shape as output_h in the forward\n              pass.\n              output_c_backprop: A 3-D tensor with the same shape as output_c in the forward\n              pass.\n              reserve_space: The same reserve_space produced in the forward operation.\n              host_reserved: The same host_reserved produced in the forward operation.\n              input_backprop: The backprop to input in the forward pass. Has the same shape\n              as input.\n              input_h_backprop: The backprop to input_h in the forward pass. Has the same\n              shape as input_h.\n              input_c_backprop: The backprop to input_c in the forward pass. Has the same\n              shape as input_c.\n              params_backprop: The backprop to the params buffer in the forward pass. Has the\n              same shape as params."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> CudnnRNNBackpropV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput input_h, TensorFlow.TFOutput input_c, TensorFlow.TFOutput parameters, TensorFlow.TFOutput output, TensorFlow.TFOutput output_h, TensorFlow.TFOutput output_c, TensorFlow.TFOutput output_backprop, TensorFlow.TFOutput output_h_backprop, TensorFlow.TFOutput output_c_backprop, TensorFlow.TFOutput reserve_space, TensorFlow.TFOutput host_reserved, string rnn_mode = null, string input_mode = null, string direction = null, Nullable<float> dropout = null, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_h
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_c
      type: TensorFlow.TFOutput
      description: To be added.
    - id: parameters
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_h
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_c
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_backprop
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_h_backprop
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_c_backprop
      type: TensorFlow.TFOutput
      description: To be added.
    - id: reserve_space
      type: TensorFlow.TFOutput
      description: To be added.
    - id: host_reserved
      type: TensorFlow.TFOutput
      description: To be added.
    - id: rnn_mode
      type: System.String
      description: Optional argument
    - id: input_mode
      type: System.String
      description: Optional argument
    - id: direction
      type: System.String
      description: Optional argument
    - id: dropout
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: seed
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: seed2
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNBackpropV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      input_backprop:
                      input_h_backprop:
                      input_c_backprop:
                      params_backprop:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.CudnnRNNBackpropV2*
  exceptions: []
- uid: TensorFlow.TFGraph.CudnnRNNCanonicalToParams(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: CudnnRNNCanonicalToParams(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CudnnRNNCanonicalToParams(TFOutput, TFOutput, TFOutput, TFOutput[], TFOutput[], String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.CudnnRNNCanonicalToParams(TFOutput, TFOutput, TFOutput, TFOutput[], TFOutput[], String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.CudnnRNNCanonicalToParams(TFOutput, TFOutput, TFOutput, TFOutput[], TFOutput[], String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts CudnnRNN params from canonical form to usable form.
  remarks: "Writes a set of weights into the opaque params buffer so they can be used in\n              upcoming training or inferences.\n              \n              Note that the params buffer may not be compatible across different GPUs. So any\n              save and restoration should be converted to and from the canonical weights and\n              biases.\n              \n              num_layers: Specifies the number of layers in the RNN model.\n              num_units: Specifies the size of the hidden state.\n              input_size: Specifies the size of the input state.\n              weights: the canonical form of weights that can be used for saving\n              and restoration. They are more likely to be compatible across different\n              generations.\n              biases: the canonical form of biases that can be used for saving\n              and restoration. They are more likely to be compatible across different\n              generations.\n              num_params: number of parameter sets for all layers.\n              Each layer may contain multiple parameter sets, with each set consisting of\n              a weight matrix and a bias vector.\n              rnn_mode: Indicates the type of the RNN model.\n              input_mode: Indicate whether there is a linear projection between the input and\n              The actual computation before the first layer. 'skip_input' is only allowed\n              when input_size == num_units; 'auto_select' implies 'skip_input' when\n              input_size == num_units; otherwise, it implies 'linear_input'.\n              direction: Indicates whether a bidirectional model will be used.\n              dir = (direction == bidirectional) ? 2 : 1\n              dropout: dropout probability. When set to 0., dropout is disabled.\n              seed: the 1st part of a seed to initialize dropout.\n              seed2: the 2nd part of a seed to initialize dropout."
  syntax:
    content: public TensorFlow.TFOutput CudnnRNNCanonicalToParams (TensorFlow.TFOutput num_layers, TensorFlow.TFOutput num_units, TensorFlow.TFOutput input_size, TensorFlow.TFOutput[] weights, TensorFlow.TFOutput[] biases, string rnn_mode = null, string input_mode = null, string direction = null, Nullable<float> dropout = null, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: num_layers
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_units
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_size
      type: TensorFlow.TFOutput
      description: To be added.
    - id: weights
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: biases
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: rnn_mode
      type: System.String
      description: Optional argument
    - id: input_mode
      type: System.String
      description: Optional argument
    - id: direction
      type: System.String
      description: Optional argument
    - id: dropout
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: seed
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: seed2
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNCanonicalToParams'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CudnnRNNCanonicalToParams*
  exceptions: []
- uid: TensorFlow.TFGraph.CudnnRNNParamsSize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: CudnnRNNParamsSize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CudnnRNNParamsSize(TFOutput, TFOutput, TFOutput, TFDataType, TFDataType, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.CudnnRNNParamsSize(TFOutput, TFOutput, TFOutput, TFDataType, TFDataType, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.CudnnRNNParamsSize(TFOutput, TFOutput, TFOutput, TFDataType, TFDataType, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes size of weights that can be used by a Cudnn RNN model.
  remarks: "Return the params size that can be used by the Cudnn RNN model. Subsequent\n              weight allocation and initialization should use this size.\n              \n              num_layers: Specifies the number of layers in the RNN model.\n              num_units: Specifies the size of the hidden state.\n              input_size: Specifies the size of the input state.\n              rnn_mode: Indicates the type of the RNN model.\n              input_mode: Indicate whether there is a linear projection between the input and\n              The actual computation before the first layer. 'skip_input' is only allowed\n              when input_size == num_units; 'auto_select' implies 'skip_input' when\n              input_size == num_units; otherwise, it implies 'linear_input'.\n              direction: Indicates whether a bidirectional model will be used.\n              dir = (direction == bidirectional) ? 2 : 1\n              dropout: dropout probability. When set to 0., dropout is disabled.\n              seed: the 1st part of a seed to initialize dropout.\n              seed2: the 2nd part of a seed to initialize dropout.\n              params_size: The size of the params buffer that should be allocated and\n              initialized for this RNN model. Note that this params buffer may not be\n              compatible across GPUs. Please use CudnnRNNParamsWeights and\n              CudnnRNNParamsBiases to save and restore them in a way that is compatible\n              across different runs."
  syntax:
    content: public TensorFlow.TFOutput CudnnRNNParamsSize (TensorFlow.TFOutput num_layers, TensorFlow.TFOutput num_units, TensorFlow.TFOutput input_size, TensorFlow.TFDataType T, TensorFlow.TFDataType S, string rnn_mode = null, string input_mode = null, string direction = null, Nullable<float> dropout = null, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: num_layers
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_units
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_size
      type: TensorFlow.TFOutput
      description: To be added.
    - id: T
      type: TensorFlow.TFDataType
      description: To be added.
    - id: S
      type: TensorFlow.TFDataType
      description: To be added.
    - id: rnn_mode
      type: System.String
      description: Optional argument
    - id: input_mode
      type: System.String
      description: Optional argument
    - id: direction
      type: System.String
      description: Optional argument
    - id: dropout
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: seed
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: seed2
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNParamsSize'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.CudnnRNNParamsSize*
  exceptions: []
- uid: TensorFlow.TFGraph.CudnnRNNParamsToCanonical(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: CudnnRNNParamsToCanonical(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CudnnRNNParamsToCanonical(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.CudnnRNNParamsToCanonical(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.CudnnRNNParamsToCanonical(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieves CudnnRNN params in canonical form.
  remarks: "Retrieves a set of weights from the opaque params buffer that can be saved and\n              restored in a way compatible with future runs.\n              \n              Note that the params buffer may not be compatible across different GPUs. So any\n              save and restoration should be converted to and from the canonical weights and\n              biases.\n              \n              num_layers: Specifies the number of layers in the RNN model.\n              num_units: Specifies the size of the hidden state.\n              input_size: Specifies the size of the input state.\n              num_params: number of parameter sets for all layers.\n              Each layer may contain multiple parameter sets, with each set consisting of\n              a weight matrix and a bias vector.\n              weights: the canonical form of weights that can be used for saving\n              and restoration. They are more likely to be compatible across different\n              generations.\n              biases: the canonical form of biases that can be used for saving\n              and restoration. They are more likely to be compatible across different\n              generations.\n              rnn_mode: Indicates the type of the RNN model.\n              input_mode: Indicate whether there is a linear projection between the input and\n              The actual computation before the first layer. 'skip_input' is only allowed\n              when input_size == num_units; 'auto_select' implies 'skip_input' when\n              input_size == num_units; otherwise, it implies 'linear_input'.\n              direction: Indicates whether a bidirectional model will be used.\n              dir = (direction == bidirectional) ? 2 : 1\n              dropout: dropout probability. When set to 0., dropout is disabled.\n              seed: the 1st part of a seed to initialize dropout.\n              seed2: the 2nd part of a seed to initialize dropout."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[]> CudnnRNNParamsToCanonical (TensorFlow.TFOutput num_layers, TensorFlow.TFOutput num_units, TensorFlow.TFOutput input_size, TensorFlow.TFOutput parameters, long num_params, string rnn_mode = null, string input_mode = null, string direction = null, Nullable<float> dropout = null, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: num_layers
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_units
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_size
      type: TensorFlow.TFOutput
      description: To be added.
    - id: parameters
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_params
      type: System.Int64
      description: To be added.
    - id: rnn_mode
      type: System.String
      description: Optional argument
    - id: input_mode
      type: System.String
      description: Optional argument
    - id: direction
      type: System.String
      description: Optional argument
    - id: dropout
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: seed
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: seed2
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNParamsToCanonical'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[]}
      description: >-
        Returns a tuple with multiple values, as follows:
                      weights:
                      biases:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.CudnnRNNParamsToCanonical*
  exceptions: []
- uid: TensorFlow.TFGraph.CudnnRNNV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  id: CudnnRNNV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CudnnRNNV2(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.CudnnRNNV2(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.CudnnRNNV2(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A RNN backed by cuDNN.
  remarks: "Computes the RNN from the input and initial states, with respect to the params\n              buffer. Produces one extra output \"host_reserved\" than CudnnRNN.\n              \n              rnn_mode: Indicates the type of the RNN model.\n              input_mode: Indicates whether there is a linear projection between the input and\n              the actual computation before the first layer. 'skip_input' is only allowed\n              when input_size == num_units; 'auto_select' implies 'skip_input' when\n              input_size == num_units; otherwise, it implies 'linear_input'.\n              direction: Indicates whether a bidirectional model will be used. Should be\n              \"unidirectional\" or \"bidirectional\".\n              dropout: Dropout probability. When set to 0., dropout is disabled.\n              seed: The 1st part of a seed to initialize dropout.\n              seed2: The 2nd part of a seed to initialize dropout.\n              input: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\n              input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n              num_units].\n              input_c: For LSTM, a 3-D tensor with the shape of\n              [num_layer * dir, batch, num_units]. For other models, it is ignored.\n              params: A 1-D tensor that contains the weights and biases in an opaque layout.\n              The size must be created through CudnnRNNParamsSize, and initialized\n              separately. Note that they might not be compatible across different\n              generations. So it is a good idea to save and restore\n              output: A 3-D tensor with the shape of [seq_length, batch_size,\n              dir * num_units].\n              output_h: The same shape has input_h.\n              output_c: The same shape as input_c for LSTM. An empty tensor for other models.\n              is_training: Indicates whether this operation is used for inferenece or\n              training.\n              reserve_space: An opaque tensor that can be used in backprop calculation. It\n              is only produced if is_training is true.\n              host_reserved: An opaque tensor that can be used in backprop calculation. It is\n              only produced if is_training is true. It is output on host memory rather than\n              device memory."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> CudnnRNNV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput input_h, TensorFlow.TFOutput input_c, TensorFlow.TFOutput parameters, string rnn_mode = null, string input_mode = null, string direction = null, Nullable<float> dropout = null, Nullable<long> seed = null, Nullable<long> seed2 = null, Nullable<bool> is_training = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_h
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_c
      type: TensorFlow.TFOutput
      description: To be added.
    - id: parameters
      type: TensorFlow.TFOutput
      description: To be added.
    - id: rnn_mode
      type: System.String
      description: Optional argument
    - id: input_mode
      type: System.String
      description: Optional argument
    - id: direction
      type: System.String
      description: Optional argument
    - id: dropout
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: seed
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: seed2
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: is_training
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'CudnnRNNV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output:
                      output_h:
                      output_c:
                      reserve_space:
                      host_reserved:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.CudnnRNNV2*
  exceptions: []
- uid: TensorFlow.TFGraph.Cumprod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: Cumprod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Cumprod(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.Cumprod(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.Cumprod(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Compute the cumulative product of the tensor <code>x</code> along <code>axis</code>.
  remarks: "By default, this op performs an inclusive cumprod, which means that the first\n              element of the input is identical to the first element of the output:\n              \n               <pre><code>\n              tf.cumprod([a, b, c])  # =&gt; [a, a * b, a * b * c]\n               </code></pre>\n              \n              By setting the <code>exclusive</code> kwarg to <code>True</code>, an exclusive cumprod is\n              performed instead:\n              \n               <pre><code>\n              tf.cumprod([a, b, c], exclusive=True)  # =&gt; [1, a, a * b]\n               </code></pre>\n              \n              By setting the <code>reverse</code> kwarg to <code>True</code>, the cumprod is performed in the\n              opposite direction:\n              \n               <pre><code>\n              tf.cumprod([a, b, c], reverse=True)  # =&gt; [a * b * c, b * c, c]\n               </code></pre>\n              \n              This is more efficient than using separate <code>tf.reverse</code> ops.\n              \n              The <code>reverse</code> and <code>exclusive</code> kwargs can also be combined:\n              \n               <pre><code>\n              tf.cumprod([a, b, c], exclusive=True, reverse=True)  # =&gt; [b * c, c, 1]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Cumprod (TensorFlow.TFOutput x, TensorFlow.TFOutput axis, Nullable<bool> exclusive = null, Nullable<bool> reverse = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: >-
        A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>,
                      <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>,
                      <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    - id: axis
      type: TensorFlow.TFOutput
      description: >-
        A <code>Tensor</code> of type <code>int32</code> (default: 0). Must be in the range
                      <code>[-rank(x), rank(x))</code>.
    - id: exclusive
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, perform exclusive cumprod.
    - id: reverse
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      A <code>bool</code> (default: False).
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Cumprod'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Cumprod*
  exceptions: []
- uid: TensorFlow.TFGraph.Cumsum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: Cumsum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Cumsum(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.Cumsum(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.Cumsum(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Compute the cumulative sum of the tensor <code>x</code> along <code>axis</code>.
  remarks: "By default, this op performs an inclusive cumsum, which means that the first\n              element of the input is identical to the first element of the output:\n              \n               <pre><code>\n              tf.cumsum([a, b, c])  # =&gt; [a, a + b, a + b + c]\n               </code></pre>\n              \n              By setting the <code>exclusive</code> kwarg to <code>True</code>, an exclusive cumsum is\n              performed instead:\n              \n               <pre><code>\n              tf.cumsum([a, b, c], exclusive=True)  # =&gt; [0, a, a + b]\n               </code></pre>\n              \n              By setting the <code>reverse</code> kwarg to <code>True</code>, the cumsum is performed in the\n              opposite direction:\n              \n               <pre><code>\n              tf.cumsum([a, b, c], reverse=True)  # =&gt; [a + b + c, b + c, c]\n               </code></pre>\n              \n              This is more efficient than using separate <code>tf.reverse</code> ops.\n              \n              The <code>reverse</code> and <code>exclusive</code> kwargs can also be combined:\n              \n               <pre><code>\n              tf.cumsum([a, b, c], exclusive=True, reverse=True)  # =&gt; [b + c, c, 0]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Cumsum (TensorFlow.TFOutput x, TensorFlow.TFOutput axis, Nullable<bool> exclusive = null, Nullable<bool> reverse = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: >-
        A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>,
                      <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>,
                      <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.
    - id: axis
      type: TensorFlow.TFOutput
      description: >-
        A <code>Tensor</code> of type <code>int32</code> (default: 0). Must be in the range
                      <code>[-rank(x), rank(x))</code>.
    - id: exclusive
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, perform exclusive cumsum.
    - id: reverse
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      A <code>bool</code> (default: False).
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Cumsum'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Cumsum*
  exceptions: []
- uid: TensorFlow.TFGraph.CurrentDependencies
  id: CurrentDependencies
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CurrentDependencies
  nameWithType: TFGraph.CurrentDependencies
  fullName: TFGraph.CurrentDependencies
  type: Property
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: "Returns the current variable dependencies in use. New tensors and operations will be created\n            with an added input dependency to the operations specified in this property. To change this, \n            use the WithDependencies method."
  syntax:
    content: public TensorFlow.TFOperation[] CurrentDependencies { get; }
    return:
      type: TensorFlow.TFOperation[]
      description: The current input dependencies to be used for new tensors and operations.
  overload: TensorFlow.TFGraph.CurrentDependencies*
  exceptions: []
- uid: TensorFlow.TFGraph.CurrentNameScope
  id: CurrentNameScope
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: CurrentNameScope
  nameWithType: TFGraph.CurrentNameScope
  fullName: TFGraph.CurrentNameScope
  type: Property
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the current name scope in use, to change this, use the WithScope method.
  syntax:
    content: public string CurrentNameScope { get; }
    return:
      type: System.String
      description: The current name scope.
  overload: TensorFlow.TFGraph.CurrentNameScope*
  exceptions: []
- uid: TensorFlow.TFGraph.DataFormatDimMap(TensorFlow.TFOutput,System.String,System.String,System.String)
  id: DataFormatDimMap(TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DataFormatDimMap(TFOutput, String, String, String)
  nameWithType: TFGraph.DataFormatDimMap(TFOutput, String, String, String)
  fullName: TFGraph.DataFormatDimMap(TFOutput, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the dimension index in the destination data format given the one in
  remarks: the source data format.
  syntax:
    content: public TensorFlow.TFOutput DataFormatDimMap (TensorFlow.TFOutput x, string src_format = null, string dst_format = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: >-
        A Tensor with each element as a dimension index in source data format.
                      Must be in the range [-4, 4).
    - id: src_format
      type: System.String
      description: >-
        Optional argument
                      source data format.
    - id: dst_format
      type: System.String
      description: >-
        Optional argument
                      destination data format.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DataFormatDimMap'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A Tensor with each element as a dimension index in destination data format.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DataFormatDimMap*
  exceptions: []
- uid: TensorFlow.TFGraph.DataFormatVecPermute(TensorFlow.TFOutput,System.String,System.String,System.String)
  id: DataFormatVecPermute(TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DataFormatVecPermute(TFOutput, String, String, String)
  nameWithType: TFGraph.DataFormatVecPermute(TFOutput, String, String, String)
  fullName: TFGraph.DataFormatVecPermute(TFOutput, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the permuted vector/tensor in the destination data format given the
  remarks: one in the source data format.
  syntax:
    content: public TensorFlow.TFOutput DataFormatVecPermute (TensorFlow.TFOutput x, string src_format = null, string dst_format = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: Vector of size 4 or Tensor of shape (4, 2) in source data format.
    - id: src_format
      type: System.String
      description: >-
        Optional argument
                      source data format.
    - id: dst_format
      type: System.String
      description: >-
        Optional argument
                      destination data format.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DataFormatVecPermute'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Vector of size 4 or Tensor of shape (4, 2) in destination data format.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DataFormatVecPermute*
  exceptions: []
- uid: TensorFlow.TFGraph.DatasetToGraph(TensorFlow.TFOutput,System.String)
  id: DatasetToGraph(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DatasetToGraph(TFOutput, String)
  nameWithType: TFGraph.DatasetToGraph(TFOutput, String)
  fullName: TFGraph.DatasetToGraph(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns a serialized GraphDef representing <code>input_dataset</code>.
  remarks: Returns a graph representation for <code>input_dataset</code>.
  syntax:
    content: public TensorFlow.TFOutput DatasetToGraph (TensorFlow.TFOutput input_dataset, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: A variant tensor representing the dataset to return the graph representation for.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DatasetToGraph'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The graph representation of the dataset (as serialized GraphDef).
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DatasetToGraph*
  exceptions: []
- uid: TensorFlow.TFGraph.DatasetToSingleElement(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: DatasetToSingleElement(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DatasetToSingleElement(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.DatasetToSingleElement(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.DatasetToSingleElement(TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs the single element from the given dataset.
  syntax:
    content: public TensorFlow.TFOutput[] DatasetToSingleElement (TensorFlow.TFOutput dataset, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: dataset
      type: TensorFlow.TFOutput
      description: A handle to a dataset that contains a single element.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DatasetToSingleElement'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        The components of the single element of <code>input</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DatasetToSingleElement*
  exceptions: []
- uid: TensorFlow.TFGraph.DebugGradientIdentity(TensorFlow.TFOutput,System.String)
  id: DebugGradientIdentity(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DebugGradientIdentity(TFOutput, String)
  nameWithType: TFGraph.DebugGradientIdentity(TFOutput, String)
  fullName: TFGraph.DebugGradientIdentity(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Identity op for gradient debugging.
  remarks: >-
    This op is hidden from public in Python. It is used by TensorFlow Debugger to
                  register gradient tensors for gradient debugging.
                  This op operates on non-reference-type tensors.
  syntax:
    content: public TensorFlow.TFOutput DebugGradientIdentity (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugGradientIdentity'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DebugGradientIdentity*
  exceptions: []
- uid: TensorFlow.TFGraph.DebugGradientRefIdentity(TensorFlow.TFOutput,System.String)
  id: DebugGradientRefIdentity(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DebugGradientRefIdentity(TFOutput, String)
  nameWithType: TFGraph.DebugGradientRefIdentity(TFOutput, String)
  fullName: TFGraph.DebugGradientRefIdentity(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Identity op for gradient debugging.
  remarks: >-
    This op is hidden from public in Python. It is used by TensorFlow Debugger to
                  register gradient tensors for gradient debugging.
                  This op operates on reference-type tensors.
  syntax:
    content: public TensorFlow.TFOutput DebugGradientRefIdentity (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugGradientRefIdentity'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DebugGradientRefIdentity*
  exceptions: []
- uid: TensorFlow.TFGraph.DebugIdentity(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Boolean},System.String)
  id: DebugIdentity(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DebugIdentity(TFOutput, String, String, String[], Nullable<Boolean>, String)
  nameWithType: TFGraph.DebugIdentity(TFOutput, String, String, String[], Nullable<Boolean>, String)
  fullName: TFGraph.DebugIdentity(TFOutput, String, String, String[], Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Debug Identity Op.
  remarks: Provides an identity mapping of the non-Ref type input tensor for debugging.
  syntax:
    content: public TensorFlow.TFOutput DebugIdentity (TensorFlow.TFOutput input, string device_name = null, string tensor_name = null, string[] debug_urls = null, Nullable<bool> gated_grpc = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Input tensor, non-Reference type.
    - id: device_name
      type: System.String
      description: Optional argument
    - id: tensor_name
      type: System.String
      description: >-
        Optional argument
                      Name of the input tensor.
    - id: debug_urls
      type: System.String[]
      description: >-
        Optional argument
                      List of URLs to debug targets, e.g.,
                      file:///foo/tfdbg_dump, grpc:://localhost:11011
    - id: gated_grpc
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Whether this op will be gated. If any of the debug_urls of this
                      debug node is of the grpc:// scheme, when the value of this attribute is set
                      to True, the data will not actually be sent via the grpc stream unless this
                      debug op has been enabled at the debug_url. If all of the debug_urls of this
                      debug node are of the grpc:// scheme and the debug op is enabled at none of
                      them, the output will be an empty Tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugIdentity'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Output tensor that equals the input tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DebugIdentity*
  exceptions: []
- uid: TensorFlow.TFGraph.DebugNanCount(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Boolean},System.String)
  id: DebugNanCount(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DebugNanCount(TFOutput, String, String, String[], Nullable<Boolean>, String)
  nameWithType: TFGraph.DebugNanCount(TFOutput, String, String, String[], Nullable<Boolean>, String)
  fullName: TFGraph.DebugNanCount(TFOutput, String, String, String[], Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Debug NaN Value Counter Op
  remarks: Counts number of NaNs in the input tensor, for debugging.
  syntax:
    content: public TensorFlow.TFOutput DebugNanCount (TensorFlow.TFOutput input, string device_name = null, string tensor_name = null, string[] debug_urls = null, Nullable<bool> gated_grpc = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Input tensor, non-Reference type.
    - id: device_name
      type: System.String
      description: Optional argument
    - id: tensor_name
      type: System.String
      description: >-
        Optional argument
                      Name of the input tensor.
    - id: debug_urls
      type: System.String[]
      description: >-
        Optional argument
                      List of URLs to debug targets, e.g.,
                      file:///foo/tfdbg_dump, grpc:://localhost:11011.
    - id: gated_grpc
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Whether this op will be gated. If any of the debug_urls of this
                      debug node is of the grpc:// scheme, when the value of this attribute is set
                      to True, the data will not actually be sent via the grpc stream unless this
                      debug op has been enabled at the debug_url. If all of the debug_urls of this
                      debug node are of the grpc:// scheme and the debug op is enabled at none of
                      them, the output will be an empty Tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugNanCount'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        An integer output tensor that is the number of NaNs in the input.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DebugNanCount*
  exceptions: []
- uid: TensorFlow.TFGraph.DebugNumericSummary(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: DebugNumericSummary(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DebugNumericSummary(TFOutput, String, String, String[], Nullable<Single>, Nullable<Single>, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.DebugNumericSummary(TFOutput, String, String, String[], Nullable<Single>, Nullable<Single>, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.DebugNumericSummary(TFOutput, String, String, String[], Nullable<Single>, Nullable<Single>, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Debug Numeric Summary Op.
  remarks: Provide a basic summary of numeric value types, range and distribution.
  syntax:
    content: public TensorFlow.TFOutput DebugNumericSummary (TensorFlow.TFOutput input, string device_name = null, string tensor_name = null, string[] debug_urls = null, Nullable<float> lower_bound = null, Nullable<float> upper_bound = null, Nullable<bool> mute_if_healthy = null, Nullable<bool> gated_grpc = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Input tensor, non-Reference type, float or double.
    - id: device_name
      type: System.String
      description: Optional argument
    - id: tensor_name
      type: System.String
      description: >-
        Optional argument
                      Name of the input tensor.
    - id: debug_urls
      type: System.String[]
      description: >-
        Optional argument
                      List of URLs to debug targets, e.g.,
                      file:///foo/tfdbg_dump, grpc:://localhost:11011
    - id: lower_bound
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      (float) The lower bound &lt;= which values will be included in the
                      generalized -inf count. Default: -inf.
    - id: upper_bound
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      (float) The upper bound &gt;= which values will be included in the
                      generalized +inf count. Default: +inf.
    - id: mute_if_healthy
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      (bool) Do not send data to the debug URLs unless at least one
                      of elements [2], [3] and [7] (i.e., the nan count and the generalized -inf and
                      inf counts) is non-zero.
    - id: gated_grpc
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Whether this op will be gated. If any of the debug_urls of this
                      debug node is of the grpc:// scheme, when the value of this attribute is set
                      to True, the data will not actually be sent via the grpc stream unless this
                      debug op has been enabled at the debug_url. If all of the debug_urls of this
                      debug node are of the grpc:// scheme and the debug op is enabled at none of
                      them, the output will be an empty Tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DebugNumericSummary'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A double tensor of shape [14 + nDimensions], where nDimensions is the
                      the number of dimensions of the tensor's shape. The elements of output are:
                      [0]: is initialized (1.0) or not (0.0).
                      [1]: total number of elements
                      [2]: NaN element count
                      [3]: generalized -inf count: elements &lt;= lower_bound. lower_bound is -inf by
                      default.
                      [4]: negative element count (excluding -inf), if lower_bound is the default
                      -inf. Otherwise, this is the count of elements &gt; lower_bound and &lt; 0.
                      [5]: zero element count
                      [6]: positive element count (excluding +inf), if upper_bound is the default
                      -inf. Otherwise, this is the count of elements &lt; upper_bound and &gt; 0.
                      [7]: generalized +inf count, elements &gt;= upper_bound. upper_bound is +inf by
                      default.
                      Output elements [1:8] are all zero, if the tensor is uninitialized.
                      [8]: minimum of all non-inf and non-NaN elements.
                      If uninitialized or no such element exists: +inf.
                      [9]: maximum of all non-inf and non-NaN elements.
                      If uninitialized or no such element exists: -inf.
                      [10]: mean of all non-inf and non-NaN elements.
                      If uninitialized or no such element exists: NaN.
                      [11]: variance of all non-inf and non-NaN elements.
                      If uninitialized or no such element exists: NaN.
                      [12]: Data type of the tensor encoded as an enum integer. See the DataType
                      proto for more details.
                      [13]: Number of dimensions of the tensor (ndims).
                      [14+]: Sizes of the dimensions.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DebugNumericSummary*
  exceptions: []
- uid: TensorFlow.TFGraph.DecodeAndCropJpeg(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Single},System.String,System.String)
  id: DecodeAndCropJpeg(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Single},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DecodeAndCropJpeg(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Single>, String, String)
  nameWithType: TFGraph.DecodeAndCropJpeg(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Single>, String, String)
  fullName: TFGraph.DecodeAndCropJpeg(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Single>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Decode and Crop a JPEG-encoded image to a uint8 tensor.
  remarks: "The attr <code>channels</code> indicates the desired number of color channels for the\n              decoded image.\n              \n              Accepted values are:\n              \n              *   0: Use the number of channels in the JPEG-encoded image.\n              *   1: output a grayscale image.\n              *   3: output an RGB image.\n              \n              If needed, the JPEG-encoded image is transformed to match the requested number\n              of color channels.\n              \n              The attr <code>ratio</code> allows downscaling the image by an integer factor during\n              decoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than\n              downscaling the image later.\n              \n              \n              It is equivalent to a combination of decode and crop, but much faster by only\n              decoding partial jpeg image."
  syntax:
    content: public TensorFlow.TFOutput DecodeAndCropJpeg (TensorFlow.TFOutput contents, TensorFlow.TFOutput crop_window, Nullable<long> channels = null, Nullable<long> ratio = null, Nullable<bool> fancy_upscaling = null, Nullable<bool> try_recover_truncated = null, Nullable<float> acceptable_fraction = null, string dct_method = null, string operName = null);
    parameters:
    - id: contents
      type: TensorFlow.TFOutput
      description: 0-D.  The JPEG-encoded image.
    - id: crop_window
      type: TensorFlow.TFOutput
      description: '1-D.  The crop window: [crop_y, crop_x, crop_height, crop_width].'
    - id: channels
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of color channels for the decoded image.
    - id: ratio
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Downscaling ratio.
    - id: fancy_upscaling
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true use a slower but nicer upscaling of the
                      chroma planes (yuv420/422 only).
    - id: try_recover_truncated
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true try to recover an image from truncated input.
    - id: acceptable_fraction
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      The minimum required fraction of lines before a truncated
                      input is accepted.
    - id: dct_method
      type: System.String
      description: >-
        Optional argument
                      string specifying a hint about the algorithm used for
                      decompression.  Defaults to "" which maps to a system-specific
                      default.  Currently valid values are ["INTEGER_FAST",
                      "INTEGER_ACCURATE"].  The hint may be ignored (e.g., the internal
                      jpeg library changes to a version that does not have that specific
                      option.)
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeAndCropJpeg'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        3-D with shape <code>[height, width, channels]</code>..
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DecodeAndCropJpeg*
  exceptions: []
- uid: TensorFlow.TFGraph.DecodeBase64(TensorFlow.TFOutput,System.String)
  id: DecodeBase64(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DecodeBase64(TFOutput, String)
  nameWithType: TFGraph.DecodeBase64(TFOutput, String)
  fullName: TFGraph.DecodeBase64(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Decode web-safe base64-encoded strings.
  remarks: >-
    Input may or may not have padding at the end. See EncodeBase64 for padding.
                  Web-safe means that input must use - and _ instead of + and /.
  syntax:
    content: public TensorFlow.TFOutput DecodeBase64 (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Base64 strings to decode.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeBase64'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Decoded strings.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DecodeBase64*
  exceptions: []
- uid: TensorFlow.TFGraph.DecodeBmp(TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  id: DecodeBmp(TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DecodeBmp(TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.DecodeBmp(TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.DecodeBmp(TFOutput, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Decode the first frame of a BMP-encoded image to a uint8 tensor.
  remarks: "The attr <code>channels</code> indicates the desired number of color channels for the\n              decoded image.\n              \n              Accepted values are:\n              \n              *   0: Use the number of channels in the BMP-encoded image.\n              *   3: output an RGB image.\n              *   4: output an RGBA image."
  syntax:
    content: public TensorFlow.TFOutput DecodeBmp (TensorFlow.TFOutput contents, Nullable<long> channels = null, string operName = null);
    parameters:
    - id: contents
      type: TensorFlow.TFOutput
      description: 0-D.  The BMP-encoded image.
    - id: channels
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeBmp'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        3-D with shape <code>[height, width, channels]</code>. RGB order
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DecodeBmp*
  exceptions: []
- uid: TensorFlow.TFGraph.DecodeCompressed(TensorFlow.TFOutput,System.String,System.String)
  id: DecodeCompressed(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DecodeCompressed(TFOutput, String, String)
  nameWithType: TFGraph.DecodeCompressed(TFOutput, String, String)
  fullName: TFGraph.DecodeCompressed(TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Decompress strings.
  remarks: "This op decompresses each element of the <code>bytes</code> input <code>Tensor</code>, which\n              is assumed to be compressed using the given <code>compression_type</code>.\n              \n              The <code>output</code> is a string <code>Tensor</code> of the same shape as <code>bytes</code>,\n              each element containing the decompressed data from the corresponding\n              element in <code>bytes</code>."
  syntax:
    content: public TensorFlow.TFOutput DecodeCompressed (TensorFlow.TFOutput bytes, string compression_type = null, string operName = null);
    parameters:
    - id: bytes
      type: TensorFlow.TFOutput
      description: A Tensor of string which is compressed.
    - id: compression_type
      type: System.String
      description: >-
        Optional argument
                      A scalar containing either (i) the empty string (no
                      compression), (ii) "ZLIB", or (iii) "GZIP".
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeCompressed'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A Tensor with the same shape as input <code>bytes</code>, uncompressed
                      from bytes.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DecodeCompressed*
  exceptions: []
- uid: TensorFlow.TFGraph.DecodeCSV(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  id: DecodeCSV(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DecodeCSV(TFOutput, TFOutput[], String, Nullable<Boolean>, String, Int64[], String)
  nameWithType: TFGraph.DecodeCSV(TFOutput, TFOutput[], String, Nullable<Boolean>, String, Int64[], String)
  fullName: TFGraph.DecodeCSV(TFOutput, TFOutput[], String, Nullable<Boolean>, String, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Convert CSV records to tensors. Each column maps to one tensor.
  remarks: >-
    RFC 4180 format is expected for the CSV records.
                  (https://tools.ietf.org/html/rfc4180)
                  Note that we allow leading and trailing spaces with int or float field.
  syntax:
    content: public TensorFlow.TFOutput[] DecodeCSV (TensorFlow.TFOutput records, TensorFlow.TFOutput[] record_defaults, string field_delim = null, Nullable<bool> use_quote_delim = null, string na_value = null, long[] select_cols = null, string operName = null);
    parameters:
    - id: records
      type: TensorFlow.TFOutput
      description: >-
        Each string is a record/row in the csv and all records should have
                      the same format.
    - id: record_defaults
      type: TensorFlow.TFOutput[]
      description: >-
        One tensor per column of the input record, with either a
                      scalar default value for that column or an empty vector if the column is
                      required.
    - id: field_delim
      type: System.String
      description: >-
        Optional argument
                      char delimiter to separate fields in a record.
    - id: use_quote_delim
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If false, treats double quotation marks as regular
                      characters inside of the string fields (ignoring RFC 4180, Section 2,
                      Bullet 5).
    - id: na_value
      type: System.String
      description: >-
        Optional argument
                      Additional string to recognize as NA/NaN.
    - id: select_cols
      type: System.Int64[]
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeCSV'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        Each tensor will have the same shape as records.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DecodeCSV*
  exceptions: []
- uid: TensorFlow.TFGraph.DecodeGif(TensorFlow.TFOutput,System.String)
  id: DecodeGif(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DecodeGif(TFOutput, String)
  nameWithType: TFGraph.DecodeGif(TFOutput, String)
  fullName: TFGraph.DecodeGif(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Decode the first frame of a GIF-encoded image to a uint8 tensor.
  remarks: "GIF with frame or transparency compression are not supported\n              convert animated GIF from compressed to uncompressed by:\n              \n              convert $src.gif -coalesce $dst.gif\n              \n              This op also supports decoding JPEGs and PNGs, though it is cleaner to use\n              <code>tf.image.decode_image</code>."
  syntax:
    content: public TensorFlow.TFOutput DecodeGif (TensorFlow.TFOutput contents, string operName = null);
    parameters:
    - id: contents
      type: TensorFlow.TFOutput
      description: 0-D.  The GIF-encoded image.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeGif'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[num_frames, height, width, 3]</code>. RGB order
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DecodeGif*
  exceptions: []
- uid: TensorFlow.TFGraph.DecodeJpeg(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Single},System.String,System.String)
  id: DecodeJpeg(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Single},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DecodeJpeg(TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Single>, String, String)
  nameWithType: TFGraph.DecodeJpeg(TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Single>, String, String)
  fullName: TFGraph.DecodeJpeg(TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Single>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Decode a JPEG-encoded image to a uint8 tensor.
  remarks: "The attr <code>channels</code> indicates the desired number of color channels for the\n              decoded image.\n              \n              Accepted values are:\n              \n              *   0: Use the number of channels in the JPEG-encoded image.\n              *   1: output a grayscale image.\n              *   3: output an RGB image.\n              \n              If needed, the JPEG-encoded image is transformed to match the requested number\n              of color channels.\n              \n              The attr <code>ratio</code> allows downscaling the image by an integer factor during\n              decoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than\n              downscaling the image later.\n              \n              \n              This op also supports decoding PNGs and non-animated GIFs since the interface is\n              the same, though it is cleaner to use <code>tf.image.decode_image</code>."
  syntax:
    content: public TensorFlow.TFOutput DecodeJpeg (TensorFlow.TFOutput contents, Nullable<long> channels = null, Nullable<long> ratio = null, Nullable<bool> fancy_upscaling = null, Nullable<bool> try_recover_truncated = null, Nullable<float> acceptable_fraction = null, string dct_method = null, string operName = null);
    parameters:
    - id: contents
      type: TensorFlow.TFOutput
      description: 0-D.  The JPEG-encoded image.
    - id: channels
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of color channels for the decoded image.
    - id: ratio
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Downscaling ratio.
    - id: fancy_upscaling
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true use a slower but nicer upscaling of the
                      chroma planes (yuv420/422 only).
    - id: try_recover_truncated
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true try to recover an image from truncated input.
    - id: acceptable_fraction
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      The minimum required fraction of lines before a truncated
                      input is accepted.
    - id: dct_method
      type: System.String
      description: >-
        Optional argument
                      string specifying a hint about the algorithm used for
                      decompression.  Defaults to "" which maps to a system-specific
                      default.  Currently valid values are ["INTEGER_FAST",
                      "INTEGER_ACCURATE"].  The hint may be ignored (e.g., the internal
                      jpeg library changes to a version that does not have that specific
                      option.)
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeJpeg'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        3-D with shape <code>[height, width, channels]</code>..
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DecodeJpeg*
  exceptions: []
- uid: TensorFlow.TFGraph.DecodeJSONExample(TensorFlow.TFOutput,System.String)
  id: DecodeJSONExample(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DecodeJSONExample(TFOutput, String)
  nameWithType: TFGraph.DecodeJSONExample(TFOutput, String)
  fullName: TFGraph.DecodeJSONExample(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Convert JSON-encoded Example records to binary protocol buffer strings.
  remarks: >-
    This op translates a tensor containing Example records, encoded using
                  the [standard JSON
                  mapping](https://developers.google.com/protocol-buffers/docs/proto3#json),
                  into a tensor containing the same records encoded as binary protocol
                  buffers. The resulting tensor can then be fed to any of the other
                  Example-parsing ops.
  syntax:
    content: public TensorFlow.TFOutput DecodeJSONExample (TensorFlow.TFOutput json_examples, string operName = null);
    parameters:
    - id: json_examples
      type: TensorFlow.TFOutput
      description: >-
        Each string is a JSON object serialized according to the JSON
                      mapping of the Example proto.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeJSONExample'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Each string is a binary Example protocol buffer corresponding
                      to the respective element of <code>json_examples</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DecodeJSONExample*
  exceptions: []
- uid: TensorFlow.TFGraph.DecodePng(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)
  id: DecodePng(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DecodePng(TFOutput, Nullable<Int64>, Nullable<TFDataType>, String)
  nameWithType: TFGraph.DecodePng(TFOutput, Nullable<Int64>, Nullable<TFDataType>, String)
  fullName: TFGraph.DecodePng(TFOutput, Nullable<Int64>, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Decode a PNG-encoded image to a uint8 or uint16 tensor.
  remarks: "The attr <code>channels</code> indicates the desired number of color channels for the\n              decoded image.\n              \n              Accepted values are:\n              \n              *   0: Use the number of channels in the PNG-encoded image.\n              *   1: output a grayscale image.\n              *   3: output an RGB image.\n              *   4: output an RGBA image.\n              \n              If needed, the PNG-encoded image is transformed to match the requested number\n              of color channels.\n              \n              This op also supports decoding JPEGs and non-animated GIFs since the interface\n              is the same, though it is cleaner to use <code>tf.image.decode_image</code>."
  syntax:
    content: public TensorFlow.TFOutput DecodePng (TensorFlow.TFOutput contents, Nullable<long> channels = null, Nullable<TensorFlow.TFDataType> dtype = null, string operName = null);
    parameters:
    - id: contents
      type: TensorFlow.TFOutput
      description: 0-D.  The PNG-encoded image.
    - id: channels
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of color channels for the decoded image.
    - id: dtype
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodePng'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        3-D with shape <code>[height, width, channels]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DecodePng*
  exceptions: []
- uid: TensorFlow.TFGraph.DecodeProtoV2(TensorFlow.TFOutput,System.String,System.String[],TensorFlow.TFDataType[],System.String,System.String,System.Nullable{System.Boolean},System.String)
  id: DecodeProtoV2(TensorFlow.TFOutput,System.String,System.String[],TensorFlow.TFDataType[],System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DecodeProtoV2(TFOutput, String, String[], TFDataType[], String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.DecodeProtoV2(TFOutput, String, String[], TFDataType[], String, String, Nullable<Boolean>, String)
  fullName: TFGraph.DecodeProtoV2(TFOutput, String, String[], TFDataType[], String, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: The op extracts fields from a serialized protocol buffers message into tensors.
  remarks: "The <code>decode_proto</code> op extracts fields from a serialized protocol buffers\n              message into tensors.  The fields in <code>field_names</code> are decoded and converted\n              to the corresponding <code>output_types</code> if possible.\n              \n              A <code>message_type</code> name must be provided to give context for the field\n              names. The actual message descriptor can be looked up either in the\n              linked-in descriptor pool or a filename provided by the caller using\n              the <code>descriptor_source</code> attribute.\n              \n              Each output tensor is a dense tensor. This means that it is padded to\n              hold the largest number of repeated elements seen in the input\n              minibatch. (The shape is also padded by one to prevent zero-sized\n              dimensions). The actual repeat counts for each example in the\n              minibatch can be found in the <code>sizes</code> output. In many cases the output\n              of <code>decode_proto</code> is fed immediately into tf.squeeze if missing values\n              are not a concern. When using tf.squeeze, always pass the squeeze\n              dimension explicitly to avoid surprises.\n              \n              For the most part, the mapping between Proto field types and\n              TensorFlow dtypes is straightforward. However, there are a few\n              special cases:\n              \n              - A proto field that contains a submessage or group can only be converted\n              to <code>DT_STRING</code> (the serialized submessage). This is to reduce the\n              complexity of the API. The resulting string can be used as input\n              to another instance of the decode_proto op.\n              \n              - TensorFlow lacks support for unsigned integers. The ops represent uint64\n              types as a <code>DT_INT64</code> with the same twos-complement bit pattern\n              (the obvious way). Unsigned int32 values can be represented exactly by\n              specifying type <code>DT_INT64</code>, or using twos-complement if the caller\n              specifies <code>DT_INT32</code> in the <code>output_types</code> attribute.\n              \n              The <code>descriptor_source</code> attribute selects a source of protocol\n              descriptors to consult when looking up <code>message_type</code>. This may be a\n              filename containing a serialized <code>FileDescriptorSet</code> message,\n              or the special value <code>local://</code>, in which case only descriptors linked\n              into the code will be searched; the filename can be on any filesystem\n              accessible to TensorFlow.\n              \n              You can build a <code>descriptor_source</code> file using the <code>--descriptor_set_out</code>\n              and <code>--include_imports</code> options to the protocol compiler <code>protoc</code>.\n              \n              The <code>local://</code> database only covers descriptors linked into the\n              code via C++ libraries, not Python imports. You can link in a proto descriptor\n              by creating a cc_library target with alwayslink=1.\n              \n              Both binary and text proto serializations are supported, and can be\n              chosen using the <code>format</code> attribute."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput[]> DecodeProtoV2 (TensorFlow.TFOutput bytes, string message_type, string[] field_names, TensorFlow.TFDataType[] output_types, string descriptor_source = null, string message_format = null, Nullable<bool> sanitize = null, string operName = null);
    parameters:
    - id: bytes
      type: TensorFlow.TFOutput
      description: Tensor of serialized protos with shape <code>batch_shape</code>.
    - id: message_type
      type: System.String
      description: Name of the proto message type to decode.
    - id: field_names
      type: System.String[]
      description: List of strings containing proto field names.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: List of TF types to use for the respective field in field_names.
    - id: descriptor_source
      type: System.String
      description: >-
        Optional argument
                      Either the special value <code>local://</code> or a path to a file containing
                      a serialized <code>FileDescriptorSet</code>.
    - id: message_format
      type: System.String
      description: >-
        Optional argument
                      Either <code>binary</code> or <code>text</code>.
    - id: sanitize
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Whether to sanitize the result or not.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeProtoV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput[]}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sizes: Tensor of int32 with shape <code>[batch_shape, len(field_names)]</code>.
                      Each entry is the number of values found for the corresponding field.
                      Optional fields may have 0 or 1 values.
                      values: List of tensors containing values for the corresponding field.
                      <code>values[i]</code> has datatype <code>output_types[i]</code>
                      and shape <code>[batch_shape, max(sizes[...,i])]</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.DecodeProtoV2*
  exceptions: []
- uid: TensorFlow.TFGraph.DecodeRaw(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  id: DecodeRaw(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DecodeRaw(TFOutput, TFDataType, Nullable<Boolean>, String)
  nameWithType: TFGraph.DecodeRaw(TFOutput, TFDataType, Nullable<Boolean>, String)
  fullName: TFGraph.DecodeRaw(TFOutput, TFDataType, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reinterpret the bytes of a string as a vector of numbers.
  syntax:
    content: public TensorFlow.TFOutput DecodeRaw (TensorFlow.TFOutput bytes, TensorFlow.TFDataType out_type, Nullable<bool> little_endian = null, string operName = null);
    parameters:
    - id: bytes
      type: TensorFlow.TFOutput
      description: All the elements must have the same length.
    - id: out_type
      type: TensorFlow.TFDataType
      description: To be added.
    - id: little_endian
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Whether the input <code>bytes</code> are in little-endian order.
                      Ignored for <code>out_type</code> values that are stored in a single byte like
                      <code>uint8</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeRaw'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A Tensor with one more dimension than the input <code>bytes</code>.  The
                      added dimension will have size equal to the length of the elements
                      of <code>bytes</code> divided by the number of bytes to represent <code>out_type</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DecodeRaw*
  exceptions: []
- uid: TensorFlow.TFGraph.DecodeWav(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: DecodeWav(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DecodeWav(TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.DecodeWav(TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.DecodeWav(TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Decode a 16-bit PCM WAV file to a float tensor.
  remarks: "The -32768 to 32767 signed 16-bit values will be scaled to -1.0 to 1.0 in float.\n              \n              When desired_channels is set, if the input contains fewer channels than this\n              then the last channel will be duplicated to give the requested number, else if\n              the input has more channels than requested then the additional channels will be\n              ignored.\n              \n              If desired_samples is set, then the audio will be cropped or padded with zeroes\n              to the requested length.\n              \n              The first output contains a Tensor with the content of the audio samples. The\n              lowest dimension will be the number of channels, and the second will be the\n              number of samples. For example, a ten-sample-long stereo WAV file should give an\n              output shape of [10, 2]."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> DecodeWav (TensorFlow.TFOutput contents, Nullable<long> desired_channels = null, Nullable<long> desired_samples = null, string operName = null);
    parameters:
    - id: contents
      type: TensorFlow.TFOutput
      description: The WAV-encoded audio, usually from a file.
    - id: desired_channels
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of sample channels wanted.
    - id: desired_samples
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Length of audio requested.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DecodeWav'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      audio: 2-D with shape <code>[length, channels]</code>.
                      sample_rate: Scalar holding the sample rate found in the WAV header.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.DecodeWav*
  exceptions: []
- uid: TensorFlow.TFGraph.DeepCopy(TensorFlow.TFOutput,System.String)
  id: DeepCopy(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DeepCopy(TFOutput, String)
  nameWithType: TFGraph.DeepCopy(TFOutput, String)
  fullName: TFGraph.DeepCopy(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Makes a copy of <code>x</code>.
  syntax:
    content: public TensorFlow.TFOutput DeepCopy (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: The source tensor of type <code>T</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DeepCopy'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        y: A <code>Tensor</code> of type <code>T</code>. A copy of <code>x</code>. Guaranteed that <code>y</code>
                      is not an alias of <code>x</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DeepCopy*
  exceptions: []
- uid: TensorFlow.TFGraph.DeleteSessionTensor(TensorFlow.TFOutput,System.String)
  id: DeleteSessionTensor(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DeleteSessionTensor(TFOutput, String)
  nameWithType: TFGraph.DeleteSessionTensor(TFOutput, String)
  fullName: TFGraph.DeleteSessionTensor(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Delete the tensor specified by its handle in the session.
  syntax:
    content: public TensorFlow.TFOperation DeleteSessionTensor (TensorFlow.TFOutput handle, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle for a tensor stored in the session state.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DeleteSessionTensor'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.DeleteSessionTensor*
  exceptions: []
- uid: TensorFlow.TFGraph.DenseToDenseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)
  id: DenseToDenseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DenseToDenseSetOperation(TFOutput, TFOutput, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.DenseToDenseSetOperation(TFOutput, TFOutput, String, Nullable<Boolean>, String)
  fullName: TFGraph.DenseToDenseSetOperation(TFOutput, TFOutput, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies set operation along last dimension of 2 <code>Tensor</code> inputs.
  remarks: "See SetOperationOp::SetOperationFromContext for values of <code>set_operation</code>.\n              \n              Output <code>result</code> is a <code>SparseTensor</code> represented by <code>result_indices</code>,\n              <code>result_values</code>, and <code>result_shape</code>. For <code>set1</code> and <code>set2</code> ranked <code>n</code>, this\n              has rank <code>n</code> and the same 1st <code>n-1</code> dimensions as <code>set1</code> and <code>set2</code>. The <code>nth</code>\n              dimension contains the result of <code>set_operation</code> applied to the corresponding\n              <code>[0...n-1]</code> dimension of <code>set</code>."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> DenseToDenseSetOperation (TensorFlow.TFOutput set1, TensorFlow.TFOutput set2, string set_operation, Nullable<bool> validate_indices = null, string operName = null);
    parameters:
    - id: set1
      type: TensorFlow.TFOutput
      description: >-
        <code>Tensor</code> with rank <code>n</code>. 1st <code>n-1</code> dimensions must be the same as <code>set2</code>.
                      Dimension <code>n</code> contains values in a set, duplicates are allowed but ignored.
    - id: set2
      type: TensorFlow.TFOutput
      description: >-
        <code>Tensor</code> with rank <code>n</code>. 1st <code>n-1</code> dimensions must be the same as <code>set1</code>.
                      Dimension <code>n</code> contains values in a set, duplicates are allowed but ignored.
    - id: set_operation
      type: System.String
      description: To be added.
    - id: validate_indices
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DenseToDenseSetOperation'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      result_indices: 2D indices of a <code>SparseTensor</code>.
                      result_values: 1D values of a <code>SparseTensor</code>.
                      result_shape: 1D <code>Tensor</code> shape of a <code>SparseTensor</code>. <code>result_shape[0...n-1]</code> is
                      the same as the 1st <code>n-1</code> dimensions of <code>set1</code> and <code>set2</code>, <code>result_shape[n]</code>
                      is the max result set size across all <code>0...n-1</code> dimensions.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.DenseToDenseSetOperation*
  exceptions: []
- uid: TensorFlow.TFGraph.DenseToSparseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)
  id: DenseToSparseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DenseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.DenseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, String)
  fullName: TFGraph.DenseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies set operation along last dimension of <code>Tensor</code> and <code>SparseTensor</code>.
  remarks: "See SetOperationOp::SetOperationFromContext for values of <code>set_operation</code>.\n              \n              Input <code>set2</code> is a <code>SparseTensor</code> represented by <code>set2_indices</code>, <code>set2_values</code>,\n              and <code>set2_shape</code>. For <code>set2</code> ranked <code>n</code>, 1st <code>n-1</code> dimensions must be the same\n              as <code>set1</code>. Dimension <code>n</code> contains values in a set, duplicates are allowed but\n              ignored.\n              \n              If <code>validate_indices</code> is <code>True</code>, this op validates the order and range of <code>set2</code>\n              indices.\n              \n              Output <code>result</code> is a <code>SparseTensor</code> represented by <code>result_indices</code>,\n              <code>result_values</code>, and <code>result_shape</code>. For <code>set1</code> and <code>set2</code> ranked <code>n</code>, this\n              has rank <code>n</code> and the same 1st <code>n-1</code> dimensions as <code>set1</code> and <code>set2</code>. The <code>nth</code>\n              dimension contains the result of <code>set_operation</code> applied to the corresponding\n              <code>[0...n-1]</code> dimension of <code>set</code>."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> DenseToSparseSetOperation (TensorFlow.TFOutput set1, TensorFlow.TFOutput set2_indices, TensorFlow.TFOutput set2_values, TensorFlow.TFOutput set2_shape, string set_operation, Nullable<bool> validate_indices = null, string operName = null);
    parameters:
    - id: set1
      type: TensorFlow.TFOutput
      description: >-
        <code>Tensor</code> with rank <code>n</code>. 1st <code>n-1</code> dimensions must be the same as <code>set2</code>.
                      Dimension <code>n</code> contains values in a set, duplicates are allowed but ignored.
    - id: set2_indices
      type: TensorFlow.TFOutput
      description: >-
        2D <code>Tensor</code>, indices of a <code>SparseTensor</code>. Must be in row-major
                      order.
    - id: set2_values
      type: TensorFlow.TFOutput
      description: >-
        1D <code>Tensor</code>, values of a <code>SparseTensor</code>. Must be in row-major
                      order.
    - id: set2_shape
      type: TensorFlow.TFOutput
      description: >-
        1D <code>Tensor</code>, shape of a <code>SparseTensor</code>. <code>set2_shape[0...n-1]</code> must
                      be the same as the 1st <code>n-1</code> dimensions of <code>set1</code>, <code>result_shape[n]</code> is the
                      max set size across <code>n-1</code> dimensions.
    - id: set_operation
      type: System.String
      description: To be added.
    - id: validate_indices
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DenseToSparseSetOperation'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      result_indices: 2D indices of a <code>SparseTensor</code>.
                      result_values: 1D values of a <code>SparseTensor</code>.
                      result_shape: 1D <code>Tensor</code> shape of a <code>SparseTensor</code>. <code>result_shape[0...n-1]</code> is
                      the same as the 1st <code>n-1</code> dimensions of <code>set1</code> and <code>set2</code>, <code>result_shape[n]</code>
                      is the max result set size across all <code>0...n-1</code> dimensions.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.DenseToSparseSetOperation*
  exceptions: []
- uid: TensorFlow.TFGraph.DepthToSpace(TensorFlow.TFOutput,System.Int64,System.String,System.String)
  id: DepthToSpace(TensorFlow.TFOutput,System.Int64,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DepthToSpace(TFOutput, Int64, String, String)
  nameWithType: TFGraph.DepthToSpace(TFOutput, Int64, String, String)
  fullName: TFGraph.DepthToSpace(TFOutput, Int64, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: DepthToSpace for tensors of type T.
  remarks: "Rearranges data from depth into blocks of spatial data.\n              This is the reverse transformation of SpaceToDepth. More specifically,\n              this op outputs a copy of the input tensor where values from the <code>depth</code>\n              dimension are moved in spatial blocks to the <code>height</code> and <code>width</code> dimensions.\n              The attr <code>block_size</code> indicates the input block size and how the data is moved.\n              \n              * Chunks of data of size <code>block_size * block_size</code> from depth are rearranged\n              into non-overlapping blocks of size <code>block_size x block_size</code>\n              * The width the output tensor is <code>input_depth * block_size</code>, whereas the\n              height is <code>input_height * block_size</code>.\n              * The Y, X coordinates within each block of the output image are determined\n              by the high order component of the input channel index.\n              * The depth of the input tensor must be divisible by\n              <code>block_size * block_size</code>.\n              \n              The <code>data_format</code> attr specifies the layout of the input and output tensors\n              with the following options:\n              \"NHWC\": <code>[ batch, height, width, channels ]</code>\n              \"NCHW\": <code>[ batch, channels, height, width ]</code>\n              \"NCHW_VECT_C\":\n              <code>qint8 [ batch, channels / 4, height, width, 4 ]</code>\n              \n              It is useful to consider the operation as transforming a 6-D Tensor.\n              e.g. for data_format = NHWC,\n              Each element in the input tensor can be specified via 6 coordinates,\n              ordered by decreasing memory layout significance as:\n              n,iY,iX,bY,bX,oC  (where n=batch index, iX, iY means X or Y coordinates\n              within the input image, bX, bY means coordinates\n              within the output block, oC means output channels).\n              The output would be the input transposed to the following layout:\n              n,iY,bY,iX,bX,oC\n              \n              This operation is useful for resizing the activations between convolutions\n              (but keeping all data), e.g. instead of pooling. It is also useful for training\n              purely convolutional models.\n              \n              For example, given an input of shape <code>[1, 1, 1, 4]</code>, data_format = \"NHWC\" and\n              block_size = 2:\n              \n               <pre><code>\n              x = [[[[1, 2, 3, 4]]]]\n              \n               </code></pre>\n              \n              This operation will output a tensor of shape <code>[1, 2, 2, 1]</code>:\n              \n               <pre><code>\n              [[[[1], [2]],\n              [[3], [4]]]]\n               </code></pre>\n              \n              Here, the input has a batch of 1 and each batch element has shape <code>[1, 1, 4]</code>,\n              the corresponding output will have 2x2 elements and will have a depth of\n              1 channel (1 = <code>4 / (block_size * block_size)</code>).\n              The output element shape is <code>[2, 2, 1]</code>.\n              \n              For an input tensor with larger depth, here of shape <code>[1, 1, 1, 12]</code>, e.g.\n              \n               <pre><code>\n              x = [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]\n               </code></pre>\n              \n              This operation, for block size of 2, will return the following tensor of shape\n              <code>[1, 2, 2, 3]</code><pre><code>\n              [[[[1, 2, 3], [4, 5, 6]],\n              [[7, 8, 9], [10, 11, 12]]]]\n              \n               </code></pre>\n              \n              Similarly, for the following input of shape <code>[1 2 2 4]</code>, and a block size of 2:\n              \n               <pre><code>\n              x =  [[[[1, 2, 3, 4],\n              [5, 6, 7, 8]],\n              [[9, 10, 11, 12],\n              [13, 14, 15, 16]]]]\n               </code></pre>\n              \n              the operator will return the following tensor of shape <code>[1 4 4 1]</code>:\n              \n               <pre><code>\n              x = [[[ [1],   [2],  [5],  [6]],\n              [ [3],   [4],  [7],  [8]],\n              [ [9],  [10], [13],  [14]],\n              [ [11], [12], [15],  [16]]]]\n              \n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput DepthToSpace (TensorFlow.TFOutput input, long block_size, string data_format = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: block_size
      type: System.Int64
      description: The size of the spatial block, same as in Space2Depth.
    - id: data_format
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthToSpace'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DepthToSpace*
  exceptions: []
- uid: TensorFlow.TFGraph.DepthwiseConv2dNative(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  id: DepthwiseConv2dNative(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DepthwiseConv2dNative(TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  nameWithType: TFGraph.DepthwiseConv2dNative(TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  fullName: TFGraph.DepthwiseConv2dNative(TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes a 2-D depthwise convolution given 4-D <code>input</code> and <code>filter</code> tensors.
  remarks: "Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>\n              and a filter / kernel tensor of shape\n              <code>[filter_height, filter_width, in_channels, channel_multiplier]</code>, containing\n              <code>in_channels</code> convolutional filters of depth 1, <code>depthwise_conv2d</code> applies\n              a different filter to each input channel (expanding from 1 channel to\n              <code>channel_multiplier</code> channels for each), then concatenates the results\n              together. Thus, the output has <code>in_channels * channel_multiplier</code> channels.\n              \n               <pre><code>\n              for k in 0..in_channels-1\n              for q in 0..channel_multiplier-1\n              output[b, i, j, k * channel_multiplier + q] =\n              sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *\n              filter[di, dj, k, q]\n               </code></pre>\n              \n              Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the same\n              horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>."
  syntax:
    content: public TensorFlow.TFOutput DepthwiseConv2dNative (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: filter
      type: TensorFlow.TFOutput
      description: To be added.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D of length 4.  The stride of the sliding window for each dimension
                      of <code>input</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, height, width, channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, channels, height, width].
    - id: dilations
      type: System.Int64[]
      description: >-
        Optional argument
                      1-D tensor of length 4.  The dilation factor for each dimension of
                      <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each filter
                      element on that dimension. The dimension order is determined by the value of
                      <code>data_format</code>, see above for details. Dilations in the batch and depth
                      dimensions must be 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthwiseConv2dNative'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DepthwiseConv2dNative*
  exceptions: []
- uid: TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  id: DepthwiseConv2dNativeBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DepthwiseConv2dNativeBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  nameWithType: TFGraph.DepthwiseConv2dNativeBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  fullName: TFGraph.DepthwiseConv2dNativeBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradients of depthwise convolution with respect to the filter.
  syntax:
    content: public TensorFlow.TFOutput DepthwiseConv2dNativeBackpropFilter (TensorFlow.TFOutput input, TensorFlow.TFOutput filter_sizes, TensorFlow.TFOutput out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape based on <code>data_format</code>.  For example, if
                      <code>data_format</code> is 'NHWC' then <code>input</code> is a 4-D <code>[batch, in_height,
                      in_width, in_channels]</code> tensor.
    - id: filter_sizes
      type: TensorFlow.TFOutput
      description: >-
        An integer vector representing the tensor shape of <code>filter</code>,
                      where <code>filter</code> is a 4-D
                      <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code> tensor.
    - id: out_backprop
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape  based on <code>data_format</code>.
                      For example, if <code>data_format</code> is 'NHWC' then
                      out_backprop shape is <code>[batch, out_height, out_width, out_channels]</code>.
                      Gradients w.r.t. the output of the convolution.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the input
                      of the convolution.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, height, width, channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, channels, height, width].
    - id: dilations
      type: System.Int64[]
      description: >-
        Optional argument
                      1-D tensor of length 4.  The dilation factor for each dimension of
                      <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each filter
                      element on that dimension. The dimension order is determined by the value of
                      <code>data_format</code>, see above for details. Dilations in the batch and depth
                      dimensions must be 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthwiseConv2dNativeBackpropFilter'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape
                      <code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
                      the <code>filter</code> input of the convolution.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropFilter*
  exceptions: []
- uid: TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  id: DepthwiseConv2dNativeBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DepthwiseConv2dNativeBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  nameWithType: TFGraph.DepthwiseConv2dNativeBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  fullName: TFGraph.DepthwiseConv2dNativeBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradients of depthwise convolution with respect to the input.
  syntax:
    content: public TensorFlow.TFOutput DepthwiseConv2dNativeBackpropInput (TensorFlow.TFOutput input_sizes, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null);
    parameters:
    - id: input_sizes
      type: TensorFlow.TFOutput
      description: >-
        An integer vector representing the shape of <code>input</code>, based
                      on <code>data_format</code>.  For example, if <code>data_format</code> is 'NHWC' then
                      <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.
    - id: filter
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape
                      <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code>.
    - id: out_backprop
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape  based on <code>data_format</code>.
                      For example, if <code>data_format</code> is 'NHWC' then
                      out_backprop shape is <code>[batch, out_height, out_width, out_channels]</code>.
                      Gradients w.r.t. the output of the convolution.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the input
                      of the convolution.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, height, width, channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, channels, height, width].
    - id: dilations
      type: System.Int64[]
      description: >-
        Optional argument
                      1-D tensor of length 4.  The dilation factor for each dimension of
                      <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each filter
                      element on that dimension. The dimension order is determined by the value of
                      <code>data_format</code>, see above for details. Dilations in the batch and depth
                      dimensions must be 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DepthwiseConv2dNativeBackpropInput'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape according to <code>data_format</code>.  For example, if
                      <code>data_format</code> is 'NHWC', output shape is <code>[batch, in_height,
                      in_width, in_channels]</code>.  Gradient w.r.t. the input of the
                      convolution.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropInput*
  exceptions: []
- uid: TensorFlow.TFGraph.Dequantize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  id: Dequantize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Dequantize(TFOutput, TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.Dequantize(TFOutput, TFOutput, TFOutput, String, String)
  fullName: TFGraph.Dequantize(TFOutput, TFOutput, TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Dequantize the 'input' tensor into a float Tensor.
  remarks: "[min_range, max_range] are scalar floats that specify the range for\n              the 'input' data. The 'mode' attribute controls exactly which calculations are\n              used to convert the float values to their quantized equivalents.\n              \n              In 'MIN_COMBINED' mode, each value of the tensor will undergo the following:\n              \n               <pre><code>\n              if T == qint8: in[i] += (range(T) + 1)/ 2.0\n              out[i] = min_range + (in[i]* (max_range - min_range) / range(T))\n               </code></pre>\n              here <code>range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()</code>\n              \n              *MIN_COMBINED Mode Example*\n              \n              If the input comes from a QuantizedRelu6, the output type is\n              quint8 (range of 0-255) but the possible range of QuantizedRelu6 is\n              0-6.  The min_range and max_range values are therefore 0.0 and 6.0.\n              Dequantize on quint8 will take each value, cast to float, and multiply\n              by 6 / 255.\n              Note that if quantizedtype is qint8, the operation will additionally add\n              each value by 128 prior to casting.\n              \n              If the mode is 'MIN_FIRST', then this approach is used:\n              \n               <pre><code>\n              num_discrete_values = 1 &lt;&lt; (# of bits in T)\n              range_adjust = num_discrete_values / (num_discrete_values - 1)\n              range = (range_max - range_min) * range_adjust\n              range_scale = range / num_discrete_values\n              const double offset_input = static_cast&lt;double&gt;(input) - lowest_quantized;\n              result = range_min + ((input - numeric_limits&lt;T&gt;::min()) * range_scale)\n               </code></pre>\n              \n              *SCALED mode Example*\n              \n              <code>SCALED</code> mode matches the quantization approach used in\n              <code>QuantizeAndDequantize{V2|V3}</code>.\n              \n              If the mode is <code>SCALED</code>, we do not use the full range of the output type,\n              choosing to elide the lowest possible value for symmetry (e.g., output range is\n              -127 to 127, not -128 to 127 for signed 8 bit quantization), so that 0.0 maps to\n              0.\n              \n              We first find the range of values in our tensor. The\n              range we use is always centered on 0, so we find m such that\n               <pre><code>\n              m = max(abs(input_min), abs(input_max))\n               </code></pre>\n              \n              Our input tensor range is then <code>[-m, m]</code>.\n              \n              Next, we choose our fixed-point quantization buckets, <code>[min_fixed, max_fixed]</code>.\n              If T is signed, this is\n               <pre><code>\n              num_bits = sizeof(T) * 8\n              [min_fixed, max_fixed] =\n              [-(1 &lt;&lt; (num_bits - 1) - 1), (1 &lt;&lt; (num_bits - 1)) - 1]\n               </code></pre>\n              \n              Otherwise, if T is unsigned, the fixed-point range is\n               <pre><code>\n              [min_fixed, max_fixed] = [0, (1 &lt;&lt; num_bits) - 1]\n               </code></pre>\n              \n              From this we compute our scaling factor, s:\n               <pre><code>\n              s = (2 * m) / (max_fixed - min_fixed)\n               </code></pre>\n              \n              Now we can dequantize the elements of our tensor:\n               <pre><code>\n              result = input * s\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Dequantize (TensorFlow.TFOutput input, TensorFlow.TFOutput min_range, TensorFlow.TFOutput max_range, string mode = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: min_range
      type: TensorFlow.TFOutput
      description: The minimum scalar value possibly produced for the input.
    - id: max_range
      type: TensorFlow.TFOutput
      description: The maximum scalar value possibly produced for the input.
    - id: mode
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Dequantize'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Dequantize*
  exceptions: []
- uid: TensorFlow.TFGraph.DeserializeIterator(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: DeserializeIterator(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DeserializeIterator(TFOutput, TFOutput, String)
  nameWithType: TFGraph.DeserializeIterator(TFOutput, TFOutput, String)
  fullName: TFGraph.DeserializeIterator(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts the given variant tensor to an iterator and stores it in the given resource.
  syntax:
    content: public TensorFlow.TFOperation DeserializeIterator (TensorFlow.TFOutput resource_handle, TensorFlow.TFOutput serialized, string operName = null);
    parameters:
    - id: resource_handle
      type: TensorFlow.TFOutput
      description: A handle to an iterator resource.
    - id: serialized
      type: TensorFlow.TFOutput
      description: >-
        A variant tensor storing the state of the iterator contained in the
                      resource.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DeserializeIterator'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.DeserializeIterator*
  exceptions: []
- uid: TensorFlow.TFGraph.DeserializeManySparse(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: DeserializeManySparse(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DeserializeManySparse(TFOutput, TFDataType, String)
  nameWithType: TFGraph.DeserializeManySparse(TFOutput, TFDataType, String)
  fullName: TFGraph.DeserializeManySparse(TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deserialize and concatenate <code>SparseTensors</code> from a serialized minibatch.
  remarks: "The input <code>serialized_sparse</code> must be a string matrix of shape <code>[N x 3]</code> where\n              <code>N</code> is the minibatch size and the rows correspond to packed outputs of\n              <code>SerializeSparse</code>.  The ranks of the original <code>SparseTensor</code> objects\n              must all match.  When the final <code>SparseTensor</code> is created, it has rank one\n              higher than the ranks of the incoming <code>SparseTensor</code> objects\n              (they have been concatenated along a new row dimension).\n              \n              The output <code>SparseTensor</code> object's shape values for all dimensions but the\n              first are the max across the input <code>SparseTensor</code> objects' shape values\n              for the corresponding dimensions.  Its first shape value is <code>N</code>, the minibatch\n              size.\n              \n              The input <code>SparseTensor</code> objects' indices are assumed ordered in\n              standard lexicographic order.  If this is not the case, after this\n              step run <code>SparseReorder</code> to restore index ordering.\n              \n              For example, if the serialized input is a <code>[2 x 3]</code> matrix representing two\n              original <code>SparseTensor</code> objects:\n              \n              index = [ 0]\n              [10]\n              [20]\n              values = [1, 2, 3]\n              shape = [50]\n              \n              and\n              \n              index = [ 2]\n              [10]\n              values = [4, 5]\n              shape = [30]\n              \n              then the final deserialized <code>SparseTensor</code> will be:\n              \n              index = [0  0]\n              [0 10]\n              [0 20]\n              [1  2]\n              [1 10]\n              values = [1, 2, 3, 4, 5]\n              shape = [2 50]"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> DeserializeManySparse (TensorFlow.TFOutput serialized_sparse, TensorFlow.TFDataType dtype, string operName = null);
    parameters:
    - id: serialized_sparse
      type: TensorFlow.TFOutput
      description: >-
        2-D, The <code>N</code> serialized <code>SparseTensor</code> objects.
                      Must have 3 columns.
    - id: dtype
      type: TensorFlow.TFDataType
      description: The <code>dtype</code> of the serialized <code>SparseTensor</code> objects.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DeserializeManySparse'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sparse_indices:
                      sparse_values:
                      sparse_shape:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.DeserializeManySparse*
  exceptions: []
- uid: TensorFlow.TFGraph.DeserializeSparse(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: DeserializeSparse(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DeserializeSparse(TFOutput, TFDataType, String)
  nameWithType: TFGraph.DeserializeSparse(TFOutput, TFDataType, String)
  fullName: TFGraph.DeserializeSparse(TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deserialize <code>SparseTensor</code> objects.
  remarks: "The input <code>serialized_sparse</code> must have the shape <code>[?, ?, ..., ?, 3]</code> where\n              the last dimension stores serialized <code>SparseTensor</code> objects and the other N\n              dimensions (N &gt;= 0) correspond to a batch. The ranks of the original\n              <code>SparseTensor</code> objects must all match. When the final <code>SparseTensor</code> is\n              created, its rank is the rank of the incoming <code>SparseTensor</code> objects plus N;\n              the sparse tensors have been concatenated along new dimensions, one for each\n              batch.\n              \n              The output <code>SparseTensor</code> object's shape values for the original dimensions\n              are the max across the input <code>SparseTensor</code> objects' shape values for the\n              corresponding dimensions. The new dimensions match the size of the batch.\n              \n              The input <code>SparseTensor</code> objects' indices are assumed ordered in\n              standard lexicographic order.  If this is not the case, after this\n              step run <code>SparseReorder</code> to restore index ordering.\n              \n              For example, if the serialized input is a <code>[2 x 3]</code> matrix representing two\n              original <code>SparseTensor</code> objects:\n              \n              index = [ 0]\n              [10]\n              [20]\n              values = [1, 2, 3]\n              shape = [50]\n              \n              and\n              \n              index = [ 2]\n              [10]\n              values = [4, 5]\n              shape = [30]\n              \n              then the final deserialized <code>SparseTensor</code> will be:\n              \n              index = [0  0]\n              [0 10]\n              [0 20]\n              [1  2]\n              [1 10]\n              values = [1, 2, 3, 4, 5]\n              shape = [2 50]"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> DeserializeSparse (TensorFlow.TFOutput serialized_sparse, TensorFlow.TFDataType dtype, string operName = null);
    parameters:
    - id: serialized_sparse
      type: TensorFlow.TFOutput
      description: >-
        The serialized <code>SparseTensor</code> objects. The last dimension
                      must have 3 columns.
    - id: dtype
      type: TensorFlow.TFDataType
      description: The <code>dtype</code> of the serialized <code>SparseTensor</code> objects.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DeserializeSparse'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sparse_indices:
                      sparse_values:
                      sparse_shape:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.DeserializeSparse*
  exceptions: []
- uid: TensorFlow.TFGraph.DestroyResourceOp(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: DestroyResourceOp(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DestroyResourceOp(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.DestroyResourceOp(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.DestroyResourceOp(TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deletes the resource specified by the handle.
  remarks: >-
    All subsequent operations using the resource will result in a NotFound
                  error status.
  syntax:
    content: public TensorFlow.TFOperation DestroyResourceOp (TensorFlow.TFOutput resource, Nullable<bool> ignore_lookup_error = null, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: handle to the resource to delete.
    - id: ignore_lookup_error
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      whether to ignore the error when the resource
                      doesn't exist.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DestroyResourceOp'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.DestroyResourceOp*
  exceptions: []
- uid: TensorFlow.TFGraph.DestroyTemporaryVariable(TensorFlow.TFOutput,System.String,System.String)
  id: DestroyTemporaryVariable(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DestroyTemporaryVariable(TFOutput, String, String)
  nameWithType: TFGraph.DestroyTemporaryVariable(TFOutput, String, String)
  fullName: TFGraph.DestroyTemporaryVariable(TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Destroys the temporary variable and returns its final value.
  remarks: "Sets output to the value of the Tensor pointed to by 'ref', then destroys\n              the temporary variable called 'var_name'.\n              All other uses of 'ref' *must* have executed before this op.\n              This is typically achieved by chaining the ref through each assign op, or by\n              using control dependencies.\n              \n              Outputs the final value of the tensor pointed to by 'ref'."
  syntax:
    content: public TensorFlow.TFOutput DestroyTemporaryVariable (TensorFlow.TFOutput reference, string var_name, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: A reference to the temporary variable tensor.
    - id: var_name
      type: System.String
      description: >-
        Name of the temporary variable, usually the name of the matching
                      'TemporaryVariable' op.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DestroyTemporaryVariable'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DestroyTemporaryVariable*
  exceptions: []
- uid: TensorFlow.TFGraph.Diag(TensorFlow.TFOutput,System.String)
  id: Diag(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Diag(TFOutput, String)
  nameWithType: TFGraph.Diag(TFOutput, String)
  fullName: TFGraph.Diag(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns a diagonal tensor with a given diagonal values.
  remarks: "Given a <code>diagonal</code>, this operation returns a tensor with the <code>diagonal</code> and\n              everything else padded with zeros. The diagonal is computed as follows:\n              \n              Assume <code>diagonal</code> has dimensions [D1,..., Dk], then the output is a tensor of\n              rank 2k with dimensions [D1,..., Dk, D1,..., Dk] where:\n              \n              <code>output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]</code> and 0 everywhere else.\n              \n              For example:\n              \n               <pre><code>\n              # 'diagonal' is [1, 2, 3, 4]\n              tf.diag(diagonal) ==&gt; [[1, 0, 0, 0]\n              [0, 2, 0, 0]\n              [0, 0, 3, 0]\n              [0, 0, 0, 4]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Diag (TensorFlow.TFOutput diagonal, string operName = null);
    parameters:
    - id: diagonal
      type: TensorFlow.TFOutput
      description: Rank k tensor where k is at most 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Diag'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Diag*
  exceptions: []
- uid: TensorFlow.TFGraph.DiagPart(TensorFlow.TFOutput,System.String)
  id: DiagPart(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DiagPart(TFOutput, String)
  nameWithType: TFGraph.DiagPart(TFOutput, String)
  fullName: TFGraph.DiagPart(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the diagonal part of the tensor.
  remarks: "This operation returns a tensor with the <code>diagonal</code> part\n              of the <code>input</code>. The <code>diagonal</code> part is computed as follows:\n              \n              Assume <code>input</code> has dimensions <code>[D1,..., Dk, D1,..., Dk]</code>, then the output is a\n              tensor of rank <code>k</code> with dimensions <code>[D1,..., Dk]</code> where:\n              \n              <code>diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]</code>.\n              \n              For example:\n              \n               <pre><code>\n              # 'input' is [[1, 0, 0, 0]\n              [0, 2, 0, 0]\n              [0, 0, 3, 0]\n              [0, 0, 0, 4]]\n              \n              tf.diag_part(input) ==&gt; [1, 2, 3, 4]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput DiagPart (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Rank k tensor where k is even and not zero.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DiagPart'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The extracted diagonal.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DiagPart*
  exceptions: []
- uid: TensorFlow.TFGraph.Digamma(TensorFlow.TFOutput,System.String)
  id: Digamma(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Digamma(TFOutput, String)
  nameWithType: TFGraph.Digamma(TFOutput, String)
  fullName: TFGraph.Digamma(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes Psi, the derivative of Lgamma (the log of the absolute value of
  remarks: <code>Gamma(x)</code>), element-wise.
  syntax:
    content: public TensorFlow.TFOutput Digamma (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Digamma'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Digamma*
  exceptions: []
- uid: TensorFlow.TFGraph.Dilation2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  id: Dilation2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Dilation2D(TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.Dilation2D(TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.Dilation2D(TFOutput, TFOutput, Int64[], Int64[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the grayscale dilation of 4-D <code>input</code> and 3-D <code>filter</code> tensors.
  remarks: "The <code>input</code> tensor has shape <code>[batch, in_height, in_width, depth]</code> and the\n              <code>filter</code> tensor has shape <code>[filter_height, filter_width, depth]</code>, i.e., each\n              input channel is processed independently of the others with its own structuring\n              function. The <code>output</code> tensor has shape\n              <code>[batch, out_height, out_width, depth]</code>. The spatial dimensions of the output\n              tensor depend on the <code>padding</code> algorithm. We currently only support the default\n              \"NHWC\" <code>data_format</code>.\n              \n              In detail, the grayscale morphological 2-D dilation is the max-sum correlation\n              (for consistency with <code>conv2d</code>, we use unmirrored filters):\n              \n              output[b, y, x, c] =\n              max_{dy, dx} input[b,\n              strides[1] * y + rates[1] * dy,\n              strides[2] * x + rates[2] * dx,\n              c] +\n              filter[dy, dx, c]\n              \n              Max-pooling is a special case when the filter has size equal to the pooling\n              kernel size and contains all zeros.\n              \n              Note on duality: The dilation of <code>input</code> by the <code>filter</code> is equal to the\n              negation of the erosion of <code>-input</code> by the reflected <code>filter</code>."
  syntax:
    content: public TensorFlow.TFOutput Dilation2D (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, long[] strides, long[] rates, string padding, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, in_height, in_width, depth]</code>.
    - id: filter
      type: TensorFlow.TFOutput
      description: 3-D with shape <code>[filter_height, filter_width, depth]</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the input
                      tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
    - id: rates
      type: System.Int64[]
      description: >-
        The input stride for atrous morphological dilation. Must be:
                      <code>[1, rate_height, rate_width, 1]</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Dilation2D'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, out_height, out_width, depth]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Dilation2D*
  exceptions: []
- uid: TensorFlow.TFGraph.Dilation2DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  id: Dilation2DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Dilation2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.Dilation2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.Dilation2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradient of morphological 2-D dilation with respect to the filter.
  syntax:
    content: public TensorFlow.TFOutput Dilation2DBackpropFilter (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, long[] rates, string padding, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, in_height, in_width, depth]</code>.
    - id: filter
      type: TensorFlow.TFOutput
      description: 3-D with shape <code>[filter_height, filter_width, depth]</code>.
    - id: out_backprop
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, out_height, out_width, depth]</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D of length 4. The stride of the sliding window for each dimension of
                      the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
    - id: rates
      type: System.Int64[]
      description: >-
        1-D of length 4. The input stride for atrous morphological dilation.
                      Must be: <code>[1, rate_height, rate_width, 1]</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Dilation2DBackpropFilter'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        3-D with shape <code>[filter_height, filter_width, depth]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Dilation2DBackpropFilter*
  exceptions: []
- uid: TensorFlow.TFGraph.Dilation2DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  id: Dilation2DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Dilation2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.Dilation2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.Dilation2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradient of morphological 2-D dilation with respect to the input.
  syntax:
    content: public TensorFlow.TFOutput Dilation2DBackpropInput (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, long[] rates, string padding, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, in_height, in_width, depth]</code>.
    - id: filter
      type: TensorFlow.TFOutput
      description: 3-D with shape <code>[filter_height, filter_width, depth]</code>.
    - id: out_backprop
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, out_height, out_width, depth]</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D of length 4. The stride of the sliding window for each dimension of
                      the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.
    - id: rates
      type: System.Int64[]
      description: >-
        1-D of length 4. The input stride for atrous morphological dilation.
                      Must be: <code>[1, rate_height, rate_width, 1]</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Dilation2DBackpropInput'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, in_height, in_width, depth]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Dilation2DBackpropInput*
  exceptions: []
- uid: TensorFlow.TFGraph.Div(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Div(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Div(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Div(TFOutput, TFOutput, String)
  fullName: TFGraph.Div(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns x / y element-wise.
  remarks: >-
    *NOTE*: <code>Div</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput Div (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Div'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Div*
  exceptions: []
- uid: TensorFlow.TFGraph.DivNoNan(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: DivNoNan(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DivNoNan(TFOutput, TFOutput, String)
  nameWithType: TFGraph.DivNoNan(TFOutput, TFOutput, String)
  fullName: TFGraph.DivNoNan(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns 0 if the denominator is zero.
  remarks: >-
    *NOTE*: <code>DivNoNan</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput DivNoNan (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DivNoNan'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DivNoNan*
  exceptions: []
- uid: TensorFlow.TFGraph.DrawBoundingBoxes(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: DrawBoundingBoxes(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DrawBoundingBoxes(TFOutput, TFOutput, String)
  nameWithType: TFGraph.DrawBoundingBoxes(TFOutput, TFOutput, String)
  fullName: TFGraph.DrawBoundingBoxes(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Draw bounding boxes on a batch of images.
  remarks: "Outputs a copy of <code>images</code> but draws on top of the pixels zero or more bounding\n              boxes specified by the locations in <code>boxes</code>. The coordinates of the each\n              bounding box in <code>boxes</code> are encoded as <code>[y_min, x_min, y_max, x_max]</code>. The\n              bounding box coordinates are floats in <code>[0.0, 1.0]</code> relative to the width and\n              height of the underlying image.\n              \n              For example, if an image is 100 x 200 pixels (height x width) and the bounding\n              box is <code>[0.1, 0.2, 0.5, 0.9]</code>, the upper-left and bottom-right coordinates of\n              the bounding box will be <code>(40, 10)</code> to <code>(180, 50)</code> (in (x,y) coordinates).\n              \n              Parts of the bounding box may fall outside the image."
  syntax:
    content: public TensorFlow.TFOutput DrawBoundingBoxes (TensorFlow.TFOutput images, TensorFlow.TFOutput boxes, string operName = null);
    parameters:
    - id: images
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, depth]</code>. A batch of images.
    - id: boxes
      type: TensorFlow.TFOutput
      description: >-
        3-D with shape <code>[batch, num_bounding_boxes, 4]</code> containing bounding
                      boxes.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DrawBoundingBoxes'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with the same shape as <code>images</code>. The batch of input images with
                      bounding boxes drawn on the images.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DrawBoundingBoxes*
  exceptions: []
- uid: TensorFlow.TFGraph.Dropout(TensorFlow.TFOutput,System.Double,TensorFlow.TFShape,System.Nullable{System.Int32},System.String)
  id: Dropout(TensorFlow.TFOutput,System.Double,TensorFlow.TFShape,System.Nullable{System.Int32},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Dropout(TFOutput, Double, TFShape, Nullable<Int32>, String)
  nameWithType: TFGraph.Dropout(TFOutput, Double, TFShape, Nullable<Int32>, String)
  fullName: TFGraph.Dropout(TFOutput, Double, TFShape, Nullable<Int32>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes dropout.
  remarks: "With probability keep_prob, outputs the input element scaled up by 1 / keep_prob, \n            otherwise outputs 0. The scaling is so that the expected sum is unchanged."
  syntax:
    content: public TensorFlow.TFOutput Dropout (TensorFlow.TFOutput x, double keep_prob, TensorFlow.TFShape noise_shape = null, Nullable<int> seed = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: A tensor.
    - id: keep_prob
      type: System.Double
      description: A scalar Tensor with the same type as x. The probability that each element is kept.
    - id: noise_shape
      type: TensorFlow.TFShape
      description: A 1-D Tensor of type int32, representing the shape for randomly generated keep/drop flags.
    - id: seed
      type: System.Nullable{System.Int32}
      description: Integer seed used for the random distribution, using the TensorFlow SetRandomSeed .
    - id: operName
      type: System.String
      description: Operation name, optional.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.Dropout*
  exceptions: []
- uid: TensorFlow.TFGraph.Dropout(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFShape,System.Nullable{System.Int32},System.String)
  id: Dropout(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFShape,System.Nullable{System.Int32},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Dropout(TFOutput, TFOutput, TFShape, Nullable<Int32>, String)
  nameWithType: TFGraph.Dropout(TFOutput, TFOutput, TFShape, Nullable<Int32>, String)
  fullName: TFGraph.Dropout(TFOutput, TFOutput, TFShape, Nullable<Int32>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes dropout.
  remarks: "With probability keep_prob, outputs the input element scaled up by 1 / keep_prob, \n            otherwise outputs 0. The scaling is so that the expected sum is unchanged."
  syntax:
    content: public TensorFlow.TFOutput Dropout (TensorFlow.TFOutput x, TensorFlow.TFOutput keep_prob, TensorFlow.TFShape noise_shape = null, Nullable<int> seed = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: A tensor.
    - id: keep_prob
      type: TensorFlow.TFOutput
      description: A scalar Tensor with the same type as x. The probability that each element is kept.
    - id: noise_shape
      type: TensorFlow.TFShape
      description: A 1-D Tensor of type int32, representing the shape for randomly generated keep/drop flags.
    - id: seed
      type: System.Nullable{System.Int32}
      description: Integer seed used for the random distribution, using the TensorFlow SetRandomSeed .
    - id: operName
      type: System.String
      description: Operation name, optional.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.Dropout*
  exceptions: []
- uid: TensorFlow.TFGraph.DynamicPartition(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  id: DynamicPartition(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DynamicPartition(TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.DynamicPartition(TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.DynamicPartition(TFOutput, TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Partitions <code>data</code> into <code>num_partitions</code> tensors using indices from <code>partitions</code>.
  remarks: "For each index tuple <code>js</code> of size <code>partitions.ndim</code>, the slice <code>data[js, ...]</code>\n              becomes part of <code>outputs[partitions[js]]</code>.  The slices with <code>partitions[js] = i</code>\n              are placed in <code>outputs[i]</code> in lexicographic order of <code>js</code>, and the first\n              dimension of <code>outputs[i]</code> is the number of entries in <code>partitions</code> equal to <code>i</code>.\n              In detail,\n              \n               <pre><code>\n              outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]\n              \n              outputs[i] = pack([data[js, ...] for js if partitions[js] == i])\n               </code></pre><code>data.shape</code> must start with <code>partitions.shape</code>.\n              \n              For example:\n              \n               <pre><code>\n              # Scalar partitions.\n              partitions = 1\n              num_partitions = 2\n              data = [10, 20]\n              outputs[0] = []  # Empty with shape [0, 2]\n              outputs[1] = [[10, 20]]\n              \n              # Vector partitions.\n              partitions = [0, 0, 1, 1, 0]\n              num_partitions = 2\n              data = [10, 20, 30, 40, 50]\n              outputs[0] = [10, 20, 50]\n              outputs[1] = [30, 40]\n               </code></pre>\n              \n              See <code>dynamic_stitch</code> for an example on how to merge partitions back.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/DynamicPartition.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput[] DynamicPartition (TensorFlow.TFOutput data, TensorFlow.TFOutput partitions, long num_partitions, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: partitions
      type: TensorFlow.TFOutput
      description: Any shape.  Indices in the range <code>[0, num_partitions)</code>.
    - id: num_partitions
      type: System.Int64
      description: The number of partitions to output.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DynamicPartition'.
    return:
      type: TensorFlow.TFOutput[]
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DynamicPartition*
  exceptions: []
- uid: TensorFlow.TFGraph.DynamicStitch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  id: DynamicStitch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: DynamicStitch(TFOutput[], TFOutput[], String)
  nameWithType: TFGraph.DynamicStitch(TFOutput[], TFOutput[], String)
  fullName: TFGraph.DynamicStitch(TFOutput[], TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Interleave the values from the <code>data</code> tensors into a single tensor.
  remarks: "Builds a merged tensor such that\n              \n               <pre><code>\n              merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]\n               </code></pre>\n              \n              For example, if each <code>indices[m]</code> is scalar or vector, we have\n              \n               <pre><code>\n              # Scalar indices:\n              merged[indices[m], ...] = data[m][...]\n              \n              # Vector indices:\n              merged[indices[m][i], ...] = data[m][i, ...]\n               </code></pre>\n              \n              Each <code>data[i].shape</code> must start with the corresponding <code>indices[i].shape</code>,\n              and the rest of <code>data[i].shape</code> must be constant w.r.t. <code>i</code>.  That is, we\n              must have <code>data[i].shape = indices[i].shape + constant</code>.  In terms of this\n              <code>constant</code>, the output shape is\n              \n              merged.shape = [max(indices)] + constant\n              \n              Values are merged in order, so if an index appears in both <code>indices[m][i]</code> and\n              <code>indices[n][j]</code> for <code>(m,i) &lt; (n,j)</code> the slice <code>data[n][j]</code> will appear in the\n              merged result. If you do not need this guarantee, ParallelDynamicStitch might\n              perform better on some devices.\n              \n              For example:\n              \n               <pre><code>\n              indices[0] = 6\n              indices[1] = [4, 1]\n              indices[2] = [[5, 2], [0, 3]]\n              data[0] = [61, 62]\n              data[1] = [[41, 42], [11, 12]]\n              data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]\n              merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],\n              [51, 52], [61, 62]]\n               </code></pre>\n              \n              This method can be used to merge partitions created by <code>dynamic_partition</code>\n              as illustrated on the following example:\n              \n               <pre><code>\n              # Apply function (increments x_i) on elements for which a certain condition\n              # apply (x_i != -1 in this example).\n              x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])\n              condition_mask=tf.not_equal(x,tf.constant(-1.))\n              partitioned_data = tf.dynamic_partition(\n              x, tf.cast(condition_mask, tf.int32) , 2)\n              partitioned_data[1] = partitioned_data[1] + 1.0\n              condition_indices = tf.dynamic_partition(\n              tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)\n              x = tf.dynamic_stitch(condition_indices, partitioned_data)\n              # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain\n              # unchanged.\n               </code></pre>\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/DynamicStitch.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput DynamicStitch (TensorFlow.TFOutput[] indices, TensorFlow.TFOutput[] data, string operName = null);
    parameters:
    - id: indices
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: data
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'DynamicStitch'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.DynamicStitch*
  exceptions: []
- uid: TensorFlow.TFGraph.EditDistance(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: EditDistance(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: EditDistance(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.EditDistance(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.EditDistance(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the (possibly normalized) Levenshtein Edit Distance.
  remarks: "The inputs are variable-length sequences provided by SparseTensors\n              (hypothesis_indices, hypothesis_values, hypothesis_shape)\n              and\n              (truth_indices, truth_values, truth_shape).\n              \n              The inputs are:"
  syntax:
    content: public TensorFlow.TFOutput EditDistance (TensorFlow.TFOutput hypothesis_indices, TensorFlow.TFOutput hypothesis_values, TensorFlow.TFOutput hypothesis_shape, TensorFlow.TFOutput truth_indices, TensorFlow.TFOutput truth_values, TensorFlow.TFOutput truth_shape, Nullable<bool> normalize = null, string operName = null);
    parameters:
    - id: hypothesis_indices
      type: TensorFlow.TFOutput
      description: >-
        The indices of the hypothesis list SparseTensor.
                      This is an N x R int64 matrix.
    - id: hypothesis_values
      type: TensorFlow.TFOutput
      description: >-
        The values of the hypothesis list SparseTensor.
                      This is an N-length vector.
    - id: hypothesis_shape
      type: TensorFlow.TFOutput
      description: >-
        The shape of the hypothesis list SparseTensor.
                      This is an R-length vector.
    - id: truth_indices
      type: TensorFlow.TFOutput
      description: >-
        The indices of the truth list SparseTensor.
                      This is an M x R int64 matrix.
    - id: truth_values
      type: TensorFlow.TFOutput
      description: >-
        The values of the truth list SparseTensor.
                      This is an M-length vector.
    - id: truth_shape
      type: TensorFlow.TFOutput
      description: truth indices, vector.
    - id: normalize
      type: System.Nullable{System.Boolean}
      description: "Optional argument\n              boolean (if true, edit distances are normalized by length of truth).\n              \n              The output is:"
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'EditDistance'.
    return:
      type: TensorFlow.TFOutput
      description: "A dense float tensor with rank R - 1.\n              \n              For the example input:\n              \n              // hypothesis represents a 2x1 matrix with variable-length values:\n              //   (0,0) = [\"a\"]\n              //   (1,0) = [\"b\"]\n              hypothesis_indices = [[0, 0, 0],\n              [1, 0, 0]]\n              hypothesis_values = [\"a\", \"b\"]\n              hypothesis_shape = [2, 1, 1]\n              \n              // truth represents a 2x2 matrix with variable-length values:\n              //   (0,0) = []\n              //   (0,1) = [\"a\"]\n              //   (1,0) = [\"b\", \"c\"]\n              //   (1,1) = [\"a\"]\n              truth_indices = [[0, 1, 0],\n              [1, 0, 0],\n              [1, 0, 1],\n              [1, 1, 0]]\n              truth_values = [\"a\", \"b\", \"c\", \"a\"]\n              truth_shape = [2, 2, 2]\n              normalize = true\n              \n              The output will be:\n              \n              // output is a 2x2 matrix with edit distances normalized by truth lengths.\n              output = [[inf, 1.0],  // (0,0): no truth, (0,1): no hypothesis\n              [0.5, 1.0]]  // (1,0): addition, (1,1): no hypothesis\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.EditDistance*
  exceptions: []
- uid: TensorFlow.TFGraph.Elu(TensorFlow.TFOutput,System.String)
  id: Elu(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Elu(TFOutput, String)
  nameWithType: TFGraph.Elu(TFOutput, String)
  fullName: TFGraph.Elu(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Computes exponential linear: <code>exp(features) - 1</code> if &lt; 0, <code>features</code> otherwise.'
  remarks: >-
    See [Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)
                  ](http://arxiv.org/abs/1511.07289)
  syntax:
    content: public TensorFlow.TFOutput Elu (TensorFlow.TFOutput features, string operName = null);
    parameters:
    - id: features
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Elu'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Elu*
  exceptions: []
- uid: TensorFlow.TFGraph.EluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: EluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: EluGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.EluGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.EluGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes gradients for the exponential linear (Elu) operation.
  syntax:
    content: public TensorFlow.TFOutput EluGrad (TensorFlow.TFOutput gradients, TensorFlow.TFOutput outputs, string operName = null);
    parameters:
    - id: gradients
      type: TensorFlow.TFOutput
      description: The backpropagated gradients to the corresponding Elu operation.
    - id: outputs
      type: TensorFlow.TFOutput
      description: The outputs of the corresponding Elu operation.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'EluGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The gradients: <code>gradients * (outputs + 1)</code> if outputs &lt; 0,
                      <code>gradients</code> otherwise.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.EluGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.Empty(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  id: Empty(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Empty(TFOutput, TFDataType, Nullable<Boolean>, String)
  nameWithType: TFGraph.Empty(TFOutput, TFDataType, Nullable<Boolean>, String)
  fullName: TFGraph.Empty(TFOutput, TFDataType, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: "Creates a tensor with the given shape.\n              \n              This operation creates a tensor of <code>shape</code> and <code>dtype</code>."
  syntax:
    content: public TensorFlow.TFOutput Empty (TensorFlow.TFOutput shape, TensorFlow.TFDataType dtype, Nullable<bool> init = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFOutput
      description: 1-D. Represents the shape of the output tensor.
    - id: dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: init
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, initialize the returned tensor with the default value of dtype.  Otherwise, the implementation is free not to initializethe tensor's content.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Empty'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A <code>Tensor</code> of type <code>T</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Empty*
  exceptions: []
- uid: TensorFlow.TFGraph.EmptyTensorList(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: EmptyTensorList(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: EmptyTensorList(TFOutput, TFDataType, String)
  nameWithType: TFGraph.EmptyTensorList(TFOutput, TFDataType, String)
  fullName: TFGraph.EmptyTensorList(TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates and returns an empty tensor list.
  remarks: "All list elements must be tensors of dtype element_dtype and shape compatible\n              with element_shape.\n              \n              handle: an empty tensor list.\n              element_dtype: the type of elements in the list.\n              element_shape: a shape compatible with that of elements in the list."
  syntax:
    content: public TensorFlow.TFOutput EmptyTensorList (TensorFlow.TFOutput element_shape, TensorFlow.TFDataType element_dtype, string operName = null);
    parameters:
    - id: element_shape
      type: TensorFlow.TFOutput
      description: To be added.
    - id: element_dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'EmptyTensorList'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.EmptyTensorList*
  exceptions: []
- uid: TensorFlow.TFGraph.EncodeBase64(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: EncodeBase64(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: EncodeBase64(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.EncodeBase64(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.EncodeBase64(TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Encode strings into web-safe base64 format.
  remarks: "Refer to the following article for more information on base64 format:\n              en.wikipedia.org/wiki/Base64. Base64 strings may have padding with '=' at the\n              end so that the encoded has length multiple of 4. See Padding section of the\n              link above.\n              \n              Web-safe means that the encoder uses - and _ instead of + and /."
  syntax:
    content: public TensorFlow.TFOutput EncodeBase64 (TensorFlow.TFOutput input, Nullable<bool> pad = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Strings to be encoded.
    - id: pad
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Bool whether padding is applied at the ends.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeBase64'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Input strings encoded in base64.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.EncodeBase64*
  exceptions: []
- uid: TensorFlow.TFGraph.EncodeJpeg(TensorFlow.TFOutput,System.String,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String)
  id: EncodeJpeg(TensorFlow.TFOutput,System.String,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: EncodeJpeg(TFOutput, String, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String, Nullable<Int64>, Nullable<Int64>, String, String)
  nameWithType: TFGraph.EncodeJpeg(TFOutput, String, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String, Nullable<Int64>, Nullable<Int64>, String, String)
  fullName: TFGraph.EncodeJpeg(TFOutput, String, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String, Nullable<Int64>, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: JPEG-encode an image.
  remarks: "<code>image</code> is a 3-D uint8 Tensor of shape <code>[height, width, channels]</code>.\n              \n              The attr <code>format</code> can be used to override the color format of the encoded\n              output.  Values can be:\n              \n              *   <code>''</code>: Use a default format based on the number of channels in the image.\n              *   <code>grayscale</code>: Output a grayscale JPEG image.  The <code>channels</code> dimension\n              of <code>image</code> must be 1.\n              *   <code>rgb</code>: Output an RGB JPEG image. The <code>channels</code> dimension\n              of <code>image</code> must be 3.\n              \n              If <code>format</code> is not specified or is the empty string, a default format is picked\n              in function of the number of channels in <code>image</code>:\n              \n              *   1: Output a grayscale image.\n              *   3: Output an RGB image."
  syntax:
    content: public TensorFlow.TFOutput EncodeJpeg (TensorFlow.TFOutput image, string format = null, Nullable<long> quality = null, Nullable<bool> progressive = null, Nullable<bool> optimize_size = null, Nullable<bool> chroma_downsampling = null, string density_unit = null, Nullable<long> x_density = null, Nullable<long> y_density = null, string xmp_metadata = null, string operName = null);
    parameters:
    - id: image
      type: TensorFlow.TFOutput
      description: 3-D with shape <code>[height, width, channels]</code>.
    - id: format
      type: System.String
      description: >-
        Optional argument
                      Per pixel image format.
    - id: quality
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Quality of the compression from 0 to 100 (higher is better and slower).
    - id: progressive
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, create a JPEG that loads progressively (coarse to fine).
    - id: optimize_size
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, spend CPU/RAM to reduce size with no quality change.
    - id: chroma_downsampling
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      See http://en.wikipedia.org/wiki/Chroma_subsampling.
    - id: density_unit
      type: System.String
      description: >-
        Optional argument
                      Unit used to specify <code>x_density</code> and <code>y_density</code>:
                      pixels per inch (<code>'in'</code>) or centimeter (<code>'cm'</code>).
    - id: x_density
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Horizontal pixels per density unit.
    - id: y_density
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Vertical pixels per density unit.
    - id: xmp_metadata
      type: System.String
      description: >-
        Optional argument
                      If not empty, embed this XMP metadata in the image header.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeJpeg'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        0-D. JPEG-encoded image.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.EncodeJpeg*
  exceptions: []
- uid: TensorFlow.TFGraph.EncodePng(TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  id: EncodePng(TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: EncodePng(TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.EncodePng(TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.EncodePng(TFOutput, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: PNG-encode an image.
  remarks: "<code>image</code> is a 3-D uint8 or uint16 Tensor of shape <code>[height, width, channels]</code>\n              where <code>channels</code> is:\n              \n              *   1: for grayscale.\n              *   2: for grayscale + alpha.\n              *   3: for RGB.\n              *   4: for RGBA.\n              \n              The ZLIB compression level, <code>compression</code>, can be -1 for the PNG-encoder\n              default or a value from 0 to 9.  9 is the highest compression level, generating\n              the smallest output, but is slower."
  syntax:
    content: public TensorFlow.TFOutput EncodePng (TensorFlow.TFOutput image, Nullable<long> compression = null, string operName = null);
    parameters:
    - id: image
      type: TensorFlow.TFOutput
      description: 3-D with shape <code>[height, width, channels]</code>.
    - id: compression
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Compression level.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodePng'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        0-D. PNG-encoded image.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.EncodePng*
  exceptions: []
- uid: TensorFlow.TFGraph.EncodeProto(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String[],System.String,System.String,System.String)
  id: EncodeProto(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: EncodeProto(TFOutput, TFOutput[], String[], String, String, String)
  nameWithType: TFGraph.EncodeProto(TFOutput, TFOutput[], String[], String, String, String)
  fullName: TFGraph.EncodeProto(TFOutput, TFOutput[], String[], String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: The op serializes protobuf messages provided in the input tensors.
  remarks: "The types of the tensors in <code>values</code> must match the schema for the\n              fields specified in <code>field_names</code>. All the tensors in <code>values</code> must\n              have a common shape prefix, *batch_shape*.\n              \n              The <code>sizes</code> tensor specifies repeat counts for each field.  The repeat\n              count (last dimension) of a each tensor in <code>values</code> must be greater\n              than or equal to corresponding repeat count in <code>sizes</code>.\n              \n              A <code>message_type</code> name must be provided to give context for the field\n              names. The actual message descriptor can be looked up either in the\n              linked-in descriptor pool or a filename provided by the caller using\n              the <code>descriptor_source</code> attribute.\n              \n              The <code>descriptor_source</code> attribute selects a source of protocol\n              descriptors to consult when looking up <code>message_type</code>. This may be a\n              filename containing a serialized <code>FileDescriptorSet</code> message,\n              or the special value <code>local://</code>, in which case only descriptors linked\n              into the code will be searched; the filename can be on any filesystem\n              accessible to TensorFlow.\n              \n              You can build a <code>descriptor_source</code> file using the <code>--descriptor_set_out</code>\n              and <code>--include_imports</code> options to the protocol compiler <code>protoc</code>.\n              \n              The <code>local://</code> database only covers descriptors linked into the\n              code via C++ libraries, not Python imports. You can link in a proto descriptor\n              by creating a cc_library target with alwayslink=1.\n              \n              There are a few special cases in the value mapping:\n              \n              Submessage and group fields must be pre-serialized as TensorFlow strings.\n              \n              TensorFlow lacks support for unsigned int64s, so they must be\n              represented as <code>tf.int64</code> with the same twos-complement bit pattern\n              (the obvious way).\n              \n              Unsigned int32 values can be represented exactly with <code>tf.int64</code>, or\n              with sign wrapping if the input is of type <code>tf.int32</code>."
  syntax:
    content: public TensorFlow.TFOutput EncodeProto (TensorFlow.TFOutput sizes, TensorFlow.TFOutput[] values, string[] field_names, string message_type, string descriptor_source = null, string operName = null);
    parameters:
    - id: sizes
      type: TensorFlow.TFOutput
      description: Tensor of int32 with shape <code>[batch_shape, len(field_names)]</code>.
    - id: values
      type: TensorFlow.TFOutput[]
      description: List of tensors containing values for the corresponding field.
    - id: field_names
      type: System.String[]
      description: List of strings containing proto field names.
    - id: message_type
      type: System.String
      description: Name of the proto message type to decode.
    - id: descriptor_source
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeProto'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Tensor of serialized protos with shape <code>batch_shape</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.EncodeProto*
  exceptions: []
- uid: TensorFlow.TFGraph.EncodeWav(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: EncodeWav(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: EncodeWav(TFOutput, TFOutput, String)
  nameWithType: TFGraph.EncodeWav(TFOutput, TFOutput, String)
  fullName: TFGraph.EncodeWav(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Encode audio data using the WAV file format.
  remarks: "This operation will generate a string suitable to be saved out to create a .wav\n              audio file. It will be encoded in the 16-bit PCM format. It takes in float\n              values in the range -1.0f to 1.0f, and any outside that value will be clamped to\n              that range.\n              \n              <code>audio</code> is a 2-D float Tensor of shape <code>[length, channels]</code>.\n              <code>sample_rate</code> is a scalar Tensor holding the rate to use (e.g. 44100)."
  syntax:
    content: public TensorFlow.TFOutput EncodeWav (TensorFlow.TFOutput audio, TensorFlow.TFOutput sample_rate, string operName = null);
    parameters:
    - id: audio
      type: TensorFlow.TFOutput
      description: 2-D with shape <code>[length, channels]</code>.
    - id: sample_rate
      type: TensorFlow.TFOutput
      description: Scalar containing the sample frequency.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'EncodeWav'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        0-D. WAV-encoded file contents.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.EncodeWav*
  exceptions: []
- uid: TensorFlow.TFGraph.EnqueueTPUEmbeddingIntegerBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  id: EnqueueTPUEmbeddingIntegerBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: EnqueueTPUEmbeddingIntegerBatch(TFOutput[], TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.EnqueueTPUEmbeddingIntegerBatch(TFOutput[], TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.EnqueueTPUEmbeddingIntegerBatch(TFOutput[], TFOutput, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An op that enqueues a list of input batch tensors to TPUEmbedding.
  syntax:
    content: public TensorFlow.TFOperation EnqueueTPUEmbeddingIntegerBatch (TensorFlow.TFOutput[] batch, TensorFlow.TFOutput mode_override, Nullable<long> device_ordinal = null, string operName = null);
    parameters:
    - id: batch
      type: TensorFlow.TFOutput[]
      description: >-
        A list of 1D tensors, one for each embedding table, containing the
                      indices into the tables.
    - id: mode_override
      type: TensorFlow.TFOutput
      description: >-
        A string input that overrides the mode specified in the
                      TPUEmbeddingConfiguration. Supported values are {'unspecified', 'inference',
                      'training', 'backward_pass_only'}. When set to 'unspecified', the mode set
                      in TPUEmbeddingConfiguration is used, otherwise mode_override is used.
    - id: device_ordinal
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The TPU device to use. Should be &gt;= 0 and less than the number
                      of TPU cores in the task on which the node is placed.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'EnqueueTPUEmbeddingIntegerBatch'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.EnqueueTPUEmbeddingIntegerBatch*
  exceptions: []
- uid: TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Nullable{System.Int64},System.String[],System.String)
  id: EnqueueTPUEmbeddingSparseBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Nullable{System.Int64},System.String[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: EnqueueTPUEmbeddingSparseBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Nullable<Int64>, String[], String)
  nameWithType: TFGraph.EnqueueTPUEmbeddingSparseBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Nullable<Int64>, String[], String)
  fullName: TFGraph.EnqueueTPUEmbeddingSparseBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Nullable<Int64>, String[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An op that enqueues TPUEmbedding input indices from a SparseTensor.
  remarks: "This Op eases the porting of code that uses embedding_lookup_sparse(),\n              although some Python preprocessing of the SparseTensor arguments to\n              embedding_lookup_sparse() is required to produce the arguments to this Op,\n              since only a single EnqueueTPUEmbeddingSparseBatch Op is allowed per training\n              step.\n              \n              The tensors at corresponding positions in the three input lists\n              must have the same shape, i.e. rank 1 with dim_size() equal to the total\n              number of lookups into the table described by the corresponding table_id."
  syntax:
    content: public TensorFlow.TFOperation EnqueueTPUEmbeddingSparseBatch (TensorFlow.TFOutput[] sample_indices, TensorFlow.TFOutput[] embedding_indices, TensorFlow.TFOutput[] aggregation_weights, TensorFlow.TFOutput mode_override, Nullable<long> device_ordinal = null, string[] combiners = null, string operName = null);
    parameters:
    - id: sample_indices
      type: TensorFlow.TFOutput[]
      description: >-
        A list of rank 1 Tensors specifying the training example and
                      feature to which the corresponding embedding_indices and aggregation_weights
                      values belong. sample_indices[i] must equal b * nf + f, where nf is the
                      number of features from the corresponding table, f is in [0, nf), and
                      b is in [0, batch size).
    - id: embedding_indices
      type: TensorFlow.TFOutput[]
      description: A list of rank 1 Tensors, indices into the embedding tables.
    - id: aggregation_weights
      type: TensorFlow.TFOutput[]
      description: >-
        A list of rank 1 Tensors containing per sample -- i.e. per
                      (training example, feature) -- aggregation weights.
    - id: mode_override
      type: TensorFlow.TFOutput
      description: >-
        A string input that overrides the mode specified in the
                      TPUEmbeddingConfiguration. Supported values are {'unspecified', 'inference',
                      'training', 'backward_pass_only'}. When set to 'unspecified', the mode set
                      in TPUEmbeddingConfiguration is used, otherwise mode_override is used.
    - id: device_ordinal
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The TPU device to use. Should be &gt;= 0 and less than the number
                      of TPU cores in the task on which the node is placed.
    - id: combiners
      type: System.String[]
      description: >-
        Optional argument
                      A list of string scalars, one for each embedding table that specify
                      how to normalize the embedding activations after weighted summation.
                      Supported combiners are 'mean', 'sum', or 'sqrtn'. It is invalid to have
                      the sum of the weights be 0 for 'mean' or the sum of the squared weights be
                      0 for 'sqrtn'. If combiners isn't passed, the default is to use 'sum' for
                      all tables.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'EnqueueTPUEmbeddingSparseBatch'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseBatch*
  exceptions: []
- uid: TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseTensorBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Int64[],System.Nullable{System.Int64},System.String[],System.String)
  id: EnqueueTPUEmbeddingSparseTensorBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Int64[],System.Nullable{System.Int64},System.String[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: EnqueueTPUEmbeddingSparseTensorBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Int64[], Nullable<Int64>, String[], String)
  nameWithType: TFGraph.EnqueueTPUEmbeddingSparseTensorBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Int64[], Nullable<Int64>, String[], String)
  fullName: TFGraph.EnqueueTPUEmbeddingSparseTensorBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Int64[], Nullable<Int64>, String[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: This Op eases the porting of code that uses tf.nn.embedding_lookup_sparse().
  remarks: "sample_indices[i], embedding_indices[i] and aggregation_weights[i] correspond\n              to the ith feature. table_ids[i] indicates which embedding table to look up ith\n              feature.\n              \n              The tensors at corresponding positions in the three input lists (sample_indices,\n              embedding_indices and aggregation_weights) must have the same shape, i.e. rank 1\n              with dim_size() equal to the total number of lookups into the table described by\n              the corresponding feature."
  syntax:
    content: public TensorFlow.TFOperation EnqueueTPUEmbeddingSparseTensorBatch (TensorFlow.TFOutput[] sample_indices, TensorFlow.TFOutput[] embedding_indices, TensorFlow.TFOutput[] aggregation_weights, TensorFlow.TFOutput mode_override, long[] table_ids, Nullable<long> device_ordinal = null, string[] combiners = null, string operName = null);
    parameters:
    - id: sample_indices
      type: TensorFlow.TFOutput[]
      description: >-
        A list of rank 1 Tensors specifying the training example to
                      which the corresponding embedding_indices and aggregation_weights values
                      belong. It corresponds to sp_ids.indices[:,0] in  embedding_lookup_sparse().
    - id: embedding_indices
      type: TensorFlow.TFOutput[]
      description: >-
        A list of rank 1 Tensors, indices into the embedding tables.
                      It corresponds to sp_ids.values in embedding_lookup_sparse().
    - id: aggregation_weights
      type: TensorFlow.TFOutput[]
      description: >-
        A list of rank 1 Tensors containing per training example
                      aggregation weights. It corresponds to sp_weights.values in
                      embedding_lookup_sparse().
    - id: mode_override
      type: TensorFlow.TFOutput
      description: >-
        A string input that overrides the mode specified in the
                      TPUEmbeddingConfiguration. Supported values are {'unspecified', 'inference',
                      'training', 'backward_pass_only'}. When set to 'unspecified', the mode set
                      in TPUEmbeddingConfiguration is used, otherwise mode_override is used.
    - id: table_ids
      type: System.Int64[]
      description: >-
        A list of integers specifying the identifier of the embedding table
                      (offset of TableDescriptor in the TPUEmbeddingConfiguration) to lookup the
                      corresponding input. The ith input is looked up using table_ids[i]. The size
                      of the table_ids list must be equal to that of sample_indices,
                      embedding_indices and aggregation_weights.
    - id: device_ordinal
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The TPU device to use. Should be &gt;= 0 and less than the number
                      of TPU cores in the task on which the node is placed.
    - id: combiners
      type: System.String[]
      description: >-
        Optional argument
                      A list of string scalars, one for each embedding table that specify
                      how to normalize the embedding activations after weighted summation.
                      Supported combiners are 'mean', 'sum', or 'sqrtn'. It is invalid to have
                      the sum of the weights be 0 for 'mean' or the sum of the squared weights be
                      0 for 'sqrtn'. If combiners isn't passed, the default is to use 'sum' for
                      all tables.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'EnqueueTPUEmbeddingSparseTensorBatch'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseTensorBatch*
  exceptions: []
- uid: TensorFlow.TFGraph.EnsureShape(TensorFlow.TFOutput,TensorFlow.TFShape,System.String)
  id: EnsureShape(TensorFlow.TFOutput,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: EnsureShape(TFOutput, TFShape, String)
  nameWithType: TFGraph.EnsureShape(TFOutput, TFShape, String)
  fullName: TFGraph.EnsureShape(TFOutput, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Ensures that the tensor's shape matches the expected shape.
  remarks: >-
    Raises an error if the input tensor's shape does not match the specified shape.
                  Returns the input tensor otherwise.
  syntax:
    content: public TensorFlow.TFOutput EnsureShape (TensorFlow.TFOutput input, TensorFlow.TFShape shape, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A tensor, whose shape is to be validated.
    - id: shape
      type: TensorFlow.TFShape
      description: The expected (possibly partially specified) shape of the input tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'EnsureShape'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A tensor with the same shape and contents as the input tensor or value.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.EnsureShape*
  exceptions: []
- uid: TensorFlow.TFGraph.Enter(TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  id: Enter(TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Enter(TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  nameWithType: TFGraph.Enter(TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  fullName: TFGraph.Enter(TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates or finds a child frame, and makes <code>data</code> available to the child frame.
  remarks: >-
    This op is used together with <code>Exit</code> to create loops in the graph.
                  The unique <code>frame_name</code> is used by the <code>Executor</code> to identify frames. If
                  <code>is_constant</code> is true, <code>output</code> is a constant in the child frame; otherwise
                  it may be changed in the child frame. At most <code>parallel_iterations</code> iterations
                  are run in parallel in the child frame.
  syntax:
    content: public TensorFlow.TFOutput Enter (TensorFlow.TFOutput data, string frame_name, Nullable<bool> is_constant = null, Nullable<long> parallel_iterations = null, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: The tensor to be made available to the child frame.
    - id: frame_name
      type: System.String
      description: The name of the child frame.
    - id: is_constant
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, the output is constant within the child frame.
    - id: parallel_iterations
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The number of iterations allowed to run in parallel.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Enter'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The same tensor as <code>data</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Enter*
  exceptions: []
- uid: TensorFlow.TFGraph.Equal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Equal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Equal(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Equal(TFOutput, TFOutput, String)
  fullName: TFGraph.Equal(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the truth value of (x == y) element-wise.
  remarks: >-
    *NOTE*: <code>Equal</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput Equal (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Equal'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Equal*
  exceptions: []
- uid: TensorFlow.TFGraph.Erf(TensorFlow.TFOutput,System.String)
  id: Erf(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Erf(TFOutput, String)
  nameWithType: TFGraph.Erf(TFOutput, String)
  fullName: TFGraph.Erf(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the Gauss error function of <code>x</code> element-wise.
  syntax:
    content: public TensorFlow.TFOutput Erf (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Erf'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Erf*
  exceptions: []
- uid: TensorFlow.TFGraph.Erfc(TensorFlow.TFOutput,System.String)
  id: Erfc(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Erfc(TFOutput, String)
  nameWithType: TFGraph.Erfc(TFOutput, String)
  fullName: TFGraph.Erfc(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the complementary error function of <code>x</code> element-wise.
  syntax:
    content: public TensorFlow.TFOutput Erfc (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Erfc'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Erfc*
  exceptions: []
- uid: TensorFlow.TFGraph.Exit(TensorFlow.TFOutput,System.String)
  id: Exit(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Exit(TFOutput, String)
  nameWithType: TFGraph.Exit(TFOutput, String)
  fullName: TFGraph.Exit(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Exits the current frame to its parent frame.
  remarks: Exit makes its input <code>data</code> available to the parent frame.
  syntax:
    content: public TensorFlow.TFOutput Exit (TensorFlow.TFOutput data, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: The tensor to be made available to the parent frame.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Exit'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The same tensor as <code>data</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Exit*
  exceptions: []
- uid: TensorFlow.TFGraph.Exp(TensorFlow.TFOutput,System.String)
  id: Exp(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Exp(TFOutput, String)
  nameWithType: TFGraph.Exp(TFOutput, String)
  fullName: TFGraph.Exp(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes exponential of x element-wise.  \\(y = e^x\\).
  syntax:
    content: public TensorFlow.TFOutput Exp (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Exp'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Exp*
  exceptions: []
- uid: TensorFlow.TFGraph.ExpandDims(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ExpandDims(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ExpandDims(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ExpandDims(TFOutput, TFOutput, String)
  fullName: TFGraph.ExpandDims(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Inserts a dimension of 1 into a tensor's shape.
  remarks: "Given a tensor <code>input</code>, this operation inserts a dimension of 1 at the\n              dimension index <code>axis</code> of <code>input</code>'s shape. The dimension index <code>axis</code> starts at\n              zero; if you specify a negative number for <code>axis</code> it is counted backward from\n              the end.\n              \n              This operation is useful if you want to add a batch dimension to a single\n              element. For example, if you have a single image of shape <code>[height, width,\n              channels]</code>, you can make it a batch of 1 image with <code>expand_dims(image, 0)</code>,\n              which will make the shape <code>[1, height, width, channels]</code>.\n              \n              Other examples:\n              \n               <pre><code>\n              # 't' is a tensor of shape [2]\n              shape(expand_dims(t, 0)) ==&gt; [1, 2]\n              shape(expand_dims(t, 1)) ==&gt; [2, 1]\n              shape(expand_dims(t, -1)) ==&gt; [2, 1]\n              \n              # 't2' is a tensor of shape [2, 3, 5]\n              shape(expand_dims(t2, 0)) ==&gt; [1, 2, 3, 5]\n              shape(expand_dims(t2, 2)) ==&gt; [2, 3, 1, 5]\n              shape(expand_dims(t2, 3)) ==&gt; [2, 3, 5, 1]\n               </code></pre>\n              \n              This operation requires that:\n              \n              <code>-1-input.dims() &lt;= dim &lt;= input.dims()</code>\n              \n              This operation is related to <code>squeeze()</code>, which removes dimensions of\n              size 1."
  syntax:
    content: public TensorFlow.TFOutput ExpandDims (TensorFlow.TFOutput input, TensorFlow.TFOutput dim, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dim
      type: TensorFlow.TFOutput
      description: >-
        0-D (scalar). Specifies the dimension index at which to
                      expand the shape of <code>input</code>. Must be in the range
                      <code>[-rank(input) - 1, rank(input)]</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ExpandDims'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Contains the same data as <code>input</code>, but its shape has an additional
                      dimension of size 1 added.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ExpandDims*
  exceptions: []
- uid: TensorFlow.TFGraph.ExperimentalDirectedInterleaveDataset(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: ExperimentalDirectedInterleaveDataset(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ExperimentalDirectedInterleaveDataset(TFOutput, TFOutput[], TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ExperimentalDirectedInterleaveDataset(TFOutput, TFOutput[], TFDataType[], TFShape[], String)
  fullName: TFGraph.ExperimentalDirectedInterleaveDataset(TFOutput, TFOutput[], TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A substitute for <code>InterleaveDataset</code> on a fixed list of <code>N</code> datasets.
  syntax:
    content: public TensorFlow.TFOutput ExperimentalDirectedInterleaveDataset (TensorFlow.TFOutput selector_input_dataset, TensorFlow.TFOutput[] data_input_datasets, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: selector_input_dataset
      type: TensorFlow.TFOutput
      description: >-
        A dataset of scalar <code>DT_INT64</code> elements that determines which of the
                      <code>N</code> data inputs should produce the next output element.
    - id: data_input_datasets
      type: TensorFlow.TFOutput[]
      description: >-
        <code>N</code> datasets with the same type that will be interleaved according to
                      the values of <code>selector_input_dataset</code>.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalDirectedInterleaveDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ExperimentalDirectedInterleaveDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.ExperimentalIgnoreErrorsDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: ExperimentalIgnoreErrorsDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ExperimentalIgnoreErrorsDataset(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ExperimentalIgnoreErrorsDataset(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.ExperimentalIgnoreErrorsDataset(TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that contains the elements of <code>input_dataset</code> ignoring errors.
  syntax:
    content: public TensorFlow.TFOutput ExperimentalIgnoreErrorsDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalIgnoreErrorsDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ExperimentalIgnoreErrorsDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.ExperimentalIteratorGetDevice(TensorFlow.TFOutput,System.String)
  id: ExperimentalIteratorGetDevice(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ExperimentalIteratorGetDevice(TFOutput, String)
  nameWithType: TFGraph.ExperimentalIteratorGetDevice(TFOutput, String)
  fullName: TFGraph.ExperimentalIteratorGetDevice(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the name of the device on which <code>resource</code> has been placed.
  syntax:
    content: public TensorFlow.TFOutput ExperimentalIteratorGetDevice (TensorFlow.TFOutput resource, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalIteratorGetDevice'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ExperimentalIteratorGetDevice*
  exceptions: []
- uid: TensorFlow.TFGraph.ExperimentalThreadPoolDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: ExperimentalThreadPoolDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ExperimentalThreadPoolDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ExperimentalThreadPoolDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.ExperimentalThreadPoolDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that uses a custom thread pool to compute <code>input_dataset</code>.
  syntax:
    content: public TensorFlow.TFOutput ExperimentalThreadPoolDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput thread_pool, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: thread_pool
      type: TensorFlow.TFOutput
      description: A resource produced by the ThreadPoolHandle op.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalThreadPoolDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ExperimentalThreadPoolDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.ExperimentalThreadPoolHandle(System.Int64,System.String,System.Nullable{System.Int64},System.String,System.String,System.String)
  id: ExperimentalThreadPoolHandle(System.Int64,System.String,System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ExperimentalThreadPoolHandle(Int64, String, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.ExperimentalThreadPoolHandle(Int64, String, Nullable<Int64>, String, String, String)
  fullName: TFGraph.ExperimentalThreadPoolHandle(Int64, String, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that uses a custom thread pool to compute <code>input_dataset</code>.
  syntax:
    content: public TensorFlow.TFOutput ExperimentalThreadPoolHandle (long num_threads, string display_name, Nullable<long> max_intra_op_parallelism = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: num_threads
      type: System.Int64
      description: The number of threads in the thread pool.
    - id: display_name
      type: System.String
      description: >-
        A human-readable name for the threads that may be visible in some
                      visualizations.
                      threadpool.
    - id: max_intra_op_parallelism
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The maximum degree of parallelism to use within operations that execute on this
                      threadpool.
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalThreadPoolHandle'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A resource that can be consumed by one or more ExperimentalThreadPoolDataset
                      ops.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ExperimentalThreadPoolHandle*
  exceptions: []
- uid: TensorFlow.TFGraph.ExperimentalUniqueDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: ExperimentalUniqueDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ExperimentalUniqueDataset(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ExperimentalUniqueDataset(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.ExperimentalUniqueDataset(TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that contains the unique elements of <code>input_dataset</code>.
  syntax:
    content: public TensorFlow.TFOutput ExperimentalUniqueDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ExperimentalUniqueDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ExperimentalUniqueDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.Expm1(TensorFlow.TFOutput,System.String)
  id: Expm1(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Expm1(TFOutput, String)
  nameWithType: TFGraph.Expm1(TFOutput, String)
  fullName: TFGraph.Expm1(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes exponential of x - 1 element-wise.
  remarks: I.e., \\(y = (\exp x) - 1\\).
  syntax:
    content: public TensorFlow.TFOutput Expm1 (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Expm1'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Expm1*
  exceptions: []
- uid: TensorFlow.TFGraph.ExtractGlimpse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: ExtractGlimpse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ExtractGlimpse(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ExtractGlimpse(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ExtractGlimpse(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Extracts a glimpse from the input tensor.
  remarks: "Returns a set of windows called glimpses extracted at location\n              <code>offsets</code> from the input tensor. If the windows only partially\n              overlaps the inputs, the non overlapping areas will be filled with\n              random noise.\n              \n              The result is a 4-D tensor of shape <code>[batch_size, glimpse_height,\n              glimpse_width, channels]</code>. The channels and batch dimensions are the\n              same as that of the input tensor. The height and width of the output\n              windows are specified in the <code>size</code> parameter.\n              \n              The argument <code>normalized</code> and <code>centered</code> controls how the windows are built:\n              \n              * If the coordinates are normalized but not centered, 0.0 and 1.0\n              correspond to the minimum and maximum of each height and width\n              dimension.\n              * If the coordinates are both normalized and centered, they range from\n              -1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to the upper\n              left corner, the lower right corner is located at (1.0, 1.0) and the\n              center is at (0, 0).\n              * If the coordinates are not normalized they are interpreted as\n              numbers of pixels."
  syntax:
    content: public TensorFlow.TFOutput ExtractGlimpse (TensorFlow.TFOutput input, TensorFlow.TFOutput size, TensorFlow.TFOutput offsets, Nullable<bool> centered = null, Nullable<bool> normalized = null, Nullable<bool> uniform_noise = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A 4-D float tensor of shape <code>[batch_size, height, width, channels]</code>.
    - id: size
      type: TensorFlow.TFOutput
      description: >-
        A 1-D tensor of 2 elements containing the size of the glimpses
                      to extract.  The glimpse height must be specified first, following
                      by the glimpse width.
    - id: offsets
      type: TensorFlow.TFOutput
      description: >-
        A 2-D integer tensor of shape <code>[batch_size, 2]</code> containing
                      the y, x locations of the center of each window.
    - id: centered
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      indicates if the offset coordinates are centered relative to
                      the image, in which case the (0, 0) offset is relative to the center
                      of the input images. If false, the (0,0) offset corresponds to the
                      upper left corner of the input images.
    - id: normalized
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      indicates if the offset coordinates are normalized.
    - id: uniform_noise
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      indicates if the noise should be generated using a
                      uniform distribution or a Gaussian distribution.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractGlimpse'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A tensor representing the glimpses <code>[batch_size,
                      glimpse_height, glimpse_width, channels]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ExtractGlimpse*
  exceptions: []
- uid: TensorFlow.TFGraph.ExtractImagePatches(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.Int64[],System.String,System.String)
  id: ExtractImagePatches(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ExtractImagePatches(TFOutput, Int64[], Int64[], Int64[], String, String)
  nameWithType: TFGraph.ExtractImagePatches(TFOutput, Int64[], Int64[], Int64[], String, String)
  fullName: TFGraph.ExtractImagePatches(TFOutput, Int64[], Int64[], Int64[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Extract <code>patches</code> from <code>images</code> and put them in the "depth" output dimension.
  syntax:
    content: public TensorFlow.TFOutput ExtractImagePatches (TensorFlow.TFOutput images, long[] ksizes, long[] strides, long[] rates, string padding, string operName = null);
    parameters:
    - id: images
      type: TensorFlow.TFOutput
      description: 4-D Tensor with shape <code>[batch, in_rows, in_cols, depth]</code>.
    - id: ksizes
      type: System.Int64[]
      description: The size of the sliding window for each dimension of <code>images</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D of length 4. How far the centers of two consecutive patches are in
                      the images. Must be: <code>[1, stride_rows, stride_cols, 1]</code>.
    - id: rates
      type: System.Int64[]
      description: >-
        1-D of length 4. Must be: <code>[1, rate_rows, rate_cols, 1]</code>. This is the
                      input stride, specifying how far two consecutive patch samples are in the
                      input. Equivalent to extracting patches with
                      <code>patch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1)</code>, followed by
                      subsampling them spatially by a factor of <code>rates</code>. This is equivalent to
                      <code>rate</code> in dilated (a.k.a. Atrous) convolutions.
    - id: padding
      type: System.String
      description: "The type of padding algorithm to use.\n              \n              We specify the size-related attributes as:\n              \n               <pre><code>\n              ksizes = [1, ksize_rows, ksize_cols, 1]\n              strides = [1, strides_rows, strides_cols, 1]\n              rates = [1, rates_rows, rates_cols, 1]\n               </code></pre>"
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractImagePatches'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D Tensor with shape <code>[batch, out_rows, out_cols, ksize_rows *
                      ksize_cols * depth]</code> containing image patches with size
                      <code>ksize_rows x ksize_cols x depth</code> vectorized in the "depth" dimension. Note
                      <code>out_rows</code> and <code>out_cols</code> are the dimensions of the output patches.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ExtractImagePatches*
  exceptions: []
- uid: TensorFlow.TFGraph.ExtractJpegShape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: ExtractJpegShape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ExtractJpegShape(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.ExtractJpegShape(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.ExtractJpegShape(TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Extract the shape information of a JPEG-encoded image.
  remarks: This op only parses the image header, so it is much faster than DecodeJpeg.
  syntax:
    content: public TensorFlow.TFOutput ExtractJpegShape (TensorFlow.TFOutput contents, Nullable<TensorFlow.TFDataType> output_type = null, string operName = null);
    parameters:
    - id: contents
      type: TensorFlow.TFOutput
      description: 0-D. The JPEG-encoded image.
    - id: output_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: >-
        Optional argument
                      (Optional) The output type of the operation (int32 or int64).
                      Defaults to int32.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractJpegShape'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        1-D. The image shape with format [height, width, channels].
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ExtractJpegShape*
  exceptions: []
- uid: TensorFlow.TFGraph.ExtractVolumePatches(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  id: ExtractVolumePatches(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ExtractVolumePatches(TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.ExtractVolumePatches(TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.ExtractVolumePatches(TFOutput, Int64[], Int64[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Extract <code>patches</code> from <code>input</code> and put them in the "depth" output dimension. 3D extension of <code>extract_image_patches</code>.
  syntax:
    content: public TensorFlow.TFOutput ExtractVolumePatches (TensorFlow.TFOutput input, long[] ksizes, long[] strides, string padding, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 5-D Tensor with shape <code>[batch, in_planes, in_rows, in_cols, depth]</code>.
    - id: ksizes
      type: System.Int64[]
      description: The size of the sliding window for each dimension of <code>input</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D of length 5. How far the centers of two consecutive patches are in
                      <code>input</code>. Must be: <code>[1, stride_planes, stride_rows, stride_cols, 1]</code>.
    - id: padding
      type: System.String
      description: "The type of padding algorithm to use.\n              \n              We specify the size-related attributes as:\n              \n               <pre><code>\n              ksizes = [1, ksize_planes, ksize_rows, ksize_cols, 1]\n              strides = [1, stride_planes, strides_rows, strides_cols, 1]\n               </code></pre>"
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ExtractVolumePatches'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        5-D Tensor with shape <code>[batch, out_planes, out_rows, out_cols,
                      ksize_planes * ksize_rows * ksize_cols * depth]</code> containing patches
                      with size <code>ksize_planes x ksize_rows x ksize_cols x depth</code> vectorized
                      in the "depth" dimension. Note <code>out_planes</code>, <code>out_rows</code> and <code>out_cols</code>
                      are the dimensions of the output patches.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ExtractVolumePatches*
  exceptions: []
- uid: TensorFlow.TFGraph.Fact(System.String)
  id: Fact(System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Fact(String)
  nameWithType: TFGraph.Fact(String)
  fullName: TFGraph.Fact(String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Output a fact about factorials.
  syntax:
    content: public TensorFlow.TFOutput Fact (string operName = null);
    parameters:
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Fact'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Fact*
  exceptions: []
- uid: TensorFlow.TFGraph.FakeParam(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  id: FakeParam(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FakeParam(TFDataType, TFShape, String)
  nameWithType: TFGraph.FakeParam(TFDataType, TFShape, String)
  fullName: TFGraph.FakeParam(TFDataType, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: >-
    This op is used as a placeholder in If branch functions. It doesn't provide a
                  valid output when run, so must either be removed (e.g. replaced with a
                  function input) or guaranteed not to be used (e.g. if mirroring an
                  intermediate output needed for the gradient computation of the other branch).
  syntax:
    content: public TensorFlow.TFOutput FakeParam (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string operName = null);
    parameters:
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of the output.
    - id: shape
      type: TensorFlow.TFShape
      description: >-
        The purported shape of the output. This is only used for shape inference;
                      the output will not necessarily have this shape. Can be a partial shape.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeParam'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        \"Fake\" output value. This should not be consumed by another op.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FakeParam*
  exceptions: []
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxArgs(TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  id: FakeQuantWithMinMaxArgs(TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FakeQuantWithMinMaxArgs(TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.FakeQuantWithMinMaxArgs(TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.FakeQuantWithMinMaxArgs(TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Fake-quantize the 'inputs' tensor, type float to 'outputs' tensor of same type.
  remarks: "Attributes <code>[min; max]</code> define the clamping range for the <code>inputs</code> data.\n              <code>inputs</code> values are quantized into the quantization range (<code>[0; 2^num_bits - 1]</code>\n              when <code>narrow_range</code> is false and <code>[1; 2^num_bits - 1]</code> when it is true) and\n              then de-quantized and output as floats in <code>[min; max]</code> interval.\n              <code>num_bits</code> is the bitwidth of the quantization; between 2 and 16, inclusive.\n              \n              Quantization is called fake since the output is still in floating point."
  syntax:
    content: public TensorFlow.TFOutput FakeQuantWithMinMaxArgs (TensorFlow.TFOutput inputs, Nullable<float> min = null, Nullable<float> max = null, Nullable<long> num_bits = null, Nullable<bool> narrow_range = null, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput
      description: To be added.
    - id: min
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: max
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: num_bits
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: narrow_range
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxArgs'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FakeQuantWithMinMaxArgs*
  exceptions: []
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxArgsGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  id: FakeQuantWithMinMaxArgsGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FakeQuantWithMinMaxArgsGradient(TFOutput, TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.FakeQuantWithMinMaxArgsGradient(TFOutput, TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.FakeQuantWithMinMaxArgsGradient(TFOutput, TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Compute gradients for a FakeQuantWithMinMaxArgs operation.
  syntax:
    content: public TensorFlow.TFOutput FakeQuantWithMinMaxArgsGradient (TensorFlow.TFOutput gradients, TensorFlow.TFOutput inputs, Nullable<float> min = null, Nullable<float> max = null, Nullable<long> num_bits = null, Nullable<bool> narrow_range = null, string operName = null);
    parameters:
    - id: gradients
      type: TensorFlow.TFOutput
      description: Backpropagated gradients above the FakeQuantWithMinMaxArgs operation.
    - id: inputs
      type: TensorFlow.TFOutput
      description: Values passed as inputs to the FakeQuantWithMinMaxArgs operation.
    - id: min
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: max
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: num_bits
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: narrow_range
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxArgsGradient'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Backpropagated gradients below the FakeQuantWithMinMaxArgs operation:
                      <code>gradients * (inputs &gt;= min && inputs &lt;= max)</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FakeQuantWithMinMaxArgsGradient*
  exceptions: []
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxVars(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  id: FakeQuantWithMinMaxVars(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FakeQuantWithMinMaxVars(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.FakeQuantWithMinMaxVars(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.FakeQuantWithMinMaxVars(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Fake-quantize the 'inputs' tensor of type float via global float scalars <code>min</code>
  remarks: "and <code>max</code> to 'outputs' tensor of same shape as <code>inputs</code>.\n              \n              <code>[min; max]</code> define the clamping range for the <code>inputs</code> data.\n              <code>inputs</code> values are quantized into the quantization range (<code>[0; 2^num_bits - 1]</code>\n              when <code>narrow_range</code> is false and <code>[1; 2^num_bits - 1]</code> when it is true) and\n              then de-quantized and output as floats in <code>[min; max]</code> interval.\n              <code>num_bits</code> is the bitwidth of the quantization; between 2 and 16, inclusive.\n              \n              This operation has a gradient and thus allows for training <code>min</code> and <code>max</code>\n              values."
  syntax:
    content: public TensorFlow.TFOutput FakeQuantWithMinMaxVars (TensorFlow.TFOutput inputs, TensorFlow.TFOutput min, TensorFlow.TFOutput max, Nullable<long> num_bits = null, Nullable<bool> narrow_range = null, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput
      description: To be added.
    - id: min
      type: TensorFlow.TFOutput
      description: To be added.
    - id: max
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_bits
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: narrow_range
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVars'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FakeQuantWithMinMaxVars*
  exceptions: []
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxVarsGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  id: FakeQuantWithMinMaxVarsGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FakeQuantWithMinMaxVarsGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.FakeQuantWithMinMaxVarsGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.FakeQuantWithMinMaxVarsGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Compute gradients for a FakeQuantWithMinMaxVars operation.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> FakeQuantWithMinMaxVarsGradient (TensorFlow.TFOutput gradients, TensorFlow.TFOutput inputs, TensorFlow.TFOutput min, TensorFlow.TFOutput max, Nullable<long> num_bits = null, Nullable<bool> narrow_range = null, string operName = null);
    parameters:
    - id: gradients
      type: TensorFlow.TFOutput
      description: Backpropagated gradients above the FakeQuantWithMinMaxVars operation.
    - id: inputs
      type: TensorFlow.TFOutput
      description: >-
        Values passed as inputs to the FakeQuantWithMinMaxVars operation.
                      min, max: Quantization interval, scalar floats.
    - id: min
      type: TensorFlow.TFOutput
      description: To be added.
    - id: max
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_bits
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The bitwidth of the quantization; between 2 and 8, inclusive.
    - id: narrow_range
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Whether to quantize into 2^num_bits - 1 distinct values.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVarsGradient'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      backprops_wrt_input: Backpropagated gradients w.r.t. inputs:
                      <code>gradients * (inputs &gt;= min && inputs &lt;= max)</code>.
                      backprop_wrt_min: Backpropagated gradients w.r.t. min parameter:
                      <code>sum(gradients * (inputs &lt; min))</code>.
                      backprop_wrt_max: Backpropagated gradients w.r.t. max parameter:
                      <code>sum(gradients * (inputs &gt; max))</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.FakeQuantWithMinMaxVarsGradient*
  exceptions: []
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannel(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  id: FakeQuantWithMinMaxVarsPerChannel(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FakeQuantWithMinMaxVarsPerChannel(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.FakeQuantWithMinMaxVarsPerChannel(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.FakeQuantWithMinMaxVarsPerChannel(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: "Fake-quantize the 'inputs' tensor of type float and one of the shapes: <code>[d]</code>,"
  remarks: "<code>[b, d]</code>\n    <code>[b, h, w, d]</code> via per-channel floats <code>min</code> and <code>max</code> of shape <code>[d]</code>\n              to 'outputs' tensor of same shape as <code>inputs</code>.\n              \n              <code>[min; max]</code> define the clamping range for the <code>inputs</code> data.\n              <code>inputs</code> values are quantized into the quantization range (<code>[0; 2^num_bits - 1]</code>\n              when <code>narrow_range</code> is false and <code>[1; 2^num_bits - 1]</code> when it is true) and\n              then de-quantized and output as floats in <code>[min; max]</code> interval.\n              <code>num_bits</code> is the bitwidth of the quantization; between 2 and 16, inclusive.\n              \n              This operation has a gradient and thus allows for training <code>min</code> and <code>max</code>\n              values."
  syntax:
    content: public TensorFlow.TFOutput FakeQuantWithMinMaxVarsPerChannel (TensorFlow.TFOutput inputs, TensorFlow.TFOutput min, TensorFlow.TFOutput max, Nullable<long> num_bits = null, Nullable<bool> narrow_range = null, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput
      description: To be added.
    - id: min
      type: TensorFlow.TFOutput
      description: To be added.
    - id: max
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_bits
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: narrow_range
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVarsPerChannel'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannel*
  exceptions: []
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  id: FakeQuantWithMinMaxVarsPerChannelGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FakeQuantWithMinMaxVarsPerChannelGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Compute gradients for a FakeQuantWithMinMaxVarsPerChannel operation.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> FakeQuantWithMinMaxVarsPerChannelGradient (TensorFlow.TFOutput gradients, TensorFlow.TFOutput inputs, TensorFlow.TFOutput min, TensorFlow.TFOutput max, Nullable<long> num_bits = null, Nullable<bool> narrow_range = null, string operName = null);
    parameters:
    - id: gradients
      type: TensorFlow.TFOutput
      description: >-
        Backpropagated gradients above the FakeQuantWithMinMaxVars operation,
                      shape one of: <code>[d]</code>, <code>[b, d]</code>,  <code>[b, h, w, d]</code>.
    - id: inputs
      type: TensorFlow.TFOutput
      description: >-
        Values passed as inputs to the FakeQuantWithMinMaxVars operation, shape
                      same as <code>gradients</code>.
                      min, max: Quantization interval, floats of shape <code>[d]</code>.
    - id: min
      type: TensorFlow.TFOutput
      description: To be added.
    - id: max
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_bits
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The bitwidth of the quantization; between 2 and 16, inclusive.
    - id: narrow_range
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Whether to quantize into 2^num_bits - 1 distinct values.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQuantWithMinMaxVarsPerChannelGradient'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      backprops_wrt_input: Backpropagated gradients w.r.t. inputs, shape same as
                      <code>inputs</code>:
                      <code>gradients * (inputs &gt;= min && inputs &lt;= max)</code>.
                      backprop_wrt_min: Backpropagated gradients w.r.t. min parameter, shape <code>[d]</code>:
                      <code>sum_per_d(gradients * (inputs &lt; min))</code>.
                      backprop_wrt_max: Backpropagated gradients w.r.t. max parameter, shape <code>[d]</code>:
                      <code>sum_per_d(gradients * (inputs &gt; max))</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient*
  exceptions: []
- uid: TensorFlow.TFGraph.FakeQueue(TensorFlow.TFOutput,System.String)
  id: FakeQueue(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FakeQueue(TFOutput, String)
  nameWithType: TFGraph.FakeQueue(TFOutput, String)
  fullName: TFGraph.FakeQueue(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated. Do not use.
  syntax:
    content: public TensorFlow.TFOutput FakeQueue (TensorFlow.TFOutput resource, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FakeQueue'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FakeQueue*
  exceptions: []
- uid: TensorFlow.TFGraph.FFT(TensorFlow.TFOutput,System.String)
  id: FFT(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FFT(TFOutput, String)
  nameWithType: TFGraph.FFT(TFOutput, String)
  fullName: TFGraph.FFT(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Fast Fourier transform.
  remarks: >-
    Computes the 1-dimensional discrete Fourier transform over the inner-most
                  dimension of <code>input</code>.
  syntax:
    content: public TensorFlow.TFOutput FFT (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A complex tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FFT'.
    return:
      type: TensorFlow.TFOutput
      description: "A complex tensor of the same shape as <code>input</code>. The inner-most\n              dimension of <code>input</code> is replaced with its 1D Fourier transform.\n              \n              @compatibility(numpy)\n              Equivalent to np.fft.fft\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.FFT*
  exceptions: []
- uid: TensorFlow.TFGraph.FFT2D(TensorFlow.TFOutput,System.String)
  id: FFT2D(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FFT2D(TFOutput, String)
  nameWithType: TFGraph.FFT2D(TFOutput, String)
  fullName: TFGraph.FFT2D(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 2D fast Fourier transform.
  remarks: >-
    Computes the 2-dimensional discrete Fourier transform over the inner-most
                  2 dimensions of <code>input</code>.
  syntax:
    content: public TensorFlow.TFOutput FFT2D (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A complex tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FFT2D'.
    return:
      type: TensorFlow.TFOutput
      description: "A complex tensor of the same shape as <code>input</code>. The inner-most 2\n              dimensions of <code>input</code> are replaced with their 2D Fourier transform.\n              \n              @compatibility(numpy)\n              Equivalent to np.fft.fft2\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.FFT2D*
  exceptions: []
- uid: TensorFlow.TFGraph.FFT3D(TensorFlow.TFOutput,System.String)
  id: FFT3D(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FFT3D(TFOutput, String)
  nameWithType: TFGraph.FFT3D(TFOutput, String)
  fullName: TFGraph.FFT3D(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 3D fast Fourier transform.
  remarks: >-
    Computes the 3-dimensional discrete Fourier transform over the inner-most 3
                  dimensions of <code>input</code>.
  syntax:
    content: public TensorFlow.TFOutput FFT3D (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A complex64 tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FFT3D'.
    return:
      type: TensorFlow.TFOutput
      description: "A complex64 tensor of the same shape as <code>input</code>. The inner-most 3\n              dimensions of <code>input</code> are replaced with their 3D Fourier transform.\n              \n              @compatibility(numpy)\n              Equivalent to np.fft.fftn with 3 dimensions.\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.FFT3D*
  exceptions: []
- uid: TensorFlow.TFGraph.FIFOQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  id: FIFOQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FIFOQueue(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.FIFOQueue(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.FIFOQueue(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A queue that produces elements in first-in first-out order.
  syntax:
    content: public TensorFlow.TFOutput FIFOQueue (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable<long> capacity = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a value.
    - id: shapes
      type: TensorFlow.TFShape[]
      description: >-
        Optional argument
                      The shape of each component in a value. The length of this attr must
                      be either 0 or the same as the length of component_types. If the length of
                      this attr is 0, the shapes of queue elements are not constrained, and
                      only one element may be dequeued at a time.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The upper bound on the number of elements in this queue.
                      Negative numbers mean no limit.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue will be shared under the given name
                      across multiple sessions.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FIFOQueue'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to the queue.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FIFOQueue*
  exceptions: []
- uid: TensorFlow.TFGraph.FIFOQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  id: FIFOQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FIFOQueueV2(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.FIFOQueueV2(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.FIFOQueueV2(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A queue that produces elements in first-in first-out order.
  syntax:
    content: public TensorFlow.TFOutput FIFOQueueV2 (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable<long> capacity = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a value.
    - id: shapes
      type: TensorFlow.TFShape[]
      description: >-
        Optional argument
                      The shape of each component in a value. The length of this attr must
                      be either 0 or the same as the length of component_types. If the length of
                      this attr is 0, the shapes of queue elements are not constrained, and
                      only one element may be dequeued at a time.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The upper bound on the number of elements in this queue.
                      Negative numbers mean no limit.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue will be shared under the given name
                      across multiple sessions.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FIFOQueueV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to the queue.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FIFOQueueV2*
  exceptions: []
- uid: TensorFlow.TFGraph.Fill(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Fill(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Fill(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Fill(TFOutput, TFOutput, String)
  fullName: TFGraph.Fill(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a tensor filled with a scalar value.
  remarks: "This operation creates a tensor of shape <code>dims</code> and fills it with <code>value</code>.\n              \n              For example:\n              \n               <pre><code>\n              # Output tensor has shape [2, 3].\n              fill([2, 3], 9) ==&gt; [[9, 9, 9]\n              [9, 9, 9]]\n               </code></pre><code>tf.fill</code> differs from <code>tf.constant</code> in a few ways:\n              \n              *   <code>tf.fill</code> only supports scalar contents, whereas <code>tf.constant</code> supports\n              Tensor values.\n              *   <code>tf.fill</code> creates an Op in the computation graph that constructs the actual\n              Tensor value at runtime. This is in contrast to <code>tf.constant</code> which embeds\n              the entire Tensor into the graph with a <code>Const</code> node.\n              *   Because <code>tf.fill</code> evaluates at graph runtime, it supports dynamic shapes\n              based on other runtime Tensors, unlike <code>tf.constant</code>."
  syntax:
    content: public TensorFlow.TFOutput Fill (TensorFlow.TFOutput dims, TensorFlow.TFOutput value, string operName = null);
    parameters:
    - id: dims
      type: TensorFlow.TFOutput
      description: 1-D. Represents the shape of the output tensor.
    - id: value
      type: TensorFlow.TFOutput
      description: "0-D (scalar). Value to fill the returned tensor.\n              \n              @compatibility(numpy)\n              Equivalent to np.full\n              @end_compatibility"
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Fill'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Fill*
  exceptions: []
- uid: TensorFlow.TFGraph.FilterByLastComponentDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: FilterByLastComponentDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FilterByLastComponentDataset(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.FilterByLastComponentDataset(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.FilterByLastComponentDataset(TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset containing elements of first component of <code>input_dataset</code> having true in the last component.
  syntax:
    content: public TensorFlow.TFOutput FilterByLastComponentDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FilterByLastComponentDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FilterByLastComponentDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.FixedLengthRecordDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: FixedLengthRecordDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FixedLengthRecordDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.FixedLengthRecordDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.FixedLengthRecordDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that emits the records from one or more binary files.
  syntax:
    content: public TensorFlow.TFOutput FixedLengthRecordDataset (TensorFlow.TFOutput filenames, TensorFlow.TFOutput header_bytes, TensorFlow.TFOutput record_bytes, TensorFlow.TFOutput footer_bytes, TensorFlow.TFOutput buffer_size, string operName = null);
    parameters:
    - id: filenames
      type: TensorFlow.TFOutput
      description: >-
        A scalar or a vector containing the name(s) of the file(s) to be
                      read.
    - id: header_bytes
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing the number of bytes to skip at the
                      beginning of a file.
    - id: record_bytes
      type: TensorFlow.TFOutput
      description: A scalar representing the number of bytes in each record.
    - id: footer_bytes
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing the number of bytes to skip at the end
                      of a file.
    - id: buffer_size
      type: TensorFlow.TFOutput
      description: A scalar representing the number of bytes to buffer. Must be &gt; 0.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FixedLengthRecordDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.FixedLengthRecordReader(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: FixedLengthRecordReader(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FixedLengthRecordReader(Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.FixedLengthRecordReader(Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.FixedLengthRecordReader(Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A Reader that outputs fixed-length records from a file.
  syntax:
    content: public TensorFlow.TFOutput FixedLengthRecordReader (long record_bytes, Nullable<long> header_bytes = null, Nullable<long> footer_bytes = null, Nullable<long> hop_bytes = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: record_bytes
      type: System.Int64
      description: Number of bytes in the record.
    - id: header_bytes
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of bytes in the header, defaults to 0.
    - id: footer_bytes
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of bytes in the footer, defaults to 0.
    - id: hop_bytes
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of bytes to hop before each read. Default of 0 means using
                      record_bytes.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordReader'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to reference the Reader.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FixedLengthRecordReader*
  exceptions: []
- uid: TensorFlow.TFGraph.FixedLengthRecordReaderV2(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String,System.String)
  id: FixedLengthRecordReaderV2(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FixedLengthRecordReaderV2(Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String, String)
  nameWithType: TFGraph.FixedLengthRecordReaderV2(Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String, String)
  fullName: TFGraph.FixedLengthRecordReaderV2(Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A Reader that outputs fixed-length records from a file.
  syntax:
    content: public TensorFlow.TFOutput FixedLengthRecordReaderV2 (long record_bytes, Nullable<long> header_bytes = null, Nullable<long> footer_bytes = null, Nullable<long> hop_bytes = null, string container = null, string shared_name = null, string encoding = null, string operName = null);
    parameters:
    - id: record_bytes
      type: System.Int64
      description: Number of bytes in the record.
    - id: header_bytes
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of bytes in the header, defaults to 0.
    - id: footer_bytes
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of bytes in the footer, defaults to 0.
    - id: hop_bytes
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of bytes to hop before each read. Default of 0 means using
                      record_bytes.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: encoding
      type: System.String
      description: >-
        Optional argument
                      The type of encoding for the file. Currently ZLIB and GZIP
                      are supported. Defaults to none.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedLengthRecordReaderV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to reference the Reader.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FixedLengthRecordReaderV2*
  exceptions: []
- uid: TensorFlow.TFGraph.FixedUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Single[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: FixedUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Single[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FixedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Single[], Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.FixedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Single[], Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.FixedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Single[], Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generates labels for candidate sampling with a learned unigram distribution.
  remarks: "A unigram sampler could use a fixed unigram distribution read from a\n              file or passed in as an in-memory array instead of building up the distribution\n              from data on the fly. There is also an option to skew the distribution by\n              applying a distortion power to the weights.\n              \n              The vocabulary file should be in CSV-like format, with the last field\n              being the weight associated with the word.\n              \n              For each batch, this op picks a single set of sampled candidate labels.\n              \n              The advantages of sampling candidates per-batch are simplicity and the\n              possibility of efficient dense matrix multiplication. The disadvantage is that\n              the sampled candidates must be chosen independently of the context and of the\n              true labels."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> FixedUnigramCandidateSampler (TensorFlow.TFOutput true_classes, long num_true, long num_sampled, bool unique, long range_max, string vocab_file = null, Nullable<float> distortion = null, Nullable<long> num_reserved_ids = null, Nullable<long> num_shards = null, Nullable<long> shard = null, float[] unigrams = null, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: true_classes
      type: TensorFlow.TFOutput
      description: >-
        A batch_size * num_true matrix, in which each row contains the
                      IDs of the num_true target_classes in the corresponding original label.
    - id: num_true
      type: System.Int64
      description: Number of true labels per context.
    - id: num_sampled
      type: System.Int64
      description: Number of candidates to randomly sample.
    - id: unique
      type: System.Boolean
      description: >-
        If unique is true, we sample with rejection, so that all sampled
                      candidates in a batch are unique. This requires some approximation to
                      estimate the post-rejection sampling probabilities.
    - id: range_max
      type: System.Int64
      description: The sampler will sample integers from the interval [0, range_max).
    - id: vocab_file
      type: System.String
      description: >-
        Optional argument
                      Each valid line in this file (which should have a CSV-like format)
                      corresponds to a valid word ID. IDs are in sequential order, starting from
                      num_reserved_ids. The last entry in each line is expected to be a value
                      corresponding to the count or relative probability. Exactly one of vocab_file
                      and unigrams needs to be passed to this op.
    - id: distortion
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      The distortion is used to skew the unigram probability distribution.
                      Each weight is first raised to the distortion's power before adding to the
                      internal unigram distribution. As a result, distortion = 1.0 gives regular
                      unigram sampling (as defined by the vocab file), and distortion = 0.0 gives
                      a uniform distribution.
    - id: num_reserved_ids
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Optionally some reserved IDs can be added in the range [0,
                      ..., num_reserved_ids) by the users. One use case is that a special unknown
                      word token is used as ID 0. These IDs will have a sampling probability of 0.
    - id: num_shards
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A sampler can be used to sample from a subset of the original range
                      in order to speed up the whole computation through parallelism. This parameter
                      (together with 'shard') indicates the number of partitions that are being
                      used in the overall computation.
    - id: shard
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A sampler can be used to sample from a subset of the original range
                      in order to speed up the whole computation through parallelism. This parameter
                      (together with 'num_shards') indicates the particular partition number of a
                      sampler op, when partitioning is being used.
    - id: unigrams
      type: System.Single[]
      description: >-
        Optional argument
                      A list of unigram counts or probabilities, one per ID in sequential
                      order. Exactly one of vocab_file and unigrams should be passed to this op.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either seed or seed2 are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      An second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FixedUnigramCandidateSampler'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sampled_candidates: A vector of length num_sampled, in which each element is
                      the ID of a sampled candidate.
                      true_expected_count: A batch_size * num_true matrix, representing
                      the number of times each candidate is expected to occur in a batch
                      of sampled candidates. If unique=true, then this is a probability.
                      sampled_expected_count: A vector of length num_sampled, for each sampled
                      candidate representing the number of times the candidate is expected
                      to occur in a batch of sampled candidates.  If unique=true, then this is a
                      probability.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.FixedUnigramCandidateSampler*
  exceptions: []
- uid: TensorFlow.TFGraph.Floor(TensorFlow.TFOutput,System.String)
  id: Floor(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Floor(TFOutput, String)
  nameWithType: TFGraph.Floor(TFOutput, String)
  fullName: TFGraph.Floor(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns element-wise largest integer not greater than x.
  syntax:
    content: public TensorFlow.TFOutput Floor (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Floor'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Floor*
  exceptions: []
- uid: TensorFlow.TFGraph.FloorDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: FloorDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FloorDiv(TFOutput, TFOutput, String)
  nameWithType: TFGraph.FloorDiv(TFOutput, TFOutput, String)
  fullName: TFGraph.FloorDiv(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns x // y element-wise.
  remarks: >-
    *NOTE*: <code>FloorDiv</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput FloorDiv (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FloorDiv'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FloorDiv*
  exceptions: []
- uid: TensorFlow.TFGraph.FloorMod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: FloorMod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FloorMod(TFOutput, TFOutput, String)
  nameWithType: TFGraph.FloorMod(TFOutput, TFOutput, String)
  fullName: TFGraph.FloorMod(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns element-wise remainder of division. When <code>x &lt; 0</code> xor <code>y &lt; 0</code> is
  remarks: "true, this follows Python semantics in that the result here is consistent\n              with a flooring divide. E.g. <code>floor(x / y) * y + mod(x, y) = x</code>.\n              \n              *NOTE*: <code>FloorMod</code> supports broadcasting. More about broadcasting\n              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)"
  syntax:
    content: public TensorFlow.TFOutput FloorMod (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FloorMod'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FloorMod*
  exceptions: []
- uid: TensorFlow.TFGraph.FractionalAvgPool(TensorFlow.TFOutput,System.Single[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: FractionalAvgPool(TensorFlow.TFOutput,System.Single[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FractionalAvgPool(TFOutput, Single[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.FractionalAvgPool(TFOutput, Single[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.FractionalAvgPool(TFOutput, Single[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Performs fractional average pooling on the input.
  remarks: >-
    Fractional average pooling is similar to Fractional max pooling in the pooling
                  region generation step. The only difference is that after pooling regions are
                  generated, a mean operation is performed instead of a max operation in each
                  pooling region.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> FractionalAvgPool (TensorFlow.TFOutput value, float[] pooling_ratio, Nullable<bool> pseudo_random = null, Nullable<bool> overlapping = null, Nullable<bool> deterministic = null, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: value
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: pooling_ratio
      type: System.Single[]
      description: >-
        Pooling ratio for each dimension of <code>value</code>, currently only
                      supports row and col dimension and should be &gt;= 1.0. For example, a valid
                      pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
                      must be 1.0 because we don't allow pooling on batch and channels
                      dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
                      respectively.
    - id: pseudo_random
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      When set to True, generates the pooling sequence in a
                      pseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin
                      Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for
                      difference between pseudorandom and random.
    - id: overlapping
      type: System.Nullable{System.Boolean}
      description: "Optional argument\n              When set to True, it means when pooling, the values at the boundary\n              of adjacent pooling cells are used by both cells. For example:\n              \n              <code>index  0  1  2  3  4</code><code>value  20 5  16 3  7</code>\n              \n              If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\n              The result would be [41/3, 26/3] for fractional avg pooling."
    - id: deterministic
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      When set to True, a fixed pooling region will be used when
                      iterating over a FractionalAvgPool node in the computation graph. Mainly used
                      in unit test to make FractionalAvgPool deterministic.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either seed or seed2 are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      An second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalAvgPool'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output: output tensor after fractional avg pooling.
                      row_pooling_sequence: row pooling sequence, needed to calculate gradient.
                      col_pooling_sequence: column pooling sequence, needed to calculate gradient.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.FractionalAvgPool*
  exceptions: []
- uid: TensorFlow.TFGraph.FractionalAvgPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: FractionalAvgPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FractionalAvgPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.FractionalAvgPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.FractionalAvgPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes gradient of the FractionalAvgPool function.
  remarks: >-
    Unlike FractionalMaxPoolGrad, we don't need to find arg_max for
                  FractionalAvgPoolGrad, we just need to evenly back-propagate each element of
                  out_backprop to those indices that form the same pooling cell. Therefore, we
                  just need to know the shape of original input tensor, instead of the whole
                  tensor.
  syntax:
    content: public TensorFlow.TFOutput FractionalAvgPoolGrad (TensorFlow.TFOutput orig_input_tensor_shape, TensorFlow.TFOutput out_backprop, TensorFlow.TFOutput row_pooling_sequence, TensorFlow.TFOutput col_pooling_sequence, Nullable<bool> overlapping = null, string operName = null);
    parameters:
    - id: orig_input_tensor_shape
      type: TensorFlow.TFOutput
      description: Original input tensor shape for <code>fractional_avg_pool</code>
    - id: out_backprop
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, height, width, channels]</code>.  Gradients
                      w.r.t. the output of <code>fractional_avg_pool</code>.
    - id: row_pooling_sequence
      type: TensorFlow.TFOutput
      description: >-
        row pooling sequence, form pooling region with
                      col_pooling_sequence.
    - id: col_pooling_sequence
      type: TensorFlow.TFOutput
      description: >-
        column pooling sequence, form pooling region with
                      row_pooling sequence.
    - id: overlapping
      type: System.Nullable{System.Boolean}
      description: "Optional argument\n              When set to True, it means when pooling, the values at the boundary\n              of adjacent pooling cells are used by both cells. For example:\n              \n              <code>index  0  1  2  3  4</code><code>value  20 5  16 3  7</code>\n              \n              If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\n              The result would be [41/3, 26/3] for fractional avg pooling."
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalAvgPoolGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D.  Gradients w.r.t. the input of <code>fractional_avg_pool</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FractionalAvgPoolGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.FractionalMaxPool(TensorFlow.TFOutput,System.Single[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: FractionalMaxPool(TensorFlow.TFOutput,System.Single[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FractionalMaxPool(TFOutput, Single[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.FractionalMaxPool(TFOutput, Single[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.FractionalMaxPool(TFOutput, Single[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Performs fractional max pooling on the input.
  remarks: "Fractional max pooling is slightly different than regular max pooling.  In\n              regular max pooling, you downsize an input set by taking the maximum value of\n              smaller N x N subsections of the set (often 2x2), and try to reduce the set by\n              a factor of N, where N is an integer.  Fractional max pooling, as you might\n              expect from the word \"fractional\", means that the overall reduction ratio N\n              does not have to be an integer.\n              \n              The sizes of the pooling regions are generated randomly but are fairly uniform.\n              For example, let's look at the height dimension, and the constraints on the\n              list of rows that will be pool boundaries.\n              \n              First we define the following:\n              \n              1.  input_row_length : the number of rows from the input set\n              2.  output_row_length : which will be smaller than the input\n              3.  alpha = input_row_length / output_row_length : our reduction ratio\n              4.  K = floor(alpha)\n              5.  row_pooling_sequence : this is the result list of pool boundary rows\n              \n              Then, row_pooling_sequence should satisfy:\n              \n              1.  a[0] = 0 : the first value of the sequence is 0\n              2.  a[end] = input_row_length : the last value of the sequence is the size\n              3.  K &lt;= (a[i+1] - a[i]) &lt;= K+1 : all intervals are K or K+1 size\n              4.  length(row_pooling_sequence) = output_row_length+1\n              \n              For more details on fractional max pooling, see this paper:\n              [Benjamin Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071)"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> FractionalMaxPool (TensorFlow.TFOutput value, float[] pooling_ratio, Nullable<bool> pseudo_random = null, Nullable<bool> overlapping = null, Nullable<bool> deterministic = null, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: value
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: pooling_ratio
      type: System.Single[]
      description: >-
        Pooling ratio for each dimension of <code>value</code>, currently only
                      supports row and col dimension and should be &gt;= 1.0. For example, a valid
                      pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
                      must be 1.0 because we don't allow pooling on batch and channels
                      dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
                      respectively.
    - id: pseudo_random
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      When set to True, generates the pooling sequence in a
                      pseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin
                      Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for
                      difference between pseudorandom and random.
    - id: overlapping
      type: System.Nullable{System.Boolean}
      description: "Optional argument\n              When set to True, it means when pooling, the values at the boundary\n              of adjacent pooling cells are used by both cells. For example:\n              \n              <code>index  0  1  2  3  4</code><code>value  20 5  16 3  7</code>\n              \n              If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\n              The result would be [20, 16] for fractional max pooling."
    - id: deterministic
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      When set to True, a fixed pooling region will be used when
                      iterating over a FractionalMaxPool node in the computation graph. Mainly used
                      in unit test to make FractionalMaxPool deterministic.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either seed or seed2 are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      An second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalMaxPool'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output: output tensor after fractional max pooling.
                      row_pooling_sequence: row pooling sequence, needed to calculate gradient.
                      col_pooling_sequence: column pooling sequence, needed to calculate gradient.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.FractionalMaxPool*
  exceptions: []
- uid: TensorFlow.TFGraph.FractionalMaxPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: FractionalMaxPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FractionalMaxPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.FractionalMaxPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.FractionalMaxPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes gradient of the FractionalMaxPool function.
  syntax:
    content: public TensorFlow.TFOutput FractionalMaxPoolGrad (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput out_backprop, TensorFlow.TFOutput row_pooling_sequence, TensorFlow.TFOutput col_pooling_sequence, Nullable<bool> overlapping = null, string operName = null);
    parameters:
    - id: orig_input
      type: TensorFlow.TFOutput
      description: Original input for <code>fractional_max_pool</code>
    - id: orig_output
      type: TensorFlow.TFOutput
      description: Original output for <code>fractional_max_pool</code>
    - id: out_backprop
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, height, width, channels]</code>.  Gradients
                      w.r.t. the output of <code>fractional_max_pool</code>.
    - id: row_pooling_sequence
      type: TensorFlow.TFOutput
      description: >-
        row pooling sequence, form pooling region with
                      col_pooling_sequence.
    - id: col_pooling_sequence
      type: TensorFlow.TFOutput
      description: >-
        column pooling sequence, form pooling region with
                      row_pooling sequence.
    - id: overlapping
      type: System.Nullable{System.Boolean}
      description: "Optional argument\n              When set to True, it means when pooling, the values at the boundary\n              of adjacent pooling cells are used by both cells. For example:\n              \n              <code>index  0  1  2  3  4</code><code>value  20 5  16 3  7</code>\n              \n              If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\n              The result would be [20, 16] for fractional max pooling."
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FractionalMaxPoolGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D.  Gradients w.r.t. the input of <code>fractional_max_pool</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FractionalMaxPoolGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.Functions
  id: Functions
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Functions
  nameWithType: TFGraph.Functions
  fullName: TFGraph.Functions
  type: Property
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns an the functions that have been defined in the graph.
  syntax:
    content: public TensorFlow.TFFunction[] Functions { get; }
    return:
      type: TensorFlow.TFFunction[]
      description: The functions.
  overload: TensorFlow.TFGraph.Functions*
  exceptions: []
- uid: TensorFlow.TFGraph.FusedBatchNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  id: FusedBatchNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FusedBatchNorm(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.FusedBatchNorm(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  fullName: TFGraph.FusedBatchNorm(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Batch normalization.
  remarks: >-
    Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
                  The size of 1D Tensors matches the dimension C of the 4D Tensors.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> FusedBatchNorm (TensorFlow.TFOutput x, TensorFlow.TFOutput scale, TensorFlow.TFOutput offset, TensorFlow.TFOutput mean, TensorFlow.TFOutput variance, Nullable<float> epsilon = null, string data_format = null, Nullable<bool> is_training = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: A 4D Tensor for input data.
    - id: scale
      type: TensorFlow.TFOutput
      description: A 1D Tensor for scaling factor, to scale the normalized x.
    - id: offset
      type: TensorFlow.TFOutput
      description: A 1D Tensor for offset, to shift to the normalized x.
    - id: mean
      type: TensorFlow.TFOutput
      description: >-
        A 1D Tensor for population mean. Used for inference only;
                      must be empty for training.
    - id: variance
      type: TensorFlow.TFOutput
      description: >-
        A 1D Tensor for population variance. Used for inference only;
                      must be empty for training.
    - id: epsilon
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      A small float number added to the variance of x.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      The data format for x and y. Either "NHWC" (default) or "NCHW".
    - id: is_training
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      A bool value to indicate the operation is for training (default)
                      or inference.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNorm'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      y: A 4D Tensor for output data.
                      batch_mean: A 1D Tensor for the computed batch mean, to be used by TensorFlow
                      to compute the running mean.
                      batch_variance: A 1D Tensor for the computed batch variance, to be used by
                      TensorFlow to compute the running variance.
                      reserve_space_1: A 1D Tensor for the computed batch mean, to be reused
                      in the gradient computation.
                      reserve_space_2: A 1D Tensor for the computed batch variance (inverted variance
                      in the cuDNN case), to be reused in the gradient computation.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.FusedBatchNorm*
  exceptions: []
- uid: TensorFlow.TFGraph.FusedBatchNormGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  id: FusedBatchNormGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FusedBatchNormGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.FusedBatchNormGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  fullName: TFGraph.FusedBatchNormGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gradient for batch normalization.
  remarks: >-
    Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
                  The size of 1D Tensors matches the dimension C of the 4D Tensors.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> FusedBatchNormGrad (TensorFlow.TFOutput y_backprop, TensorFlow.TFOutput x, TensorFlow.TFOutput scale, TensorFlow.TFOutput reserve_space_1, TensorFlow.TFOutput reserve_space_2, Nullable<float> epsilon = null, string data_format = null, Nullable<bool> is_training = null, string operName = null);
    parameters:
    - id: y_backprop
      type: TensorFlow.TFOutput
      description: A 4D Tensor for the gradient with respect to y.
    - id: x
      type: TensorFlow.TFOutput
      description: A 4D Tensor for input data.
    - id: scale
      type: TensorFlow.TFOutput
      description: A 1D Tensor for scaling factor, to scale the normalized x.
    - id: reserve_space_1
      type: TensorFlow.TFOutput
      description: >-
        When is_training is True, a 1D Tensor for the computed batch
                      mean to be reused in gradient computation. When is_training is
                      False, a 1D Tensor for the population mean to be reused in both
                      1st and 2nd order gradient computation.
    - id: reserve_space_2
      type: TensorFlow.TFOutput
      description: >-
        When is_training is True, a 1D Tensor for the computed batch
                      variance (inverted variance in the cuDNN case) to be reused in
                      gradient computation. When is_training is False, a 1D Tensor
                      for the population variance to be reused in both 1st and 2nd
                      order gradient computation.
    - id: epsilon
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      A small float number added to the variance of x.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      The data format for y_backprop, x, x_backprop.
                      Either "NHWC" (default) or "NCHW".
    - id: is_training
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      A bool value to indicate the operation is for training (default)
                      or inference.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormGrad'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      x_backprop: A 4D Tensor for the gradient with respect to x.
                      scale_backprop: A 1D Tensor for the gradient with respect to scale.
                      offset_backprop: A 1D Tensor for the gradient with respect to offset.
                      reserve_space_3: Unused placeholder to match the mean input in FusedBatchNorm.
                      reserve_space_4: Unused placeholder to match the variance input
                      in FusedBatchNorm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.FusedBatchNormGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.FusedBatchNormGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  id: FusedBatchNormGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FusedBatchNormGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.FusedBatchNormGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  fullName: TFGraph.FusedBatchNormGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gradient for batch normalization.
  remarks: >-
    Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
                  The size of 1D Tensors matches the dimension C of the 4D Tensors.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> FusedBatchNormGradV2 (TensorFlow.TFOutput y_backprop, TensorFlow.TFOutput x, TensorFlow.TFOutput scale, TensorFlow.TFOutput reserve_space_1, TensorFlow.TFOutput reserve_space_2, Nullable<float> epsilon = null, string data_format = null, Nullable<bool> is_training = null, string operName = null);
    parameters:
    - id: y_backprop
      type: TensorFlow.TFOutput
      description: A 4D Tensor for the gradient with respect to y.
    - id: x
      type: TensorFlow.TFOutput
      description: A 4D Tensor for input data.
    - id: scale
      type: TensorFlow.TFOutput
      description: A 1D Tensor for scaling factor, to scale the normalized x.
    - id: reserve_space_1
      type: TensorFlow.TFOutput
      description: >-
        When is_training is True, a 1D Tensor for the computed batch
                      mean to be reused in gradient computation. When is_training is
                      False, a 1D Tensor for the population mean to be reused in both
                      1st and 2nd order gradient computation.
    - id: reserve_space_2
      type: TensorFlow.TFOutput
      description: >-
        When is_training is True, a 1D Tensor for the computed batch
                      variance (inverted variance in the cuDNN case) to be reused in
                      gradient computation. When is_training is False, a 1D Tensor
                      for the population variance to be reused in both 1st and 2nd
                      order gradient computation.
    - id: epsilon
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      A small float number added to the variance of x.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      The data format for y_backprop, x, x_backprop.
                      Either "NHWC" (default) or "NCHW".
    - id: is_training
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      A bool value to indicate the operation is for training (default)
                      or inference.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormGradV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      x_backprop: A 4D Tensor for the gradient with respect to x.
                      scale_backprop: A 1D Tensor for the gradient with respect to scale.
                      offset_backprop: A 1D Tensor for the gradient with respect to offset.
                      reserve_space_3: Unused placeholder to match the mean input in FusedBatchNorm.
                      reserve_space_4: Unused placeholder to match the variance input
                      in FusedBatchNorm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.FusedBatchNormGradV2*
  exceptions: []
- uid: TensorFlow.TFGraph.FusedBatchNormV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  id: FusedBatchNormV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FusedBatchNormV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.FusedBatchNormV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  fullName: TFGraph.FusedBatchNormV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Batch normalization.
  remarks: >-
    Note that the size of 4D Tensors are defined by either "NHWC" or "NCHW".
                  The size of 1D Tensors matches the dimension C of the 4D Tensors.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> FusedBatchNormV2 (TensorFlow.TFOutput x, TensorFlow.TFOutput scale, TensorFlow.TFOutput offset, TensorFlow.TFOutput mean, TensorFlow.TFOutput variance, Nullable<float> epsilon = null, string data_format = null, Nullable<bool> is_training = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: A 4D Tensor for input data.
    - id: scale
      type: TensorFlow.TFOutput
      description: A 1D Tensor for scaling factor, to scale the normalized x.
    - id: offset
      type: TensorFlow.TFOutput
      description: A 1D Tensor for offset, to shift to the normalized x.
    - id: mean
      type: TensorFlow.TFOutput
      description: >-
        A 1D Tensor for population mean. Used for inference only;
                      must be empty for training.
    - id: variance
      type: TensorFlow.TFOutput
      description: >-
        A 1D Tensor for population variance. Used for inference only;
                      must be empty for training.
    - id: epsilon
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      A small float number added to the variance of x.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      The data format for x and y. Either "NHWC" (default) or "NCHW".
    - id: is_training
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      A bool value to indicate the operation is for training (default)
                      or inference.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedBatchNormV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      y: A 4D Tensor for output data.
                      batch_mean: A 1D Tensor for the computed batch mean, to be used by TensorFlow
                      to compute the running mean.
                      batch_variance: A 1D Tensor for the computed batch variance, to be used by
                      TensorFlow to compute the running variance.
                      reserve_space_1: A 1D Tensor for the computed batch mean, to be reused
                      in the gradient computation.
                      reserve_space_2: A 1D Tensor for the computed batch variance (inverted variance
                      in the cuDNN case), to be reused in the gradient computation.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.FusedBatchNormV2*
  exceptions: []
- uid: TensorFlow.TFGraph.FusedPadConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Int64[],System.String,System.String)
  id: FusedPadConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FusedPadConv2D(TFOutput, TFOutput, TFOutput, String, Int64[], String, String)
  nameWithType: TFGraph.FusedPadConv2D(TFOutput, TFOutput, TFOutput, String, Int64[], String, String)
  fullName: TFGraph.FusedPadConv2D(TFOutput, TFOutput, TFOutput, String, Int64[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Performs a padding as a preprocess during a convolution.
  remarks: >-
    Similar to FusedResizeAndPadConv2d, this op allows for an optimized
                  implementation where the spatial padding transformation stage is fused with the
                  im2col lookup, but in this case without the bilinear filtering required for
                  resizing. Fusing the padding prevents the need to write out the intermediate
                  results as whole tensors, reducing memory pressure, and we can get some latency
                  gains by merging the transformation calculations.
                  The data_format attribute for Conv2D isn't supported by this op, and 'NHWC'
                  order is used instead.
                  Internally this op uses a single per-graph scratch buffer, which means that it
                  will block if multiple versions are being run in parallel. This is because this
                  operator is primarily an optimization to minimize memory usage.
  syntax:
    content: public TensorFlow.TFOutput FusedPadConv2D (TensorFlow.TFOutput input, TensorFlow.TFOutput paddings, TensorFlow.TFOutput filter, string mode, long[] strides, string padding, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
    - id: paddings
      type: TensorFlow.TFOutput
      description: >-
        A two-column matrix specifying the padding sizes. The number of
                      rows must be the same as the rank of <code>input</code>.
    - id: filter
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape
                      <code>[filter_height, filter_width, in_channels, out_channels]</code>.
    - id: mode
      type: System.String
      description: To be added.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D of length 4.  The stride of the sliding window for each dimension
                      of <code>input</code>. Must be in the same order as the dimension specified with format.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedPadConv2D'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FusedPadConv2D*
  exceptions: []
- uid: TensorFlow.TFGraph.FusedResizeAndPadConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Int64[],System.String,System.Nullable{System.Boolean},System.String)
  id: FusedResizeAndPadConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Int64[],System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: FusedResizeAndPadConv2D(TFOutput, TFOutput, TFOutput, TFOutput, String, Int64[], String, Nullable<Boolean>, String)
  nameWithType: TFGraph.FusedResizeAndPadConv2D(TFOutput, TFOutput, TFOutput, TFOutput, String, Int64[], String, Nullable<Boolean>, String)
  fullName: TFGraph.FusedResizeAndPadConv2D(TFOutput, TFOutput, TFOutput, TFOutput, String, Int64[], String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Performs a resize and padding as a preprocess during a convolution.
  remarks: >-
    It's often possible to do spatial transformations more efficiently as part of
                  the packing stage of a convolution, so this op allows for an optimized
                  implementation where these stages are fused together. This prevents the need to
                  write out the intermediate results as whole tensors, reducing memory pressure,
                  and we can get some latency gains by merging the transformation calculations.
                  The data_format attribute for Conv2D isn't supported by this op, and defaults to
                  'NHWC' order.
                  Internally this op uses a single per-graph scratch buffer, which means that it
                  will block if multiple versions are being run in parallel. This is because this
                  operator is primarily an optimization to minimize memory usage.
  syntax:
    content: public TensorFlow.TFOutput FusedResizeAndPadConv2D (TensorFlow.TFOutput input, TensorFlow.TFOutput size, TensorFlow.TFOutput paddings, TensorFlow.TFOutput filter, string mode, long[] strides, string padding, Nullable<bool> resize_align_corners = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.
    - id: size
      type: TensorFlow.TFOutput
      description: >-
        A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
                      new size for the images.
    - id: paddings
      type: TensorFlow.TFOutput
      description: >-
        A two-column matrix specifying the padding sizes. The number of
                      rows must be the same as the rank of <code>input</code>.
    - id: filter
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape
                      <code>[filter_height, filter_width, in_channels, out_channels]</code>.
    - id: mode
      type: System.String
      description: To be added.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D of length 4.  The stride of the sliding window for each dimension
                      of <code>input</code>. Must be in the same order as the dimension specified with format.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: resize_align_corners
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, the centers of the 4 corner pixels of the input and output tensors are
                      aligned, preserving the values at the corner pixels. Defaults to false.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'FusedResizeAndPadConv2D'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.FusedResizeAndPadConv2D*
  exceptions: []
- uid: TensorFlow.TFGraph.Gather(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: Gather(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Gather(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Gather(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Gather(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gather slices from <code>params</code> according to <code>indices</code>.
  remarks: "<code>indices</code> must be an integer tensor of any dimension (usually 0-D or 1-D).\n              Produces an output tensor with shape <code>indices.shape + params.shape[1:]</code> where:\n              \n               <pre><code>\n              # Scalar indices\n              output[:, ..., :] = params[indices, :, ... :]\n              \n              # Vector indices\n              output[i, :, ..., :] = params[indices[i], :, ... :]\n              \n              # Higher rank indices\n              output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]\n               </code></pre>\n              \n              If <code>indices</code> is a permutation and <code>len(indices) == params.shape[0]</code> then\n              this operation will permute <code>params</code> accordingly.\n              \n              <code>validate_indices</code>: DEPRECATED. If this operation is assigned to CPU, values in\n              <code>indices</code> are always validated to be within range. If assigned to GPU,\n              out-of-bound indices result in safe but unspecified behavior, which may include\n              raising an error.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/Gather.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput Gather (TensorFlow.TFOutput parameters, TensorFlow.TFOutput indices, Nullable<bool> validate_indices = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: validate_indices
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Gather'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Gather*
  exceptions: []
- uid: TensorFlow.TFGraph.GatherNd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: GatherNd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GatherNd(TFOutput, TFOutput, String)
  nameWithType: TFGraph.GatherNd(TFOutput, TFOutput, String)
  fullName: TFGraph.GatherNd(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gather slices from <code>params</code> into a Tensor with shape specified by <code>indices</code>.
  remarks: "<code>indices</code> is an K-dimensional integer tensor, best thought of as a\n              (K-1)-dimensional tensor of indices into <code>params</code>, where each element defines a\n              slice of <code>params</code>:\n              \n              output[\\\\(i_0, ..., i_{K-2}\\\\)] = params[indices[\\\\(i_0, ..., i_{K-2}\\\\)]]\n              \n              Whereas in <code>tf.gather</code><code>indices</code> defines slices into the first\n              dimension of <code>params</code>, in <code>tf.gather_nd</code>, <code>indices</code> defines slices into the\n              first <code>N</code> dimensions of <code>params</code>, where <code>N = indices.shape[-1]</code>.\n              \n              The last dimension of <code>indices</code> can be at most the rank of\n              <code>params</code>:\n              \n              indices.shape[-1] &lt;= params.rank\n              \n              The last dimension of <code>indices</code> corresponds to elements\n              (if <code>indices.shape[-1] == params.rank</code>) or slices\n              (if <code>indices.shape[-1] &lt; params.rank</code>) along dimension <code>indices.shape[-1]</code>\n              of <code>params</code>.  The output tensor has shape\n              \n              indices.shape[:-1] + params.shape[indices.shape[-1]:]\n              \n              Note that on CPU, if an out of bound index is found, an error is returned.\n              On GPU, if an out of bound index is found, a 0 is stored in the\n              corresponding output value.\n              \n              Some examples below.\n              \n              Simple indexing into a matrix:\n              \n               <pre><code>\n              indices = [[0, 0], [1, 1]]\n              params = [['a', 'b'], ['c', 'd']]\n              output = ['a', 'd']\n               </code></pre>\n              \n              Slice indexing into a matrix:\n              \n               <pre><code>\n              indices = [[1], [0]]\n              params = [['a', 'b'], ['c', 'd']]\n              output = [['c', 'd'], ['a', 'b']]\n               </code></pre>\n              \n              Indexing into a 3-tensor:\n              \n               <pre><code>\n              indices = [[1]]\n              params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n              output = [[['a1', 'b1'], ['c1', 'd1']]]\n              \n              \n              indices = [[0, 1], [1, 0]]\n              params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n              output = [['c0', 'd0'], ['a1', 'b1']]\n              \n              \n              indices = [[0, 0, 1], [1, 0, 1]]\n              params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n              output = ['b0', 'b1']\n               </code></pre>\n              \n              Batched indexing into a matrix:\n              \n               <pre><code>\n              indices = [[[0, 0]], [[0, 1]]]\n              params = [['a', 'b'], ['c', 'd']]\n              output = [['a'], ['b']]\n               </code></pre>\n              \n              Batched slice indexing into a matrix:\n              \n               <pre><code>\n              indices = [[[1]], [[0]]]\n              params = [['a', 'b'], ['c', 'd']]\n              output = [[['c', 'd']], [['a', 'b']]]\n               </code></pre>\n              \n              Batched indexing into a 3-tensor:\n              \n               <pre><code>\n              indices = [[[1]], [[0]]]\n              params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n              output = [[[['a1', 'b1'], ['c1', 'd1']]],\n              [[['a0', 'b0'], ['c0', 'd0']]]]\n              \n              indices = [[[0, 1], [1, 0]], [[0, 0], [1, 1]]]\n              params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n              output = [[['c0', 'd0'], ['a1', 'b1']],\n              [['a0', 'b0'], ['c1', 'd1']]]\n              \n              \n              indices = [[[0, 0, 1], [1, 0, 1]], [[0, 1, 1], [1, 1, 0]]]\n              params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n              output = [['b0', 'b1'], ['d0', 'c1']]\n               </code></pre>\n              \n              See also <code>tf.gather</code> and <code>tf.batch_gather</code>."
  syntax:
    content: public TensorFlow.TFOutput GatherNd (TensorFlow.TFOutput parameters, TensorFlow.TFOutput indices, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: The tensor from which to gather values.
    - id: indices
      type: TensorFlow.TFOutput
      description: Index tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'GatherNd'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Values from <code>params</code> gathered from indices given by <code>indices</code>, with
                      shape <code>indices.shape[:-1] + params.shape[indices.shape[-1]:]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.GatherNd*
  exceptions: []
- uid: TensorFlow.TFGraph.GatherV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: GatherV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GatherV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.GatherV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.GatherV2(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gather slices from <code>params</code> axis <code>axis</code> according to <code>indices</code>.
  remarks: "<code>indices</code> must be an integer tensor of any dimension (usually 0-D or 1-D).\n              Produces an output tensor with shape <code>params.shape[:axis] + indices.shape +\n              params.shape[axis + 1:]</code> where:\n              \n               <pre><code>\n              # Scalar indices (output is rank(params) - 1).\n              output[a_0, ..., a_n, b_0, ..., b_n] =\n              params[a_0, ..., a_n, indices, b_0, ..., b_n]\n              \n              # Vector indices (output is rank(params)).\n              output[a_0, ..., a_n, i, b_0, ..., b_n] =\n              params[a_0, ..., a_n, indices[i], b_0, ..., b_n]\n              \n              # Higher rank indices (output is rank(params) + rank(indices) - 1).\n              output[a_0, ..., a_n, i, ..., j, b_0, ... b_n] =\n              params[a_0, ..., a_n, indices[i, ..., j], b_0, ..., b_n]\n               </code></pre>\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/Gather.png\" alt&gt;\n              &lt;/div&gt;\n              \n              Note that on CPU, if an out of bound index is found, an error is returned.\n              On GPU, if an out of bound index is found, a 0 is stored in the\n              corresponding output value.\n              \n              See also <code>tf.batch_gather</code> and <code>tf.gather_nd</code>."
  syntax:
    content: public TensorFlow.TFOutput GatherV2 (TensorFlow.TFOutput parameters, TensorFlow.TFOutput indices, TensorFlow.TFOutput axis, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: >-
        The tensor from which to gather values. Must be at least rank
                      <code>axis + 1</code>.
    - id: indices
      type: TensorFlow.TFOutput
      description: Index tensor. Must be in range <code>[0, params.shape[axis])</code>.
    - id: axis
      type: TensorFlow.TFOutput
      description: >-
        The axis in <code>params</code> to gather <code>indices</code> from. Defaults to the first
                      dimension. Supports negative indexes.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'GatherV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Values from <code>params</code> gathered from indices given by <code>indices</code>, with
                      shape <code>params.shape[:axis] + indices.shape + params.shape[axis + 1:]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.GatherV2*
  exceptions: []
- uid: TensorFlow.TFGraph.GcsConfigureBlockCache(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: GcsConfigureBlockCache(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GcsConfigureBlockCache(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.GcsConfigureBlockCache(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.GcsConfigureBlockCache(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Re-configures the GCS block cache with the new configuration values.
  remarks: >-
    If the values are the same as already configured values, this op is a no-op. If
                  they are different, the current contents of the block cache is dropped, and a
                  new block cache is created fresh.
  syntax:
    content: public TensorFlow.TFOperation GcsConfigureBlockCache (TensorFlow.TFOutput max_cache_size, TensorFlow.TFOutput block_size, TensorFlow.TFOutput max_staleness, string operName = null);
    parameters:
    - id: max_cache_size
      type: TensorFlow.TFOutput
      description: To be added.
    - id: block_size
      type: TensorFlow.TFOutput
      description: To be added.
    - id: max_staleness
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'GcsConfigureBlockCache'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.GcsConfigureBlockCache*
  exceptions: []
- uid: TensorFlow.TFGraph.GcsConfigureCredentials(TensorFlow.TFOutput,System.String)
  id: GcsConfigureCredentials(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GcsConfigureCredentials(TFOutput, String)
  nameWithType: TFGraph.GcsConfigureCredentials(TFOutput, String)
  fullName: TFGraph.GcsConfigureCredentials(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Configures the credentials used by the GCS client of the local TF runtime.
  remarks: "The json input can be of the format:\n              \n              1. Refresh Token:\n              {\n              \"client_id\": \"&lt;redacted&gt;\",\n              \"client_secret\": \"&lt;redacted&gt;\",\n              \"refresh_token: \"&lt;redacted&gt;\",\n              \"type\": \"authorized_user\",\n              }\n              \n              2. Service Account:\n              {\n              \"type\": \"service_account\",\n              \"project_id\": \"&lt;redacted&gt;\",\n              \"private_key_id\": \"&lt;redacted&gt;\",\n              \"private_key\": \"------BEGIN PRIVATE KEY-----\\n&lt;REDACTED&gt;\\n-----END PRIVATE KEY------\\n\",\n              \"client_email\": \"&lt;REDACTED&gt;@&lt;REDACTED&gt;.iam.gserviceaccount.com\",\n              \"client_id\": \"&lt;REDACTED&gt;\",\n              # Some additional fields elided\n              }\n              \n              Note the credentials established through this method are shared across all\n              sessions run on this runtime.\n              \n              Note be sure to feed the inputs to this op to ensure the credentials are not\n              stored in a constant op within the graph that might accidentally be checkpointed\n              or in other ways be persisted or exfiltrated."
  syntax:
    content: public TensorFlow.TFOperation GcsConfigureCredentials (TensorFlow.TFOutput json, string operName = null);
    parameters:
    - id: json
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'GcsConfigureCredentials'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.GcsConfigureCredentials*
  exceptions: []
- uid: TensorFlow.TFGraph.GenerateBigQueryReaderPartitions(System.String,System.String,System.String,System.String[],System.Int64,System.Int64,System.String,System.String)
  id: GenerateBigQueryReaderPartitions(System.String,System.String,System.String,System.String[],System.Int64,System.Int64,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GenerateBigQueryReaderPartitions(String, String, String, String[], Int64, Int64, String, String)
  nameWithType: TFGraph.GenerateBigQueryReaderPartitions(String, String, String, String[], Int64, Int64, String, String)
  fullName: TFGraph.GenerateBigQueryReaderPartitions(String, String, String, String[], Int64, Int64, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generates serialized partition messages suitable for batch reads.
  remarks: >-
    This op should not be used directly by clients. Instead, the
                  bigquery_reader_ops.py file defines a clean interface to the reader.
  syntax:
    content: public TensorFlow.TFOutput GenerateBigQueryReaderPartitions (string project_id, string dataset_id, string table_id, string[] columns, long timestamp_millis, long num_partitions, string test_end_point = null, string operName = null);
    parameters:
    - id: project_id
      type: System.String
      description: GCP project ID.
    - id: dataset_id
      type: System.String
      description: BigQuery Dataset ID.
    - id: table_id
      type: System.String
      description: Table to read.
    - id: columns
      type: System.String[]
      description: List of columns to read. Leave empty to read all columns.
    - id: timestamp_millis
      type: System.Int64
      description: >-
        Table snapshot timestamp in millis since epoch. Relative
                      (negative or zero) snapshot times are not allowed. For more details, see
                      'Table Decorators' in BigQuery docs.
    - id: num_partitions
      type: System.Int64
      description: Number of partitions to split the table into.
    - id: test_end_point
      type: System.String
      description: >-
        Optional argument
                      Do not use. For testing purposes only.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'GenerateBigQueryReaderPartitions'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Serialized table partitions.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.GenerateBigQueryReaderPartitions*
  exceptions: []
- uid: TensorFlow.TFGraph.GenerateVocabRemapping(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String)
  id: GenerateVocabRemapping(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GenerateVocabRemapping(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String)
  nameWithType: TFGraph.GenerateVocabRemapping(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String)
  fullName: TFGraph.GenerateVocabRemapping(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Given a path to new and old vocabulary files, returns a remapping Tensor of
  remarks: "length <code>num_new_vocab</code>, where <code>remapping[i]</code> contains the row number in the old\n              vocabulary that corresponds to row <code>i</code> in the new vocabulary (starting at line\n              <code>new_vocab_offset</code> and up to <code>num_new_vocab</code> entities), or <code>-1</code> if entry <code>i</code>\n              in the new vocabulary is not in the old vocabulary.  The old vocabulary is\n              constrained to the first <code>old_vocab_size</code> entries if <code>old_vocab_size</code> is not the\n              default value of -1.\n              \n              <code>num_vocab_offset</code> enables\n              use in the partitioned variable case, and should generally be set through\n              examining partitioning info.  The format of the files should be a text file,\n              with each line containing a single entity within the vocabulary.\n              \n              For example, with <code>new_vocab_file</code> a text file containing each of the following\n              elements on a single line: <code>[f0, f1, f2, f3]</code>, old_vocab_file = [f1, f0, f3],\n              <code>num_new_vocab = 3, new_vocab_offset = 1</code>, the returned remapping would be\n              <code>[0, -1, 2]</code>.\n              \n              The op also returns a count of how many entries in the new vocabulary\n              were present in the old vocabulary, which is used to calculate the number of\n              values to initialize in a weight matrix remapping\n              \n              This functionality can be used to remap both row vocabularies (typically,\n              features) and column vocabularies (typically, classes) from TensorFlow\n              checkpoints.  Note that the partitioning logic relies on contiguous vocabularies\n              corresponding to div-partitioned variables.  Moreover, the underlying remapping\n              uses an IndexTable (as opposed to an inexact CuckooTable), so client code should\n              use the corresponding index_table_from_file() as the FeatureColumn framework\n              does (as opposed to tf.feature_to_id(), which uses a CuckooTable)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> GenerateVocabRemapping (TensorFlow.TFOutput new_vocab_file, TensorFlow.TFOutput old_vocab_file, long new_vocab_offset, long num_new_vocab, Nullable<long> old_vocab_size = null, string operName = null);
    parameters:
    - id: new_vocab_file
      type: TensorFlow.TFOutput
      description: Path to the new vocab file.
    - id: old_vocab_file
      type: TensorFlow.TFOutput
      description: Path to the old vocab file.
    - id: new_vocab_offset
      type: System.Int64
      description: How many entries into the new vocab file to start reading.
    - id: num_new_vocab
      type: System.Int64
      description: Number of entries in the new vocab file to remap.
    - id: old_vocab_size
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of entries in the old vocab file to consider.  If -1,
                      use the entire old vocabulary.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'GenerateVocabRemapping'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      remapping: A Tensor of length num_new_vocab where the element at index i
                      is equal to the old ID that maps to the new ID i.  This element is -1 for any
                      new ID that is not found in the old vocabulary.
                      num_present: Number of new vocab entries found in old vocab.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.GenerateVocabRemapping*
  exceptions: []
- uid: TensorFlow.TFGraph.GetEnumerator
  id: GetEnumerator
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: TFGraph.GetEnumerator()
  fullName: TFGraph.GetEnumerator()
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the enumerator that returns all the TFOperations in a graph.
  syntax:
    content: >-
      [System.Runtime.CompilerServices.IteratorStateMachine(typeof(TensorFlow.TFGraph/<GetEnumerator>d__986))]

      public System.Collections.Generic.IEnumerable<TensorFlow.TFOperation> GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{TensorFlow.TFOperation}
      description: The enumerator.
  overload: TensorFlow.TFGraph.GetEnumerator*
  exceptions: []
  attributes:
  - type: System.Runtime.CompilerServices.IteratorStateMachine
- uid: TensorFlow.TFGraph.GetGlobalVariablesInitializer
  id: GetGlobalVariablesInitializer
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GetGlobalVariablesInitializer()
  nameWithType: TFGraph.GetGlobalVariablesInitializer()
  fullName: TFGraph.GetGlobalVariablesInitializer()
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gets the list of all registered global variables.
  remarks: >-
    After this method is invoked the list of pending initialization variables
                is cleared.
  syntax:
    content: public TensorFlow.TFOperation[] GetGlobalVariablesInitializer ();
    parameters: []
    return:
      type: TensorFlow.TFOperation[]
      description: The array of variables that should be initialized.
  overload: TensorFlow.TFGraph.GetGlobalVariablesInitializer*
  exceptions: []
- uid: TensorFlow.TFGraph.GetRandomSeeds(System.Nullable{System.Int32},System.Int32@,System.Int32@)
  id: GetRandomSeeds(System.Nullable{System.Int32},System.Int32@,System.Int32@)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GetRandomSeeds(Nullable<Int32>, Int32, Int32)
  nameWithType: TFGraph.GetRandomSeeds(Nullable<Int32>, Int32, Int32)
  fullName: TFGraph.GetRandomSeeds(Nullable<Int32>, Int32, Int32)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the graph and local seeds based on an optionally set incoming seed value.
  remarks: "This helper function returns two seeds derived from graph-level and op-level seeds.\n            Many random operations internally use the two seeds to allow user to change \n            the seed globally for a graph, or for only specific operations."
  syntax:
    content: public void GetRandomSeeds (Nullable<int> operationSeed, out int graphSeed, out int localSeed);
    parameters:
    - id: operationSeed
      type: System.Nullable{System.Int32}
      description: The seed value that might be set.
    - id: graphSeed
      type: System.Int32
      description: Returned graph seed.
    - id: localSeed
      type: System.Int32
      description: Returned local seed.
  overload: TensorFlow.TFGraph.GetRandomSeeds*
  exceptions: []
- uid: TensorFlow.TFGraph.GetSessionHandle(TensorFlow.TFOutput,System.String)
  id: GetSessionHandle(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GetSessionHandle(TFOutput, String)
  nameWithType: TFGraph.GetSessionHandle(TFOutput, String)
  fullName: TFGraph.GetSessionHandle(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Store the input tensor in the state of the current session.
  syntax:
    content: public TensorFlow.TFOutput GetSessionHandle (TensorFlow.TFOutput value, string operName = null);
    parameters:
    - id: value
      type: TensorFlow.TFOutput
      description: The tensor to be stored.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'GetSessionHandle'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle for the tensor stored in the session state, represented
                      as a string.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.GetSessionHandle*
  exceptions: []
- uid: TensorFlow.TFGraph.GetSessionHandleV2(TensorFlow.TFOutput,System.String)
  id: GetSessionHandleV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GetSessionHandleV2(TFOutput, String)
  nameWithType: TFGraph.GetSessionHandleV2(TFOutput, String)
  fullName: TFGraph.GetSessionHandleV2(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Store the input tensor in the state of the current session.
  syntax:
    content: public TensorFlow.TFOutput GetSessionHandleV2 (TensorFlow.TFOutput value, string operName = null);
    parameters:
    - id: value
      type: TensorFlow.TFOutput
      description: The tensor to be stored.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'GetSessionHandleV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle for the tensor stored in the session state, represented
                      as a ResourceHandle object.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.GetSessionHandleV2*
  exceptions: []
- uid: TensorFlow.TFGraph.GetSessionTensor(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: GetSessionTensor(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GetSessionTensor(TFOutput, TFDataType, String)
  nameWithType: TFGraph.GetSessionTensor(TFOutput, TFDataType, String)
  fullName: TFGraph.GetSessionTensor(TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Get the value of the tensor specified by its handle.
  syntax:
    content: public TensorFlow.TFOutput GetSessionTensor (TensorFlow.TFOutput handle, TensorFlow.TFDataType dtype, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle for a tensor stored in the session state.
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of the output value.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'GetSessionTensor'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The tensor for the given handle.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.GetSessionTensor*
  exceptions: []
- uid: TensorFlow.TFGraph.GetShape(TensorFlow.TFOutput,TensorFlow.TFStatus)
  id: GetShape(TensorFlow.TFOutput,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GetShape(TFOutput, TFStatus)
  nameWithType: TFGraph.GetShape(TFOutput, TFStatus)
  fullName: TFGraph.GetShape(TFOutput, TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the tensor shape for the specific output pparameters as an array of longs.
  syntax:
    content: public long[] GetShape (TensorFlow.TFOutput output, TensorFlow.TFStatus status = null);
    parameters:
    - id: output
      type: TensorFlow.TFOutput
      description: The output operation to probe.
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
    return:
      type: System.Int64[]
      description: null for single dimension, .
  overload: TensorFlow.TFGraph.GetShape*
  exceptions: []
- uid: TensorFlow.TFGraph.GetTensorNumDims(TensorFlow.TFOutput,TensorFlow.TFStatus)
  id: GetTensorNumDims(TensorFlow.TFOutput,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GetTensorNumDims(TFOutput, TFStatus)
  nameWithType: TFGraph.GetTensorNumDims(TFOutput, TFStatus)
  fullName: TFGraph.GetTensorNumDims(TFOutput, TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the number of dimensions of the Tensor referenced by output
  syntax:
    content: public int GetTensorNumDims (TensorFlow.TFOutput output, TensorFlow.TFStatus status = null);
    parameters:
    - id: output
      type: TensorFlow.TFOutput
      description: The tensor to probe.
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
    return:
      type: System.Int32
      description: The number of dimensions of the tensor.
  overload: TensorFlow.TFGraph.GetTensorNumDims*
  exceptions: []
- uid: TensorFlow.TFGraph.GetTensorShape(TensorFlow.TFOutput,TensorFlow.TFStatus)
  id: GetTensorShape(TensorFlow.TFOutput,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GetTensorShape(TFOutput, TFStatus)
  nameWithType: TFGraph.GetTensorShape(TFOutput, TFStatus)
  fullName: TFGraph.GetTensorShape(TFOutput, TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the shape of a tensor specified in <code>output</code>.
  syntax:
    content: public TensorFlow.TFShape GetTensorShape (TensorFlow.TFOutput output, TensorFlow.TFStatus status = null);
    parameters:
    - id: output
      type: TensorFlow.TFOutput
      description: The tensor that you want to look up.
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
    return:
      type: TensorFlow.TFShape
      description: The tensor shape.    If the number of dimensions in the shape is unknown or the shape is, a scalar, the values in the array will be zero. Otherwise, each element of will be set corresponding to the size of the dimension. An  unknown dimension is represented by -1.
  overload: TensorFlow.TFGraph.GetTensorShape*
  exceptions: []
- uid: TensorFlow.TFGraph.GlobalNorm(TensorFlow.TFOutput[],System.String)
  id: GlobalNorm(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GlobalNorm(TFOutput[], String)
  nameWithType: TFGraph.GlobalNorm(TFOutput[], String)
  fullName: TFGraph.GlobalNorm(TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the global norm of multiple tensors.
  remarks: "<p>\n             Given a tuple or list of tensors <code>tensors</code>, this operation returns the global norm of the elements in all tensors \n             in <code>tensors</code>. The global norm is computed as: <code>global_norm = sqrt(sum([l2norm(t)**2 for t in t_list]))</code>. Any \n             entries in <code>tensors</code> that are of type None are ignored.</p>"
  syntax:
    content: public TensorFlow.TFOutput GlobalNorm (TensorFlow.TFOutput[] tensors, string operName = null);
    parameters:
    - id: tensors
      type: TensorFlow.TFOutput[]
      description: The input tensors.
    - id: operName
      type: System.String
      description: Operation name, optional.
    return:
      type: TensorFlow.TFOutput
      description: A clipped <xref href="TensorFlow.TFOutput"></xref>.
  overload: TensorFlow.TFGraph.GlobalNorm*
  exceptions: []
- uid: TensorFlow.TFGraph.Greater(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Greater(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Greater(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Greater(TFOutput, TFOutput, String)
  fullName: TFGraph.Greater(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the truth value of (x &gt; y) element-wise.
  remarks: >-
    *NOTE*: <code>Greater</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput Greater (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Greater'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Greater*
  exceptions: []
- uid: TensorFlow.TFGraph.GreaterEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: GreaterEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GreaterEqual(TFOutput, TFOutput, String)
  nameWithType: TFGraph.GreaterEqual(TFOutput, TFOutput, String)
  fullName: TFGraph.GreaterEqual(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the truth value of (x &gt;= y) element-wise.
  remarks: >-
    *NOTE*: <code>GreaterEqual</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput GreaterEqual (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'GreaterEqual'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.GreaterEqual*
  exceptions: []
- uid: TensorFlow.TFGraph.GuaranteeConst(TensorFlow.TFOutput,System.String)
  id: GuaranteeConst(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: GuaranteeConst(TFOutput, String)
  nameWithType: TFGraph.GuaranteeConst(TFOutput, String)
  fullName: TFGraph.GuaranteeConst(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gives a guarantee to the TF runtime that the input tensor is a constant.
  remarks: "The runtime is then free to make optimizations based on this.\n              \n              Only accepts value typed tensors as inputs and rejects resource variable handles\n              as input.\n              \n              Returns the input tensor without modification."
  syntax:
    content: public TensorFlow.TFOutput GuaranteeConst (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'GuaranteeConst'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.GuaranteeConst*
  exceptions: []
- uid: TensorFlow.TFGraph.HashTable(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  id: HashTable(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: HashTable(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.HashTable(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  fullName: TFGraph.HashTable(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a non-initialized hash table.
  remarks: >-
    This op creates a hash table, specifying the type of its keys and values.
                  Before using the table you will have to initialize it.  After initialization the
                  table will be immutable.
  syntax:
    content: public TensorFlow.TFOutput HashTable (TensorFlow.TFDataType key_dtype, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable<bool> use_node_name_sharing = null, string operName = null);
    parameters:
    - id: key_dtype
      type: TensorFlow.TFDataType
      description: Type of the table keys.
    - id: value_dtype
      type: TensorFlow.TFDataType
      description: Type of the table values.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is shared under the given name across
                      multiple sessions.
    - id: use_node_name_sharing
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true and shared_name is empty, the table is shared
                      using the node name.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'HashTable'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Handle to a table.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.HashTable*
  exceptions: []
- uid: TensorFlow.TFGraph.HashTableV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  id: HashTableV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: HashTableV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.HashTableV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  fullName: TFGraph.HashTableV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a non-initialized hash table.
  remarks: >-
    This op creates a hash table, specifying the type of its keys and values.
                  Before using the table you will have to initialize it.  After initialization the
                  table will be immutable.
  syntax:
    content: public TensorFlow.TFOutput HashTableV2 (TensorFlow.TFDataType key_dtype, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable<bool> use_node_name_sharing = null, string operName = null);
    parameters:
    - id: key_dtype
      type: TensorFlow.TFDataType
      description: Type of the table keys.
    - id: value_dtype
      type: TensorFlow.TFDataType
      description: Type of the table values.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is shared under the given name across
                      multiple sessions.
    - id: use_node_name_sharing
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true and shared_name is empty, the table is shared
                      using the node name.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'HashTableV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Handle to a table.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.HashTableV2*
  exceptions: []
- uid: TensorFlow.TFGraph.HistogramFixedWidth(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: HistogramFixedWidth(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: HistogramFixedWidth(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.HistogramFixedWidth(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.HistogramFixedWidth(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Return histogram of values.
  remarks: "Given the tensor <code>values</code>, this operation returns a rank 1 histogram counting\n              the number of entries in <code>values</code> that fall into every bin.  The bins are\n              equal width and determined by the arguments <code>value_range</code> and <code>nbins</code>.\n              \n               <pre><code>\n              # Bins will be:  (-inf, 1), [1, 2), [2, 3), [3, 4), [4, inf)\n              nbins = 5\n              value_range = [0.0, 5.0]\n              new_values = [-1.0, 0.0, 1.5, 2.0, 5.0, 15]\n              \n              with tf.get_default_session() as sess:\n              hist = tf.histogram_fixed_width(new_values, value_range, nbins=5)\n              variables.global_variables_initializer().run()\n              sess.run(hist) =&gt; [2, 1, 1, 0, 2]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput HistogramFixedWidth (TensorFlow.TFOutput values, TensorFlow.TFOutput value_range, TensorFlow.TFOutput nbins, Nullable<TensorFlow.TFDataType> dtype = null, string operName = null);
    parameters:
    - id: values
      type: TensorFlow.TFOutput
      description: Numeric <code>Tensor</code>.
    - id: value_range
      type: TensorFlow.TFOutput
      description: >-
        Shape [2] <code>Tensor</code> of same <code>dtype</code> as <code>values</code>.
                      values &lt;= value_range[0] will be mapped to hist[0],
                      values &gt;= value_range[1] will be mapped to hist[-1].
    - id: nbins
      type: TensorFlow.TFOutput
      description: Scalar <code>int32 Tensor</code>.  Number of histogram bins.
    - id: dtype
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'HistogramFixedWidth'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A 1-D <code>Tensor</code> holding histogram of values.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.HistogramFixedWidth*
  exceptions: []
- uid: TensorFlow.TFGraph.HistogramSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: HistogramSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: HistogramSummary(TFOutput, TFOutput, String)
  nameWithType: TFGraph.HistogramSummary(TFOutput, TFOutput, String)
  fullName: TFGraph.HistogramSummary(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs a <code>Summary</code> protocol buffer with a histogram.
  remarks: "The generated\n              [<code>Summary</code>](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)\n              has one summary value containing a histogram for <code>values</code>.\n              \n              This op reports an <code>InvalidArgument</code> error if any value is not finite."
  syntax:
    content: public TensorFlow.TFOutput HistogramSummary (TensorFlow.TFOutput tag, TensorFlow.TFOutput values, string operName = null);
    parameters:
    - id: tag
      type: TensorFlow.TFOutput
      description: Scalar.  Tag to use for the <code>Summary.Value</code>.
    - id: values
      type: TensorFlow.TFOutput
      description: Any shape. Values to use to build the histogram.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'HistogramSummary'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Scalar. Serialized <code>Summary</code> protocol buffer.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.HistogramSummary*
  exceptions: []
- uid: TensorFlow.TFGraph.HostConst(TensorFlow.TFTensor,TensorFlow.TFDataType,System.String)
  id: HostConst(TensorFlow.TFTensor,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: HostConst(TFTensor, TFDataType, String)
  nameWithType: TFGraph.HostConst(TFTensor, TFDataType, String)
  fullName: TFGraph.HostConst(TFTensor, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns a constant tensor on the host. Only for writing C++ tests.
  syntax:
    content: public TensorFlow.TFOutput HostConst (TensorFlow.TFTensor value, TensorFlow.TFDataType dtype, string operName = null);
    parameters:
    - id: value
      type: TensorFlow.TFTensor
      description: Attr <code>value</code> is the tensor to return.
    - id: dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'HostConst'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.HostConst*
  exceptions: []
- uid: TensorFlow.TFGraph.HSVToRGB(TensorFlow.TFOutput,System.String)
  id: HSVToRGB(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: HSVToRGB(TFOutput, String)
  nameWithType: TFGraph.HSVToRGB(TFOutput, String)
  fullName: TFGraph.HSVToRGB(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Convert one or more images from HSV to RGB.
  remarks: "Outputs a tensor of the same shape as the <code>images</code> tensor, containing the RGB\n              value of the pixels. The output is only well defined if the value in <code>images</code>\n              are in <code>[0,1]</code>.\n              \n              See <code>rgb_to_hsv</code> for a description of the HSV encoding."
  syntax:
    content: public TensorFlow.TFOutput HSVToRGB (TensorFlow.TFOutput images, string operName = null);
    parameters:
    - id: images
      type: TensorFlow.TFOutput
      description: 1-D or higher rank. HSV data to convert. Last dimension must be size 3.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'HSVToRGB'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        <code>images</code> converted to RGB.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.HSVToRGB*
  exceptions: []
- uid: TensorFlow.TFGraph.Identity(TensorFlow.TFOutput,System.String)
  id: Identity(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Identity(TFOutput, String)
  nameWithType: TFGraph.Identity(TFOutput, String)
  fullName: TFGraph.Identity(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Return a tensor with the same shape and contents as the input tensor or value.
  syntax:
    content: public TensorFlow.TFOutput Identity (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Identity'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Identity*
  exceptions: []
- uid: TensorFlow.TFGraph.IdentityN(TensorFlow.TFOutput[],System.String)
  id: IdentityN(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IdentityN(TFOutput[], String)
  nameWithType: TFGraph.IdentityN(TFOutput[], String)
  fullName: TFGraph.IdentityN(TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns a list of tensors with the same shapes and contents as the input
  remarks: "tensors.\n              \n              This op can be used to override the gradient for complicated functions. For\n              example, suppose y = f(x) and we wish to apply a custom function g for backprop\n              such that dx = g(dy). In Python,\n              \n               <pre><code>\n              with tf.get_default_graph().gradient_override_map(\n              {'IdentityN': 'OverrideGradientWithG'}):\n              y, _ = identity_n([f(x), x])\n              \n              @tf.RegisterGradient('OverrideGradientWithG')\n              def ApplyG(op, dy, _):\n              return [None, g(dy)]  # Do not backprop to f(x).\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput[] IdentityN (TensorFlow.TFOutput[] input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IdentityN'.
    return:
      type: TensorFlow.TFOutput[]
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IdentityN*
  exceptions: []
- uid: TensorFlow.TFGraph.IdentityReader(System.String,System.String,System.String)
  id: IdentityReader(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IdentityReader(String, String, String)
  nameWithType: TFGraph.IdentityReader(String, String, String)
  fullName: TFGraph.IdentityReader(String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A Reader that outputs the queued work as both the key and value.
  remarks: >-
    To use, enqueue strings in a Queue.  ReaderRead will take the front
                  work string and output (work, work).
  syntax:
    content: public TensorFlow.TFOutput IdentityReader (string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IdentityReader'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to reference the Reader.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IdentityReader*
  exceptions: []
- uid: TensorFlow.TFGraph.IdentityReaderV2(System.String,System.String,System.String)
  id: IdentityReaderV2(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IdentityReaderV2(String, String, String)
  nameWithType: TFGraph.IdentityReaderV2(String, String, String)
  fullName: TFGraph.IdentityReaderV2(String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A Reader that outputs the queued work as both the key and value.
  remarks: >-
    To use, enqueue strings in a Queue.  ReaderRead will take the front
                  work string and output (work, work).
  syntax:
    content: public TensorFlow.TFOutput IdentityReaderV2 (string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IdentityReaderV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to reference the Reader.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IdentityReaderV2*
  exceptions: []
- uid: TensorFlow.TFGraph.IFFT(TensorFlow.TFOutput,System.String)
  id: IFFT(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IFFT(TFOutput, String)
  nameWithType: TFGraph.IFFT(TFOutput, String)
  fullName: TFGraph.IFFT(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Inverse fast Fourier transform.
  remarks: >-
    Computes the inverse 1-dimensional discrete Fourier transform over the
                  inner-most dimension of <code>input</code>.
  syntax:
    content: public TensorFlow.TFOutput IFFT (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A complex tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IFFT'.
    return:
      type: TensorFlow.TFOutput
      description: "A complex tensor of the same shape as <code>input</code>. The inner-most\n              dimension of <code>input</code> is replaced with its inverse 1D Fourier transform.\n              \n              @compatibility(numpy)\n              Equivalent to np.fft.ifft\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.IFFT*
  exceptions: []
- uid: TensorFlow.TFGraph.IFFT2D(TensorFlow.TFOutput,System.String)
  id: IFFT2D(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IFFT2D(TFOutput, String)
  nameWithType: TFGraph.IFFT2D(TFOutput, String)
  fullName: TFGraph.IFFT2D(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Inverse 2D fast Fourier transform.
  remarks: >-
    Computes the inverse 2-dimensional discrete Fourier transform over the
                  inner-most 2 dimensions of <code>input</code>.
  syntax:
    content: public TensorFlow.TFOutput IFFT2D (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A complex tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IFFT2D'.
    return:
      type: TensorFlow.TFOutput
      description: "A complex tensor of the same shape as <code>input</code>. The inner-most 2\n              dimensions of <code>input</code> are replaced with their inverse 2D Fourier transform.\n              \n              @compatibility(numpy)\n              Equivalent to np.fft.ifft2\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.IFFT2D*
  exceptions: []
- uid: TensorFlow.TFGraph.IFFT3D(TensorFlow.TFOutput,System.String)
  id: IFFT3D(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IFFT3D(TFOutput, String)
  nameWithType: TFGraph.IFFT3D(TFOutput, String)
  fullName: TFGraph.IFFT3D(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Inverse 3D fast Fourier transform.
  remarks: >-
    Computes the inverse 3-dimensional discrete Fourier transform over the
                  inner-most 3 dimensions of <code>input</code>.
  syntax:
    content: public TensorFlow.TFOutput IFFT3D (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A complex64 tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IFFT3D'.
    return:
      type: TensorFlow.TFOutput
      description: "A complex64 tensor of the same shape as <code>input</code>. The inner-most 3\n              dimensions of <code>input</code> are replaced with their inverse 3D Fourier transform.\n              \n              @compatibility(numpy)\n              Equivalent to np.fft.ifftn with 3 dimensions.\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.IFFT3D*
  exceptions: []
- uid: TensorFlow.TFGraph.Igamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Igamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Igamma(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Igamma(TFOutput, TFOutput, String)
  fullName: TFGraph.Igamma(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Compute the lower regularized incomplete Gamma function <code>P(a, x)</code>.
  remarks: "The lower regularized incomplete Gamma function is defined as:\n              \n              \n              \\\\(P(a, x) = gamma(a, x) / Gamma(a) = 1 - Q(a, x)\\\\)\n              \n              where\n              \n              \\\\(gamma(a, x) = \\\\int_{0}^{x} t^{a-1} exp(-t) dt\\\\)\n              \n              is the lower incomplete Gamma function.\n              \n              Note, above <code>Q(a, x)</code> (<code>Igammac</code>) is the upper regularized complete\n              Gamma function."
  syntax:
    content: public TensorFlow.TFOutput Igamma (TensorFlow.TFOutput a, TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: a
      type: TensorFlow.TFOutput
      description: To be added.
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Igamma'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Igamma*
  exceptions: []
- uid: TensorFlow.TFGraph.Igammac(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Igammac(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Igammac(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Igammac(TFOutput, TFOutput, String)
  fullName: TFGraph.Igammac(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Compute the upper regularized incomplete Gamma function <code>Q(a, x)</code>.
  remarks: "The upper regularized incomplete Gamma function is defined as:\n              \n              \\\\(Q(a, x) = Gamma(a, x) / Gamma(a) = 1 - P(a, x)\\\\)\n              \n              where\n              \n              \\\\(Gamma(a, x) = int_{x}^{\\infty} t^{a-1} exp(-t) dt\\\\)\n              \n              is the upper incomplete Gama function.\n              \n              Note, above <code>P(a, x)</code> (<code>Igamma</code>) is the lower regularized complete\n              Gamma function."
  syntax:
    content: public TensorFlow.TFOutput Igammac (TensorFlow.TFOutput a, TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: a
      type: TensorFlow.TFOutput
      description: To be added.
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Igammac'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Igammac*
  exceptions: []
- uid: TensorFlow.TFGraph.IgammaGradA(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: IgammaGradA(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IgammaGradA(TFOutput, TFOutput, String)
  nameWithType: TFGraph.IgammaGradA(TFOutput, TFOutput, String)
  fullName: TFGraph.IgammaGradA(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradient of <code>igamma(a, x)</code> wrt <code>a</code>.
  syntax:
    content: public TensorFlow.TFOutput IgammaGradA (TensorFlow.TFOutput a, TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: a
      type: TensorFlow.TFOutput
      description: To be added.
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IgammaGradA'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IgammaGradA*
  exceptions: []
- uid: TensorFlow.TFGraph.Imag(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: Imag(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Imag(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Imag(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Imag(TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the imaginary part of a complex number.
  remarks: "Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of\n              type <code>float</code> that is the imaginary part of each element in <code>input</code>. All\n              elements in <code>input</code> must be complex numbers of the form \\\\(a + bj\\\\), where *a*\n              is the real part and *b* is the imaginary part returned by this operation.\n              \n              For example:\n              \n               <pre><code>\n              # tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\n              tf.imag(input) ==&gt; [4.75, 5.75]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Imag (TensorFlow.TFOutput input, Nullable<TensorFlow.TFDataType> Tout = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: Tout
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Imag'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Imag*
  exceptions: []
- uid: TensorFlow.TFGraph.ImageSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},TensorFlow.TFTensor,System.String)
  id: ImageSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},TensorFlow.TFTensor,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ImageSummary(TFOutput, TFOutput, Nullable<Int64>, TFTensor, String)
  nameWithType: TFGraph.ImageSummary(TFOutput, TFOutput, Nullable<Int64>, TFTensor, String)
  fullName: TFGraph.ImageSummary(TFOutput, TFOutput, Nullable<Int64>, TFTensor, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs a <code>Summary</code> protocol buffer with images.
  remarks: "The summary has up to <code>max_images</code> summary values containing images. The\n              images are built from <code>tensor</code> which must be 4-D with shape <code>[batch_size,\n              height, width, channels]</code> and where <code>channels</code> can be:\n              \n              *  1: <code>tensor</code> is interpreted as Grayscale.\n              *  3: <code>tensor</code> is interpreted as RGB.\n              *  4: <code>tensor</code> is interpreted as RGBA.\n              \n              The images have the same number of channels as the input tensor. For float\n              input, the values are normalized one image at a time to fit in the range\n              <code>[0, 255]</code>.  <code>uint8</code> values are unchanged.  The op uses two different\n              normalization algorithms:\n              \n              *  If the input values are all positive, they are rescaled so the largest one\n              is 255.\n              \n              *  If any input value is negative, the values are shifted so input value 0.0\n              is at 127.  They are then rescaled so that either the smallest value is 0,\n              or the largest one is 255.\n              \n              The <code>tag</code> argument is a scalar <code>Tensor</code> of type <code>string</code>.  It is used to\n              build the <code>tag</code> of the summary values:\n              \n              *  If <code>max_images</code> is 1, the summary value tag is '*tag*/image'.\n              *  If <code>max_images</code> is greater than 1, the summary value tags are\n              generated sequentially as '*tag*/image/0', '*tag*/image/1', etc.\n              \n              The <code>bad_color</code> argument is the color to use in the generated images for\n              non-finite input values.  It is a <code>uint8</code> 1-D tensor of length <code>channels</code>.\n              Each element must be in the range <code>[0, 255]</code> (It represents the value of a\n              pixel in the output image).  Non-finite values in the input tensor are\n              replaced by this tensor in the output image.  The default value is the color\n              red."
  syntax:
    content: public TensorFlow.TFOutput ImageSummary (TensorFlow.TFOutput tag, TensorFlow.TFOutput tensor, Nullable<long> max_images = null, TensorFlow.TFTensor bad_color = null, string operName = null);
    parameters:
    - id: tag
      type: TensorFlow.TFOutput
      description: Scalar. Used to build the <code>tag</code> attribute of the summary values.
    - id: tensor
      type: TensorFlow.TFOutput
      description: >-
        4-D of shape <code>[batch_size, height, width, channels]</code> where
                      <code>channels</code> is 1, 3, or 4.
    - id: max_images
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Max number of batch elements to generate images for.
    - id: bad_color
      type: TensorFlow.TFTensor
      description: >-
        Optional argument
                      Color to use for pixels with non-finite values.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ImageSummary'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Scalar. Serialized <code>Summary</code> protocol buffer.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ImageSummary*
  exceptions: []
- uid: TensorFlow.TFGraph.ImmutableConst(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String)
  id: ImmutableConst(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ImmutableConst(TFDataType, TFShape, String, String)
  nameWithType: TFGraph.ImmutableConst(TFDataType, TFShape, String, String)
  fullName: TFGraph.ImmutableConst(TFDataType, TFShape, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns immutable tensor from memory region.
  remarks: The current implementation memmaps the tensor from a file.
  syntax:
    content: public TensorFlow.TFOutput ImmutableConst (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string memory_region_name, string operName = null);
    parameters:
    - id: dtype
      type: TensorFlow.TFDataType
      description: Type of the returned tensor.
    - id: shape
      type: TensorFlow.TFShape
      description: Shape of the returned tensor.
    - id: memory_region_name
      type: System.String
      description: >-
        Name of readonly memory region used by the tensor, see
                      NewReadOnlyMemoryRegionFromFile in tensorflow::Env.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ImmutableConst'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ImmutableConst*
  exceptions: []
- uid: TensorFlow.TFGraph.Import(System.Byte[],System.String,TensorFlow.TFStatus)
  id: Import(System.Byte[],System.String,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Import(Byte[], String, TFStatus)
  nameWithType: TFGraph.Import(Byte[], String, TFStatus)
  fullName: TFGraph.Import(Byte[], String, TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Import a serialized graph held in a byte array into this graph, using the specified prefix.
  syntax:
    content: public void Import (byte[] buffer, string prefix = "", TensorFlow.TFStatus status = null);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: A byte array containing the serialized graph.
    - id: prefix
      type: System.String
      description: A prefix that will be prepended to names of nodes in the graph when they are imported into the graph.
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
  overload: TensorFlow.TFGraph.Import*
  exceptions: []
- uid: TensorFlow.TFGraph.Import(System.Byte[],TensorFlow.TFImportGraphDefOptions,TensorFlow.TFStatus)
  id: Import(System.Byte[],TensorFlow.TFImportGraphDefOptions,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Import(Byte[], TFImportGraphDefOptions, TFStatus)
  nameWithType: TFGraph.Import(Byte[], TFImportGraphDefOptions, TFStatus)
  fullName: TFGraph.Import(Byte[], TFImportGraphDefOptions, TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Import a serialized graph held in a byte array into this graph, using the specified import options.
  remarks: If you are tryig to load a file stored using the SavedModel file format, you should use the <xref href="TensorFlow.TFSession.FromSavedModel"></xref> API instead.
  syntax:
    content: public void Import (byte[] buffer, TensorFlow.TFImportGraphDefOptions options, TensorFlow.TFStatus status = null);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: A byte array containing the serialized graph.
    - id: options
      type: TensorFlow.TFImportGraphDefOptions
      description: Importing graph options.
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
  overload: TensorFlow.TFGraph.Import*
  exceptions: []
- uid: TensorFlow.TFGraph.Import(TensorFlow.TFBuffer,System.String,TensorFlow.TFStatus)
  id: Import(TensorFlow.TFBuffer,System.String,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Import(TFBuffer, String, TFStatus)
  nameWithType: TFGraph.Import(TFBuffer, String, TFStatus)
  fullName: TFGraph.Import(TFBuffer, String, TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Import a serialized graph into this graph, using the specified prefix.
  syntax:
    content: public void Import (TensorFlow.TFBuffer graphDef, string prefix = "", TensorFlow.TFStatus status = null);
    parameters:
    - id: graphDef
      type: TensorFlow.TFBuffer
      description: A buffer containing the serialized graph.
    - id: prefix
      type: System.String
      description: A prefix that will be prepended to names of nodes in the <code>graphDef</code> when they are imported into the graph.
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
  overload: TensorFlow.TFGraph.Import*
  exceptions: []
- uid: TensorFlow.TFGraph.Import(TensorFlow.TFBuffer,TensorFlow.TFImportGraphDefOptions,TensorFlow.TFStatus)
  id: Import(TensorFlow.TFBuffer,TensorFlow.TFImportGraphDefOptions,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Import(TFBuffer, TFImportGraphDefOptions, TFStatus)
  nameWithType: TFGraph.Import(TFBuffer, TFImportGraphDefOptions, TFStatus)
  fullName: TFGraph.Import(TFBuffer, TFImportGraphDefOptions, TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Import a serialized graph into this graph, using the specified importing options.
  syntax:
    content: public void Import (TensorFlow.TFBuffer graphDef, TensorFlow.TFImportGraphDefOptions options, TensorFlow.TFStatus status = null);
    parameters:
    - id: graphDef
      type: TensorFlow.TFBuffer
      description: A buffer containing the serialized graph.
    - id: options
      type: TensorFlow.TFImportGraphDefOptions
      description: Importing graph options.
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
  overload: TensorFlow.TFGraph.Import*
  exceptions: []
- uid: TensorFlow.TFGraph.ImportGraphDef(TensorFlow.TFBuffer,TensorFlow.TFImportGraphDefOptions,TensorFlow.TFOutput[],TensorFlow.TFStatus)
  id: ImportGraphDef(TensorFlow.TFBuffer,TensorFlow.TFImportGraphDefOptions,TensorFlow.TFOutput[],TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ImportGraphDef(TFBuffer, TFImportGraphDefOptions, TFOutput[], TFStatus)
  nameWithType: TFGraph.ImportGraphDef(TFBuffer, TFImportGraphDefOptions, TFOutput[], TFStatus)
  fullName: TFGraph.ImportGraphDef(TFBuffer, TFImportGraphDefOptions, TFOutput[], TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Imports a graph serialized into the graph
  remarks: If you are tryig to load a file stored using the SavedModel file format, you should use the <xref href="TensorFlow.TFSession.FromSavedModel"></xref> API instead.
  syntax:
    content: public void ImportGraphDef (TensorFlow.TFBuffer graphDef, TensorFlow.TFImportGraphDefOptions options, TensorFlow.TFOutput[] returnOutputs, TensorFlow.TFStatus status = null);
    parameters:
    - id: graphDef
      type: TensorFlow.TFBuffer
      description: Serialized graph definition (in protocol buffer format).
    - id: options
      type: TensorFlow.TFImportGraphDefOptions
      description: Import options.
    - id: returnOutputs
      type: TensorFlow.TFOutput[]
      description: Array large enough to contain all the return options.
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
  overload: TensorFlow.TFGraph.ImportGraphDef*
  exceptions: []
- uid: TensorFlow.TFGraph.InfeedDequeue(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  id: InfeedDequeue(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InfeedDequeue(TFDataType, TFShape, String)
  nameWithType: TFGraph.InfeedDequeue(TFDataType, TFShape, String)
  fullName: TFGraph.InfeedDequeue(TFDataType, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A placeholder op for a value that will be fed into the computation.
  syntax:
    content: public TensorFlow.TFOutput InfeedDequeue (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string operName = null);
    parameters:
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of elements in the tensor.
    - id: shape
      type: TensorFlow.TFShape
      description: The shape of the tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InfeedDequeue'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A tensor that will be provided using the infeed mechanism.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.InfeedDequeue*
  exceptions: []
- uid: TensorFlow.TFGraph.InfeedDequeueTuple(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: InfeedDequeueTuple(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InfeedDequeueTuple(TFDataType[], TFShape[], String)
  nameWithType: TFGraph.InfeedDequeueTuple(TFDataType[], TFShape[], String)
  fullName: TFGraph.InfeedDequeueTuple(TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A placeholder op for multiple values that will be fed into the computation
  remarks: simultaneously as an XLA tuple.
  syntax:
    content: public TensorFlow.TFOutput[] InfeedDequeueTuple (TensorFlow.TFDataType[] dtypes, TensorFlow.TFShape[] shapes, string operName = null);
    parameters:
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: The element types of each element in <code>outputs</code>.
    - id: shapes
      type: TensorFlow.TFShape[]
      description: The shapes of each tensor in <code>outputs</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InfeedDequeueTuple'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        A list of tensors that will be provided using the infeed mechanism.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.InfeedDequeueTuple*
  exceptions: []
- uid: TensorFlow.TFGraph.InfeedEnqueue(TensorFlow.TFOutput,TensorFlow.TFShape,System.Nullable{System.Int64},System.String)
  id: InfeedEnqueue(TensorFlow.TFOutput,TensorFlow.TFShape,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InfeedEnqueue(TFOutput, TFShape, Nullable<Int64>, String)
  nameWithType: TFGraph.InfeedEnqueue(TFOutput, TFShape, Nullable<Int64>, String)
  fullName: TFGraph.InfeedEnqueue(TFOutput, TFShape, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An op which feeds a single Tensor value into the computation.
  syntax:
    content: public TensorFlow.TFOperation InfeedEnqueue (TensorFlow.TFOutput input, TensorFlow.TFShape shape = null, Nullable<long> device_ordinal = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A tensor that will be provided using the infeed mechanism.
    - id: shape
      type: TensorFlow.TFShape
      description: >-
        Optional argument
                      The shape of the tensor.
    - id: device_ordinal
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The TPU device to use. This should be -1 when the Op
                      is running on a TPU device, and &gt;= 0 when the Op is running on the CPU
                      device.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InfeedEnqueue'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.InfeedEnqueue*
  exceptions: []
- uid: TensorFlow.TFGraph.InfeedEnqueueTuple(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String)
  id: InfeedEnqueueTuple(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InfeedEnqueueTuple(TFOutput[], TFShape[], Nullable<Int64>, String)
  nameWithType: TFGraph.InfeedEnqueueTuple(TFOutput[], TFShape[], Nullable<Int64>, String)
  fullName: TFGraph.InfeedEnqueueTuple(TFOutput[], TFShape[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An op which feeds multiple Tensor values into the computation as an XLA tuple.
  syntax:
    content: public TensorFlow.TFOperation InfeedEnqueueTuple (TensorFlow.TFOutput[] inputs, TensorFlow.TFShape[] shapes, Nullable<long> device_ordinal = null, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: A list of tensors that will be provided using the infeed mechanism.
    - id: shapes
      type: TensorFlow.TFShape[]
      description: The shapes of each tensor in <code>inputs</code>.
    - id: device_ordinal
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The TPU device to use. This should be -1 when the Op
                      is running on a TPU device, and &gt;= 0 when the Op is running on the CPU
                      device.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InfeedEnqueueTuple'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.InfeedEnqueueTuple*
  exceptions: []
- uid: TensorFlow.TFGraph.InitializeTable(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: InitializeTable(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InitializeTable(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.InitializeTable(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.InitializeTable(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Table initializer that takes two tensors for keys and values respectively.
  syntax:
    content: public TensorFlow.TFOperation InitializeTable (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to a table which will be initialized.
    - id: keys
      type: TensorFlow.TFOutput
      description: Keys of type Tkey.
    - id: values
      type: TensorFlow.TFOutput
      description: Values of type Tval.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTable'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.InitializeTable*
  exceptions: []
- uid: TensorFlow.TFGraph.InitializeTableFromTextFile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: InitializeTableFromTextFile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InitializeTableFromTextFile(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.InitializeTableFromTextFile(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.InitializeTableFromTextFile(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Initializes a table from a text file.
  remarks: "It inserts one key-value pair into the table for each line of the file.\n              The key and value is extracted from the whole line content, elements from the\n              split line based on <code>delimiter</code> or the line number (starting from zero).\n              Where to extract the key and value from a line is specified by <code>key_index</code> and\n              <code>value_index</code>.\n              \n              - A value of -1 means use the line number(starting from zero), expects <code>int64</code>.\n              - A value of -2 means use the whole line content, expects <code>string</code>.\n              - A value &gt;= 0 means use the index (starting at zero) of the split line based\n              on <code>delimiter</code>."
  syntax:
    content: public TensorFlow.TFOperation InitializeTableFromTextFile (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput filename, long key_index, long value_index, Nullable<long> vocab_size = null, string delimiter = null, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to a table which will be initialized.
    - id: filename
      type: TensorFlow.TFOutput
      description: Filename of a vocabulary text file.
    - id: key_index
      type: System.Int64
      description: Column index in a line to get the table <code>key</code> values from.
    - id: value_index
      type: System.Int64
      description: >-
        Column index that represents information of a line to get the table
                      <code>value</code> values from.
    - id: vocab_size
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of elements of the file, use -1 if unknown.
    - id: delimiter
      type: System.String
      description: >-
        Optional argument
                      Delimiter to separate fields in a line.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTableFromTextFile'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.InitializeTableFromTextFile*
  exceptions: []
- uid: TensorFlow.TFGraph.InitializeTableFromTextFileV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: InitializeTableFromTextFileV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InitializeTableFromTextFileV2(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.InitializeTableFromTextFileV2(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.InitializeTableFromTextFileV2(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Initializes a table from a text file.
  remarks: "It inserts one key-value pair into the table for each line of the file.\n              The key and value is extracted from the whole line content, elements from the\n              split line based on <code>delimiter</code> or the line number (starting from zero).\n              Where to extract the key and value from a line is specified by <code>key_index</code> and\n              <code>value_index</code>.\n              \n              - A value of -1 means use the line number(starting from zero), expects <code>int64</code>.\n              - A value of -2 means use the whole line content, expects <code>string</code>.\n              - A value &gt;= 0 means use the index (starting at zero) of the split line based\n              on <code>delimiter</code>."
  syntax:
    content: public TensorFlow.TFOperation InitializeTableFromTextFileV2 (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput filename, long key_index, long value_index, Nullable<long> vocab_size = null, string delimiter = null, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to a table which will be initialized.
    - id: filename
      type: TensorFlow.TFOutput
      description: Filename of a vocabulary text file.
    - id: key_index
      type: System.Int64
      description: Column index in a line to get the table <code>key</code> values from.
    - id: value_index
      type: System.Int64
      description: >-
        Column index that represents information of a line to get the table
                      <code>value</code> values from.
    - id: vocab_size
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of elements of the file, use -1 if unknown.
    - id: delimiter
      type: System.String
      description: >-
        Optional argument
                      Delimiter to separate fields in a line.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTableFromTextFileV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.InitializeTableFromTextFileV2*
  exceptions: []
- uid: TensorFlow.TFGraph.InitializeTableV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: InitializeTableV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InitializeTableV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.InitializeTableV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.InitializeTableV2(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Table initializer that takes two tensors for keys and values respectively.
  syntax:
    content: public TensorFlow.TFOperation InitializeTableV2 (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to a table which will be initialized.
    - id: keys
      type: TensorFlow.TFOutput
      description: Keys of type Tkey.
    - id: values
      type: TensorFlow.TFOutput
      description: Values of type Tval.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InitializeTableV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.InitializeTableV2*
  exceptions: []
- uid: TensorFlow.TFGraph.InplaceAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: InplaceAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InplaceAdd(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.InplaceAdd(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.InplaceAdd(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: "Adds v into specified rows of x.\n              \n              Computes y = x; y[i, :] += v; return y."
  syntax:
    content: public TensorFlow.TFOutput InplaceAdd (TensorFlow.TFOutput x, TensorFlow.TFOutput i, TensorFlow.TFOutput v, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: A <code>Tensor</code> of type T.
    - id: i
      type: TensorFlow.TFOutput
      description: A vector. Indices into the left-most dimension of <code>x</code>.
    - id: v
      type: TensorFlow.TFOutput
      description: A <code>Tensor</code> of type T. Same dimension sizes as x except the first dimension, which must be the same as i's size.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InplaceAdd'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A <code>Tensor</code> of type T. An alias of <code>x</code>. The content of <code>y</code> is undefined if there are duplicates in <code>i</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.InplaceAdd*
  exceptions: []
- uid: TensorFlow.TFGraph.InplaceSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: InplaceSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InplaceSub(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.InplaceSub(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.InplaceSub(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: "Subtracts <code>v</code> into specified rows of <code>x</code>.\n              \n              Computes y = x; y[i, :] -= v; return y."
  syntax:
    content: public TensorFlow.TFOutput InplaceSub (TensorFlow.TFOutput x, TensorFlow.TFOutput i, TensorFlow.TFOutput v, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: A <code>Tensor</code> of type T.
    - id: i
      type: TensorFlow.TFOutput
      description: A vector. Indices into the left-most dimension of <code>x</code>.
    - id: v
      type: TensorFlow.TFOutput
      description: A <code>Tensor</code> of type T. Same dimension sizes as x except the first dimension, which must be the same as i's size.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InplaceSub'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A <code>Tensor</code> of type T. An alias of <code>x</code>. The content of <code>y</code> is undefined if there are duplicates in <code>i</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.InplaceSub*
  exceptions: []
- uid: TensorFlow.TFGraph.InplaceUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: InplaceUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InplaceUpdate(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.InplaceUpdate(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.InplaceUpdate(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: "Updates specified rows with values in <code>v</code>.\n              \n              Computes <code>x[i, :] = v; return x</code>."
  syntax:
    content: public TensorFlow.TFOutput InplaceUpdate (TensorFlow.TFOutput x, TensorFlow.TFOutput i, TensorFlow.TFOutput v, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: A tensor of type <code>T</code>.
    - id: i
      type: TensorFlow.TFOutput
      description: A vector. Indices into the left-most dimension of <code>x</code>.
    - id: v
      type: TensorFlow.TFOutput
      description: A <code>Tensor</code> of type T. Same dimension sizes as x except the first dimension, which must be the same as i's size.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InplaceUpdate'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A <code>Tensor</code> of type T. An alias of <code>x</code>. The content of <code>y</code> is undefined if there are duplicates in <code>i</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.InplaceUpdate*
  exceptions: []
- uid: TensorFlow.TFGraph.InTopK(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  id: InTopK(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InTopK(TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.InTopK(TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.InTopK(TFOutput, TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Says whether the targets are in the top <code>K</code> predictions.
  remarks: "This outputs a <code>batch_size</code> bool array, an entry <code>out[i]</code> is <code>true</code> if the\n              prediction for the target class is among the top <code>k</code> predictions among\n              all predictions for example <code>i</code>. Note that the behavior of <code>InTopK</code> differs\n              from the <code>TopK</code> op in its handling of ties; if multiple classes have the\n              same prediction value and straddle the top-<code>k</code> boundary, all of those\n              classes are considered to be in the top <code>k</code>.\n              \n              More formally, let\n              \n              \\\\(predictions_i\\\\) be the predictions for all classes for example <code>i</code>,\n              \\\\(targets_i\\\\) be the target class for example <code>i</code>,\n              \\\\(out_i\\\\) be the output for example <code>i</code>,\n              \n              $$out_i = predictions_{i, targets_i} \\in TopKIncludingTies(predictions_i)$$"
  syntax:
    content: public TensorFlow.TFOutput InTopK (TensorFlow.TFOutput predictions, TensorFlow.TFOutput targets, long k, string operName = null);
    parameters:
    - id: predictions
      type: TensorFlow.TFOutput
      description: A <code>batch_size</code> x <code>classes</code> tensor.
    - id: targets
      type: TensorFlow.TFOutput
      description: A <code>batch_size</code> vector of class ids.
    - id: k
      type: System.Int64
      description: Number of top elements to look at for computing precision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InTopK'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Computed Precision at <code>k</code> as a <code>bool Tensor</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.InTopK*
  exceptions: []
- uid: TensorFlow.TFGraph.InTopKV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: InTopKV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InTopKV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.InTopKV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.InTopKV2(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Says whether the targets are in the top <code>K</code> predictions.
  remarks: "This outputs a <code>batch_size</code> bool array, an entry <code>out[i]</code> is <code>true</code> if the\n              prediction for the target class is among the top <code>k</code> predictions among\n              all predictions for example <code>i</code>. Note that the behavior of <code>InTopK</code> differs\n              from the <code>TopK</code> op in its handling of ties; if multiple classes have the\n              same prediction value and straddle the top-<code>k</code> boundary, all of those\n              classes are considered to be in the top <code>k</code>.\n              \n              More formally, let\n              \n              \\\\(predictions_i\\\\) be the predictions for all classes for example <code>i</code>,\n              \\\\(targets_i\\\\) be the target class for example <code>i</code>,\n              \\\\(out_i\\\\) be the output for example <code>i</code>,\n              \n              $$out_i = predictions_{i, targets_i} \\in TopKIncludingTies(predictions_i)$$"
  syntax:
    content: public TensorFlow.TFOutput InTopKV2 (TensorFlow.TFOutput predictions, TensorFlow.TFOutput targets, TensorFlow.TFOutput k, string operName = null);
    parameters:
    - id: predictions
      type: TensorFlow.TFOutput
      description: A <code>batch_size</code> x <code>classes</code> tensor.
    - id: targets
      type: TensorFlow.TFOutput
      description: A <code>batch_size</code> vector of class ids.
    - id: k
      type: TensorFlow.TFOutput
      description: Number of top elements to look at for computing precision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InTopKV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Computed precision at <code>k</code> as a <code>bool Tensor</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.InTopKV2*
  exceptions: []
- uid: TensorFlow.TFGraph.Inv(TensorFlow.TFOutput,System.String)
  id: Inv(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Inv(TFOutput, String)
  nameWithType: TFGraph.Inv(TFOutput, String)
  fullName: TFGraph.Inv(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the reciprocal of x element-wise.
  remarks: I.e., \\(y = 1 / x\\).
  syntax:
    content: public TensorFlow.TFOutput Inv (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Inv'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Inv*
  exceptions: []
- uid: TensorFlow.TFGraph.Invert(TensorFlow.TFOutput,System.String)
  id: Invert(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Invert(TFOutput, String)
  nameWithType: TFGraph.Invert(TFOutput, String)
  fullName: TFGraph.Invert(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Flips all bits elementwise.
  remarks: >-
    The result will have exactly those bits set, that are not set in <code>x</code>. The
                  computation is performed on the underlying representation of x.
  syntax:
    content: public TensorFlow.TFOutput Invert (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Invert'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Invert*
  exceptions: []
- uid: TensorFlow.TFGraph.InvertPermutation(TensorFlow.TFOutput,System.String)
  id: InvertPermutation(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InvertPermutation(TFOutput, String)
  nameWithType: TFGraph.InvertPermutation(TFOutput, String)
  fullName: TFGraph.InvertPermutation(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the inverse permutation of a tensor.
  remarks: "This operation computes the inverse of an index permutation. It takes a 1-D\n              integer tensor <code>x</code>, which represents the indices of a zero-based array, and\n              swaps each value with its index position. In other words, for an output tensor\n              <code>y</code> and an input tensor <code>x</code>, this operation computes the following:\n              \n              <code>y[x[i]] = i for i in [0, 1, ..., len(x) - 1]</code>\n              \n              The values must include 0. There can be no duplicate values or negative values.\n              \n              For example:\n              \n               <pre><code>\n              # tensor <code>x</code> is [3, 4, 0, 2, 1]\n              invert_permutation(x) ==&gt; [2, 4, 3, 0, 1]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput InvertPermutation (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: 1-D.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InvertPermutation'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        1-D.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.InvertPermutation*
  exceptions: []
- uid: TensorFlow.TFGraph.InvGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: InvGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: InvGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.InvGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.InvGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradient for the inverse of <code>x</code> wrt its input.
  remarks: >-
    Specifically, <code>grad = -dy * y*y</code>, where <code>y = 1/x</code>, and <code>dy</code>
                  is the corresponding input gradient.
  syntax:
    content: public TensorFlow.TFOutput InvGrad (TensorFlow.TFOutput y, TensorFlow.TFOutput dy, string operName = null);
    parameters:
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dy
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'InvGrad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.InvGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.IRFFT(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: IRFFT(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IRFFT(TFOutput, TFOutput, String)
  nameWithType: TFGraph.IRFFT(TFOutput, TFOutput, String)
  fullName: TFGraph.IRFFT(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Inverse real-valued fast Fourier transform.
  remarks: "Computes the inverse 1-dimensional discrete Fourier transform of a real-valued\n              signal over the inner-most dimension of <code>input</code>.\n              \n              The inner-most dimension of <code>input</code> is assumed to be the result of <code>RFFT</code>: the\n              <code>fft_length / 2 + 1</code> unique components of the DFT of a real-valued signal. If\n              <code>fft_length</code> is not provided, it is computed from the size of the inner-most\n              dimension of <code>input</code> (<code>fft_length = 2 * (inner - 1)</code>). If the FFT length used to\n              compute <code>input</code> is odd, it should be provided since it cannot be inferred\n              properly.\n              \n              Along the axis <code>IRFFT</code> is computed on, if <code>fft_length / 2 + 1</code> is smaller\n              than the corresponding dimension of <code>input</code>, the dimension is cropped. If it is\n              larger, the dimension is padded with zeros."
  syntax:
    content: public TensorFlow.TFOutput IRFFT (TensorFlow.TFOutput input, TensorFlow.TFOutput fft_length, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A complex64 tensor.
    - id: fft_length
      type: TensorFlow.TFOutput
      description: An int32 tensor of shape [1]. The FFT length.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IRFFT'.
    return:
      type: TensorFlow.TFOutput
      description: "A float32 tensor of the same rank as <code>input</code>. The inner-most\n              dimension of <code>input</code> is replaced with the <code>fft_length</code> samples of its inverse\n              1D Fourier transform.\n              \n              @compatibility(numpy)\n              Equivalent to np.fft.irfft\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.IRFFT*
  exceptions: []
- uid: TensorFlow.TFGraph.IRFFT2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: IRFFT2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IRFFT2D(TFOutput, TFOutput, String)
  nameWithType: TFGraph.IRFFT2D(TFOutput, TFOutput, String)
  fullName: TFGraph.IRFFT2D(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Inverse 2D real-valued fast Fourier transform.
  remarks: "Computes the inverse 2-dimensional discrete Fourier transform of a real-valued\n              signal over the inner-most 2 dimensions of <code>input</code>.\n              \n              The inner-most 2 dimensions of <code>input</code> are assumed to be the result of <code>RFFT2D</code>:\n              The inner-most dimension contains the <code>fft_length / 2 + 1</code> unique components of\n              the DFT of a real-valued signal. If <code>fft_length</code> is not provided, it is computed\n              from the size of the inner-most 2 dimensions of <code>input</code>. If the FFT length used\n              to compute <code>input</code> is odd, it should be provided since it cannot be inferred\n              properly.\n              \n              Along each axis <code>IRFFT2D</code> is computed on, if <code>fft_length</code> (or\n              <code>fft_length / 2 + 1</code> for the inner-most dimension) is smaller than the\n              corresponding dimension of <code>input</code>, the dimension is cropped. If it is larger,\n              the dimension is padded with zeros."
  syntax:
    content: public TensorFlow.TFOutput IRFFT2D (TensorFlow.TFOutput input, TensorFlow.TFOutput fft_length, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A complex64 tensor.
    - id: fft_length
      type: TensorFlow.TFOutput
      description: An int32 tensor of shape [2]. The FFT length for each dimension.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IRFFT2D'.
    return:
      type: TensorFlow.TFOutput
      description: "A float32 tensor of the same rank as <code>input</code>. The inner-most 2\n              dimensions of <code>input</code> are replaced with the <code>fft_length</code> samples of their\n              inverse 2D Fourier transform.\n              \n              @compatibility(numpy)\n              Equivalent to np.fft.irfft2\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.IRFFT2D*
  exceptions: []
- uid: TensorFlow.TFGraph.IRFFT3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: IRFFT3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IRFFT3D(TFOutput, TFOutput, String)
  nameWithType: TFGraph.IRFFT3D(TFOutput, TFOutput, String)
  fullName: TFGraph.IRFFT3D(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Inverse 3D real-valued fast Fourier transform.
  remarks: "Computes the inverse 3-dimensional discrete Fourier transform of a real-valued\n              signal over the inner-most 3 dimensions of <code>input</code>.\n              \n              The inner-most 3 dimensions of <code>input</code> are assumed to be the result of <code>RFFT3D</code>:\n              The inner-most dimension contains the <code>fft_length / 2 + 1</code> unique components of\n              the DFT of a real-valued signal. If <code>fft_length</code> is not provided, it is computed\n              from the size of the inner-most 3 dimensions of <code>input</code>. If the FFT length used\n              to compute <code>input</code> is odd, it should be provided since it cannot be inferred\n              properly.\n              \n              Along each axis <code>IRFFT3D</code> is computed on, if <code>fft_length</code> (or\n              <code>fft_length / 2 + 1</code> for the inner-most dimension) is smaller than the\n              corresponding dimension of <code>input</code>, the dimension is cropped. If it is larger,\n              the dimension is padded with zeros."
  syntax:
    content: public TensorFlow.TFOutput IRFFT3D (TensorFlow.TFOutput input, TensorFlow.TFOutput fft_length, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A complex64 tensor.
    - id: fft_length
      type: TensorFlow.TFOutput
      description: An int32 tensor of shape [3]. The FFT length for each dimension.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IRFFT3D'.
    return:
      type: TensorFlow.TFOutput
      description: "A float32 tensor of the same rank as <code>input</code>. The inner-most 3\n              dimensions of <code>input</code> are replaced with the <code>fft_length</code> samples of their\n              inverse 3D real Fourier transform.\n              \n              @compatibility(numpy)\n              Equivalent to np.irfftn with 3 dimensions.\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.IRFFT3D*
  exceptions: []
- uid: TensorFlow.TFGraph.IsBoostedTreesEnsembleInitialized(TensorFlow.TFOutput,System.String)
  id: IsBoostedTreesEnsembleInitialized(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IsBoostedTreesEnsembleInitialized(TFOutput, String)
  nameWithType: TFGraph.IsBoostedTreesEnsembleInitialized(TFOutput, String)
  fullName: TFGraph.IsBoostedTreesEnsembleInitialized(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Checks whether a tree ensemble has been initialized.
  syntax:
    content: public TensorFlow.TFOutput IsBoostedTreesEnsembleInitialized (TensorFlow.TFOutput tree_ensemble_handle, string operName = null);
    parameters:
    - id: tree_ensemble_handle
      type: TensorFlow.TFOutput
      description: Handle to the tree ensemble resouce.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IsBoostedTreesEnsembleInitialized'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        output boolean on whether it is initialized or not.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IsBoostedTreesEnsembleInitialized*
  exceptions: []
- uid: TensorFlow.TFGraph.IsBoostedTreesQuantileStreamResourceInitialized(TensorFlow.TFOutput,System.String)
  id: IsBoostedTreesQuantileStreamResourceInitialized(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IsBoostedTreesQuantileStreamResourceInitialized(TFOutput, String)
  nameWithType: TFGraph.IsBoostedTreesQuantileStreamResourceInitialized(TFOutput, String)
  fullName: TFGraph.IsBoostedTreesQuantileStreamResourceInitialized(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Checks whether a quantile stream has been initialized.
  remarks: An Op that checks if quantile stream resource is initialized.
  syntax:
    content: public TensorFlow.TFOutput IsBoostedTreesQuantileStreamResourceInitialized (TensorFlow.TFOutput quantile_stream_resource_handle, string operName = null);
    parameters:
    - id: quantile_stream_resource_handle
      type: TensorFlow.TFOutput
      description: resource; The reference to quantile stream resource handle.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IsBoostedTreesQuantileStreamResourceInitialized'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        bool; True if the resource is initialized, False otherwise.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IsBoostedTreesQuantileStreamResourceInitialized*
  exceptions: []
- uid: TensorFlow.TFGraph.IsFinite(TensorFlow.TFOutput,System.String)
  id: IsFinite(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IsFinite(TFOutput, String)
  nameWithType: TFGraph.IsFinite(TFOutput, String)
  fullName: TFGraph.IsFinite(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns which elements of x are finite.
  remarks: >-
    @compatibility(numpy)
                  Equivalent to np.isfinite
                  @end_compatibility
  syntax:
    content: public TensorFlow.TFOutput IsFinite (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IsFinite'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IsFinite*
  exceptions: []
- uid: TensorFlow.TFGraph.IsInf(TensorFlow.TFOutput,System.String)
  id: IsInf(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IsInf(TFOutput, String)
  nameWithType: TFGraph.IsInf(TFOutput, String)
  fullName: TFGraph.IsInf(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns which elements of x are Inf.
  remarks: >-
    @compatibility(numpy)
                  Equivalent to np.isinf
                  @end_compatibility
  syntax:
    content: public TensorFlow.TFOutput IsInf (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IsInf'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IsInf*
  exceptions: []
- uid: TensorFlow.TFGraph.IsNan(TensorFlow.TFOutput,System.String)
  id: IsNan(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IsNan(TFOutput, String)
  nameWithType: TFGraph.IsNan(TFOutput, String)
  fullName: TFGraph.IsNan(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns which elements of x are NaN.
  remarks: >-
    @compatibility(numpy)
                  Equivalent to np.isnan
                  @end_compatibility
  syntax:
    content: public TensorFlow.TFOutput IsNan (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IsNan'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IsNan*
  exceptions: []
- uid: TensorFlow.TFGraph.IsVariableInitialized(TensorFlow.TFOutput,System.String)
  id: IsVariableInitialized(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IsVariableInitialized(TFOutput, String)
  nameWithType: TFGraph.IsVariableInitialized(TFOutput, String)
  fullName: TFGraph.IsVariableInitialized(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Checks whether a tensor has been initialized.
  remarks: Outputs boolean scalar indicating whether the tensor has been initialized.
  syntax:
    content: public TensorFlow.TFOutput IsVariableInitialized (TensorFlow.TFOutput reference, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node. May be uninitialized.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IsVariableInitialized'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IsVariableInitialized*
  exceptions: []
- uid: TensorFlow.TFGraph.Item(System.String)
  id: Item(System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Item(String)
  nameWithType: TFGraph.Item(String)
  fullName: TFGraph.Item(String)
  type: Property
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gets the <xref href="TensorFlow.TFGraph"></xref> with the specified name, or null if the named operation does not exist in the graph.
  syntax:
    content: public TensorFlow.TFOperation this[string name] { get; }
    parameters:
    - id: name
      type: System.String
      description: Name to lookup.
    return:
      type: TensorFlow.TFOperation
      description: To be added.
  overload: TensorFlow.TFGraph.Item*
  exceptions: []
- uid: TensorFlow.TFGraph.Iterator(System.String,System.String,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: Iterator(System.String,System.String,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Iterator(String, String, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.Iterator(String, String, TFDataType[], TFShape[], String)
  fullName: TFGraph.Iterator(String, String, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A container for an iterator resource.
  syntax:
    content: public TensorFlow.TFOutput Iterator (string shared_name, string container, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: shared_name
      type: System.String
      description: To be added.
    - id: container
      type: System.String
      description: To be added.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Iterator'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A handle to the iterator that can be passed to a "MakeIterator"
                      or "IteratorGetNext" op.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Iterator*
  exceptions: []
- uid: TensorFlow.TFGraph.IteratorFromStringHandle(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: IteratorFromStringHandle(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.IteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.IteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts the given string representing a handle to an iterator to a resource.
  syntax:
    content: public TensorFlow.TFOutput IteratorFromStringHandle (TensorFlow.TFOutput string_handle, TensorFlow.TFDataType[] output_types = null, TensorFlow.TFShape[] output_shapes = null, string operName = null);
    parameters:
    - id: string_handle
      type: TensorFlow.TFOutput
      description: A string representation of the given handle.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: >-
        Optional argument
                      If specified, defines the type of each tuple component in an
                      element produced by the resulting iterator.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: >-
        Optional argument
                      If specified, defines the shape of each tuple component in an
                      element produced by the resulting iterator.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorFromStringHandle'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A handle to an iterator resource.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IteratorFromStringHandle*
  exceptions: []
- uid: TensorFlow.TFGraph.IteratorGetNext(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: IteratorGetNext(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IteratorGetNext(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.IteratorGetNext(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.IteratorGetNext(TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gets the next output from the given iterator .
  syntax:
    content: public TensorFlow.TFOutput[] IteratorGetNext (TensorFlow.TFOutput iterator, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: iterator
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorGetNext'.
    return:
      type: TensorFlow.TFOutput[]
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IteratorGetNext*
  exceptions: []
- uid: TensorFlow.TFGraph.IteratorGetNextAsOptional(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: IteratorGetNextAsOptional(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IteratorGetNextAsOptional(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.IteratorGetNextAsOptional(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.IteratorGetNextAsOptional(TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gets the next output from the given iterator as an Optional variant.
  syntax:
    content: public TensorFlow.TFOutput IteratorGetNextAsOptional (TensorFlow.TFOutput iterator, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: iterator
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorGetNextAsOptional'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IteratorGetNextAsOptional*
  exceptions: []
- uid: TensorFlow.TFGraph.IteratorGetNextSync(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: IteratorGetNextSync(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IteratorGetNextSync(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.IteratorGetNextSync(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.IteratorGetNextSync(TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gets the next output from the given iterator.
  remarks: >-
    This operation is a synchronous version IteratorGetNext. It should only be used
                  in situations where the iterator does not block the calling thread, or where
                  the calling thread is not a member of the thread pool used to execute parallel
                  operations (e.g. in eager mode).
  syntax:
    content: public TensorFlow.TFOutput[] IteratorGetNextSync (TensorFlow.TFOutput iterator, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: iterator
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorGetNextSync'.
    return:
      type: TensorFlow.TFOutput[]
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IteratorGetNextSync*
  exceptions: []
- uid: TensorFlow.TFGraph.IteratorToStringHandle(TensorFlow.TFOutput,System.String)
  id: IteratorToStringHandle(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: IteratorToStringHandle(TFOutput, String)
  nameWithType: TFGraph.IteratorToStringHandle(TFOutput, String)
  fullName: TFGraph.IteratorToStringHandle(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts the given <code>resource_handle</code> representing an iterator to a string.
  syntax:
    content: public TensorFlow.TFOutput IteratorToStringHandle (TensorFlow.TFOutput resource_handle, string operName = null);
    parameters:
    - id: resource_handle
      type: TensorFlow.TFOutput
      description: A handle to an iterator resource.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'IteratorToStringHandle'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A string representation of the given handle.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.IteratorToStringHandle*
  exceptions: []
- uid: TensorFlow.TFGraph.L2Loss(TensorFlow.TFOutput,System.String)
  id: L2Loss(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: L2Loss(TFOutput, String)
  nameWithType: TFGraph.L2Loss(TFOutput, String)
  fullName: TFGraph.L2Loss(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: L2 Loss.
  remarks: "Computes half the L2 norm of a tensor without the <code>sqrt</code>:\n              \n              output = sum(t ** 2) / 2"
  syntax:
    content: public TensorFlow.TFOutput L2Loss (TensorFlow.TFOutput t, string operName = null);
    parameters:
    - id: t
      type: TensorFlow.TFOutput
      description: Typically 2-D, but may have any dimensions.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'L2Loss'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        0-D.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.L2Loss*
  exceptions: []
- uid: TensorFlow.TFGraph.LearnedUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: LearnedUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LearnedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.LearnedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.LearnedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generates labels for candidate sampling with a learned unigram distribution.
  remarks: "See explanations of candidate sampling and the data formats at\n              go/candidate-sampling.\n              \n              For each batch, this op picks a single set of sampled candidate labels.\n              \n              The advantages of sampling candidates per-batch are simplicity and the\n              possibility of efficient dense matrix multiplication. The disadvantage is that\n              the sampled candidates must be chosen independently of the context and of the\n              true labels."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> LearnedUnigramCandidateSampler (TensorFlow.TFOutput true_classes, long num_true, long num_sampled, bool unique, long range_max, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: true_classes
      type: TensorFlow.TFOutput
      description: >-
        A batch_size * num_true matrix, in which each row contains the
                      IDs of the num_true target_classes in the corresponding original label.
    - id: num_true
      type: System.Int64
      description: Number of true labels per context.
    - id: num_sampled
      type: System.Int64
      description: Number of candidates to randomly sample.
    - id: unique
      type: System.Boolean
      description: >-
        If unique is true, we sample with rejection, so that all sampled
                      candidates in a batch are unique. This requires some approximation to
                      estimate the post-rejection sampling probabilities.
    - id: range_max
      type: System.Int64
      description: The sampler will sample integers from the interval [0, range_max).
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either seed or seed2 are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      An second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LearnedUnigramCandidateSampler'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sampled_candidates: A vector of length num_sampled, in which each element is
                      the ID of a sampled candidate.
                      true_expected_count: A batch_size * num_true matrix, representing
                      the number of times each candidate is expected to occur in a batch
                      of sampled candidates. If unique=true, then this is a probability.
                      sampled_expected_count: A vector of length num_sampled, for each sampled
                      candidate representing the number of times the candidate is expected
                      to occur in a batch of sampled candidates.  If unique=true, then this is a
                      probability.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.LearnedUnigramCandidateSampler*
  exceptions: []
- uid: TensorFlow.TFGraph.LeftShift(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: LeftShift(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LeftShift(TFOutput, TFOutput, String)
  nameWithType: TFGraph.LeftShift(TFOutput, TFOutput, String)
  fullName: TFGraph.LeftShift(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Elementwise computes the bitwise left-shift of <code>x</code> and <code>y</code>.
  remarks: >-
    If <code>y</code> is negative, or greater than or equal to the width of <code>x</code> in bits the
                  result is implementation defined.
  syntax:
    content: public TensorFlow.TFOutput LeftShift (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LeftShift'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LeftShift*
  exceptions: []
- uid: TensorFlow.TFGraph.Less(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Less(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Less(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Less(TFOutput, TFOutput, String)
  fullName: TFGraph.Less(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the truth value of (x &lt; y) element-wise.
  remarks: >-
    *NOTE*: <code>Less</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput Less (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Less'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Less*
  exceptions: []
- uid: TensorFlow.TFGraph.LessEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: LessEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LessEqual(TFOutput, TFOutput, String)
  nameWithType: TFGraph.LessEqual(TFOutput, TFOutput, String)
  fullName: TFGraph.LessEqual(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the truth value of (x &lt;= y) element-wise.
  remarks: >-
    *NOTE*: <code>LessEqual</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput LessEqual (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LessEqual'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LessEqual*
  exceptions: []
- uid: TensorFlow.TFGraph.Lgamma(TensorFlow.TFOutput,System.String)
  id: Lgamma(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Lgamma(TFOutput, String)
  nameWithType: TFGraph.Lgamma(TFOutput, String)
  fullName: TFGraph.Lgamma(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the log of the absolute value of <code>Gamma(x)</code> element-wise.
  syntax:
    content: public TensorFlow.TFOutput Lgamma (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Lgamma'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Lgamma*
  exceptions: []
- uid: TensorFlow.TFGraph.LinSpace(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: LinSpace(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LinSpace(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LinSpace(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LinSpace(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generates values in an interval.
  remarks: "A sequence of <code>num</code> evenly-spaced values are generated beginning at <code>start</code>.\n              If <code>num &gt; 1</code>, the values in the sequence increase by <code>stop - start / num - 1</code>,\n              so that the last one is exactly <code>stop</code>.\n              \n              For example:\n              \n               <pre><code>\n              tf.linspace(10.0, 12.0, 3, name=\"linspace\") =&gt; [ 10.0  11.0  12.0]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput LinSpace (TensorFlow.TFOutput start, TensorFlow.TFOutput stop, TensorFlow.TFOutput num, string operName = null);
    parameters:
    - id: start
      type: TensorFlow.TFOutput
      description: 0-D tensor. First entry in the range.
    - id: stop
      type: TensorFlow.TFOutput
      description: 0-D tensor. Last entry in the range.
    - id: num
      type: TensorFlow.TFOutput
      description: 0-D tensor. Number of values to generate.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LinSpace'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        1-D. The generated values.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LinSpace*
  exceptions: []
- uid: TensorFlow.TFGraph.ListDiff(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: ListDiff(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ListDiff(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.ListDiff(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.ListDiff(TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the difference between two lists of numbers or strings.
  remarks: "Given a list <code>x</code> and a list <code>y</code>, this operation returns a list <code>out</code> that\n              represents all values that are in <code>x</code> but not in <code>y</code>. The returned list <code>out</code>\n              is sorted in the same order that the numbers appear in <code>x</code> (duplicates are\n              preserved). This operation also returns a list <code>idx</code> that represents the\n              position of each <code>out</code> element in <code>x</code>. In other words:\n              \n              <code>out[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]</code>\n              \n              For example, given this input:\n              \n               <pre><code>\n              x = [1, 2, 3, 4, 5, 6]\n              y = [1, 3, 5]\n               </code></pre>\n              \n              This operation would return:\n              \n               <pre><code>\n              out ==&gt; [2, 4, 6]\n              idx ==&gt; [1, 3, 5]\n               </code></pre>"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> ListDiff (TensorFlow.TFOutput x, TensorFlow.TFOutput y, Nullable<TensorFlow.TFDataType> out_idx = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: 1-D. Values to keep.
    - id: y
      type: TensorFlow.TFOutput
      description: 1-D. Values to remove.
    - id: out_idx
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ListDiff'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output: 1-D. Values present in <code>x</code> but not in <code>y</code>.
                      idx: 1-D. Positions of <code>x</code> values preserved in <code>out</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.ListDiff*
  exceptions: []
- uid: TensorFlow.TFGraph.LMDBReader(System.String,System.String,System.String)
  id: LMDBReader(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LMDBReader(String, String, String)
  nameWithType: TFGraph.LMDBReader(String, String, String)
  fullName: TFGraph.LMDBReader(String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A Reader that outputs the records from a LMDB file.
  syntax:
    content: public TensorFlow.TFOutput LMDBReader (string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LMDBReader'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to reference the Reader.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LMDBReader*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadAndRemapMatrix(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String)
  id: LoadAndRemapMatrix(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadAndRemapMatrix(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String)
  nameWithType: TFGraph.LoadAndRemapMatrix(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String)
  fullName: TFGraph.LoadAndRemapMatrix(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Loads a 2-D (matrix) <code>Tensor</code> with name <code>old_tensor_name</code> from the checkpoint
  remarks: "at <code>ckpt_path</code> and potentially reorders its rows and columns using the\n              specified remappings.\n              \n              Most users should use one of the wrapper initializers (such as\n              <code>tf.contrib.framework.load_and_remap_matrix_initializer</code>) instead of this\n              function directly.\n              \n              The remappings are 1-D tensors with the following properties:\n              \n              * <code>row_remapping</code> must have exactly <code>num_rows</code> entries. Row <code>i</code> of the output\n              matrix will be initialized from the row corresponding to index\n              <code>row_remapping[i]</code> in the old <code>Tensor</code> from the checkpoint.\n              * <code>col_remapping</code> must have either 0 entries (indicating that no column\n              reordering is needed) or <code>num_cols</code> entries. If specified, column <code>j</code> of the\n              output matrix will be initialized from the column corresponding to index\n              <code>col_remapping[j]</code> in the old <code>Tensor</code> from the checkpoint.\n              * A value of -1 in either of the remappings signifies a \"missing\" entry. In that\n              case, values from the <code>initializing_values</code> tensor will be used to fill that\n              missing row or column. If <code>row_remapping</code> has <code>r</code> missing entries and\n              <code>col_remapping</code> has <code>c</code> missing entries, then the following condition must be\n              true:\n              \n              <code>(r * num_cols) + (c * num_rows) - (r * c) == len(initializing_values)</code>\n              \n              The remapping tensors can be generated using the GenerateVocabRemapping op.\n              \n              As an example, with row_remapping = [1, 0, -1], col_remapping = [0, 2, -1],\n              initializing_values = [0.5, -0.5, 0.25, -0.25, 42], and w(i, j) representing\n              the value from row i, column j of the old tensor in the checkpoint, the output\n              matrix will look like the following:\n              \n              [[w(1, 0),  w(1, 2),  0.5],\n              [w(0, 0),  w(0, 2), -0.5],\n              [0.25,    -0.25,      42]]"
  syntax:
    content: public TensorFlow.TFOutput LoadAndRemapMatrix (TensorFlow.TFOutput ckpt_path, TensorFlow.TFOutput old_tensor_name, TensorFlow.TFOutput row_remapping, TensorFlow.TFOutput col_remapping, TensorFlow.TFOutput initializing_values, long num_rows, long num_cols, Nullable<long> max_rows_in_memory = null, string operName = null);
    parameters:
    - id: ckpt_path
      type: TensorFlow.TFOutput
      description: >-
        Path to the TensorFlow checkpoint (version 2, <code>TensorBundle</code>) from
                      which the old matrix <code>Tensor</code> will be loaded.
    - id: old_tensor_name
      type: TensorFlow.TFOutput
      description: Name of the 2-D <code>Tensor</code> to load from checkpoint.
    - id: row_remapping
      type: TensorFlow.TFOutput
      description: >-
        An int <code>Tensor</code> of row remappings (generally created by
                      <code>generate_vocab_remapping</code>).  Even if no row remapping is needed, this must
                      still be an index-valued Tensor (e.g. [0, 1, 2, ...]), or a shifted
                      index-valued <code>Tensor</code> (e.g. [8, 9, 10, ...], for partitioned <code>Variables</code>).
    - id: col_remapping
      type: TensorFlow.TFOutput
      description: >-
        An int <code>Tensor</code> of column remappings (generally created by
                      <code>generate_vocab_remapping</code>).  May be a size-0 <code>Tensor</code> if only row remapping
                      is to be done (e.g. column ordering is the same).
    - id: initializing_values
      type: TensorFlow.TFOutput
      description: >-
        A float <code>Tensor</code> containing  values to fill in for cells
                      in the output matrix that are not loaded from the checkpoint. Length must be
                      exactly the same as the number of missing / new cells.
    - id: num_rows
      type: System.Int64
      description: Number of rows (length of the 1st dimension) in the output matrix.
    - id: num_cols
      type: System.Int64
      description: Number of columns (length of the 2nd dimension) in the output matrix.
    - id: max_rows_in_memory
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The maximum number of rows to load from the checkpoint at
                      once. If less than or equal to 0, the entire matrix will be loaded into
                      memory. Setting this arg trades increased disk reads for lower memory usage.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadAndRemapMatrix'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Output matrix containing existing values loaded from the
                      checkpoint, and with any missing values filled in from initializing_values.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LoadAndRemapMatrix*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingAdadeltaParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingAdadeltaParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingAdadeltaParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingAdadeltaParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the Adadelta optimization algorithm.\n              accumulators: A tensor containing the initial embedding table accumulators to use in embedding\n              lookups using the Adadelta optimization algorithm.\n              updates: A tensor containing the initial embedding table updates to use in embedding\n              lookups using the Adadelta optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingAdadeltaParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput updates, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the Adadelta optimization algorithm.
    - id: accumulators
      type: TensorFlow.TFOutput
      description: Value of accumulators used in the Adadelta optimization algorithm.
    - id: updates
      type: TensorFlow.TFOutput
      description: Value of updates used in the Adadelta optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingAdadeltaParameters'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingAdadeltaParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingAdadeltaParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the Adadelta optimization algorithm.\n              accumulators: A tensor containing the initial embedding table accumulators to use in embedding\n              lookups using the Adadelta optimization algorithm.\n              updates: A tensor containing the initial embedding table updates to use in embedding\n              lookups using the Adadelta optimization algorithm.\n              gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding\n              lookups using the Adadelta optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingAdadeltaParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput updates, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the Adadelta optimization algorithm.
    - id: accumulators
      type: TensorFlow.TFOutput
      description: Value of accumulators used in the Adadelta optimization algorithm.
    - id: updates
      type: TensorFlow.TFOutput
      description: Value of updates used in the Adadelta optimization algorithm.
    - id: gradient_accumulators
      type: TensorFlow.TFOutput
      description: Value of gradient_accumulators used in the Adadelta optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingAdadeltaParametersGradAccumDebug'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingAdagradParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the Adagrad optimization algorithm.\n              accumulators: A tensor containing the initial embedding table accumulators to use in embedding\n              lookups using the Adagrad optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingAdagradParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the Adagrad optimization algorithm.
    - id: accumulators
      type: TensorFlow.TFOutput
      description: Value of accumulators used in the Adagrad optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingAdagradParameters'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingAdagradParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the Adagrad optimization algorithm.\n              accumulators: A tensor containing the initial embedding table accumulators to use in embedding\n              lookups using the Adagrad optimization algorithm.\n              gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding\n              lookups using the Adagrad optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingAdagradParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the Adagrad optimization algorithm.
    - id: accumulators
      type: TensorFlow.TFOutput
      description: Value of accumulators used in the Adagrad optimization algorithm.
    - id: gradient_accumulators
      type: TensorFlow.TFOutput
      description: Value of gradient_accumulators used in the Adagrad optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingAdagradParametersGradAccumDebug'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingADAMParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingADAMParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingADAMParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingADAMParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingADAMParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the ADAM optimization algorithm.\n              momenta: A tensor containing the initial embedding table momenta to use in embedding\n              lookups using the ADAM optimization algorithm.\n              velocities: A tensor containing the initial embedding table velocities to use in embedding\n              lookups using the ADAM optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingADAMParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput momenta, TensorFlow.TFOutput velocities, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the ADAM optimization algorithm.
    - id: momenta
      type: TensorFlow.TFOutput
      description: Value of momenta used in the ADAM optimization algorithm.
    - id: velocities
      type: TensorFlow.TFOutput
      description: Value of velocities used in the ADAM optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingADAMParameters'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingADAMParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingADAMParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingADAMParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingADAMParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingADAMParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingADAMParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the ADAM optimization algorithm.\n              momenta: A tensor containing the initial embedding table momenta to use in embedding\n              lookups using the ADAM optimization algorithm.\n              velocities: A tensor containing the initial embedding table velocities to use in embedding\n              lookups using the ADAM optimization algorithm.\n              gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding\n              lookups using the ADAM optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingADAMParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput momenta, TensorFlow.TFOutput velocities, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the ADAM optimization algorithm.
    - id: momenta
      type: TensorFlow.TFOutput
      description: Value of momenta used in the ADAM optimization algorithm.
    - id: velocities
      type: TensorFlow.TFOutput
      description: Value of velocities used in the ADAM optimization algorithm.
    - id: gradient_accumulators
      type: TensorFlow.TFOutput
      description: Value of gradient_accumulators used in the ADAM optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingADAMParametersGradAccumDebug'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingADAMParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingCenteredRMSPropParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingCenteredRMSPropParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingCenteredRMSPropParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingCenteredRMSPropParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingCenteredRMSPropParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the centered RMSProp optimization algorithm.\n              ms: A tensor containing the initial embedding table ms to use in embedding\n              lookups using the centered RMSProp optimization algorithm.\n              mom: A tensor containing the initial embedding table mom to use in embedding\n              lookups using the centered RMSProp optimization algorithm.\n              mg: A tensor containing the initial embedding table mg to use in embedding\n              lookups using the centered RMSProp optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingCenteredRMSPropParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput mg, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the centered RMSProp optimization algorithm.
    - id: ms
      type: TensorFlow.TFOutput
      description: Value of ms used in the centered RMSProp optimization algorithm.
    - id: mom
      type: TensorFlow.TFOutput
      description: Value of mom used in the centered RMSProp optimization algorithm.
    - id: mg
      type: TensorFlow.TFOutput
      description: Value of mg used in the centered RMSProp optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingCenteredRMSPropParameters'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingCenteredRMSPropParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingFTRLParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingFTRLParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingFTRLParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingFTRLParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the FTRL optimization algorithm.\n              accumulators: A tensor containing the initial embedding table accumulators to use in embedding\n              lookups using the FTRL optimization algorithm.\n              linears: A tensor containing the initial embedding table linears to use in embedding\n              lookups using the FTRL optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingFTRLParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput linears, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the FTRL optimization algorithm.
    - id: accumulators
      type: TensorFlow.TFOutput
      description: Value of accumulators used in the FTRL optimization algorithm.
    - id: linears
      type: TensorFlow.TFOutput
      description: Value of linears used in the FTRL optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingFTRLParameters'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingFTRLParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingFTRLParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingFTRLParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingFTRLParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the FTRL optimization algorithm.\n              accumulators: A tensor containing the initial embedding table accumulators to use in embedding\n              lookups using the FTRL optimization algorithm.\n              linears: A tensor containing the initial embedding table linears to use in embedding\n              lookups using the FTRL optimization algorithm.\n              gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding\n              lookups using the FTRL optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingFTRLParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput linears, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the FTRL optimization algorithm.
    - id: accumulators
      type: TensorFlow.TFOutput
      description: Value of accumulators used in the FTRL optimization algorithm.
    - id: linears
      type: TensorFlow.TFOutput
      description: Value of linears used in the FTRL optimization algorithm.
    - id: gradient_accumulators
      type: TensorFlow.TFOutput
      description: Value of gradient_accumulators used in the FTRL optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingFTRLParametersGradAccumDebug'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingMDLAdagradLightParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingMDLAdagradLightParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingMDLAdagradLightParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingMDLAdagradLightParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingMDLAdagradLightParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the MDL Adagrad Light optimization algorithm.\n              accumulators: A tensor containing the initial embedding table accumulators to use in embedding\n              lookups using the MDL Adagrad Light optimization algorithm.\n              weights: A tensor containing the initial embedding table weights to use in embedding\n              lookups using the MDL Adagrad Light optimization algorithm.\n              benefits: A tensor containing the initial embedding table benefits to use in embedding\n              lookups using the MDL Adagrad Light optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingMDLAdagradLightParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput weights, TensorFlow.TFOutput benefits, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the MDL Adagrad Light optimization algorithm.
    - id: accumulators
      type: TensorFlow.TFOutput
      description: Value of accumulators used in the MDL Adagrad Light optimization algorithm.
    - id: weights
      type: TensorFlow.TFOutput
      description: Value of weights used in the MDL Adagrad Light optimization algorithm.
    - id: benefits
      type: TensorFlow.TFOutput
      description: Value of benefits used in the MDL Adagrad Light optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingMDLAdagradLightParameters'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingMDLAdagradLightParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingMomentumParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingMomentumParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingMomentumParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingMomentumParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the Momentum optimization algorithm.\n              momenta: A tensor containing the initial embedding table momenta to use in embedding\n              lookups using the Momentum optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingMomentumParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput momenta, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the Momentum optimization algorithm.
    - id: momenta
      type: TensorFlow.TFOutput
      description: Value of momenta used in the Momentum optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingMomentumParameters'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingMomentumParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingMomentumParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingMomentumParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingMomentumParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the Momentum optimization algorithm.\n              momenta: A tensor containing the initial embedding table momenta to use in embedding\n              lookups using the Momentum optimization algorithm.\n              gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding\n              lookups using the Momentum optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingMomentumParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput momenta, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the Momentum optimization algorithm.
    - id: momenta
      type: TensorFlow.TFOutput
      description: Value of momenta used in the Momentum optimization algorithm.
    - id: gradient_accumulators
      type: TensorFlow.TFOutput
      description: Value of gradient_accumulators used in the Momentum optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingMomentumParametersGradAccumDebug'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingProximalAdagradParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingProximalAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingProximalAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingProximalAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the proximal Adagrad optimization algorithm.\n              accumulators: A tensor containing the initial embedding table accumulators to use in embedding\n              lookups using the proximal Adagrad optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingProximalAdagradParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the proximal Adagrad optimization algorithm.
    - id: accumulators
      type: TensorFlow.TFOutput
      description: Value of accumulators used in the proximal Adagrad optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingProximalAdagradParameters'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the proximal Adagrad optimization algorithm.\n              accumulators: A tensor containing the initial embedding table accumulators to use in embedding\n              lookups using the proximal Adagrad optimization algorithm.\n              gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding\n              lookups using the proximal Adagrad optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the proximal Adagrad optimization algorithm.
    - id: accumulators
      type: TensorFlow.TFOutput
      description: Value of accumulators used in the proximal Adagrad optimization algorithm.
    - id: gradient_accumulators
      type: TensorFlow.TFOutput
      description: Value of gradient_accumulators used in the proximal Adagrad optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingRMSPropParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingRMSPropParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingRMSPropParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingRMSPropParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the RMSProp optimization algorithm.\n              ms: A tensor containing the initial embedding table ms to use in embedding\n              lookups using the RMSProp optimization algorithm.\n              mom: A tensor containing the initial embedding table mom to use in embedding\n              lookups using the RMSProp optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingRMSPropParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the RMSProp optimization algorithm.
    - id: ms
      type: TensorFlow.TFOutput
      description: Value of ms used in the RMSProp optimization algorithm.
    - id: mom
      type: TensorFlow.TFOutput
      description: Value of mom used in the RMSProp optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingRMSPropParameters'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingRMSPropParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingRMSPropParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingRMSPropParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingRMSPropParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the RMSProp optimization algorithm.\n              ms: A tensor containing the initial embedding table ms to use in embedding\n              lookups using the RMSProp optimization algorithm.\n              mom: A tensor containing the initial embedding table mom to use in embedding\n              lookups using the RMSProp optimization algorithm.\n              gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding\n              lookups using the RMSProp optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingRMSPropParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the RMSProp optimization algorithm.
    - id: ms
      type: TensorFlow.TFOutput
      description: Value of ms used in the RMSProp optimization algorithm.
    - id: mom
      type: TensorFlow.TFOutput
      description: Value of mom used in the RMSProp optimization algorithm.
    - id: gradient_accumulators
      type: TensorFlow.TFOutput
      description: Value of gradient_accumulators used in the RMSProp optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingRMSPropParametersGradAccumDebug'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingStochasticGradientDescentParameters(TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: LoadTPUEmbeddingStochasticGradientDescentParameters(TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoadTPUEmbeddingStochasticGradientDescentParameters(TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingStochasticGradientDescentParameters(TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingStochasticGradientDescentParameters(TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Load embedding parameters for a single table.
  remarks: "An op that loads optimization parameters into HBM for embedding. Must be\n              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct\n              embedding table configuration. For example, this op is used to install\n              parameters that are loaded from a checkpoint before a training loop is\n              executed.\n              \n              parameters: A tensor containing the initial embedding table parameters to use in embedding\n              lookups using the stochastic gradient descent optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOperation LoadTPUEmbeddingStochasticGradientDescentParameters (TensorFlow.TFOutput parameters, long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: parameters
      type: TensorFlow.TFOutput
      description: Value of parameters used in the stochastic gradient descent optimization algorithm.
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoadTPUEmbeddingStochasticGradientDescentParameters'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LoadTPUEmbeddingStochasticGradientDescentParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.Log(TensorFlow.TFOutput,System.String)
  id: Log(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Log(TFOutput, String)
  nameWithType: TFGraph.Log(TFOutput, String)
  fullName: TFGraph.Log(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes natural logarithm of x element-wise.
  remarks: I.e., \\(y = \log_e x\\).
  syntax:
    content: public TensorFlow.TFOutput Log (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Log'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Log*
  exceptions: []
- uid: TensorFlow.TFGraph.Log1p(TensorFlow.TFOutput,System.String)
  id: Log1p(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Log1p(TFOutput, String)
  nameWithType: TFGraph.Log1p(TFOutput, String)
  fullName: TFGraph.Log1p(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes natural logarithm of (1 + x) element-wise.
  remarks: I.e., \\(y = \log_e (1 + x)\\).
  syntax:
    content: public TensorFlow.TFOutput Log1p (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Log1p'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Log1p*
  exceptions: []
- uid: TensorFlow.TFGraph.LogicalAnd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: LogicalAnd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LogicalAnd(TFOutput, TFOutput, String)
  nameWithType: TFGraph.LogicalAnd(TFOutput, TFOutput, String)
  fullName: TFGraph.LogicalAnd(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the truth value of x AND y element-wise.
  remarks: >-
    *NOTE*: <code>LogicalAnd</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput LogicalAnd (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LogicalAnd'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LogicalAnd*
  exceptions: []
- uid: TensorFlow.TFGraph.LogicalNot(TensorFlow.TFOutput,System.String)
  id: LogicalNot(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LogicalNot(TFOutput, String)
  nameWithType: TFGraph.LogicalNot(TFOutput, String)
  fullName: TFGraph.LogicalNot(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the truth value of NOT x element-wise.
  syntax:
    content: public TensorFlow.TFOutput LogicalNot (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LogicalNot'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LogicalNot*
  exceptions: []
- uid: TensorFlow.TFGraph.LogicalOr(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: LogicalOr(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LogicalOr(TFOutput, TFOutput, String)
  nameWithType: TFGraph.LogicalOr(TFOutput, TFOutput, String)
  fullName: TFGraph.LogicalOr(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the truth value of x OR y element-wise.
  remarks: >-
    *NOTE*: <code>LogicalOr</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput LogicalOr (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LogicalOr'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LogicalOr*
  exceptions: []
- uid: TensorFlow.TFGraph.LogMatrixDeterminant(TensorFlow.TFOutput,System.String)
  id: LogMatrixDeterminant(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LogMatrixDeterminant(TFOutput, String)
  nameWithType: TFGraph.LogMatrixDeterminant(TFOutput, String)
  fullName: TFGraph.LogMatrixDeterminant(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the sign and the log of the absolute value of the determinant of
  remarks: "one or more square matrices.\n              \n              The input is a tensor of shape <code>[N, M, M]</code> whose inner-most 2 dimensions\n              form square matrices. The outputs are two tensors containing the signs and\n              absolute values of the log determinants for all N input submatrices\n              <code>[..., :, :]</code> such that the determinant = sign*exp(log_abs_determinant).\n              The log_abs_determinant is computed as det(P)*sum(log(diag(LU))) where LU\n              is the LU decomposition of the input and P is the corresponding\n              permutation matrix."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> LogMatrixDeterminant (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Shape is <code>[N, M, M]</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LogMatrixDeterminant'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sign: The signs of the log determinants of the inputs. Shape is <code>[N]</code>.
                      log_abs_determinant: The logs of the absolute values of the determinants
                      of the N input matrices.  Shape is <code>[N]</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.LogMatrixDeterminant*
  exceptions: []
- uid: TensorFlow.TFGraph.LogSoftmax(TensorFlow.TFOutput,System.String)
  id: LogSoftmax(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LogSoftmax(TFOutput, String)
  nameWithType: TFGraph.LogSoftmax(TFOutput, String)
  fullName: TFGraph.LogSoftmax(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes log softmax activations.
  remarks: "For each batch <code>i</code> and class <code>j</code> we have\n              \n              logsoftmax[i, j] = logits[i, j] - log(sum(exp(logits[i])))"
  syntax:
    content: public TensorFlow.TFOutput LogSoftmax (TensorFlow.TFOutput logits, string operName = null);
    parameters:
    - id: logits
      type: TensorFlow.TFOutput
      description: 2-D with shape <code>[batch_size, num_classes]</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LogSoftmax'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same shape as <code>logits</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LogSoftmax*
  exceptions: []
- uid: TensorFlow.TFGraph.LogUniformCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: LogUniformCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LogUniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.LogUniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.LogUniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generates labels for candidate sampling with a log-uniform distribution.
  remarks: "See explanations of candidate sampling and the data formats at\n              go/candidate-sampling.\n              \n              For each batch, this op picks a single set of sampled candidate labels.\n              \n              The advantages of sampling candidates per-batch are simplicity and the\n              possibility of efficient dense matrix multiplication. The disadvantage is that\n              the sampled candidates must be chosen independently of the context and of the\n              true labels."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> LogUniformCandidateSampler (TensorFlow.TFOutput true_classes, long num_true, long num_sampled, bool unique, long range_max, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: true_classes
      type: TensorFlow.TFOutput
      description: >-
        A batch_size * num_true matrix, in which each row contains the
                      IDs of the num_true target_classes in the corresponding original label.
    - id: num_true
      type: System.Int64
      description: Number of true labels per context.
    - id: num_sampled
      type: System.Int64
      description: Number of candidates to randomly sample.
    - id: unique
      type: System.Boolean
      description: >-
        If unique is true, we sample with rejection, so that all sampled
                      candidates in a batch are unique. This requires some approximation to
                      estimate the post-rejection sampling probabilities.
    - id: range_max
      type: System.Int64
      description: The sampler will sample integers from the interval [0, range_max).
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either seed or seed2 are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      An second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LogUniformCandidateSampler'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sampled_candidates: A vector of length num_sampled, in which each element is
                      the ID of a sampled candidate.
                      true_expected_count: A batch_size * num_true matrix, representing
                      the number of times each candidate is expected to occur in a batch
                      of sampled candidates. If unique=true, then this is a probability.
                      sampled_expected_count: A vector of length num_sampled, for each sampled
                      candidate representing the number of times the candidate is expected
                      to occur in a batch of sampled candidates.  If unique=true, then this is a
                      probability.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.LogUniformCandidateSampler*
  exceptions: []
- uid: TensorFlow.TFGraph.LookupTableExport(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)
  id: LookupTableExport(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LookupTableExport(TFOutput, TFDataType, TFDataType, String)
  nameWithType: TFGraph.LookupTableExport(TFOutput, TFDataType, TFDataType, String)
  fullName: TFGraph.LookupTableExport(TFOutput, TFDataType, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs all keys and values in the table.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> LookupTableExport (TensorFlow.TFOutput table_handle, TensorFlow.TFDataType Tkeys, TensorFlow.TFDataType Tvalues, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to the table.
    - id: Tkeys
      type: TensorFlow.TFDataType
      description: To be added.
    - id: Tvalues
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableExport'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      keys: Vector of all keys present in the table.
                      values: Tensor of all values in the table. Indexed in parallel with <code>keys</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.LookupTableExport*
  exceptions: []
- uid: TensorFlow.TFGraph.LookupTableExportV2(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)
  id: LookupTableExportV2(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LookupTableExportV2(TFOutput, TFDataType, TFDataType, String)
  nameWithType: TFGraph.LookupTableExportV2(TFOutput, TFDataType, TFDataType, String)
  fullName: TFGraph.LookupTableExportV2(TFOutput, TFDataType, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs all keys and values in the table.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> LookupTableExportV2 (TensorFlow.TFOutput table_handle, TensorFlow.TFDataType Tkeys, TensorFlow.TFDataType Tvalues, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to the table.
    - id: Tkeys
      type: TensorFlow.TFDataType
      description: To be added.
    - id: Tvalues
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableExportV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      keys: Vector of all keys present in the table.
                      values: Tensor of all values in the table. Indexed in parallel with <code>keys</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.LookupTableExportV2*
  exceptions: []
- uid: TensorFlow.TFGraph.LookupTableFind(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: LookupTableFind(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LookupTableFind(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LookupTableFind(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LookupTableFind(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Looks up keys in a table, outputs the corresponding values.
  remarks: "The tensor <code>keys</code> must of the same type as the keys of the table.\n              The output <code>values</code> is of the type of the table values.\n              \n              The scalar <code>default_value</code> is the value output for keys not present in the\n              table. It must also be of the same type as the table values."
  syntax:
    content: public TensorFlow.TFOutput LookupTableFind (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput default_value, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to the table.
    - id: keys
      type: TensorFlow.TFOutput
      description: Any shape.  Keys to look up.
    - id: default_value
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableFind'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same shape as <code>keys</code>.  Values found in the table, or <code>default_values</code>
                      for missing keys.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LookupTableFind*
  exceptions: []
- uid: TensorFlow.TFGraph.LookupTableFindV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: LookupTableFindV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LookupTableFindV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LookupTableFindV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LookupTableFindV2(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Looks up keys in a table, outputs the corresponding values.
  remarks: "The tensor <code>keys</code> must of the same type as the keys of the table.\n              The output <code>values</code> is of the type of the table values.\n              \n              The scalar <code>default_value</code> is the value output for keys not present in the\n              table. It must also be of the same type as the table values."
  syntax:
    content: public TensorFlow.TFOutput LookupTableFindV2 (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput default_value, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to the table.
    - id: keys
      type: TensorFlow.TFOutput
      description: Any shape.  Keys to look up.
    - id: default_value
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableFindV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same shape as <code>keys</code>.  Values found in the table, or <code>default_values</code>
                      for missing keys.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LookupTableFindV2*
  exceptions: []
- uid: TensorFlow.TFGraph.LookupTableImport(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: LookupTableImport(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LookupTableImport(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LookupTableImport(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LookupTableImport(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Replaces the contents of the table with the specified keys and values.
  remarks: >-
    The tensor <code>keys</code> must be of the same type as the keys of the table.
                  The tensor <code>values</code> must be of the type of the table values.
  syntax:
    content: public TensorFlow.TFOperation LookupTableImport (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to the table.
    - id: keys
      type: TensorFlow.TFOutput
      description: Any shape.  Keys to look up.
    - id: values
      type: TensorFlow.TFOutput
      description: Values to associate with keys.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableImport'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LookupTableImport*
  exceptions: []
- uid: TensorFlow.TFGraph.LookupTableImportV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: LookupTableImportV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LookupTableImportV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LookupTableImportV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LookupTableImportV2(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Replaces the contents of the table with the specified keys and values.
  remarks: >-
    The tensor <code>keys</code> must be of the same type as the keys of the table.
                  The tensor <code>values</code> must be of the type of the table values.
  syntax:
    content: public TensorFlow.TFOperation LookupTableImportV2 (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to the table.
    - id: keys
      type: TensorFlow.TFOutput
      description: Any shape.  Keys to look up.
    - id: values
      type: TensorFlow.TFOutput
      description: Values to associate with keys.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableImportV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LookupTableImportV2*
  exceptions: []
- uid: TensorFlow.TFGraph.LookupTableInsert(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: LookupTableInsert(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LookupTableInsert(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LookupTableInsert(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LookupTableInsert(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Updates the table to associates keys with values.
  remarks: >-
    The tensor <code>keys</code> must be of the same type as the keys of the table.
                  The tensor <code>values</code> must be of the type of the table values.
  syntax:
    content: public TensorFlow.TFOperation LookupTableInsert (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to the table.
    - id: keys
      type: TensorFlow.TFOutput
      description: Any shape.  Keys to look up.
    - id: values
      type: TensorFlow.TFOutput
      description: Values to associate with keys.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableInsert'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LookupTableInsert*
  exceptions: []
- uid: TensorFlow.TFGraph.LookupTableInsertV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: LookupTableInsertV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LookupTableInsertV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LookupTableInsertV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LookupTableInsertV2(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Updates the table to associates keys with values.
  remarks: >-
    The tensor <code>keys</code> must be of the same type as the keys of the table.
                  The tensor <code>values</code> must be of the type of the table values.
  syntax:
    content: public TensorFlow.TFOperation LookupTableInsertV2 (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to the table.
    - id: keys
      type: TensorFlow.TFOutput
      description: Any shape.  Keys to look up.
    - id: values
      type: TensorFlow.TFOutput
      description: Values to associate with keys.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableInsertV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.LookupTableInsertV2*
  exceptions: []
- uid: TensorFlow.TFGraph.LookupTableSize(TensorFlow.TFOutput,System.String)
  id: LookupTableSize(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LookupTableSize(TFOutput, String)
  nameWithType: TFGraph.LookupTableSize(TFOutput, String)
  fullName: TFGraph.LookupTableSize(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the number of elements in the given table.
  syntax:
    content: public TensorFlow.TFOutput LookupTableSize (TensorFlow.TFOutput table_handle, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to the table.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableSize'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Scalar that contains number of elements in the table.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LookupTableSize*
  exceptions: []
- uid: TensorFlow.TFGraph.LookupTableSizeV2(TensorFlow.TFOutput,System.String)
  id: LookupTableSizeV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LookupTableSizeV2(TFOutput, String)
  nameWithType: TFGraph.LookupTableSizeV2(TFOutput, String)
  fullName: TFGraph.LookupTableSizeV2(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the number of elements in the given table.
  syntax:
    content: public TensorFlow.TFOutput LookupTableSizeV2 (TensorFlow.TFOutput table_handle, string operName = null);
    parameters:
    - id: table_handle
      type: TensorFlow.TFOutput
      description: Handle to the table.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LookupTableSizeV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Scalar that contains number of elements in the table.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LookupTableSizeV2*
  exceptions: []
- uid: TensorFlow.TFGraph.LoopCond(TensorFlow.TFOutput,System.String)
  id: LoopCond(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LoopCond(TFOutput, String)
  nameWithType: TFGraph.LoopCond(TFOutput, String)
  fullName: TFGraph.LoopCond(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Forwards the input to the output.
  remarks: >-
    This operator represents the loop termination condition used by the
                  "pivot" switches of a loop.
  syntax:
    content: public TensorFlow.TFOutput LoopCond (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A boolean scalar, representing the branch predicate of the Switch op.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LoopCond'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The same tensor as <code>input</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LoopCond*
  exceptions: []
- uid: TensorFlow.TFGraph.LowerBound(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: LowerBound(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LowerBound(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.LowerBound(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.LowerBound(TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies lower_bound(sorted_search_values, values) along each row.
  remarks: "Each set of rows with the same index in (sorted_inputs, values) is treated\n              independently.  The resulting row is the equivalent of calling\n              <code>np.searchsorted(sorted_inputs, values, side='left')</code>.\n              \n              The result is not a global index to the entire\n              <code>Tensor</code>, but rather just the index in the last dimension.\n              \n              A 2-D example:\n              sorted_sequence = [[0, 3, 9, 9, 10],\n              [1, 2, 3, 4, 5]]\n              values = [[2, 4, 9],\n              [0, 2, 6]]\n              \n              result = LowerBound(sorted_sequence, values)\n              \n              result == [[1, 2, 2],\n              [0, 1, 5]]"
  syntax:
    content: public TensorFlow.TFOutput LowerBound (TensorFlow.TFOutput sorted_inputs, TensorFlow.TFOutput values, Nullable<TensorFlow.TFDataType> out_type = null, string operName = null);
    parameters:
    - id: sorted_inputs
      type: TensorFlow.TFOutput
      description: 2-D Tensor where each row is ordered.
    - id: values
      type: TensorFlow.TFOutput
      description: >-
        2-D Tensor with the same numbers of rows as <code>sorted_search_values</code>. Contains
                      the values that will be searched for in <code>sorted_search_values</code>.
    - id: out_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LowerBound'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A <code>Tensor</code> with the same shape as <code>values</code>.  It contains the first scalar index
                      into the last dimension where values can be inserted without changing the
                      ordered property.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LowerBound*
  exceptions: []
- uid: TensorFlow.TFGraph.LRN(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  id: LRN(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LRN(TFOutput, Nullable<Int64>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  nameWithType: TFGraph.LRN(TFOutput, Nullable<Int64>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  fullName: TFGraph.LRN(TFOutput, Nullable<Int64>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Local Response Normalization.
  remarks: "The 4-D <code>input</code> tensor is treated as a 3-D array of 1-D vectors (along the last\n              dimension), and each vector is normalized independently.  Within a given vector,\n              each component is divided by the weighted, squared sum of inputs within\n              <code>depth_radius</code>.  In detail,\n              \n              sqr_sum[a, b, c, d] =\n              sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)\n              output = input / (bias + alpha * sqr_sum) ** beta\n              \n              For details, see [Krizhevsky et al., ImageNet classification with deep\n              convolutional neural networks (NIPS 2012)](http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks)."
  syntax:
    content: public TensorFlow.TFOutput LRN (TensorFlow.TFOutput input, Nullable<long> depth_radius = null, Nullable<float> bias = null, Nullable<float> alpha = null, Nullable<float> beta = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 4-D.
    - id: depth_radius
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      0-D.  Half-width of the 1-D normalization window.
    - id: bias
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      An offset (usually positive to avoid dividing by 0).
    - id: alpha
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      A scale factor, usually positive.
    - id: beta
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      An exponent.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LRN'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LRN*
  exceptions: []
- uid: TensorFlow.TFGraph.LRNGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  id: LRNGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: LRNGrad(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  nameWithType: TFGraph.LRNGrad(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  fullName: TFGraph.LRNGrad(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gradients for Local Response Normalization.
  syntax:
    content: public TensorFlow.TFOutput LRNGrad (TensorFlow.TFOutput input_grads, TensorFlow.TFOutput input_image, TensorFlow.TFOutput output_image, Nullable<long> depth_radius = null, Nullable<float> bias = null, Nullable<float> alpha = null, Nullable<float> beta = null, string operName = null);
    parameters:
    - id: input_grads
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: input_image
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: output_image
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: depth_radius
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A depth radius.
    - id: bias
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      An offset (usually &gt; 0 to avoid dividing by 0).
    - id: alpha
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      A scale factor, usually positive.
    - id: beta
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      An exponent.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'LRNGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The gradients for LRN.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.LRNGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.MakeIterator(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: MakeIterator(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MakeIterator(TFOutput, TFOutput, String)
  nameWithType: TFGraph.MakeIterator(TFOutput, TFOutput, String)
  fullName: TFGraph.MakeIterator(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Makes a new iterator from the given <code>dataset</code> and stores it in <code>iterator</code>.
  remarks: >-
    This operation may be executed multiple times. Each execution will reset the
                  iterator in <code>iterator</code> to the first element of <code>dataset</code>.
  syntax:
    content: public TensorFlow.TFOperation MakeIterator (TensorFlow.TFOutput dataset, TensorFlow.TFOutput iterator, string operName = null);
    parameters:
    - id: dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: iterator
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MakeIterator'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.MakeIterator*
  exceptions: []
- uid: TensorFlow.TFGraph.MapClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: MapClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MapClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op removes all elements in the underlying container.
  syntax:
    content: public TensorFlow.TFOperation MapClear (TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MapClear'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.MapClear*
  exceptions: []
- uid: TensorFlow.TFGraph.MapIncompleteSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: MapIncompleteSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MapIncompleteSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapIncompleteSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapIncompleteSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op returns the number of incomplete elements in the underlying container.
  syntax:
    content: public TensorFlow.TFOutput MapIncompleteSize (TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MapIncompleteSize'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MapIncompleteSize*
  exceptions: []
- uid: TensorFlow.TFGraph.MapPeek(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: MapPeek(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MapPeek(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapPeek(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapPeek(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op peeks at the values at the specified key.  If the
  remarks: >-
    underlying container does not contain this key
                  this op will block until it does.
  syntax:
    content: public TensorFlow.TFOutput[] MapPeek (TensorFlow.TFOutput key, TensorFlow.TFOutput indices, TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: key
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MapPeek'.
    return:
      type: TensorFlow.TFOutput[]
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MapPeek*
  exceptions: []
- uid: TensorFlow.TFGraph.MapSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: MapSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MapSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op returns the number of elements in the underlying container.
  syntax:
    content: public TensorFlow.TFOutput MapSize (TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MapSize'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MapSize*
  exceptions: []
- uid: TensorFlow.TFGraph.MapStage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: MapStage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Stage (key, values) in the underlying container which behaves like a hashtable.
  syntax:
    content: public TensorFlow.TFOperation MapStage (TensorFlow.TFOutput key, TensorFlow.TFOutput indices, TensorFlow.TFOutput[] values, TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: key
      type: TensorFlow.TFOutput
      description: int64
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: values
      type: TensorFlow.TFOutput[]
      description: >-
        a list of tensors
                      dtypes A list of data types that inserted values should adhere to.
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Maximum number of elements in the Staging Area. If &gt; 0, inserts
                      on the container will block when the capacity is reached.
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue is placed in the given container. Otherwise,
                      a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      It is necessary to match this name to the matching Unstage Op.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MapStage'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.MapStage*
  exceptions: []
- uid: TensorFlow.TFGraph.MapUnstage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: MapUnstage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MapUnstage(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapUnstage(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapUnstage(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op removes and returns the values associated with the key
  remarks: >-
    from the underlying container.   If the underlying container
                  does not contain this key, the op will block until it does.
  syntax:
    content: public TensorFlow.TFOutput[] MapUnstage (TensorFlow.TFOutput key, TensorFlow.TFOutput indices, TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: key
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MapUnstage'.
    return:
      type: TensorFlow.TFOutput[]
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MapUnstage*
  exceptions: []
- uid: TensorFlow.TFGraph.MapUnstageNoKey(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: MapUnstageNoKey(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MapUnstageNoKey(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapUnstageNoKey(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapUnstageNoKey(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op removes and returns a random (key, value)
  remarks: >-
    from the underlying container.   If the underlying container
                  does not contain elements, the op will block until it does.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput[]> MapUnstageNoKey (TensorFlow.TFOutput indices, TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MapUnstageNoKey'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput[]}
      description: >-
        Returns a tuple with multiple values, as follows:
                      key:
                      values:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.MapUnstageNoKey*
  exceptions: []
- uid: TensorFlow.TFGraph.MatchingFiles(TensorFlow.TFOutput,System.String)
  id: MatchingFiles(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MatchingFiles(TFOutput, String)
  nameWithType: TFGraph.MatchingFiles(TFOutput, String)
  fullName: TFGraph.MatchingFiles(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the set of files matching one or more glob patterns.
  remarks: >-
    Note that this routine only supports wildcard characters in the
                  basename portion of the pattern, not in the directory portion.
                  Note also that the order of filenames returned can be non-deterministic.
  syntax:
    content: public TensorFlow.TFOutput MatchingFiles (TensorFlow.TFOutput pattern, string operName = null);
    parameters:
    - id: pattern
      type: TensorFlow.TFOutput
      description: Shell wildcard pattern(s). Scalar or vector of type string.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MatchingFiles'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A vector of matching filenames.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MatchingFiles*
  exceptions: []
- uid: TensorFlow.TFGraph.MatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: MatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.MatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.MatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Multiply the matrix "a" by the matrix "b".
  remarks: "The inputs must be two-dimensional matrices and the inner dimension of\n              \"a\" (after being transposed if transpose_a is true) must match the\n              outer dimension of \"b\" (after being transposed if transposed_b is\n              true).\n              \n              *Note*: The default kernel implementation for MatMul on GPUs uses\n              cublas."
  syntax:
    content: public TensorFlow.TFOutput MatMul (TensorFlow.TFOutput a, TensorFlow.TFOutput b, Nullable<bool> transpose_a = null, Nullable<bool> transpose_b = null, string operName = null);
    parameters:
    - id: a
      type: TensorFlow.TFOutput
      description: To be added.
    - id: b
      type: TensorFlow.TFOutput
      description: To be added.
    - id: transpose_a
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, "a" is transposed before multiplication.
    - id: transpose_b
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, "b" is transposed before multiplication.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MatMul'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MatMul*
  exceptions: []
- uid: TensorFlow.TFGraph.MatrixBandPart(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: MatrixBandPart(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MatrixBandPart(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.MatrixBandPart(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.MatrixBandPart(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Copy a tensor setting everything outside a central band in each innermost matrix
  remarks: "to zero.\n              \n              The <code>band</code> part is computed as follows:\n              Assume <code>input</code> has <code>k</code> dimensions <code>[I, J, K, ..., M, N]</code>, then the output is a\n              tensor with the same shape where\n              \n              <code>band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]</code>.\n              \n              The indicator function\n              \n              <code>in_band(m, n) = (num_lower &lt; 0 || (m-n) &lt;= num_lower)) &&\n              (num_upper &lt; 0 || (n-m) &lt;= num_upper)</code>.\n              \n              For example:\n              \n               <pre><code>\n              # if 'input' is [[ 0,  1,  2, 3]\n              [-1,  0,  1, 2]\n              [-2, -1,  0, 1]\n              [-3, -2, -1, 0]],\n              \n              tf.matrix_band_part(input, 1, -1) ==&gt; [[ 0,  1,  2, 3]\n              [-1,  0,  1, 2]\n              [ 0, -1,  0, 1]\n              [ 0,  0, -1, 0]],\n              \n              tf.matrix_band_part(input, 2, 1) ==&gt; [[ 0,  1,  0, 0]\n              [-1,  0,  1, 0]\n              [-2, -1,  0, 1]\n              [ 0, -2, -1, 0]]\n               </code></pre>\n              \n              Useful special cases:\n              \n               <pre><code>\n              tf.matrix_band_part(input, 0, -1) ==&gt; Upper triangular part.\n              tf.matrix_band_part(input, -1, 0) ==&gt; Lower triangular part.\n              tf.matrix_band_part(input, 0, 0) ==&gt; Diagonal.\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput MatrixBandPart (TensorFlow.TFOutput input, TensorFlow.TFOutput num_lower, TensorFlow.TFOutput num_upper, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Rank <code>k</code> tensor.
    - id: num_lower
      type: TensorFlow.TFOutput
      description: >-
        0-D tensor. Number of subdiagonals to keep. If negative, keep entire
                      lower triangle.
    - id: num_upper
      type: TensorFlow.TFOutput
      description: >-
        0-D tensor. Number of superdiagonals to keep. If negative, keep
                      entire upper triangle.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixBandPart'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Rank <code>k</code> tensor of the same shape as input. The extracted banded tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MatrixBandPart*
  exceptions: []
- uid: TensorFlow.TFGraph.MatrixDeterminant(TensorFlow.TFOutput,System.String)
  id: MatrixDeterminant(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MatrixDeterminant(TFOutput, String)
  nameWithType: TFGraph.MatrixDeterminant(TFOutput, String)
  fullName: TFGraph.MatrixDeterminant(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the determinant of one or more square matrices.
  remarks: >-
    The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
                  form square matrices. The output is a tensor containing the determinants
                  for all input submatrices <code>[..., :, :]</code>.
  syntax:
    content: public TensorFlow.TFOutput MatrixDeterminant (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Shape is <code>[..., M, M]</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDeterminant'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Shape is <code>[...]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MatrixDeterminant*
  exceptions: []
- uid: TensorFlow.TFGraph.MatrixDiag(TensorFlow.TFOutput,System.String)
  id: MatrixDiag(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MatrixDiag(TFOutput, String)
  nameWithType: TFGraph.MatrixDiag(TFOutput, String)
  fullName: TFGraph.MatrixDiag(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  syntax:
    content: public TensorFlow.TFOutput MatrixDiag (TensorFlow.TFOutput diagonal, string operName = null);
    parameters:
    - id: diagonal
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: To be added.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.MatrixDiag*
  exceptions: []
- uid: TensorFlow.TFGraph.MatrixDiagPart(TensorFlow.TFOutput,System.String)
  id: MatrixDiagPart(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MatrixDiagPart(TFOutput, String)
  nameWithType: TFGraph.MatrixDiagPart(TFOutput, String)
  fullName: TFGraph.MatrixDiagPart(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the batched diagonal part of a batched tensor.
  remarks: "This operation returns a tensor with the <code>diagonal</code> part\n              of the batched <code>input</code>. The <code>diagonal</code> part is computed as follows:\n              \n              Assume <code>input</code> has <code>k</code> dimensions <code>[I, J, K, ..., M, N]</code>, then the output is a\n              tensor of rank <code>k - 1</code> with dimensions <code>[I, J, K, ..., min(M, N)]</code> where:\n              \n              <code>diagonal[i, j, k, ..., n] = input[i, j, k, ..., n, n]</code>.\n              \n              The input must be at least a matrix.\n              \n              For example:\n              \n               <pre><code>\n              # 'input' is [[[1, 0, 0, 0]\n              [0, 2, 0, 0]\n              [0, 0, 3, 0]\n              [0, 0, 0, 4]],\n              [[5, 0, 0, 0]\n              [0, 6, 0, 0]\n              [0, 0, 7, 0]\n              [0, 0, 0, 8]]]\n              \n              and input.shape = (2, 4, 4)\n              \n              tf.matrix_diag_part(input) ==&gt; [[1, 2, 3, 4], [5, 6, 7, 8]]\n              \n              which has shape (2, 4)\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput MatrixDiagPart (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Rank <code>k</code> tensor where <code>k &gt;= 2</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixDiagPart'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The extracted diagonal(s) having shape
                      <code>diagonal.shape = input.shape[:-2] + [min(input.shape[-2:])]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MatrixDiagPart*
  exceptions: []
- uid: TensorFlow.TFGraph.MatrixExponential(TensorFlow.TFOutput,System.String)
  id: MatrixExponential(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MatrixExponential(TFOutput, String)
  nameWithType: TFGraph.MatrixExponential(TFOutput, String)
  fullName: TFGraph.MatrixExponential(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated, use python implementation tf.linalg.matrix_exponential.
  syntax:
    content: public TensorFlow.TFOutput MatrixExponential (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixExponential'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MatrixExponential*
  exceptions: []
- uid: TensorFlow.TFGraph.MatrixInverse(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: MatrixInverse(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MatrixInverse(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.MatrixInverse(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.MatrixInverse(TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the inverse of one or more square invertible matrices or their
  remarks: "adjoints (conjugate transposes).\n              \n              The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions\n              form square matrices. The output is a tensor of the same shape as the input\n              containing the inverse for all input submatrices <code>[..., :, :]</code>.\n              \n              The op uses LU decomposition with partial pivoting to compute the inverses.\n              \n              If a matrix is not invertible there is no guarantee what the op does. It\n              may detect the condition and raise an exception or it may simply return a\n              garbage result."
  syntax:
    content: public TensorFlow.TFOutput MatrixInverse (TensorFlow.TFOutput input, Nullable<bool> adjoint = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Shape is <code>[..., M, M]</code>.
    - id: adjoint
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixInverse'.
    return:
      type: TensorFlow.TFOutput
      description: "Shape is <code>[..., M, M]</code>.\n              \n              @compatibility(numpy)\n              Equivalent to np.linalg.inv\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.MatrixInverse*
  exceptions: []
- uid: TensorFlow.TFGraph.MatrixLogarithm(TensorFlow.TFOutput,System.String)
  id: MatrixLogarithm(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MatrixLogarithm(TFOutput, String)
  nameWithType: TFGraph.MatrixLogarithm(TFOutput, String)
  fullName: TFGraph.MatrixLogarithm(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Computes the matrix logarithm of one or more square matrices:'
  remarks: "\\\\(log(exp(A)) = A\\\\)\n              \n              This op is only defined for complex matrices. If A is positive-definite and\n              real, then casting to a complex matrix, taking the logarithm and casting back\n              to a real matrix will give the correct result.\n              \n              This function computes the matrix logarithm using the Schur-Parlett algorithm.\n              Details of the algorithm can be found in Section 11.6.2 of:\n              Nicholas J. Higham, Functions of Matrices: Theory and Computation, SIAM 2008.\n              ISBN 978-0-898716-46-7.\n              \n              The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions\n              form square matrices. The output is a tensor of the same shape as the input\n              containing the exponential for all input submatrices <code>[..., :, :]</code>."
  syntax:
    content: public TensorFlow.TFOutput MatrixLogarithm (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Shape is <code>[..., M, M]</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixLogarithm'.
    return:
      type: TensorFlow.TFOutput
      description: "Shape is <code>[..., M, M]</code>.\n              \n              @compatibility(scipy)\n              Equivalent to scipy.linalg.logm\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.MatrixLogarithm*
  exceptions: []
- uid: TensorFlow.TFGraph.MatrixSetDiag(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: MatrixSetDiag(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MatrixSetDiag(TFOutput, TFOutput, String)
  nameWithType: TFGraph.MatrixSetDiag(TFOutput, TFOutput, String)
  fullName: TFGraph.MatrixSetDiag(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns a batched matrix tensor with new batched diagonal values.
  remarks: "Given <code>input</code> and <code>diagonal</code>, this operation returns a tensor with the\n              same shape and values as <code>input</code>, except for the main diagonal of the\n              innermost matrices.  These will be overwritten by the values in <code>diagonal</code>.\n              \n              The output is computed as follows:\n              \n              Assume <code>input</code> has <code>k+1</code> dimensions <code>[I, J, K, ..., M, N]</code> and <code>diagonal</code> has\n              <code>k</code> dimensions <code>[I, J, K, ..., min(M, N)]</code>.  Then the output is a\n              tensor of rank <code>k+1</code> with dimensions <code>[I, J, K, ..., M, N]</code> where:\n              \n              * <code>output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]</code> for <code>m == n</code>.\n              * <code>output[i, j, k, ..., m, n] = input[i, j, k, ..., m, n]</code> for <code>m != n</code>."
  syntax:
    content: public TensorFlow.TFOutput MatrixSetDiag (TensorFlow.TFOutput input, TensorFlow.TFOutput diagonal, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Rank <code>k+1</code>, where <code>k &gt;= 1</code>.
    - id: diagonal
      type: TensorFlow.TFOutput
      description: Rank <code>k</code>, where <code>k &gt;= 1</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSetDiag'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Rank <code>k+1</code>, with <code>output.shape = input.shape</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MatrixSetDiag*
  exceptions: []
- uid: TensorFlow.TFGraph.MatrixSolve(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: MatrixSolve(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MatrixSolve(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.MatrixSolve(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.MatrixSolve(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Solves systems of linear equations.
  remarks: >-
    <code>Matrix</code> is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
                  form square matrices. <code>Rhs</code> is a tensor of shape <code>[..., M, K]</code>. The <code>output</code> is
                  a tensor shape <code>[..., M, K]</code>.  If <code>adjoint</code> is <code>False</code> then each output matrix
                  satisfies <code>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]</code>.
                  If <code>adjoint</code> is <code>True</code> then each output matrix satisfies
                  <code>adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]</code>.
  syntax:
    content: public TensorFlow.TFOutput MatrixSolve (TensorFlow.TFOutput matrix, TensorFlow.TFOutput rhs, Nullable<bool> adjoint = null, string operName = null);
    parameters:
    - id: matrix
      type: TensorFlow.TFOutput
      description: Shape is <code>[..., M, M]</code>.
    - id: rhs
      type: TensorFlow.TFOutput
      description: Shape is <code>[..., M, K]</code>.
    - id: adjoint
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Boolean indicating whether to solve with <code>matrix</code> or its (block-wise)
                      adjoint.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSolve'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Shape is <code>[..., M, K]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MatrixSolve*
  exceptions: []
- uid: TensorFlow.TFGraph.MatrixSolveLs(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: MatrixSolveLs(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MatrixSolveLs(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.MatrixSolveLs(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.MatrixSolveLs(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Solves one or more linear least-squares problems.
  remarks: "<code>matrix</code> is a tensor of shape <code>[..., M, N]</code> whose inner-most 2 dimensions\n              form real or complex matrices of size <code>[M, N]</code>. <code>Rhs</code> is a tensor of the same\n              type as <code>matrix</code> and shape <code>[..., M, K]</code>.\n              The output is a tensor shape <code>[..., N, K]</code> where each output matrix solves\n              each of the equations\n              <code>matrix[..., :, :]</code> * <code>output[..., :, :]</code> = <code>rhs[..., :, :]</code>\n              in the least squares sense.\n              \n              We use the following notation for (complex) matrix and right-hand sides\n              in the batch:\n              \n              <code>matrix</code>=\\\\(A \\in \\mathbb{C}^{m \\times n}\\\\),\n              <code>rhs</code>=\\\\(B  \\in \\mathbb{C}^{m \\times k}\\\\),\n              <code>output</code>=\\\\(X  \\in \\mathbb{C}^{n \\times k}\\\\),\n              <code>l2_regularizer</code>=\\\\(\\lambda \\in \\mathbb{R}\\\\).\n              \n              If <code>fast</code> is <code>True</code>, then the solution is computed by solving the normal\n              equations using Cholesky decomposition. Specifically, if \\\\(m \\ge n\\\\) then\n              \\\\(X = (A^H A + \\lambda I)^{-1} A^H B\\\\), which solves the least-squares\n              problem \\\\(X = \\mathrm{argmin}_{Z \\in \\Re^{n \\times k} } ||A Z - B||_F^2 + \\lambda ||Z||_F^2\\\\).\n              If \\\\(m \\lt n\\\\) then <code>output</code> is computed as\n              \\\\(X = A^H (A A^H + \\lambda I)^{-1} B\\\\), which (for \\\\(\\lambda = 0\\\\)) is the\n              minimum-norm solution to the under-determined linear system, i.e.\n              \\\\(X = \\mathrm{argmin}_{Z \\in \\mathbb{C}^{n \\times k} } ||Z||_F^2 \\\\),\n              subject to \\\\(A Z = B\\\\). Notice that the fast path is only numerically stable\n              when \\\\(A\\\\) is numerically full rank and has a condition number\n              \\\\(\\mathrm{cond}(A) \\lt \\frac{1}{\\sqrt{\\epsilon_{mach} } }\\\\) or \\\\(\\lambda\\\\) is\n              sufficiently large.\n              \n              If <code>fast</code> is <code>False</code> an algorithm based on the numerically robust complete\n              orthogonal decomposition is used. This computes the minimum-norm\n              least-squares solution, even when \\\\(A\\\\) is rank deficient. This path is\n              typically 6-7 times slower than the fast path. If <code>fast</code> is <code>False</code> then\n              <code>l2_regularizer</code> is ignored."
  syntax:
    content: public TensorFlow.TFOutput MatrixSolveLs (TensorFlow.TFOutput matrix, TensorFlow.TFOutput rhs, TensorFlow.TFOutput l2_regularizer, Nullable<bool> fast = null, string operName = null);
    parameters:
    - id: matrix
      type: TensorFlow.TFOutput
      description: Shape is <code>[..., M, N]</code>.
    - id: rhs
      type: TensorFlow.TFOutput
      description: Shape is <code>[..., M, K]</code>.
    - id: l2_regularizer
      type: TensorFlow.TFOutput
      description: "Scalar tensor.\n              \n              @compatibility(numpy)\n              Equivalent to np.linalg.lstsq\n              @end_compatibility"
    - id: fast
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixSolveLs'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Shape is <code>[..., N, K]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MatrixSolveLs*
  exceptions: []
- uid: TensorFlow.TFGraph.MatrixTriangularSolve(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: MatrixTriangularSolve(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MatrixTriangularSolve(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.MatrixTriangularSolve(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.MatrixTriangularSolve(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Solves systems of linear equations with upper or lower triangular matrices by
  remarks: "backsubstitution.\n              \n              <code>matrix</code> is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions form\n              square matrices. If <code>lower</code> is <code>True</code> then the strictly upper triangular part\n              of each inner-most matrix is assumed to be zero and not accessed.\n              If <code>lower</code> is False then the strictly lower triangular part of each inner-most\n              matrix is assumed to be zero and not accessed.\n              <code>rhs</code> is a tensor of shape <code>[..., M, K]</code>.\n              \n              The output is a tensor of shape <code>[..., M, K]</code>. If <code>adjoint</code> is\n              <code>True</code> then the innermost matrices in <code>output</code> satisfy matrix equations\n              <code>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]</code>.\n              If <code>adjoint</code> is <code>False</code> then the strictly then the  innermost matrices in\n              <code>output</code> satisfy matrix equations\n              <code>adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]</code>."
  syntax:
    content: public TensorFlow.TFOutput MatrixTriangularSolve (TensorFlow.TFOutput matrix, TensorFlow.TFOutput rhs, Nullable<bool> lower = null, Nullable<bool> adjoint = null, string operName = null);
    parameters:
    - id: matrix
      type: TensorFlow.TFOutput
      description: Shape is <code>[..., M, M]</code>.
    - id: rhs
      type: TensorFlow.TFOutput
      description: Shape is <code>[..., M, K]</code>.
    - id: lower
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Boolean indicating whether the innermost matrices in <code>matrix</code> are
                      lower or upper triangular.
    - id: adjoint
      type: System.Nullable{System.Boolean}
      description: "Optional argument\n              Boolean indicating whether to solve with <code>matrix</code> or its (block-wise)\n              adjoint.\n              \n              @compatibility(numpy)\n              Equivalent to scipy.linalg.solve_triangular\n              @end_compatibility"
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MatrixTriangularSolve'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Shape is <code>[..., M, K]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MatrixTriangularSolve*
  exceptions: []
- uid: TensorFlow.TFGraph.Max(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: Max(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Max(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Max(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Max(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the maximum of elements across dimensions of a tensor.
  remarks: >-
    Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
                  <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
                  <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
                  retained with length 1.
  syntax:
    content: public TensorFlow.TFOutput Max (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable<bool> keep_dims = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The tensor to reduce.
    - id: reduction_indices
      type: TensorFlow.TFOutput
      description: >-
        The dimensions to reduce. Must be in the range
                      <code>[-rank(input), rank(input))</code>.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, retain reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Max'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The reduced tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Max*
  exceptions: []
- uid: TensorFlow.TFGraph.Maximum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Maximum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Maximum(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Maximum(TFOutput, TFOutput, String)
  fullName: TFGraph.Maximum(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Returns the max of x and y (i.e. x &gt; y ? x : y) element-wise.'
  remarks: >-
    *NOTE*: <code>Maximum</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput Maximum (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Maximum'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Maximum*
  exceptions: []
- uid: TensorFlow.TFGraph.MaxPool(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  id: MaxPool(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MaxPool(TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.MaxPool(TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.MaxPool(TFOutput, Int64[], Int64[], String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Performs max pooling on the input.
  syntax:
    content: public TensorFlow.TFOutput MaxPool (TensorFlow.TFOutput input, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 4-D input to pool over.
    - id: ksize
      type: System.Int64[]
      description: The size of the window for each dimension of the input tensor.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the
                      input tensor.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, in_channels, in_height, in_width].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The max pooled output tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MaxPool*
  exceptions: []
- uid: TensorFlow.TFGraph.MaxPool3D(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  id: MaxPool3D(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MaxPool3D(TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.MaxPool3D(TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.MaxPool3D(TFOutput, Int64[], Int64[], String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Performs 3D max pooling on the input.
  syntax:
    content: public TensorFlow.TFOutput MaxPool3D (TensorFlow.TFOutput input, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.
    - id: ksize
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The size of the window for each dimension of
                      the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The stride of the sliding window for each
                      dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      The data format of the input and output data. With the
                      default format "NDHWC", the data is stored in the order of:
                      [batch, in_depth, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCDHW", the data storage order is:
                      [batch, in_channels, in_depth, in_height, in_width].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool3D'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The max pooled output tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MaxPool3D*
  exceptions: []
- uid: TensorFlow.TFGraph.MaxPool3DGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  id: MaxPool3DGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MaxPool3DGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.MaxPool3DGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.MaxPool3DGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes gradients of max pooling function.
  syntax:
    content: public TensorFlow.TFOutput MaxPool3DGrad (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);
    parameters:
    - id: orig_input
      type: TensorFlow.TFOutput
      description: The original input tensor.
    - id: orig_output
      type: TensorFlow.TFOutput
      description: The original output tensor.
    - id: grad
      type: TensorFlow.TFOutput
      description: Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.
    - id: ksize
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The size of the window for each dimension of
                      the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The stride of the sliding window for each
                      dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      The data format of the input and output data. With the
                      default format "NDHWC", the data is stored in the order of:
                      [batch, in_depth, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCDHW", the data storage order is:
                      [batch, in_channels, in_depth, in_height, in_width].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool3DGrad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MaxPool3DGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.MaxPool3DGradGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  id: MaxPool3DGradGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MaxPool3DGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.MaxPool3DGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.MaxPool3DGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes second-order gradients of the maxpooling function.
  syntax:
    content: public TensorFlow.TFOutput MaxPool3DGradGrad (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);
    parameters:
    - id: orig_input
      type: TensorFlow.TFOutput
      description: The original input tensor.
    - id: orig_output
      type: TensorFlow.TFOutput
      description: The original output tensor.
    - id: grad
      type: TensorFlow.TFOutput
      description: Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.
    - id: ksize
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The size of the window for each dimension of
                      the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.
    - id: strides
      type: System.Int64[]
      description: >-
        1-D tensor of length 5. The stride of the sliding window for each
                      dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      The data format of the input and output data. With the
                      default format "NDHWC", the data is stored in the order of:
                      [batch, in_depth, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCDHW", the data storage order is:
                      [batch, in_channels, in_depth, in_height, in_width].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPool3DGradGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Gradients of gradients w.r.t. the input to <code>max_pool</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MaxPool3DGradGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.MaxPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  id: MaxPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MaxPoolGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.MaxPoolGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.MaxPoolGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes gradients of the maxpooling function.
  syntax:
    content: public TensorFlow.TFOutput MaxPoolGrad (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);
    parameters:
    - id: orig_input
      type: TensorFlow.TFOutput
      description: The original input tensor.
    - id: orig_output
      type: TensorFlow.TFOutput
      description: The original output tensor.
    - id: grad
      type: TensorFlow.TFOutput
      description: 4-D.  Gradients w.r.t. the output of <code>max_pool</code>.
    - id: ksize
      type: System.Int64[]
      description: The size of the window for each dimension of the input tensor.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the
                      input tensor.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, in_channels, in_height, in_width].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Gradients w.r.t. the input to <code>max_pool</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MaxPoolGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.MaxPoolGradGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  id: MaxPoolGradGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MaxPoolGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.MaxPoolGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.MaxPoolGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes second-order gradients of the maxpooling function.
  syntax:
    content: public TensorFlow.TFOutput MaxPoolGradGrad (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);
    parameters:
    - id: orig_input
      type: TensorFlow.TFOutput
      description: The original input tensor.
    - id: orig_output
      type: TensorFlow.TFOutput
      description: The original output tensor.
    - id: grad
      type: TensorFlow.TFOutput
      description: 4-D.  Gradients of gradients w.r.t. the input of <code>max_pool</code>.
    - id: ksize
      type: System.Int64[]
      description: The size of the window for each dimension of the input tensor.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the
                      input tensor.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, in_channels, in_height, in_width].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Gradients of gradients w.r.t. the input to <code>max_pool</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MaxPoolGradGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.MaxPoolGradGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  id: MaxPoolGradGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MaxPoolGradGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  nameWithType: TFGraph.MaxPoolGradGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  fullName: TFGraph.MaxPoolGradGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes second-order gradients of the maxpooling function.
  syntax:
    content: public TensorFlow.TFOutput MaxPoolGradGradV2 (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput grad, TensorFlow.TFOutput ksize, TensorFlow.TFOutput strides, string padding, string data_format = null, string operName = null);
    parameters:
    - id: orig_input
      type: TensorFlow.TFOutput
      description: The original input tensor.
    - id: orig_output
      type: TensorFlow.TFOutput
      description: The original output tensor.
    - id: grad
      type: TensorFlow.TFOutput
      description: 4-D.  Gradients of gradients w.r.t. the input of <code>max_pool</code>.
    - id: ksize
      type: TensorFlow.TFOutput
      description: The size of the window for each dimension of the input tensor.
    - id: strides
      type: TensorFlow.TFOutput
      description: >-
        The stride of the sliding window for each dimension of the
                      input tensor.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, in_channels, in_height, in_width].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradGradV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Gradients of gradients w.r.t. the input to <code>max_pool</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MaxPoolGradGradV2*
  exceptions: []
- uid: TensorFlow.TFGraph.MaxPoolGradGradWithArgmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  id: MaxPoolGradGradWithArgmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MaxPoolGradGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.MaxPoolGradGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.MaxPoolGradGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes second-order gradients of the maxpooling function.
  syntax:
    content: public TensorFlow.TFOutput MaxPoolGradGradWithArgmax (TensorFlow.TFOutput input, TensorFlow.TFOutput grad, TensorFlow.TFOutput argmax, long[] ksize, long[] strides, string padding, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The original input.
    - id: grad
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, height, width, channels]</code>.  Gradients w.r.t. the
                      input of <code>max_pool</code>.
    - id: argmax
      type: TensorFlow.TFOutput
      description: The indices of the maximum values chosen for each output of <code>max_pool</code>.
    - id: ksize
      type: System.Int64[]
      description: The size of the window for each dimension of the input tensor.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the
                      input tensor.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradGradWithArgmax'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Gradients of gradients w.r.t. the input of <code>max_pool</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MaxPoolGradGradWithArgmax*
  exceptions: []
- uid: TensorFlow.TFGraph.MaxPoolGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  id: MaxPoolGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MaxPoolGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  nameWithType: TFGraph.MaxPoolGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  fullName: TFGraph.MaxPoolGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes gradients of the maxpooling function.
  syntax:
    content: public TensorFlow.TFOutput MaxPoolGradV2 (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput grad, TensorFlow.TFOutput ksize, TensorFlow.TFOutput strides, string padding, string data_format = null, string operName = null);
    parameters:
    - id: orig_input
      type: TensorFlow.TFOutput
      description: The original input tensor.
    - id: orig_output
      type: TensorFlow.TFOutput
      description: The original output tensor.
    - id: grad
      type: TensorFlow.TFOutput
      description: 4-D.  Gradients w.r.t. the output of <code>max_pool</code>.
    - id: ksize
      type: TensorFlow.TFOutput
      description: The size of the window for each dimension of the input tensor.
    - id: strides
      type: TensorFlow.TFOutput
      description: >-
        The stride of the sliding window for each dimension of the
                      input tensor.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, in_channels, in_height, in_width].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Gradients w.r.t. the input to <code>max_pool</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MaxPoolGradV2*
  exceptions: []
- uid: TensorFlow.TFGraph.MaxPoolGradWithArgmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  id: MaxPoolGradWithArgmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MaxPoolGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.MaxPoolGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.MaxPoolGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes gradients of the maxpooling function.
  syntax:
    content: public TensorFlow.TFOutput MaxPoolGradWithArgmax (TensorFlow.TFOutput input, TensorFlow.TFOutput grad, TensorFlow.TFOutput argmax, long[] ksize, long[] strides, string padding, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The original input.
    - id: grad
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, height, width, channels]</code>.  Gradients w.r.t. the
                      output of <code>max_pool</code>.
    - id: argmax
      type: TensorFlow.TFOutput
      description: The indices of the maximum values chosen for each output of <code>max_pool</code>.
    - id: ksize
      type: System.Int64[]
      description: The size of the window for each dimension of the input tensor.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the
                      input tensor.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolGradWithArgmax'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Gradients w.r.t. the input of <code>max_pool</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MaxPoolGradWithArgmax*
  exceptions: []
- uid: TensorFlow.TFGraph.MaxPoolV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  id: MaxPoolV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MaxPoolV2(TFOutput, TFOutput, TFOutput, String, String, String)
  nameWithType: TFGraph.MaxPoolV2(TFOutput, TFOutput, TFOutput, String, String, String)
  fullName: TFGraph.MaxPoolV2(TFOutput, TFOutput, TFOutput, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Performs max pooling on the input.
  syntax:
    content: public TensorFlow.TFOutput MaxPoolV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput ksize, TensorFlow.TFOutput strides, string padding, string data_format = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 4-D input to pool over.
    - id: ksize
      type: TensorFlow.TFOutput
      description: The size of the window for each dimension of the input tensor.
    - id: strides
      type: TensorFlow.TFOutput
      description: >-
        The stride of the sliding window for each dimension of the
                      input tensor.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: data_format
      type: System.String
      description: >-
        Optional argument
                      Specify the data format of the input and output data. With the
                      default format "NHWC", the data is stored in the order of:
                      [batch, in_height, in_width, in_channels].
                      Alternatively, the format could be "NCHW", the data storage order of:
                      [batch, in_channels, in_height, in_width].
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The max pooled output tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MaxPoolV2*
  exceptions: []
- uid: TensorFlow.TFGraph.MaxPoolWithArgmax(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.Nullable{TensorFlow.TFDataType},System.String)
  id: MaxPoolWithArgmax(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MaxPoolWithArgmax(TFOutput, Int64[], Int64[], String, Nullable<TFDataType>, String)
  nameWithType: TFGraph.MaxPoolWithArgmax(TFOutput, Int64[], Int64[], String, Nullable<TFDataType>, String)
  fullName: TFGraph.MaxPoolWithArgmax(TFOutput, Int64[], Int64[], String, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Performs max pooling on the input and outputs both max values and indices.
  remarks: "The indices in <code>argmax</code> are flattened, so that a maximum value at position\n              <code>[b, y, x, c]</code> becomes flattened index\n              <code>((b * height + y) * width + x) * channels + c</code>.\n              \n              The indices returned are always in <code>[0, height) x [0, width)</code> before flattening,\n              even if padding is involved and the mathematically correct answer is outside\n              (either negative or too large).  This is a bug, but fixing it is difficult to do\n              in a safe backwards compatible way, especially due to flattening."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> MaxPoolWithArgmax (TensorFlow.TFOutput input, long[] ksize, long[] strides, string padding, Nullable<TensorFlow.TFDataType> Targmax = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.  Input to pool over.
    - id: ksize
      type: System.Int64[]
      description: The size of the window for each dimension of the input tensor.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the
                      input tensor.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: Targmax
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MaxPoolWithArgmax'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output: The max pooled output tensor.
                      argmax: 4-D.  The flattened indices of the max values chosen for each output.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.MaxPoolWithArgmax*
  exceptions: []
- uid: TensorFlow.TFGraph.Mean(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: Mean(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Mean(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Mean(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Mean(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the mean of elements across dimensions of a tensor.
  remarks: >-
    Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
                  <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
                  <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
                  retained with length 1.
  syntax:
    content: public TensorFlow.TFOutput Mean (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable<bool> keep_dims = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The tensor to reduce.
    - id: reduction_indices
      type: TensorFlow.TFOutput
      description: >-
        The dimensions to reduce. Must be in the range
                      <code>[-rank(input), rank(input))</code>.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, retain reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Mean'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The reduced tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Mean*
  exceptions: []
- uid: TensorFlow.TFGraph.Merge(TensorFlow.TFOutput[],System.String)
  id: Merge(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Merge(TFOutput[], String)
  nameWithType: TFGraph.Merge(TFOutput[], String)
  fullName: TFGraph.Merge(TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Forwards the value of an available tensor from <code>inputs</code> to <code>output</code>.
  remarks: "<code>Merge</code> waits for at least one of the tensors in <code>inputs</code> to become available.\n              It is usually combined with <code>Switch</code> to implement branching.\n              \n              <code>Merge</code> forwards the first tensor to become available to <code>output</code>, and sets\n              <code>value_index</code> to its index in <code>inputs</code>."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> Merge (TensorFlow.TFOutput[] inputs, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: The input tensors, exactly one of which will become available.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Merge'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output: Will be set to the available input tensor.
                      value_index: The index of the chosen input tensor in <code>inputs</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.Merge*
  exceptions: []
- uid: TensorFlow.TFGraph.MergeSummary(TensorFlow.TFOutput[],System.String)
  id: MergeSummary(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MergeSummary(TFOutput[], String)
  nameWithType: TFGraph.MergeSummary(TFOutput[], String)
  fullName: TFGraph.MergeSummary(TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Merges summaries.
  remarks: "This op creates a\n              [<code>Summary</code>](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)\n              protocol buffer that contains the union of all the values in the input\n              summaries.\n              \n              When the Op is run, it reports an <code>InvalidArgument</code> error if multiple values\n              in the summaries to merge use the same tag."
  syntax:
    content: public TensorFlow.TFOutput MergeSummary (TensorFlow.TFOutput[] inputs, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: >-
        Can be of any shape.  Each must contain serialized <code>Summary</code> protocol
                      buffers.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MergeSummary'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Scalar. Serialized <code>Summary</code> protocol buffer.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MergeSummary*
  exceptions: []
- uid: TensorFlow.TFGraph.MergeV2Checkpoints(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: MergeV2Checkpoints(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MergeV2Checkpoints(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.MergeV2Checkpoints(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.MergeV2Checkpoints(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'V2 format specific: merges the metadata files of sharded checkpoints.  The'
  remarks: "result is one logical checkpoint, with one physical metadata file and renamed\n              data files.\n              \n              Intended for \"grouping\" multiple checkpoints in a sharded checkpoint setup.\n              \n              If delete_old_dirs is true, attempts to delete recursively the dirname of each\n              path in the input checkpoint_prefixes.  This is useful when those paths are non\n              user-facing temporary locations."
  syntax:
    content: public TensorFlow.TFOperation MergeV2Checkpoints (TensorFlow.TFOutput checkpoint_prefixes, TensorFlow.TFOutput destination_prefix, Nullable<bool> delete_old_dirs = null, string operName = null);
    parameters:
    - id: checkpoint_prefixes
      type: TensorFlow.TFOutput
      description: prefixes of V2 checkpoints to merge.
    - id: destination_prefix
      type: TensorFlow.TFOutput
      description: >-
        scalar.  The desired final prefix.  Allowed to be the same
                      as one of the checkpoint_prefixes.
    - id: delete_old_dirs
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      see above.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MergeV2Checkpoints'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.MergeV2Checkpoints*
  exceptions: []
- uid: TensorFlow.TFGraph.Mfcc(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: Mfcc(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Mfcc(TFOutput, TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.Mfcc(TFOutput, TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.Mfcc(TFOutput, TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Transforms a spectrogram into a form that's useful for speech recognition.
  remarks: >-
    Mel Frequency Cepstral Coefficients are a way of representing audio data that's
                  been effective as an input feature for machine learning. They are created by
                  taking the spectrum of a spectrogram (a 'cepstrum'), and discarding some of the
                  higher frequencies that are less significant to the human ear. They have a long
                  history in the speech recognition world, and https://en.wikipedia.org/wiki/Mel-frequency_cepstrum
                  is a good resource to learn more.
  syntax:
    content: public TensorFlow.TFOutput Mfcc (TensorFlow.TFOutput spectrogram, TensorFlow.TFOutput sample_rate, Nullable<float> upper_frequency_limit = null, Nullable<float> lower_frequency_limit = null, Nullable<long> filterbank_channel_count = null, Nullable<long> dct_coefficient_count = null, string operName = null);
    parameters:
    - id: spectrogram
      type: TensorFlow.TFOutput
      description: >-
        Typically produced by the Spectrogram op, with magnitude_squared
                      set to true.
    - id: sample_rate
      type: TensorFlow.TFOutput
      description: How many samples per second the source audio used.
    - id: upper_frequency_limit
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      The highest frequency to use when calculating the
                      ceptstrum.
    - id: lower_frequency_limit
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      The lowest frequency to use when calculating the
                      ceptstrum.
    - id: filterbank_channel_count
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Resolution of the Mel bank used internally.
    - id: dct_coefficient_count
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      How many output channels to produce per time slice.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Mfcc'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Mfcc*
  exceptions: []
- uid: TensorFlow.TFGraph.Min(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: Min(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Min(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Min(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Min(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the minimum of elements across dimensions of a tensor.
  remarks: >-
    Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
                  <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
                  <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
                  retained with length 1.
  syntax:
    content: public TensorFlow.TFOutput Min (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable<bool> keep_dims = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The tensor to reduce.
    - id: reduction_indices
      type: TensorFlow.TFOutput
      description: >-
        The dimensions to reduce. Must be in the range
                      <code>[-rank(input), rank(input))</code>.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, retain reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Min'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The reduced tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Min*
  exceptions: []
- uid: TensorFlow.TFGraph.Minimum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Minimum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Minimum(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Minimum(TFOutput, TFOutput, String)
  fullName: TFGraph.Minimum(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Returns the min of x and y (i.e. x &lt; y ? x : y) element-wise.'
  remarks: >-
    *NOTE*: <code>Minimum</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput Minimum (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Minimum'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Minimum*
  exceptions: []
- uid: TensorFlow.TFGraph.MirrorPad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  id: MirrorPad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MirrorPad(TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.MirrorPad(TFOutput, TFOutput, String, String)
  fullName: TFGraph.MirrorPad(TFOutput, TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Pads a tensor with mirrored values.
  remarks: "This operation pads a <code>input</code> with mirrored values according to the <code>paddings</code>\n              you specify. <code>paddings</code> is an integer tensor with shape <code>[n, 2]</code>, where n is\n              the rank of <code>input</code>. For each dimension D of <code>input</code>, <code>paddings[D, 0]</code> indicates\n              how many values to add before the contents of <code>input</code> in that dimension, and\n              <code>paddings[D, 1]</code> indicates how many values to add after the contents of <code>input</code>\n              in that dimension. Both <code>paddings[D, 0]</code> and <code>paddings[D, 1]</code> must be no greater\n              than <code>input.dim_size(D)</code> (or <code>input.dim_size(D) - 1</code>) if <code>copy_border</code> is true\n              (if false, respectively).\n              \n              The padded size of each dimension D of the output is:\n              \n              <code>paddings(D, 0) + input.dim_size(D) + paddings(D, 1)</code>\n              \n              For example:\n              \n               <pre><code>\n              # 't' is [[1, 2, 3], [4, 5, 6]].\n              # 'paddings' is [[1, 1]], [2, 2]].\n              # 'mode' is SYMMETRIC.\n              # rank of 't' is 2.\n              pad(t, paddings) ==&gt; [[2, 1, 1, 2, 3, 3, 2]\n              [2, 1, 1, 2, 3, 3, 2]\n              [5, 4, 4, 5, 6, 6, 5]\n              [5, 4, 4, 5, 6, 6, 5]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput MirrorPad (TensorFlow.TFOutput input, TensorFlow.TFOutput paddings, string mode, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The input tensor to be padded.
    - id: paddings
      type: TensorFlow.TFOutput
      description: >-
        A two-column matrix specifying the padding sizes. The number of
                      rows must be the same as the rank of <code>input</code>.
    - id: mode
      type: System.String
      description: >-
        Either <code>REFLECT</code> or <code>SYMMETRIC</code>. In reflect mode the padded regions
                      do not include the borders, while in symmetric mode the padded regions
                      do include the borders. For example, if <code>input</code> is <code>[1, 2, 3]</code> and <code>paddings</code>
                      is <code>[0, 2]</code>, then the output is <code>[1, 2, 3, 2, 1]</code> in reflect mode, and
                      it is <code>[1, 2, 3, 3, 2]</code> in symmetric mode.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MirrorPad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The padded tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MirrorPad*
  exceptions: []
- uid: TensorFlow.TFGraph.MirrorPadGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  id: MirrorPadGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MirrorPadGrad(TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.MirrorPadGrad(TFOutput, TFOutput, String, String)
  fullName: TFGraph.MirrorPadGrad(TFOutput, TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gradient op for <code>MirrorPad</code> op. This op folds a mirror-padded tensor.
  remarks: "This operation folds the padded areas of <code>input</code> by <code>MirrorPad</code> according to the\n              <code>paddings</code> you specify. <code>paddings</code> must be the same as <code>paddings</code> argument\n              given to the corresponding <code>MirrorPad</code> op.\n              \n              The folded size of each dimension D of the output is:\n              \n              <code>input.dim_size(D) - paddings(D, 0) - paddings(D, 1)</code>\n              \n              For example:\n              \n               <pre><code>\n              # 't' is [[1, 2, 3], [4, 5, 6], [7, 8, 9]].\n              # 'paddings' is [[0, 1]], [0, 1]].\n              # 'mode' is SYMMETRIC.\n              # rank of 't' is 2.\n              pad(t, paddings) ==&gt; [[ 1,  5]\n              [11, 28]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput MirrorPadGrad (TensorFlow.TFOutput input, TensorFlow.TFOutput paddings, string mode, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The input tensor to be folded.
    - id: paddings
      type: TensorFlow.TFOutput
      description: >-
        A two-column matrix specifying the padding sizes. The number of
                      rows must be the same as the rank of <code>input</code>.
    - id: mode
      type: System.String
      description: The mode used in the <code>MirrorPad</code> op.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MirrorPadGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The folded tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MirrorPadGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.Mod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Mod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Mod(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Mod(TFOutput, TFOutput, String)
  fullName: TFGraph.Mod(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns element-wise remainder of division. This emulates C semantics in that
  remarks: "the result here is consistent with a truncating divide. E.g.\n              <code>tf.truncatediv(x, y) * y + truncate_mod(x, y) = x</code>.\n              \n              *NOTE*: <code>Mod</code> supports broadcasting. More about broadcasting\n              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)"
  syntax:
    content: public TensorFlow.TFOutput Mod (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Mod'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Mod*
  exceptions: []
- uid: TensorFlow.TFGraph.ModelDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: ModelDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ModelDataset(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ModelDataset(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.ModelDataset(TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Identity transformation that models performance.
  remarks: Identity transformation that models performance.
  syntax:
    content: public TensorFlow.TFOutput ModelDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: A variant tensor representing the input dataset.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ModelDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ModelDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.Mul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Mul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Mul(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Mul(TFOutput, TFOutput, String)
  fullName: TFGraph.Mul(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns x * y element-wise.
  remarks: >-
    *NOTE*: <code>Multiply</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput Mul (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Mul'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Mul*
  exceptions: []
- uid: TensorFlow.TFGraph.MultiDeviceIterator(System.String[],System.String,System.String,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: MultiDeviceIterator(System.String[],System.String,System.String,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MultiDeviceIterator(String[], String, String, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.MultiDeviceIterator(String[], String, String, TFDataType[], TFShape[], String)
  fullName: TFGraph.MultiDeviceIterator(String[], String, String, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a MultiDeviceIterator resource.
  syntax:
    content: public TensorFlow.TFOutput MultiDeviceIterator (string[] devices, string shared_name, string container, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: devices
      type: System.String[]
      description: A list of devices the iterator works across.
    - id: shared_name
      type: System.String
      description: >-
        If non-empty, this resource will be shared under the given name
                      across multiple sessions.
    - id: container
      type: System.String
      description: >-
        If non-empty, this resource is placed in the given container.
                      Otherwise, a default container is used.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: The type list for the return values.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: The list of shapes being produced.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIterator'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Handle to the resource created.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MultiDeviceIterator*
  exceptions: []
- uid: TensorFlow.TFGraph.MultiDeviceIteratorFromStringHandle(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: MultiDeviceIteratorFromStringHandle(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MultiDeviceIteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.MultiDeviceIteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.MultiDeviceIteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generates a MultiDeviceIterator resource from its provided string handle.
  syntax:
    content: public TensorFlow.TFOutput MultiDeviceIteratorFromStringHandle (TensorFlow.TFOutput string_handle, TensorFlow.TFDataType[] output_types = null, TensorFlow.TFShape[] output_shapes = null, string operName = null);
    parameters:
    - id: string_handle
      type: TensorFlow.TFOutput
      description: String representing the resource.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: >-
        Optional argument
                      The type list for the return values.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: >-
        Optional argument
                      The list of shapes being produced.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIteratorFromStringHandle'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A MultiDeviceIterator resource.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MultiDeviceIteratorFromStringHandle*
  exceptions: []
- uid: TensorFlow.TFGraph.MultiDeviceIteratorGetNextFromShard(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: MultiDeviceIteratorGetNextFromShard(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MultiDeviceIteratorGetNextFromShard(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.MultiDeviceIteratorGetNextFromShard(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.MultiDeviceIteratorGetNextFromShard(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gets next element for the provided shard number.
  syntax:
    content: public TensorFlow.TFOutput[] MultiDeviceIteratorGetNextFromShard (TensorFlow.TFOutput multi_device_iterator, TensorFlow.TFOutput shard_num, TensorFlow.TFOutput incarnation_id, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: multi_device_iterator
      type: TensorFlow.TFOutput
      description: A MultiDeviceIterator resource.
    - id: shard_num
      type: TensorFlow.TFOutput
      description: Integer representing which shard to fetch data for.
    - id: incarnation_id
      type: TensorFlow.TFOutput
      description: Which incarnation of the MultiDeviceIterator is running.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: The type list for the return values.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: The list of shapes being produced.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIteratorGetNextFromShard'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        Result of the get_next on the dataset.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MultiDeviceIteratorGetNextFromShard*
  exceptions: []
- uid: TensorFlow.TFGraph.MultiDeviceIteratorInit(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: MultiDeviceIteratorInit(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MultiDeviceIteratorInit(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.MultiDeviceIteratorInit(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.MultiDeviceIteratorInit(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Initializes the multi device iterator with the given dataset.
  syntax:
    content: public TensorFlow.TFOutput MultiDeviceIteratorInit (TensorFlow.TFOutput dataset, TensorFlow.TFOutput multi_device_iterator, TensorFlow.TFOutput max_buffer_size, string operName = null);
    parameters:
    - id: dataset
      type: TensorFlow.TFOutput
      description: Dataset to be iterated upon.
    - id: multi_device_iterator
      type: TensorFlow.TFOutput
      description: A MultiDeviceIteratorResource.
    - id: max_buffer_size
      type: TensorFlow.TFOutput
      description: The maximum size of the host side per device buffer to keep.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIteratorInit'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        An int64 indicating which incarnation of the MultiDeviceIterator
                      is running.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MultiDeviceIteratorInit*
  exceptions: []
- uid: TensorFlow.TFGraph.MultiDeviceIteratorToStringHandle(TensorFlow.TFOutput,System.String)
  id: MultiDeviceIteratorToStringHandle(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MultiDeviceIteratorToStringHandle(TFOutput, String)
  nameWithType: TFGraph.MultiDeviceIteratorToStringHandle(TFOutput, String)
  fullName: TFGraph.MultiDeviceIteratorToStringHandle(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Produces a string handle for the given MultiDeviceIterator.
  syntax:
    content: public TensorFlow.TFOutput MultiDeviceIteratorToStringHandle (TensorFlow.TFOutput multi_device_iterator, string operName = null);
    parameters:
    - id: multi_device_iterator
      type: TensorFlow.TFOutput
      description: A MultiDeviceIterator resource.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MultiDeviceIteratorToStringHandle'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A string representing the resource.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MultiDeviceIteratorToStringHandle*
  exceptions: []
- uid: TensorFlow.TFGraph.Multinomial(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)
  id: Multinomial(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Multinomial(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Multinomial(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<TFDataType>, String)
  fullName: TFGraph.Multinomial(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Draws samples from a multinomial distribution.
  syntax:
    content: public TensorFlow.TFOutput Multinomial (TensorFlow.TFOutput logits, TensorFlow.TFOutput num_samples, Nullable<long> seed = null, Nullable<long> seed2 = null, Nullable<TensorFlow.TFDataType> output_dtype = null, string operName = null);
    parameters:
    - id: logits
      type: TensorFlow.TFOutput
      description: >-
        2-D Tensor with shape <code>[batch_size, num_classes]</code>.  Each slice <code>[i, :]</code>
                      represents the unnormalized log probabilities for all classes.
    - id: num_samples
      type: TensorFlow.TFOutput
      description: 0-D.  Number of independent samples to draw for each row slice.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either seed or seed2 is set to be non-zero, the internal random number
                      generator is seeded by the given seed.  Otherwise, a random seed is used.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A second seed to avoid seed collision.
    - id: output_dtype
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Multinomial'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        2-D Tensor with shape <code>[batch_size, num_samples]</code>.  Each slice <code>[i, :]</code>
                      contains the drawn class labels with range <code>[0, num_classes)</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Multinomial*
  exceptions: []
- uid: TensorFlow.TFGraph.MutableDenseHashTable(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.Nullable{System.Int64},System.Nullable{System.Single},System.String)
  id: MutableDenseHashTable(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.Nullable{System.Int64},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MutableDenseHashTable(TFOutput, TFDataType, String, String, Nullable<Boolean>, TFShape, Nullable<Int64>, Nullable<Single>, String)
  nameWithType: TFGraph.MutableDenseHashTable(TFOutput, TFDataType, String, String, Nullable<Boolean>, TFShape, Nullable<Int64>, Nullable<Single>, String)
  fullName: TFGraph.MutableDenseHashTable(TFOutput, TFDataType, String, String, Nullable<Boolean>, TFShape, Nullable<Int64>, Nullable<Single>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates an empty hash table that uses tensors as the backing store.
  remarks: "It uses \"open addressing\" with quadratic reprobing to resolve\n              collisions.\n              \n              This op creates a mutable hash table, specifying the type of its keys and\n              values. Each value must be a scalar. Data can be inserted into the table using\n              the insert operations. It does not support the initialization operation."
  syntax:
    content: public TensorFlow.TFOutput MutableDenseHashTable (TensorFlow.TFOutput empty_key, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable<bool> use_node_name_sharing = null, TensorFlow.TFShape value_shape = null, Nullable<long> initial_num_buckets = null, Nullable<float> max_load_factor = null, string operName = null);
    parameters:
    - id: empty_key
      type: TensorFlow.TFOutput
      description: >-
        The key used to represent empty key buckets internally. Must not
                      be used in insert or lookup operations.
    - id: value_dtype
      type: TensorFlow.TFDataType
      description: Type of the table values.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is shared under the given name across
                      multiple sessions.
    - id: use_node_name_sharing
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: value_shape
      type: TensorFlow.TFShape
      description: >-
        Optional argument
                      The shape of each value.
    - id: initial_num_buckets
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The initial number of hash table buckets. Must be a power
                      to 2.
    - id: max_load_factor
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      The maximum ratio between number of entries and number of
                      buckets before growing the table. Must be between 0 and 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableDenseHashTable'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Handle to a table.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MutableDenseHashTable*
  exceptions: []
- uid: TensorFlow.TFGraph.MutableDenseHashTableV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.Nullable{System.Int64},System.Nullable{System.Single},System.String)
  id: MutableDenseHashTableV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.Nullable{System.Int64},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MutableDenseHashTableV2(TFOutput, TFDataType, String, String, Nullable<Boolean>, TFShape, Nullable<Int64>, Nullable<Single>, String)
  nameWithType: TFGraph.MutableDenseHashTableV2(TFOutput, TFDataType, String, String, Nullable<Boolean>, TFShape, Nullable<Int64>, Nullable<Single>, String)
  fullName: TFGraph.MutableDenseHashTableV2(TFOutput, TFDataType, String, String, Nullable<Boolean>, TFShape, Nullable<Int64>, Nullable<Single>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates an empty hash table that uses tensors as the backing store.
  remarks: "It uses \"open addressing\" with quadratic reprobing to resolve\n              collisions.\n              \n              This op creates a mutable hash table, specifying the type of its keys and\n              values. Each value must be a scalar. Data can be inserted into the table using\n              the insert operations. It does not support the initialization operation."
  syntax:
    content: public TensorFlow.TFOutput MutableDenseHashTableV2 (TensorFlow.TFOutput empty_key, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable<bool> use_node_name_sharing = null, TensorFlow.TFShape value_shape = null, Nullable<long> initial_num_buckets = null, Nullable<float> max_load_factor = null, string operName = null);
    parameters:
    - id: empty_key
      type: TensorFlow.TFOutput
      description: >-
        The key used to represent empty key buckets internally. Must not
                      be used in insert or lookup operations.
    - id: value_dtype
      type: TensorFlow.TFDataType
      description: Type of the table values.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is shared under the given name across
                      multiple sessions.
    - id: use_node_name_sharing
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: value_shape
      type: TensorFlow.TFShape
      description: >-
        Optional argument
                      The shape of each value.
    - id: initial_num_buckets
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The initial number of hash table buckets. Must be a power
                      to 2.
    - id: max_load_factor
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      The maximum ratio between number of entries and number of
                      buckets before growing the table. Must be between 0 and 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableDenseHashTableV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Handle to a table.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MutableDenseHashTableV2*
  exceptions: []
- uid: TensorFlow.TFGraph.MutableHashTable(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  id: MutableHashTable(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MutableHashTable(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.MutableHashTable(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  fullName: TFGraph.MutableHashTable(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates an empty hash table.
  remarks: >-
    This op creates a mutable hash table, specifying the type of its keys and
                  values. Each value must be a scalar. Data can be inserted into the table using
                  the insert operations. It does not support the initialization operation.
  syntax:
    content: public TensorFlow.TFOutput MutableHashTable (TensorFlow.TFDataType key_dtype, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable<bool> use_node_name_sharing = null, string operName = null);
    parameters:
    - id: key_dtype
      type: TensorFlow.TFDataType
      description: Type of the table keys.
    - id: value_dtype
      type: TensorFlow.TFDataType
      description: Type of the table values.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is shared under the given name across
                      multiple sessions.
    - id: use_node_name_sharing
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true and shared_name is empty, the table is shared
                      using the node name.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTable'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Handle to a table.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MutableHashTable*
  exceptions: []
- uid: TensorFlow.TFGraph.MutableHashTableOfTensors(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.String)
  id: MutableHashTableOfTensors(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MutableHashTableOfTensors(TFDataType, TFDataType, String, String, Nullable<Boolean>, TFShape, String)
  nameWithType: TFGraph.MutableHashTableOfTensors(TFDataType, TFDataType, String, String, Nullable<Boolean>, TFShape, String)
  fullName: TFGraph.MutableHashTableOfTensors(TFDataType, TFDataType, String, String, Nullable<Boolean>, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates an empty hash table.
  remarks: >-
    This op creates a mutable hash table, specifying the type of its keys and
                  values. Each value must be a vector. Data can be inserted into the table using
                  the insert operations. It does not support the initialization operation.
  syntax:
    content: public TensorFlow.TFOutput MutableHashTableOfTensors (TensorFlow.TFDataType key_dtype, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable<bool> use_node_name_sharing = null, TensorFlow.TFShape value_shape = null, string operName = null);
    parameters:
    - id: key_dtype
      type: TensorFlow.TFDataType
      description: Type of the table keys.
    - id: value_dtype
      type: TensorFlow.TFDataType
      description: Type of the table values.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is shared under the given name across
                      multiple sessions.
    - id: use_node_name_sharing
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: value_shape
      type: TensorFlow.TFShape
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTableOfTensors'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Handle to a table.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MutableHashTableOfTensors*
  exceptions: []
- uid: TensorFlow.TFGraph.MutableHashTableOfTensorsV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.String)
  id: MutableHashTableOfTensorsV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MutableHashTableOfTensorsV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, TFShape, String)
  nameWithType: TFGraph.MutableHashTableOfTensorsV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, TFShape, String)
  fullName: TFGraph.MutableHashTableOfTensorsV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates an empty hash table.
  remarks: >-
    This op creates a mutable hash table, specifying the type of its keys and
                  values. Each value must be a vector. Data can be inserted into the table using
                  the insert operations. It does not support the initialization operation.
  syntax:
    content: public TensorFlow.TFOutput MutableHashTableOfTensorsV2 (TensorFlow.TFDataType key_dtype, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable<bool> use_node_name_sharing = null, TensorFlow.TFShape value_shape = null, string operName = null);
    parameters:
    - id: key_dtype
      type: TensorFlow.TFDataType
      description: Type of the table keys.
    - id: value_dtype
      type: TensorFlow.TFDataType
      description: Type of the table values.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is shared under the given name across
                      multiple sessions.
    - id: use_node_name_sharing
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: value_shape
      type: TensorFlow.TFShape
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTableOfTensorsV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Handle to a table.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MutableHashTableOfTensorsV2*
  exceptions: []
- uid: TensorFlow.TFGraph.MutableHashTableV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  id: MutableHashTableV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MutableHashTableV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.MutableHashTableV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  fullName: TFGraph.MutableHashTableV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates an empty hash table.
  remarks: >-
    This op creates a mutable hash table, specifying the type of its keys and
                  values. Each value must be a scalar. Data can be inserted into the table using
                  the insert operations. It does not support the initialization operation.
  syntax:
    content: public TensorFlow.TFOutput MutableHashTableV2 (TensorFlow.TFDataType key_dtype, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable<bool> use_node_name_sharing = null, string operName = null);
    parameters:
    - id: key_dtype
      type: TensorFlow.TFDataType
      description: Type of the table keys.
    - id: value_dtype
      type: TensorFlow.TFDataType
      description: Type of the table values.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this table is shared under the given name across
                      multiple sessions.
    - id: use_node_name_sharing
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true and shared_name is empty, the table is shared
                      using the node name.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MutableHashTableV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Handle to a table.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MutableHashTableV2*
  exceptions: []
- uid: TensorFlow.TFGraph.MutexLock(TensorFlow.TFOutput,System.String)
  id: MutexLock(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MutexLock(TFOutput, String)
  nameWithType: TFGraph.MutexLock(TFOutput, String)
  fullName: TFGraph.MutexLock(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Locks a mutex resource.  The output is the lock.  So long as the lock tensor
  remarks: "is alive, any other request to use <code>MutexLock</code> with this mutex will wait.\n              \n              This is particularly useful for creating a critical section when used in\n              conjunction with <code>MutexLockIdentity</code>:\n              \n               <pre><code>\n              \n              mutex = mutex_v2(\n              shared_name=handle_name, container=container, name=name)\n              \n              def execute_in_critical_section(fn, *args, **kwargs):\n              lock = gen_resource_variable_ops.mutex_lock(mutex)\n              \n              with ops.control_dependencies([lock]):\n              r = fn(*args, **kwargs)\n              \n              with ops.control_dependencies(nest.flatten(r)):\n              with ops.colocate_with(mutex):\n              ensure_lock_exists = mutex_lock_identity(lock)\n              \n              # Make sure that if any element of r is accessed, all of\n              # them are executed together.\n              r = nest.map_structure(tf.identity, r)\n              \n              with ops.control_dependencies([ensure_lock_exists]):\n              return nest.map_structure(tf.identity, r)\n               </code></pre>\n              \n              While <code>fn</code> is running in the critical section, no other functions which wish to\n              use this critical section may run.\n              \n              Often the use case is that two executions of the same graph, in parallel,\n              wish to run <code>fn</code>; and we wish to ensure that only one of them executes\n              at a time.  This is especially important if <code>fn</code> modifies one or more\n              variables at a time.\n              \n              It is also useful if two separate functions must share a resource, but we\n              wish to ensure the usage is exclusive."
  syntax:
    content: public TensorFlow.TFOutput MutexLock (TensorFlow.TFOutput mutex, string operName = null);
    parameters:
    - id: mutex
      type: TensorFlow.TFOutput
      description: The mutex resource to lock.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MutexLock'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A tensor that keeps a shared pointer to a lock on the mutex;
                      when the Tensor is destroyed, the use count on the shared pointer is decreased
                      by 1.  When it reaches 0, the lock is released.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MutexLock*
  exceptions: []
- uid: TensorFlow.TFGraph.MutexV2(System.String,System.String,System.String)
  id: MutexV2(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: MutexV2(String, String, String)
  nameWithType: TFGraph.MutexV2(String, String, String)
  fullName: TFGraph.MutexV2(String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a Mutex resource that can be locked by <code>MutexLock</code>.
  syntax:
    content: public TensorFlow.TFOutput MutexV2 (string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this variable is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this variable is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'MutexV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The mutex resource.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.MutexV2*
  exceptions: []
- uid: TensorFlow.TFGraph.Neg(TensorFlow.TFOutput,System.String)
  id: Neg(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Neg(TFOutput, String)
  nameWithType: TFGraph.Neg(TFOutput, String)
  fullName: TFGraph.Neg(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes numerical negative value element-wise.
  remarks: I.e., \\(y = -x\\).
  syntax:
    content: public TensorFlow.TFOutput Neg (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Neg'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Neg*
  exceptions: []
- uid: TensorFlow.TFGraph.NegTrain(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64,System.String)
  id: NegTrain(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: NegTrain(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], Int64, String)
  nameWithType: TFGraph.NegTrain(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], Int64, String)
  fullName: TFGraph.NegTrain(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Training via negative sampling.
  syntax:
    content: public TensorFlow.TFOperation NegTrain (TensorFlow.TFOutput w_in, TensorFlow.TFOutput w_out, TensorFlow.TFOutput examples, TensorFlow.TFOutput labels, TensorFlow.TFOutput lr, long[] vocab_count, long num_negative_samples, string operName = null);
    parameters:
    - id: w_in
      type: TensorFlow.TFOutput
      description: input word embedding.
    - id: w_out
      type: TensorFlow.TFOutput
      description: output word embedding.
    - id: examples
      type: TensorFlow.TFOutput
      description: A vector of word ids.
    - id: labels
      type: TensorFlow.TFOutput
      description: A vector of word ids.
    - id: lr
      type: TensorFlow.TFOutput
      description: To be added.
    - id: vocab_count
      type: System.Int64[]
      description: Count of words in the vocabulary.
    - id: num_negative_samples
      type: System.Int64
      description: Number of negative samples per example.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'NegTrain'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.NegTrain*
  exceptions: []
- uid: TensorFlow.TFGraph.NextIteration(TensorFlow.TFOutput,System.String)
  id: NextIteration(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: NextIteration(TFOutput, String)
  nameWithType: TFGraph.NextIteration(TFOutput, String)
  fullName: TFGraph.NextIteration(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Makes its input available to the next iteration.
  syntax:
    content: public TensorFlow.TFOutput NextIteration (TensorFlow.TFOutput data, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: The tensor to be made available to the next iteration.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'NextIteration'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The same tensor as <code>data</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.NextIteration*
  exceptions: []
- uid: TensorFlow.TFGraph.NonMaxSuppression(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String)
  id: NonMaxSuppression(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: NonMaxSuppression(TFOutput, TFOutput, TFOutput, Nullable<Single>, String)
  nameWithType: TFGraph.NonMaxSuppression(TFOutput, TFOutput, TFOutput, Nullable<Single>, String)
  fullName: TFGraph.NonMaxSuppression(TFOutput, TFOutput, TFOutput, Nullable<Single>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Greedily selects a subset of bounding boxes in descending order of score,
  remarks: >-
    pruning away boxes that have high intersection-over-union (IOU) overlap
                  with previously selected boxes.  Bounding boxes are supplied as
                  [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
                  diagonal pair of box corners and the coordinates can be provided as normalized
                  (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
                  is agnostic to where the origin is in the coordinate system.  Note that this
                  algorithm is invariant to orthogonal transformations and translations
                  of the coordinate system; thus translating or reflections of the coordinate
                  system result in the same boxes being selected by the algorithm.
                  The output of this operation is a set of integers indexing into the input
                  collection of bounding boxes representing the selected boxes.  The bounding
                  box coordinates corresponding to the selected indices can then be obtained
                  using the <code>tf.gather operation</code>.  For example:
                  selected_indices = tf.image.non_max_suppression(
                  boxes, scores, max_output_size, iou_threshold)
                  selected_boxes = tf.gather(boxes, selected_indices)
  syntax:
    content: public TensorFlow.TFOutput NonMaxSuppression (TensorFlow.TFOutput boxes, TensorFlow.TFOutput scores, TensorFlow.TFOutput max_output_size, Nullable<float> iou_threshold = null, string operName = null);
    parameters:
    - id: boxes
      type: TensorFlow.TFOutput
      description: A 2-D float tensor of shape <code>[num_boxes, 4]</code>.
    - id: scores
      type: TensorFlow.TFOutput
      description: >-
        A 1-D float tensor of shape <code>[num_boxes]</code> representing a single
                      score corresponding to each box (each row of boxes).
    - id: max_output_size
      type: TensorFlow.TFOutput
      description: >-
        A scalar integer tensor representing the maximum number of
                      boxes to be selected by non max suppression.
    - id: iou_threshold
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      A float representing the threshold for deciding whether boxes
                      overlap too much with respect to IOU.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppression'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A 1-D integer tensor of shape <code>[M]</code> representing the selected
                      indices from the boxes tensor, where <code>M &lt;= max_output_size</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.NonMaxSuppression*
  exceptions: []
- uid: TensorFlow.TFGraph.NonMaxSuppressionV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: NonMaxSuppressionV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: NonMaxSuppressionV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.NonMaxSuppressionV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.NonMaxSuppressionV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Greedily selects a subset of bounding boxes in descending order of score,
  remarks: "pruning away boxes that have high intersection-over-union (IOU) overlap\n              with previously selected boxes.  Bounding boxes are supplied as\n              [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any\n              diagonal pair of box corners and the coordinates can be provided as normalized\n              (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm\n              is agnostic to where the origin is in the coordinate system.  Note that this\n              algorithm is invariant to orthogonal transformations and translations\n              of the coordinate system; thus translating or reflections of the coordinate\n              system result in the same boxes being selected by the algorithm.\n              \n              The output of this operation is a set of integers indexing into the input\n              collection of bounding boxes representing the selected boxes.  The bounding\n              box coordinates corresponding to the selected indices can then be obtained\n              using the <code>tf.gather operation</code>.  For example:\n              \n              selected_indices = tf.image.non_max_suppression_v2(\n              boxes, scores, max_output_size, iou_threshold)\n              selected_boxes = tf.gather(boxes, selected_indices)"
  syntax:
    content: public TensorFlow.TFOutput NonMaxSuppressionV2 (TensorFlow.TFOutput boxes, TensorFlow.TFOutput scores, TensorFlow.TFOutput max_output_size, TensorFlow.TFOutput iou_threshold, string operName = null);
    parameters:
    - id: boxes
      type: TensorFlow.TFOutput
      description: A 2-D float tensor of shape <code>[num_boxes, 4]</code>.
    - id: scores
      type: TensorFlow.TFOutput
      description: >-
        A 1-D float tensor of shape <code>[num_boxes]</code> representing a single
                      score corresponding to each box (each row of boxes).
    - id: max_output_size
      type: TensorFlow.TFOutput
      description: >-
        A scalar integer tensor representing the maximum number of
                      boxes to be selected by non max suppression.
    - id: iou_threshold
      type: TensorFlow.TFOutput
      description: >-
        A 0-D float tensor representing the threshold for deciding whether
                      boxes overlap too much with respect to IOU.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A 1-D integer tensor of shape <code>[M]</code> representing the selected
                      indices from the boxes tensor, where <code>M &lt;= max_output_size</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.NonMaxSuppressionV2*
  exceptions: []
- uid: TensorFlow.TFGraph.NonMaxSuppressionV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: NonMaxSuppressionV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: NonMaxSuppressionV3(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.NonMaxSuppressionV3(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.NonMaxSuppressionV3(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Greedily selects a subset of bounding boxes in descending order of score,
  remarks: >-
    pruning away boxes that have high intersection-over-union (IOU) overlap
                  with previously selected boxes.  Bounding boxes with score less than
                  <code>score_threshold</code> are removed.  Bounding boxes are supplied as
                  [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
                  diagonal pair of box corners and the coordinates can be provided as normalized
                  (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
                  is agnostic to where the origin is in the coordinate system and more
                  generally is invariant to orthogonal transformations and translations
                  of the coordinate system; thus translating or reflections of the coordinate
                  system result in the same boxes being selected by the algorithm.
                  The output of this operation is a set of integers indexing into the input
                  collection of bounding boxes representing the selected boxes.  The bounding
                  box coordinates corresponding to the selected indices can then be obtained
                  using the <code>tf.gather operation</code>.  For example:
                  selected_indices = tf.image.non_max_suppression_v2(
                  boxes, scores, max_output_size, iou_threshold, score_threshold)
                  selected_boxes = tf.gather(boxes, selected_indices)
  syntax:
    content: public TensorFlow.TFOutput NonMaxSuppressionV3 (TensorFlow.TFOutput boxes, TensorFlow.TFOutput scores, TensorFlow.TFOutput max_output_size, TensorFlow.TFOutput iou_threshold, TensorFlow.TFOutput score_threshold, string operName = null);
    parameters:
    - id: boxes
      type: TensorFlow.TFOutput
      description: A 2-D float tensor of shape <code>[num_boxes, 4]</code>.
    - id: scores
      type: TensorFlow.TFOutput
      description: >-
        A 1-D float tensor of shape <code>[num_boxes]</code> representing a single
                      score corresponding to each box (each row of boxes).
    - id: max_output_size
      type: TensorFlow.TFOutput
      description: >-
        A scalar integer tensor representing the maximum number of
                      boxes to be selected by non max suppression.
    - id: iou_threshold
      type: TensorFlow.TFOutput
      description: >-
        A 0-D float tensor representing the threshold for deciding whether
                      boxes overlap too much with respect to IOU.
    - id: score_threshold
      type: TensorFlow.TFOutput
      description: >-
        A 0-D float tensor representing the threshold for deciding when to remove
                      boxes based on score.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionV3'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A 1-D integer tensor of shape <code>[M]</code> representing the selected
                      indices from the boxes tensor, where <code>M &lt;= max_output_size</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.NonMaxSuppressionV3*
  exceptions: []
- uid: TensorFlow.TFGraph.NonMaxSuppressionV4(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: NonMaxSuppressionV4(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: NonMaxSuppressionV4(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.NonMaxSuppressionV4(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.NonMaxSuppressionV4(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Greedily selects a subset of bounding boxes in descending order of score,
  remarks: >-
    pruning away boxes that have high intersection-over-union (IOU) overlap
                  with previously selected boxes.  Bounding boxes with score less than
                  <code>score_threshold</code> are removed.  Bounding boxes are supplied as
                  [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
                  diagonal pair of box corners and the coordinates can be provided as normalized
                  (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
                  is agnostic to where the origin is in the coordinate system and more
                  generally is invariant to orthogonal transformations and translations
                  of the coordinate system; thus translating or reflections of the coordinate
                  system result in the same boxes being selected by the algorithm.
                  The output of this operation is a set of integers indexing into the input
                  collection of bounding boxes representing the selected boxes.  The bounding
                  box coordinates corresponding to the selected indices can then be obtained
                  using the <code>tf.gather operation</code>.  For example:
                  selected_indices = tf.image.non_max_suppression_v2(
                  boxes, scores, max_output_size, iou_threshold, score_threshold)
                  selected_boxes = tf.gather(boxes, selected_indices)
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> NonMaxSuppressionV4 (TensorFlow.TFOutput boxes, TensorFlow.TFOutput scores, TensorFlow.TFOutput max_output_size, TensorFlow.TFOutput iou_threshold, TensorFlow.TFOutput score_threshold, Nullable<bool> pad_to_max_output_size = null, string operName = null);
    parameters:
    - id: boxes
      type: TensorFlow.TFOutput
      description: A 2-D float tensor of shape <code>[num_boxes, 4]</code>.
    - id: scores
      type: TensorFlow.TFOutput
      description: >-
        A 1-D float tensor of shape <code>[num_boxes]</code> representing a single
                      score corresponding to each box (each row of boxes).
    - id: max_output_size
      type: TensorFlow.TFOutput
      description: >-
        A scalar integer tensor representing the maximum number of
                      boxes to be selected by non max suppression.
    - id: iou_threshold
      type: TensorFlow.TFOutput
      description: >-
        A 0-D float tensor representing the threshold for deciding whether
                      boxes overlap too much with respect to IOU.
    - id: score_threshold
      type: TensorFlow.TFOutput
      description: >-
        A 0-D float tensor representing the threshold for deciding when to remove
                      boxes based on score.
    - id: pad_to_max_output_size
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, the output <code>selected_indices</code> is padded to be of length
                      <code>max_output_size</code>. Defaults to false.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionV4'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      selected_indices: A 1-D integer tensor of shape <code>[M]</code> representing the selected
                      indices from the boxes tensor, where <code>M &lt;= max_output_size</code>.
                      valid_outputs: A 0-D integer tensor representing the number of valid elements in
                      <code>selected_indices</code>, with the valid elements appearing first.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.NonMaxSuppressionV4*
  exceptions: []
- uid: TensorFlow.TFGraph.NonMaxSuppressionWithOverlaps(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: NonMaxSuppressionWithOverlaps(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: NonMaxSuppressionWithOverlaps(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.NonMaxSuppressionWithOverlaps(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.NonMaxSuppressionWithOverlaps(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Greedily selects a subset of bounding boxes in descending order of score,
  remarks: "pruning away boxes that have high overlaps\n              with previously selected boxes.  Bounding boxes with score less than\n              <code>score_threshold</code> are removed. N-by-n overlap values are supplied as square matrix,\n              which allows for defining a custom overlap criterium (eg. intersection over union,\n              intersection over area, etc.).\n              \n              The output of this operation is a set of integers indexing into the input\n              collection of bounding boxes representing the selected boxes.  The bounding\n              box coordinates corresponding to the selected indices can then be obtained\n              using the <code>tf.gather operation</code>.  For example:\n              \n              selected_indices = tf.image.non_max_suppression_with_overlaps(\n              overlaps, scores, max_output_size, overlap_threshold, score_threshold)\n              selected_boxes = tf.gather(boxes, selected_indices)"
  syntax:
    content: public TensorFlow.TFOutput NonMaxSuppressionWithOverlaps (TensorFlow.TFOutput overlaps, TensorFlow.TFOutput scores, TensorFlow.TFOutput max_output_size, TensorFlow.TFOutput overlap_threshold, TensorFlow.TFOutput score_threshold, string operName = null);
    parameters:
    - id: overlaps
      type: TensorFlow.TFOutput
      description: >-
        A 2-D float tensor of shape <code>[num_boxes, num_boxes]</code> representing
                      the n-by-n box overlap values.
    - id: scores
      type: TensorFlow.TFOutput
      description: >-
        A 1-D float tensor of shape <code>[num_boxes]</code> representing a single
                      score corresponding to each box (each row of boxes).
    - id: max_output_size
      type: TensorFlow.TFOutput
      description: >-
        A scalar integer tensor representing the maximum number of
                      boxes to be selected by non max suppression.
    - id: overlap_threshold
      type: TensorFlow.TFOutput
      description: >-
        A 0-D float tensor representing the threshold for deciding whether
                      boxes overlap too.
    - id: score_threshold
      type: TensorFlow.TFOutput
      description: >-
        A 0-D float tensor representing the threshold for deciding when to remove
                      boxes based on score.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'NonMaxSuppressionWithOverlaps'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A 1-D integer tensor of shape <code>[M]</code> representing the selected
                      indices from the boxes tensor, where <code>M &lt;= max_output_size</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.NonMaxSuppressionWithOverlaps*
  exceptions: []
- uid: TensorFlow.TFGraph.NoOp(System.String)
  id: NoOp(System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: NoOp(String)
  nameWithType: TFGraph.NoOp(String)
  fullName: TFGraph.NoOp(String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Does nothing. Only useful as a placeholder for control edges.
  syntax:
    content: public TensorFlow.TFOperation NoOp (string operName = null);
    parameters:
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'NoOp'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.NoOp*
  exceptions: []
- uid: TensorFlow.TFGraph.NotEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: NotEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: NotEqual(TFOutput, TFOutput, String)
  nameWithType: TFGraph.NotEqual(TFOutput, TFOutput, String)
  fullName: TFGraph.NotEqual(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the truth value of (x != y) element-wise.
  remarks: >-
    *NOTE*: <code>NotEqual</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput NotEqual (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'NotEqual'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.NotEqual*
  exceptions: []
- uid: TensorFlow.TFGraph.NthElement(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: NthElement(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: NthElement(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.NthElement(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.NthElement(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Finds values of the <code>n</code>-th order statistic for the last dimension.
  remarks: "If the input is a vector (rank-1), finds the entries which is the nth-smallest\n              value in the vector and outputs their values as scalar tensor.\n              \n              For matrices (resp. higher rank input), computes the entries which is the\n              nth-smallest value in each row (resp. vector along the last dimension). Thus,\n              \n              values.shape = input.shape[:-1]"
  syntax:
    content: public TensorFlow.TFOutput NthElement (TensorFlow.TFOutput input, TensorFlow.TFOutput n, Nullable<bool> reverse = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 1-D or higher with last dimension at least <code>n+1</code>.
    - id: n
      type: TensorFlow.TFOutput
      description: >-
        0-D. Position of sorted vector to select along the last dimension (along
                      each row for matrices). Valid range of n is <code>[0, input.shape[:-1])</code>
    - id: reverse
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      When set to True, find the nth-largest value in the vector and vice
                      versa.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'NthElement'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The <code>n</code>-th order statistic along each last dimensional slice.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.NthElement*
  exceptions: []
- uid: TensorFlow.TFGraph.NumFunctions
  id: NumFunctions
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: NumFunctions
  nameWithType: TFGraph.NumFunctions
  fullName: TFGraph.NumFunctions
  type: Property
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the number of TF_Functions registered in this graph.
  syntax:
    content: public int NumFunctions { get; }
    return:
      type: System.Int32
      description: The number functions.
  overload: TensorFlow.TFGraph.NumFunctions*
  exceptions: []
- uid: TensorFlow.TFGraph.OneHot(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  id: OneHot(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OneHot(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.OneHot(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.OneHot(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  syntax:
    content: public TensorFlow.TFOutput OneHot (TensorFlow.TFOutput indices, TensorFlow.TFOutput depth, TensorFlow.TFOutput on_value, TensorFlow.TFOutput off_value, Nullable<long> axis = null, string operName = null);
    parameters:
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: depth
      type: TensorFlow.TFOutput
      description: To be added.
    - id: on_value
      type: TensorFlow.TFOutput
      description: To be added.
    - id: off_value
      type: TensorFlow.TFOutput
      description: To be added.
    - id: axis
      type: System.Nullable{System.Int64}
      description: To be added.
    - id: operName
      type: System.String
      description: To be added.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.OneHot*
  exceptions: []
- uid: TensorFlow.TFGraph.Ones(TensorFlow.TFShape,TensorFlow.TFDataType,System.String)
  id: Ones(TensorFlow.TFShape,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Ones(TFShape, TFDataType, String)
  nameWithType: TFGraph.Ones(TFShape, TFDataType, String)
  fullName: TFGraph.Ones(TFShape, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs One values based on shape of tensor
  syntax:
    content: public TensorFlow.TFOutput Ones (TensorFlow.TFShape shape, TensorFlow.TFDataType dtype = TensorFlow.TFDataType.Double, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFShape
      description: Shape of the output tensor
    - id: dtype
      type: TensorFlow.TFDataType
      description: 'Optional Type of the Zero value. Default: Double'
    - id: operName
      type: System.String
      description: Operation name, optional.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.Ones*
  exceptions: []
- uid: TensorFlow.TFGraph.OnesLike(TensorFlow.TFOutput,System.String)
  id: OnesLike(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OnesLike(TFOutput, String)
  nameWithType: TFGraph.OnesLike(TFOutput, String)
  fullName: TFGraph.OnesLike(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns a tensor of ones with the same shape and type as x.
  syntax:
    content: public TensorFlow.TFOutput OnesLike (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: a tensor of type T.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OnesLike'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        a tensor of the same shape and type as x but filled with ones.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.OnesLike*
  exceptions: []
- uid: TensorFlow.TFGraph.OptimizeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: OptimizeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OptimizeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.OptimizeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.OptimizeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset by applying optimizations to <code>input_dataset</code>.
  remarks: Creates a dataset by applying optimizations to <code>input_dataset</code>.
  syntax:
    content: public TensorFlow.TFOutput OptimizeDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput optimizations, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: A variant tensor representing the input dataset.
    - id: optimizations
      type: TensorFlow.TFOutput
      description: A <code>tf.string</code> vector <code>tf.Tensor</code> identifying optimizations to use.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OptimizeDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.OptimizeDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.OptionalFromValue(TensorFlow.TFOutput[],System.String)
  id: OptionalFromValue(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OptionalFromValue(TFOutput[], String)
  nameWithType: TFGraph.OptionalFromValue(TFOutput[], String)
  fullName: TFGraph.OptionalFromValue(TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Constructs an Optional variant from a tuple of tensors.
  syntax:
    content: public TensorFlow.TFOutput OptionalFromValue (TensorFlow.TFOutput[] components, string operName = null);
    parameters:
    - id: components
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OptionalFromValue'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.OptionalFromValue*
  exceptions: []
- uid: TensorFlow.TFGraph.OptionalGetValue(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: OptionalGetValue(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OptionalGetValue(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.OptionalGetValue(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.OptionalGetValue(TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the value stored in an Optional variant or raises an error if none exists.
  syntax:
    content: public TensorFlow.TFOutput[] OptionalGetValue (TensorFlow.TFOutput optional, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: optional
      type: TensorFlow.TFOutput
      description: To be added.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OptionalGetValue'.
    return:
      type: TensorFlow.TFOutput[]
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.OptionalGetValue*
  exceptions: []
- uid: TensorFlow.TFGraph.OptionalHasValue(TensorFlow.TFOutput,System.String)
  id: OptionalHasValue(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OptionalHasValue(TFOutput, String)
  nameWithType: TFGraph.OptionalHasValue(TFOutput, String)
  fullName: TFGraph.OptionalHasValue(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns true if and only if the given Optional variant has a value.
  syntax:
    content: public TensorFlow.TFOutput OptionalHasValue (TensorFlow.TFOutput optional, string operName = null);
    parameters:
    - id: optional
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OptionalHasValue'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.OptionalHasValue*
  exceptions: []
- uid: TensorFlow.TFGraph.OptionalNone(System.String)
  id: OptionalNone(System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OptionalNone(String)
  nameWithType: TFGraph.OptionalNone(String)
  fullName: TFGraph.OptionalNone(String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates an Optional variant with no value.
  syntax:
    content: public TensorFlow.TFOutput OptionalNone (string operName = null);
    parameters:
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OptionalNone'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.OptionalNone*
  exceptions: []
- uid: TensorFlow.TFGraph.OrderedMapClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: OrderedMapClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OrderedMapClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op removes all elements in the underlying container.
  syntax:
    content: public TensorFlow.TFOperation OrderedMapClear (TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapClear'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.OrderedMapClear*
  exceptions: []
- uid: TensorFlow.TFGraph.OrderedMapIncompleteSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: OrderedMapIncompleteSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OrderedMapIncompleteSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapIncompleteSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapIncompleteSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op returns the number of incomplete elements in the underlying container.
  syntax:
    content: public TensorFlow.TFOutput OrderedMapIncompleteSize (TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapIncompleteSize'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.OrderedMapIncompleteSize*
  exceptions: []
- uid: TensorFlow.TFGraph.OrderedMapPeek(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: OrderedMapPeek(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OrderedMapPeek(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapPeek(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapPeek(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op peeks at the values at the specified key.  If the
  remarks: >-
    underlying container does not contain this key
                  this op will block until it does.   This Op is optimized for
                  performance.
  syntax:
    content: public TensorFlow.TFOutput[] OrderedMapPeek (TensorFlow.TFOutput key, TensorFlow.TFOutput indices, TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: key
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapPeek'.
    return:
      type: TensorFlow.TFOutput[]
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.OrderedMapPeek*
  exceptions: []
- uid: TensorFlow.TFGraph.OrderedMapSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: OrderedMapSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OrderedMapSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op returns the number of elements in the underlying container.
  syntax:
    content: public TensorFlow.TFOutput OrderedMapSize (TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapSize'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.OrderedMapSize*
  exceptions: []
- uid: TensorFlow.TFGraph.OrderedMapStage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: OrderedMapStage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OrderedMapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Stage (key, values) in the underlying container which behaves like a ordered
  remarks: associative container.   Elements are ordered by key.
  syntax:
    content: public TensorFlow.TFOperation OrderedMapStage (TensorFlow.TFOutput key, TensorFlow.TFOutput indices, TensorFlow.TFOutput[] values, TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: key
      type: TensorFlow.TFOutput
      description: int64
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: values
      type: TensorFlow.TFOutput[]
      description: >-
        a list of tensors
                      dtypes A list of data types that inserted values should adhere to.
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Maximum number of elements in the Staging Area. If &gt; 0, inserts
                      on the container will block when the capacity is reached.
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue is placed in the given container. Otherwise,
                      a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      It is necessary to match this name to the matching Unstage Op.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapStage'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.OrderedMapStage*
  exceptions: []
- uid: TensorFlow.TFGraph.OrderedMapUnstage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: OrderedMapUnstage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OrderedMapUnstage(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapUnstage(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapUnstage(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op removes and returns the values associated with the key
  remarks: >-
    from the underlying container.   If the underlying container
                  does not contain this key, the op will block until it does.
  syntax:
    content: public TensorFlow.TFOutput[] OrderedMapUnstage (TensorFlow.TFOutput key, TensorFlow.TFOutput indices, TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: key
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapUnstage'.
    return:
      type: TensorFlow.TFOutput[]
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.OrderedMapUnstage*
  exceptions: []
- uid: TensorFlow.TFGraph.OrderedMapUnstageNoKey(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: OrderedMapUnstageNoKey(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OrderedMapUnstageNoKey(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapUnstageNoKey(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapUnstageNoKey(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op removes and returns the (key, value) element with the smallest
  remarks: >-
    key from the underlying container.   If the underlying container
                  does not contain elements, the op will block until it does.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput[]> OrderedMapUnstageNoKey (TensorFlow.TFOutput indices, TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OrderedMapUnstageNoKey'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput[]}
      description: >-
        Returns a tuple with multiple values, as follows:
                      key:
                      values:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.OrderedMapUnstageNoKey*
  exceptions: []
- uid: TensorFlow.TFGraph.OutfeedDequeue(TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Int64},System.String)
  id: OutfeedDequeue(TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OutfeedDequeue(TFDataType, TFShape, Nullable<Int64>, String)
  nameWithType: TFGraph.OutfeedDequeue(TFDataType, TFShape, Nullable<Int64>, String)
  fullName: TFGraph.OutfeedDequeue(TFDataType, TFShape, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieves a single tensor from the computation outfeed.  This operation will
  remarks: block indefinitely until data is available.
  syntax:
    content: public TensorFlow.TFOutput OutfeedDequeue (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, Nullable<long> device_ordinal = null, string operName = null);
    parameters:
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of elements in the tensor.
    - id: shape
      type: TensorFlow.TFShape
      description: The shape of the tensor.
    - id: device_ordinal
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The TPU device to use. This should be -1 when the Op
                      is running on a TPU device, and &gt;= 0 when the Op is running on the CPU
                      device.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OutfeedDequeue'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A tensor that will be read from the device outfeed.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.OutfeedDequeue*
  exceptions: []
- uid: TensorFlow.TFGraph.OutfeedDequeueTuple(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String)
  id: OutfeedDequeueTuple(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OutfeedDequeueTuple(TFDataType[], TFShape[], Nullable<Int64>, String)
  nameWithType: TFGraph.OutfeedDequeueTuple(TFDataType[], TFShape[], Nullable<Int64>, String)
  fullName: TFGraph.OutfeedDequeueTuple(TFDataType[], TFShape[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve multiple values that will be emitted by the computation as an XLA
  remarks: >-
    tuple.  This operations will block indefinitely until data is available.
                  Output <code>i</code> corresponds to XLA tuple element <code>i</code>.
  syntax:
    content: public TensorFlow.TFOutput[] OutfeedDequeueTuple (TensorFlow.TFDataType[] dtypes, TensorFlow.TFShape[] shapes, Nullable<long> device_ordinal = null, string operName = null);
    parameters:
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: The element types of each element in <code>outputs</code>.
    - id: shapes
      type: TensorFlow.TFShape[]
      description: The shapes of each tensor in <code>outputs</code>.
    - id: device_ordinal
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The TPU device to use. This should be -1 when the Op
                      is running on a TPU device, and &gt;= 0 when the Op is running on the CPU
                      device.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OutfeedDequeueTuple'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        A list of tensors that will be read from the outfeed.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.OutfeedDequeueTuple*
  exceptions: []
- uid: TensorFlow.TFGraph.OutfeedEnqueue(TensorFlow.TFOutput,System.String)
  id: OutfeedEnqueue(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OutfeedEnqueue(TFOutput, String)
  nameWithType: TFGraph.OutfeedEnqueue(TFOutput, String)
  fullName: TFGraph.OutfeedEnqueue(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An op which emits a single Tensor value from an XLA computation.
  syntax:
    content: public TensorFlow.TFOperation OutfeedEnqueue (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A tensor that will be inserted into the outfeed queue.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OutfeedEnqueue'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.OutfeedEnqueue*
  exceptions: []
- uid: TensorFlow.TFGraph.OutfeedEnqueueTuple(TensorFlow.TFOutput[],System.String)
  id: OutfeedEnqueueTuple(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: OutfeedEnqueueTuple(TFOutput[], String)
  nameWithType: TFGraph.OutfeedEnqueueTuple(TFOutput[], String)
  fullName: TFGraph.OutfeedEnqueueTuple(TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An op which emits multiple Tensor values from an XLA computation.
  syntax:
    content: public TensorFlow.TFOperation OutfeedEnqueueTuple (TensorFlow.TFOutput[] inputs, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: >-
        A list of tensors that will be inserted into the outfeed queue as an
                      XLA tuple.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'OutfeedEnqueueTuple'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.OutfeedEnqueueTuple*
  exceptions: []
- uid: TensorFlow.TFGraph.Pack(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  id: Pack(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Pack(TFOutput[], Nullable<Int64>, String)
  nameWithType: TFGraph.Pack(TFOutput[], Nullable<Int64>, String)
  fullName: TFGraph.Pack(TFOutput[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Packs a list of <code>N</code> rank-<code>R</code> tensors into one rank-<code>(R+1)</code> tensor.
  remarks: "Packs the <code>N</code> tensors in <code>values</code> into a tensor with rank one higher than each\n              tensor in <code>values</code>, by packing them along the <code>axis</code> dimension.\n              Given a list of tensors of shape <code>(A, B, C)</code>;\n              \n              if <code>axis == 0</code> then the <code>output</code> tensor will have the shape <code>(N, A, B, C)</code>.\n              if <code>axis == 1</code> then the <code>output</code> tensor will have the shape <code>(A, N, B, C)</code>.\n              Etc.\n              \n              For example:\n              \n               <pre><code>\n              # 'x' is [1, 4]\n              # 'y' is [2, 5]\n              # 'z' is [3, 6]\n              pack([x, y, z]) =&gt; [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.\n              pack([x, y, z], axis=1) =&gt; [[1, 2, 3], [4, 5, 6]]\n               </code></pre>\n              \n              This is the opposite of <code>unpack</code>."
  syntax:
    content: public TensorFlow.TFOutput Pack (TensorFlow.TFOutput[] values, Nullable<long> axis = null, string operName = null);
    parameters:
    - id: values
      type: TensorFlow.TFOutput[]
      description: Must be of same shape and type.
    - id: axis
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Dimension along which to pack.  Negative values wrap around, so the
                      valid range is <code>[-(R+1), R+1)</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Pack'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The packed tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Pack*
  exceptions: []
- uid: TensorFlow.TFGraph.Pad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Pad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Pad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Pad(TFOutput, TFOutput, String)
  fullName: TFGraph.Pad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Pads a tensor with zeros.
  remarks: "This operation pads a <code>input</code> with zeros according to the <code>paddings</code> you\n              specify. <code>paddings</code> is an integer tensor with shape <code>[Dn, 2]</code>, where n is the\n              rank of <code>input</code>. For each dimension D of <code>input</code>, <code>paddings[D, 0]</code> indicates\n              how many zeros to add before the contents of <code>input</code> in that dimension, and\n              <code>paddings[D, 1]</code> indicates how many zeros to add after the contents of <code>input</code>\n              in that dimension.\n              \n              The padded size of each dimension D of the output is:\n              \n              <code>paddings(D, 0) + input.dim_size(D) + paddings(D, 1)</code>\n              \n              For example:\n              \n               <pre><code>\n              # 't' is [[1, 1], [2, 2]]\n              # 'paddings' is [[1, 1], [2, 2]]\n              # rank of 't' is 2\n              pad(t, paddings) ==&gt; [[0, 0, 0, 0, 0, 0]\n              [0, 0, 1, 1, 0, 0]\n              [0, 0, 2, 2, 0, 0]\n              [0, 0, 0, 0, 0, 0]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Pad (TensorFlow.TFOutput input, TensorFlow.TFOutput paddings, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: paddings
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Pad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Pad*
  exceptions: []
- uid: TensorFlow.TFGraph.PaddedBatchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)
  id: PaddedBatchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: PaddedBatchDataset(TFOutput, TFOutput, TFOutput[], TFOutput[], TFShape[], String)
  nameWithType: TFGraph.PaddedBatchDataset(TFOutput, TFOutput, TFOutput[], TFOutput[], TFShape[], String)
  fullName: TFGraph.PaddedBatchDataset(TFOutput, TFOutput, TFOutput[], TFOutput[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that batches and pads <code>batch_size</code> elements from the input.
  syntax:
    content: public TensorFlow.TFOutput PaddedBatchDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput batch_size, TensorFlow.TFOutput[] padded_shapes, TensorFlow.TFOutput[] padding_values, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: batch_size
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing the number of elements to accumulate in a
                      batch.
    - id: padded_shapes
      type: TensorFlow.TFOutput[]
      description: >-
        A list of int64 tensors representing the desired padded shapes
                      of the corresponding output components. These shapes may be partially
                      specified, using <code>-1</code> to indicate that a particular dimension should be
                      padded to the maximum size of all batch elements.
    - id: padding_values
      type: TensorFlow.TFOutput[]
      description: >-
        A list of scalars containing the padding value to use for
                      each of the outputs.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddedBatchDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.PaddedBatchDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.PaddedBatchDatasetV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFShape[],System.String)
  id: PaddedBatchDatasetV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: PaddedBatchDatasetV2(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput, TFShape[], String)
  nameWithType: TFGraph.PaddedBatchDatasetV2(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput, TFShape[], String)
  fullName: TFGraph.PaddedBatchDatasetV2(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput, TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that batches and pads <code>batch_size</code> elements from the input.
  syntax:
    content: public TensorFlow.TFOutput PaddedBatchDatasetV2 (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput batch_size, TensorFlow.TFOutput[] padded_shapes, TensorFlow.TFOutput[] padding_values, TensorFlow.TFOutput drop_remainder, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: batch_size
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing the number of elements to accumulate in a
                      batch.
    - id: padded_shapes
      type: TensorFlow.TFOutput[]
      description: >-
        A list of int64 tensors representing the desired padded shapes
                      of the corresponding output components. These shapes may be partially
                      specified, using <code>-1</code> to indicate that a particular dimension should be
                      padded to the maximum size of all batch elements.
    - id: padding_values
      type: TensorFlow.TFOutput[]
      description: >-
        A list of scalars containing the padding value to use for
                      each of the outputs.
    - id: drop_remainder
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing whether the last batch should be dropped in case its size
                      is smaller than desired.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddedBatchDatasetV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.PaddedBatchDatasetV2*
  exceptions: []
- uid: TensorFlow.TFGraph.PaddingFIFOQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  id: PaddingFIFOQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: PaddingFIFOQueue(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.PaddingFIFOQueue(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.PaddingFIFOQueue(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A queue that produces elements in first-in first-out order.
  remarks: >-
    Variable-size shapes are allowed by setting the corresponding shape dimensions
                  to 0 in the shape attr.  In this case DequeueMany will pad up to the maximum
                  size of any given element in the minibatch.  See below for details.
  syntax:
    content: public TensorFlow.TFOutput PaddingFIFOQueue (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable<long> capacity = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a value.
    - id: shapes
      type: TensorFlow.TFShape[]
      description: >-
        Optional argument
                      The shape of each component in a value. The length of this attr must
                      be either 0 or the same as the length of component_types.
                      Shapes of fixed rank but variable size are allowed by setting
                      any shape dimension to -1.  In this case, the inputs' shape may vary along
                      the given dimension, and DequeueMany will pad the given dimension with
                      zeros up to the maximum shape of all elements in the given batch.
                      If the length of this attr is 0, different queue elements may have
                      different ranks and shapes, but only one element may be dequeued at a time.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The upper bound on the number of elements in this queue.
                      Negative numbers mean no limit.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue will be shared under the given name
                      across multiple sessions.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddingFIFOQueue'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to the queue.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.PaddingFIFOQueue*
  exceptions: []
- uid: TensorFlow.TFGraph.PaddingFIFOQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  id: PaddingFIFOQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: PaddingFIFOQueueV2(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.PaddingFIFOQueueV2(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.PaddingFIFOQueueV2(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A queue that produces elements in first-in first-out order.
  remarks: >-
    Variable-size shapes are allowed by setting the corresponding shape dimensions
                  to 0 in the shape attr.  In this case DequeueMany will pad up to the maximum
                  size of any given element in the minibatch.  See below for details.
  syntax:
    content: public TensorFlow.TFOutput PaddingFIFOQueueV2 (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable<long> capacity = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a value.
    - id: shapes
      type: TensorFlow.TFShape[]
      description: >-
        Optional argument
                      The shape of each component in a value. The length of this attr must
                      be either 0 or the same as the length of component_types.
                      Shapes of fixed rank but variable size are allowed by setting
                      any shape dimension to -1.  In this case, the inputs' shape may vary along
                      the given dimension, and DequeueMany will pad the given dimension with
                      zeros up to the maximum shape of all elements in the given batch.
                      If the length of this attr is 0, different queue elements may have
                      different ranks and shapes, but only one element may be dequeued at a time.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The upper bound on the number of elements in this queue.
                      Negative numbers mean no limit.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue will be shared under the given name
                      across multiple sessions.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'PaddingFIFOQueueV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to the queue.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.PaddingFIFOQueueV2*
  exceptions: []
- uid: TensorFlow.TFGraph.PadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: PadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: PadV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.PadV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.PadV2(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Pads a tensor.
  remarks: "This operation pads <code>input</code> according to the <code>paddings</code> and <code>constant_values</code>\n              you specify. <code>paddings</code> is an integer tensor with shape <code>[Dn, 2]</code>, where n is\n              the rank of <code>input</code>. For each dimension D of <code>input</code>, <code>paddings[D, 0]</code> indicates\n              how many padding values to add before the contents of <code>input</code> in that dimension,\n              and <code>paddings[D, 1]</code> indicates how many padding values to add after the contents\n              of <code>input</code> in that dimension. <code>constant_values</code> is a scalar tensor of the same\n              type as <code>input</code> that indicates the value to use for padding <code>input</code>.\n              \n              The padded size of each dimension D of the output is:\n              \n              <code>paddings(D, 0) + input.dim_size(D) + paddings(D, 1)</code>\n              \n              For example:\n              \n               <pre><code>\n              # 't' is [[1, 1], [2, 2]]\n              # 'paddings' is [[1, 1], [2, 2]]\n              # 'constant_values' is 0\n              # rank of 't' is 2\n              pad(t, paddings) ==&gt; [[0, 0, 0, 0, 0, 0]\n              [0, 0, 1, 1, 0, 0]\n              [0, 0, 2, 2, 0, 0]\n              [0, 0, 0, 0, 0, 0]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput PadV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput paddings, TensorFlow.TFOutput constant_values, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: paddings
      type: TensorFlow.TFOutput
      description: To be added.
    - id: constant_values
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'PadV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.PadV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ParallelConcat(TensorFlow.TFOutput[],TensorFlow.TFShape,System.String)
  id: ParallelConcat(TensorFlow.TFOutput[],TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ParallelConcat(TFOutput[], TFShape, String)
  nameWithType: TFGraph.ParallelConcat(TFOutput[], TFShape, String)
  fullName: TFGraph.ParallelConcat(TFOutput[], TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Concatenates a list of <code>N</code> tensors along the first dimension.
  remarks: "The input tensors are all required to have size 1 in the first dimension.\n              \n              For example:\n              \n               <pre><code>\n              # 'x' is [[1, 4]]\n              # 'y' is [[2, 5]]\n              # 'z' is [[3, 6]]\n              parallel_concat([x, y, z]) =&gt; [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.\n               </code></pre>\n              \n              The difference between concat and parallel_concat is that concat requires all\n              of the inputs be computed before the operation will begin but doesn't require\n              that the input shapes be known during graph construction.  Parallel concat\n              will copy pieces of the input into the output as they become available, in\n              some situations this can provide a performance benefit."
  syntax:
    content: public TensorFlow.TFOutput ParallelConcat (TensorFlow.TFOutput[] values, TensorFlow.TFShape shape, string operName = null);
    parameters:
    - id: values
      type: TensorFlow.TFOutput[]
      description: >-
        Tensors to be concatenated. All must have size 1 in the first dimension
                      and same shape.
    - id: shape
      type: TensorFlow.TFShape
      description: >-
        the final shape of the result; should be equal to the shapes of any input
                      but with the number of input values in the first dimension.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ParallelConcat'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The concatenated tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ParallelConcat*
  exceptions: []
- uid: TensorFlow.TFGraph.ParallelDynamicStitch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  id: ParallelDynamicStitch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ParallelDynamicStitch(TFOutput[], TFOutput[], String)
  nameWithType: TFGraph.ParallelDynamicStitch(TFOutput[], TFOutput[], String)
  fullName: TFGraph.ParallelDynamicStitch(TFOutput[], TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Interleave the values from the <code>data</code> tensors into a single tensor.
  remarks: "Builds a merged tensor such that\n              \n               <pre><code>\n              merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]\n               </code></pre>\n              \n              For example, if each <code>indices[m]</code> is scalar or vector, we have\n              \n               <pre><code>\n              # Scalar indices:\n              merged[indices[m], ...] = data[m][...]\n              \n              # Vector indices:\n              merged[indices[m][i], ...] = data[m][i, ...]\n               </code></pre>\n              \n              Each <code>data[i].shape</code> must start with the corresponding <code>indices[i].shape</code>,\n              and the rest of <code>data[i].shape</code> must be constant w.r.t. <code>i</code>.  That is, we\n              must have <code>data[i].shape = indices[i].shape + constant</code>.  In terms of this\n              <code>constant</code>, the output shape is\n              \n              merged.shape = [max(indices)] + constant\n              \n              Values may be merged in parallel, so if an index appears in both <code>indices[m][i]</code>\n              and <code>indices[n][j]</code>, the result may be invalid. This differs from the normal\n              DynamicStitch operator that defines the behavior in that case.\n              \n              For example:\n              \n               <pre><code>\n              indices[0] = 6\n              indices[1] = [4, 1]\n              indices[2] = [[5, 2], [0, 3]]\n              data[0] = [61, 62]\n              data[1] = [[41, 42], [11, 12]]\n              data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]\n              merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],\n              [51, 52], [61, 62]]\n               </code></pre>\n              \n              This method can be used to merge partitions created by <code>dynamic_partition</code>\n              as illustrated on the following example:\n              \n               <pre><code>\n              # Apply function (increments x_i) on elements for which a certain condition\n              # apply (x_i != -1 in this example).\n              x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])\n              condition_mask=tf.not_equal(x,tf.constant(-1.))\n              partitioned_data = tf.dynamic_partition(\n              x, tf.cast(condition_mask, tf.int32) , 2)\n              partitioned_data[1] = partitioned_data[1] + 1.0\n              condition_indices = tf.dynamic_partition(\n              tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)\n              x = tf.dynamic_stitch(condition_indices, partitioned_data)\n              # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain\n              # unchanged.\n               </code></pre>\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/DynamicStitch.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput ParallelDynamicStitch (TensorFlow.TFOutput[] indices, TensorFlow.TFOutput[] data, string operName = null);
    parameters:
    - id: indices
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: data
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ParallelDynamicStitch'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ParallelDynamicStitch*
  exceptions: []
- uid: TensorFlow.TFGraph.ParameterizedTruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: ParameterizedTruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ParameterizedTruncatedNormal(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.ParameterizedTruncatedNormal(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.ParameterizedTruncatedNormal(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs random values from a normal distribution. The parameters may each be a
  remarks: >-
    scalar which applies to the entire output, or a vector of length shape[0] which
                  stores the parameters for each batch.
  syntax:
    content: public TensorFlow.TFOutput ParameterizedTruncatedNormal (TensorFlow.TFOutput shape, TensorFlow.TFOutput means, TensorFlow.TFOutput stdevs, TensorFlow.TFOutput minvals, TensorFlow.TFOutput maxvals, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFOutput
      description: The shape of the output tensor. Batches are indexed by the 0th dimension.
    - id: means
      type: TensorFlow.TFOutput
      description: The mean parameter of each batch.
    - id: stdevs
      type: TensorFlow.TFOutput
      description: The standard deviation parameter of each batch. Must be greater than 0.
    - id: minvals
      type: TensorFlow.TFOutput
      description: The minimum cutoff. May be -infinity.
    - id: maxvals
      type: TensorFlow.TFOutput
      description: >-
        The maximum cutoff. May be +infinity, and must be more than the minval
                      for each batch.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ParameterizedTruncatedNormal'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A matrix of shape num_batches x samples_per_batch, filled with random
                      truncated normal values using the parameters for each row.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ParameterizedTruncatedNormal*
  exceptions: []
- uid: TensorFlow.TFGraph.ParseExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: ParseExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ParseExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ParseExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFDataType[], TFShape[], String)
  fullName: TFGraph.ParseExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Transforms a vector of brain.Example protos (as strings) into typed tensors.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]> ParseExample (TensorFlow.TFOutput serialized, TensorFlow.TFOutput names, TensorFlow.TFOutput[] sparse_keys, TensorFlow.TFOutput[] dense_keys, TensorFlow.TFOutput[] dense_defaults, TensorFlow.TFDataType[] sparse_types, TensorFlow.TFShape[] dense_shapes, string operName = null);
    parameters:
    - id: serialized
      type: TensorFlow.TFOutput
      description: A vector containing a batch of binary serialized Example protos.
    - id: names
      type: TensorFlow.TFOutput
      description: >-
        A vector containing the names of the serialized protos.
                      May contain, for example, table key (descriptive) names for the
                      corresponding serialized protos.  These are purely useful for debugging
                      purposes, and the presence of values here has no effect on the output.
                      May also be an empty vector if no names are available.
                      If non-empty, this vector must be the same length as "serialized".
    - id: sparse_keys
      type: TensorFlow.TFOutput[]
      description: >-
        A list of Nsparse string Tensors (scalars).
                      The keys expected in the Examples' features associated with sparse values.
    - id: dense_keys
      type: TensorFlow.TFOutput[]
      description: >-
        A list of Ndense string Tensors (scalars).
                      The keys expected in the Examples' features associated with dense values.
    - id: dense_defaults
      type: TensorFlow.TFOutput[]
      description: >-
        A list of Ndense Tensors (some may be empty).
                      dense_defaults[j] provides default values
                      when the example's feature_map lacks dense_key[j].  If an empty Tensor is
                      provided for dense_defaults[j], then the Feature dense_keys[j] is required.
                      The input type is inferred from dense_defaults[j], even when it's empty.
                      If dense_defaults[j] is not empty, and dense_shapes[j] is fully defined,
                      then the shape of dense_defaults[j] must match that of dense_shapes[j].
                      If dense_shapes[j] has an undefined major dimension (variable strides dense
                      feature), dense_defaults[j] must contain a single element:
                      the padding element.
    - id: sparse_types
      type: TensorFlow.TFDataType[]
      description: >-
        A list of Nsparse types; the data types of data in each Feature
                      given in sparse_keys.
                      Currently the ParseExample supports DT_FLOAT (FloatList),
                      DT_INT64 (Int64List), and DT_STRING (BytesList).
    - id: dense_shapes
      type: TensorFlow.TFShape[]
      description: >-
        A list of Ndense shapes; the shapes of data in each Feature
                      given in dense_keys.
                      The number of elements in the Feature corresponding to dense_key[j]
                      must always equal dense_shapes[j].NumEntries().
                      If dense_shapes[j] == (D0, D1, ..., DN) then the shape of output
                      Tensor dense_values[j] will be (|serialized|, D0, D1, ..., DN):
                      The dense outputs are just the inputs row-stacked by batch.
                      This works for dense_shapes[j] = (-1, D1, ..., DN).  In this case
                      the shape of the output Tensor dense_values[j] will be
                      (|serialized|, M, D1, .., DN), where M is the maximum number of blocks
                      of elements of length D1 * .... * DN, across all minibatch entries
                      in the input.  Any minibatch entry with less than M blocks of elements of
                      length D1 * ... * DN will be padded with the corresponding default_value
                      scalar element along the second dimension.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseExample'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sparse_indices:
                      sparse_values:
                      sparse_shapes:
                      dense_values:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.ParseExample*
  exceptions: []
- uid: TensorFlow.TFGraph.ParseSequenceExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String[],System.String[],System.String[],System.String[],System.String[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},TensorFlow.TFDataType[],TensorFlow.TFDataType[],TensorFlow.TFShape[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: ParseSequenceExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String[],System.String[],System.String[],System.String[],System.String[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},TensorFlow.TFDataType[],TensorFlow.TFDataType[],TensorFlow.TFShape[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ParseSequenceExample(TFOutput, TFOutput, TFOutput[], String[], String[], String[], String[], String[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ParseSequenceExample(TFOutput, TFOutput, TFOutput[], String[], String[], String[], String[], String[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)
  fullName: TFGraph.ParseSequenceExample(TFOutput, TFOutput, TFOutput[], String[], String[], String[], String[], String[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Transforms a vector of brain.SequenceExample protos (as strings) into typed tensors.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[]>> ParseSequenceExample (TensorFlow.TFOutput serialized, TensorFlow.TFOutput debug_name, TensorFlow.TFOutput[] context_dense_defaults, string[] feature_list_dense_missing_assumed_empty, string[] context_sparse_keys, string[] context_dense_keys, string[] feature_list_sparse_keys, string[] feature_list_dense_keys, Nullable<long> Ncontext_sparse = null, Nullable<long> Ncontext_dense = null, Nullable<long> Nfeature_list_sparse = null, Nullable<long> Nfeature_list_dense = null, TensorFlow.TFDataType[] context_sparse_types = null, TensorFlow.TFDataType[] feature_list_dense_types = null, TensorFlow.TFShape[] context_dense_shapes = null, TensorFlow.TFDataType[] feature_list_sparse_types = null, TensorFlow.TFShape[] feature_list_dense_shapes = null, string operName = null);
    parameters:
    - id: serialized
      type: TensorFlow.TFOutput
      description: A vector containing binary serialized SequenceExample protos.
    - id: debug_name
      type: TensorFlow.TFOutput
      description: >-
        A vector containing the names of the serialized protos.
                      May contain, for example, table key (descriptive) name for the
                      corresponding serialized proto.  This is purely useful for debugging
                      purposes, and the presence of values here has no effect on the output.
                      May also be an empty vector if no name is available.
    - id: context_dense_defaults
      type: TensorFlow.TFOutput[]
      description: >-
        A list of Ncontext_dense Tensors (some may be empty).
                      context_dense_defaults[j] provides default values
                      when the SequenceExample's context map lacks context_dense_key[j].
                      If an empty Tensor is provided for context_dense_defaults[j],
                      then the Feature context_dense_keys[j] is required.
                      The input type is inferred from context_dense_defaults[j], even when it's
                      empty.  If context_dense_defaults[j] is not empty, its shape must match
                      context_dense_shapes[j].
    - id: feature_list_dense_missing_assumed_empty
      type: System.String[]
      description: >-
        A vector listing the
                      FeatureList keys which may be missing from the SequenceExamples.  If the
                      associated FeatureList is missing, it is treated as empty.  By default,
                      any FeatureList not listed in this vector must exist in the SequenceExamples.
    - id: context_sparse_keys
      type: System.String[]
      description: >-
        A list of Ncontext_sparse string Tensors (scalars).
                      The keys expected in the Examples' features associated with context_sparse
                      values.
    - id: context_dense_keys
      type: System.String[]
      description: >-
        A list of Ncontext_dense string Tensors (scalars).
                      The keys expected in the SequenceExamples' context features associated with
                      dense values.
    - id: feature_list_sparse_keys
      type: System.String[]
      description: >-
        A list of Nfeature_list_sparse string Tensors
                      (scalars).  The keys expected in the FeatureLists associated with sparse
                      values.
    - id: feature_list_dense_keys
      type: System.String[]
      description: >-
        A list of Nfeature_list_dense string Tensors (scalars).
                      The keys expected in the SequenceExamples' feature_lists associated
                      with lists of dense values.
    - id: Ncontext_sparse
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: Ncontext_dense
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: Nfeature_list_sparse
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: Nfeature_list_dense
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: context_sparse_types
      type: TensorFlow.TFDataType[]
      description: >-
        Optional argument
                      A list of Ncontext_sparse types; the data types of data in
                      each context Feature given in context_sparse_keys.
                      Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
                      DT_INT64 (Int64List), and DT_STRING (BytesList).
    - id: feature_list_dense_types
      type: TensorFlow.TFDataType[]
      description: Optional argument
    - id: context_dense_shapes
      type: TensorFlow.TFShape[]
      description: >-
        Optional argument
                      A list of Ncontext_dense shapes; the shapes of data in
                      each context Feature given in context_dense_keys.
                      The number of elements in the Feature corresponding to context_dense_key[j]
                      must always equal context_dense_shapes[j].NumEntries().
                      The shape of context_dense_values[j] will match context_dense_shapes[j].
    - id: feature_list_sparse_types
      type: TensorFlow.TFDataType[]
      description: >-
        Optional argument
                      A list of Nfeature_list_sparse types; the data types
                      of data in each FeatureList given in feature_list_sparse_keys.
                      Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
                      DT_INT64 (Int64List), and DT_STRING (BytesList).
    - id: feature_list_dense_shapes
      type: TensorFlow.TFShape[]
      description: >-
        Optional argument
                      A list of Nfeature_list_dense shapes; the shapes of
                      data in each FeatureList given in feature_list_dense_keys.
                      The shape of each Feature in the FeatureList corresponding to
                      feature_list_dense_key[j] must always equal
                      feature_list_dense_shapes[j].NumEntries().
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseSequenceExample'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[]}}
      description: >-
        Returns a tuple with multiple values, as follows:
                      context_sparse_indices:
                      context_sparse_values:
                      context_sparse_shapes:
                      context_dense_values:
                      feature_list_sparse_indices:
                      feature_list_sparse_values:
                      feature_list_sparse_shapes:
                      feature_list_dense_values:
                      feature_list_dense_lengths:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.ParseSequenceExample*
  exceptions: []
- uid: TensorFlow.TFGraph.ParseSingleExample(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String[],System.String[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: ParseSingleExample(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String[],System.String[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ParseSingleExample(TFOutput, TFOutput[], Int64, String[], String[], TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ParseSingleExample(TFOutput, TFOutput[], Int64, String[], String[], TFDataType[], TFShape[], String)
  fullName: TFGraph.ParseSingleExample(TFOutput, TFOutput[], Int64, String[], String[], TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Transforms a tf.Example proto (as a string) into typed tensors.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]> ParseSingleExample (TensorFlow.TFOutput serialized, TensorFlow.TFOutput[] dense_defaults, long num_sparse, string[] sparse_keys, string[] dense_keys, TensorFlow.TFDataType[] sparse_types, TensorFlow.TFShape[] dense_shapes, string operName = null);
    parameters:
    - id: serialized
      type: TensorFlow.TFOutput
      description: A vector containing a batch of binary serialized Example protos.
    - id: dense_defaults
      type: TensorFlow.TFOutput[]
      description: >-
        A list of Tensors (some may be empty), whose length matches
                      the length of <code>dense_keys</code>. dense_defaults[j] provides default values
                      when the example's feature_map lacks dense_key[j].  If an empty Tensor is
                      provided for dense_defaults[j], then the Feature dense_keys[j] is required.
                      The input type is inferred from dense_defaults[j], even when it's empty.
                      If dense_defaults[j] is not empty, and dense_shapes[j] is fully defined,
                      then the shape of dense_defaults[j] must match that of dense_shapes[j].
                      If dense_shapes[j] has an undefined major dimension (variable strides dense
                      feature), dense_defaults[j] must contain a single element:
                      the padding element.
    - id: num_sparse
      type: System.Int64
      description: >-
        The number of sparse features to be parsed from the example. This
                      must match the lengths of <code>sparse_keys</code> and <code>sparse_types</code>.
    - id: sparse_keys
      type: System.String[]
      description: >-
        A list of <code>num_sparse</code> strings.
                      The keys expected in the Examples' features associated with sparse values.
    - id: dense_keys
      type: System.String[]
      description: >-
        The keys expected in the Examples' features associated with dense
                      values.
    - id: sparse_types
      type: TensorFlow.TFDataType[]
      description: >-
        A list of <code>num_sparse</code> types; the data types of data in each
                      Feature given in sparse_keys.
                      Currently the ParseSingleExample op supports DT_FLOAT (FloatList),
                      DT_INT64 (Int64List), and DT_STRING (BytesList).
    - id: dense_shapes
      type: TensorFlow.TFShape[]
      description: >-
        The shapes of data in each Feature given in dense_keys.
                      The length of this list must match the length of <code>dense_keys</code>.  The
                      number of elements in the Feature corresponding to dense_key[j] must
                      always equal dense_shapes[j].NumEntries().  If dense_shapes[j] ==
                      (D0, D1, ..., DN) then the shape of output Tensor dense_values[j]
                      will be (D0, D1, ..., DN): In the case dense_shapes[j] = (-1, D1,
                      ..., DN), the shape of the output Tensor dense_values[j] will be (M,
                      D1, .., DN), where M is the number of blocks of elements of length
                      D1 * .... * DN, in the input.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseSingleExample'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sparse_indices:
                      sparse_values:
                      sparse_shapes:
                      dense_values:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.ParseSingleExample*
  exceptions: []
- uid: TensorFlow.TFGraph.ParseSingleSequenceExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFDataType[],TensorFlow.TFShape[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: ParseSingleSequenceExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFDataType[],TensorFlow.TFShape[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ParseSingleSequenceExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ParseSingleSequenceExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)
  fullName: TFGraph.ParseSingleSequenceExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Transforms a scalar brain.SequenceExample proto (as strings) into typed tensors.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],ValueTuple<TensorFlow.TFOutput[]>> ParseSingleSequenceExample (TensorFlow.TFOutput serialized, TensorFlow.TFOutput feature_list_dense_missing_assumed_empty, TensorFlow.TFOutput[] context_sparse_keys, TensorFlow.TFOutput[] context_dense_keys, TensorFlow.TFOutput[] feature_list_sparse_keys, TensorFlow.TFOutput[] feature_list_dense_keys, TensorFlow.TFOutput[] context_dense_defaults, TensorFlow.TFOutput debug_name, TensorFlow.TFDataType[] context_sparse_types = null, TensorFlow.TFDataType[] feature_list_dense_types = null, TensorFlow.TFShape[] context_dense_shapes = null, TensorFlow.TFDataType[] feature_list_sparse_types = null, TensorFlow.TFShape[] feature_list_dense_shapes = null, string operName = null);
    parameters:
    - id: serialized
      type: TensorFlow.TFOutput
      description: A scalar containing a binary serialized SequenceExample proto.
    - id: feature_list_dense_missing_assumed_empty
      type: TensorFlow.TFOutput
      description: >-
        A vector listing the
                      FeatureList keys which may be missing from the SequenceExample.  If the
                      associated FeatureList is missing, it is treated as empty.  By default,
                      any FeatureList not listed in this vector must exist in the SequenceExample.
    - id: context_sparse_keys
      type: TensorFlow.TFOutput[]
      description: >-
        A list of Ncontext_sparse string Tensors (scalars).
                      The keys expected in the Examples' features associated with context_sparse
                      values.
    - id: context_dense_keys
      type: TensorFlow.TFOutput[]
      description: >-
        A list of Ncontext_dense string Tensors (scalars).
                      The keys expected in the SequenceExamples' context features associated with
                      dense values.
    - id: feature_list_sparse_keys
      type: TensorFlow.TFOutput[]
      description: >-
        A list of Nfeature_list_sparse string Tensors
                      (scalars).  The keys expected in the FeatureLists associated with sparse
                      values.
    - id: feature_list_dense_keys
      type: TensorFlow.TFOutput[]
      description: >-
        A list of Nfeature_list_dense string Tensors (scalars).
                      The keys expected in the SequenceExamples' feature_lists associated
                      with lists of dense values.
    - id: context_dense_defaults
      type: TensorFlow.TFOutput[]
      description: >-
        A list of Ncontext_dense Tensors (some may be empty).
                      context_dense_defaults[j] provides default values
                      when the SequenceExample's context map lacks context_dense_key[j].
                      If an empty Tensor is provided for context_dense_defaults[j],
                      then the Feature context_dense_keys[j] is required.
                      The input type is inferred from context_dense_defaults[j], even when it's
                      empty.  If context_dense_defaults[j] is not empty, its shape must match
                      context_dense_shapes[j].
    - id: debug_name
      type: TensorFlow.TFOutput
      description: >-
        A scalar containing the name of the serialized proto.
                      May contain, for example, table key (descriptive) name for the
                      corresponding serialized proto.  This is purely useful for debugging
                      purposes, and the presence of values here has no effect on the output.
                      May also be an empty scalar if no name is available.
    - id: context_sparse_types
      type: TensorFlow.TFDataType[]
      description: >-
        Optional argument
                      A list of Ncontext_sparse types; the data types of data in
                      each context Feature given in context_sparse_keys.
                      Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
                      DT_INT64 (Int64List), and DT_STRING (BytesList).
    - id: feature_list_dense_types
      type: TensorFlow.TFDataType[]
      description: Optional argument
    - id: context_dense_shapes
      type: TensorFlow.TFShape[]
      description: >-
        Optional argument
                      A list of Ncontext_dense shapes; the shapes of data in
                      each context Feature given in context_dense_keys.
                      The number of elements in the Feature corresponding to context_dense_key[j]
                      must always equal context_dense_shapes[j].NumEntries().
                      The shape of context_dense_values[j] will match context_dense_shapes[j].
    - id: feature_list_sparse_types
      type: TensorFlow.TFDataType[]
      description: >-
        Optional argument
                      A list of Nfeature_list_sparse types; the data types
                      of data in each FeatureList given in feature_list_sparse_keys.
                      Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
                      DT_INT64 (Int64List), and DT_STRING (BytesList).
    - id: feature_list_dense_shapes
      type: TensorFlow.TFShape[]
      description: >-
        Optional argument
                      A list of Nfeature_list_dense shapes; the shapes of
                      data in each FeatureList given in feature_list_dense_keys.
                      The shape of each Feature in the FeatureList corresponding to
                      feature_list_dense_key[j] must always equal
                      feature_list_dense_shapes[j].NumEntries().
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseSingleSequenceExample'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.ValueTuple{TensorFlow.TFOutput[]}}
      description: >-
        Returns a tuple with multiple values, as follows:
                      context_sparse_indices:
                      context_sparse_values:
                      context_sparse_shapes:
                      context_dense_values:
                      feature_list_sparse_indices:
                      feature_list_sparse_values:
                      feature_list_sparse_shapes:
                      feature_list_dense_values:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.ParseSingleSequenceExample*
  exceptions: []
- uid: TensorFlow.TFGraph.ParseTensor(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: ParseTensor(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ParseTensor(TFOutput, TFDataType, String)
  nameWithType: TFGraph.ParseTensor(TFOutput, TFDataType, String)
  fullName: TFGraph.ParseTensor(TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Transforms a serialized tensorflow.TensorProto proto into a Tensor.
  syntax:
    content: public TensorFlow.TFOutput ParseTensor (TensorFlow.TFOutput serialized, TensorFlow.TFDataType out_type, string operName = null);
    parameters:
    - id: serialized
      type: TensorFlow.TFOutput
      description: A scalar string containing a serialized TensorProto proto.
    - id: out_type
      type: TensorFlow.TFDataType
      description: >-
        The type of the serialized tensor.  The provided type must match the
                      type of the serialized tensor and no implicit conversion will take place.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ParseTensor'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A Tensor of type <code>out_type</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ParseTensor*
  exceptions: []
- uid: TensorFlow.TFGraph.Placeholder(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  id: Placeholder(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Placeholder(TFDataType, TFShape, String)
  nameWithType: TFGraph.Placeholder(TFDataType, TFShape, String)
  fullName: TFGraph.Placeholder(TFDataType, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A placeholder op for a value that will be fed into the computation.
  remarks: >-
    N.B. This operation will fail with an error if it is executed. It is
                  intended as a way to represent a value that will always be fed, and to
                  provide attrs that enable the fed value to be checked at runtime.
  syntax:
    content: public TensorFlow.TFOutput Placeholder (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape = null, string operName = null);
    parameters:
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of elements in the tensor.
    - id: shape
      type: TensorFlow.TFShape
      description: >-
        Optional argument
                      (Optional) The shape of the tensor. If the shape has 0 dimensions, the
                      shape is unconstrained.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Placeholder'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A placeholder tensor that must be replaced using the feed mechanism.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Placeholder*
  exceptions: []
- uid: TensorFlow.TFGraph.PlaceholderV2(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  id: PlaceholderV2(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: PlaceholderV2(TFDataType, TFShape, String)
  nameWithType: TFGraph.PlaceholderV2(TFDataType, TFShape, String)
  fullName: TFGraph.PlaceholderV2(TFDataType, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A placeholder op for a value that will be fed into the computation.
  remarks: >-
    N.B. This operation will fail with an error if it is executed. It is
                  intended as a way to represent a value that will always be fed, and to
                  provide attrs that enable the fed value to be checked at runtime.
  syntax:
    content: public TensorFlow.TFOutput PlaceholderV2 (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string operName = null);
    parameters:
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of elements in the tensor.
    - id: shape
      type: TensorFlow.TFShape
      description: >-
        The shape of the tensor. The shape can be any partially-specified
                      shape.  To be unconstrained, pass in a shape with unknown rank.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'PlaceholderV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A placeholder tensor that must be replaced using the feed mechanism.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.PlaceholderV2*
  exceptions: []
- uid: TensorFlow.TFGraph.PlaceholderWithDefault(TensorFlow.TFOutput,TensorFlow.TFShape,System.String)
  id: PlaceholderWithDefault(TensorFlow.TFOutput,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: PlaceholderWithDefault(TFOutput, TFShape, String)
  nameWithType: TFGraph.PlaceholderWithDefault(TFOutput, TFShape, String)
  fullName: TFGraph.PlaceholderWithDefault(TFOutput, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A placeholder op that passes through <code>input</code> when its output is not fed.
  syntax:
    content: public TensorFlow.TFOutput PlaceholderWithDefault (TensorFlow.TFOutput input, TensorFlow.TFShape shape, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The default value to produce when <code>output</code> is not fed.
    - id: shape
      type: TensorFlow.TFShape
      description: The (possibly partial) shape of the tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'PlaceholderWithDefault'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A placeholder tensor that defaults to <code>input</code> if it is not fed.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.PlaceholderWithDefault*
  exceptions: []
- uid: TensorFlow.TFGraph.Polygamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Polygamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Polygamma(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Polygamma(TFOutput, TFOutput, String)
  fullName: TFGraph.Polygamma(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Compute the polygamma function \\(\psi^{(n)}(x)\\).
  remarks: "The polygamma function is defined as:\n              \n              \n              \\\\(\\psi^{(n)}(x) = \\frac{d^n}{dx^n} \\psi(x)\\\\)\n              \n              where \\\\(\\psi(x)\\\\) is the digamma function."
  syntax:
    content: public TensorFlow.TFOutput Polygamma (TensorFlow.TFOutput a, TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: a
      type: TensorFlow.TFOutput
      description: To be added.
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Polygamma'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Polygamma*
  exceptions: []
- uid: TensorFlow.TFGraph.PopulationCount(TensorFlow.TFOutput,System.String)
  id: PopulationCount(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: PopulationCount(TFOutput, String)
  nameWithType: TFGraph.PopulationCount(TFOutput, String)
  fullName: TFGraph.PopulationCount(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes element-wise population count (a.k.a. popcount, bitsum, bitcount).
  remarks: "For each entry in <code>x</code>, calculates the number of <code>1</code> (on) bits in the binary\n              representation of that entry.\n              \n              **NOTE**: It is more efficient to first <code>tf.bitcast</code> your tensors into\n              <code>int32</code> or <code>int64</code> and perform the bitcount on the result, than to feed in\n              8- or 16-bit inputs and then aggregate the resulting counts."
  syntax:
    content: public TensorFlow.TFOutput PopulationCount (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'PopulationCount'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.PopulationCount*
  exceptions: []
- uid: TensorFlow.TFGraph.Pow(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Pow(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Pow(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Pow(TFOutput, TFOutput, String)
  fullName: TFGraph.Pow(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the power of one value to another.
  remarks: "Given a tensor <code>x</code> and a tensor <code>y</code>, this operation computes \\\\(x^y\\\\) for\n              corresponding elements in <code>x</code> and <code>y</code>. For example:\n              \n               <pre><code>\n              # tensor 'x' is [[2, 2]], [3, 3]]\n              # tensor 'y' is [[8, 16], [2, 3]]\n              tf.pow(x, y) ==&gt; [[256, 65536], [9, 27]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Pow (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Pow'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Pow*
  exceptions: []
- uid: TensorFlow.TFGraph.PrefetchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: PrefetchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: PrefetchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.PrefetchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.PrefetchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that asynchronously prefetches elements from <code>input_dataset</code>.
  syntax:
    content: public TensorFlow.TFOutput PrefetchDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput buffer_size, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: buffer_size
      type: TensorFlow.TFOutput
      description: >-
        The maximum number of elements to buffer in an iterator over
                      this dataset.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'PrefetchDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.PrefetchDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.PreventGradient(TensorFlow.TFOutput,System.String,System.String)
  id: PreventGradient(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: PreventGradient(TFOutput, String, String)
  nameWithType: TFGraph.PreventGradient(TFOutput, String, String)
  fullName: TFGraph.PreventGradient(TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An identity op that triggers an error if a gradient is requested.
  remarks: "When executed in a graph, this op outputs its input tensor as-is.\n              \n              When building ops to compute gradients, the TensorFlow gradient system\n              will return an error when trying to lookup the gradient of this op,\n              because no gradient must ever be registered for this function.  This\n              op exists to prevent subtle bugs from silently returning unimplemented\n              gradients in some corner cases."
  syntax:
    content: public TensorFlow.TFOutput PreventGradient (TensorFlow.TFOutput input, string message = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: any tensor.
    - id: message
      type: System.String
      description: >-
        Optional argument
                      Will be printed in the error when anyone tries to differentiate
                      this operation.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'PreventGradient'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        the same input tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.PreventGradient*
  exceptions: []
- uid: TensorFlow.TFGraph.Print(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: Print(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Print(TFOutput, TFOutput[], String, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.Print(TFOutput, TFOutput[], String, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.Print(TFOutput, TFOutput[], String, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Prints a list of tensors.
  remarks: Passes <code>input</code> through to <code>output</code> and prints <code>data</code> when evaluating.
  syntax:
    content: public TensorFlow.TFOutput Print (TensorFlow.TFOutput input, TensorFlow.TFOutput[] data, string message = null, Nullable<long> first_n = null, Nullable<long> summarize = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The tensor passed to <code>output</code>
    - id: data
      type: TensorFlow.TFOutput[]
      description: A list of tensors to print out when op is evaluated.
    - id: message
      type: System.String
      description: >-
        Optional argument
                      A string, prefix of the error message.
    - id: first_n
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Only log <code>first_n</code> number of times. -1 disables logging.
    - id: summarize
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Only print this many entries of each tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Print'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        = The unmodified <code>input</code> tensor
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Print*
  exceptions: []
- uid: TensorFlow.TFGraph.PrintV2(TensorFlow.TFOutput,System.String,System.String)
  id: PrintV2(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: PrintV2(TFOutput, String, String)
  nameWithType: TFGraph.PrintV2(TFOutput, String, String)
  fullName: TFGraph.PrintV2(TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Prints a string scalar.
  remarks: Prints a string scalar to the desired output_stream.
  syntax:
    content: public TensorFlow.TFOperation PrintV2 (TensorFlow.TFOutput input, string output_stream = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The string scalar to print.
    - id: output_stream
      type: System.String
      description: >-
        Optional argument
                      A string specifying the output stream or logging level to print to.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'PrintV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.PrintV2*
  exceptions: []
- uid: TensorFlow.TFGraph.PriorityQueue(TensorFlow.TFShape[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String,System.String,System.String)
  id: PriorityQueue(TensorFlow.TFShape[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: PriorityQueue(TFShape[], TFDataType[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.PriorityQueue(TFShape[], TFDataType[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.PriorityQueue(TFShape[], TFDataType[], Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A queue that produces elements sorted by the first component value.
  remarks: >-
    Note that the PriorityQueue requires the first component of any element
                  to be a scalar int64, in addition to the other elements declared by
                  component_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue
                  and DequeueMany) on a PriorityQueue will all require (resp. output) one extra
                  entry in their input (resp. output) lists.
  syntax:
    content: public TensorFlow.TFOutput PriorityQueue (TensorFlow.TFShape[] shapes, TensorFlow.TFDataType[] component_types = null, Nullable<long> capacity = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: shapes
      type: TensorFlow.TFShape[]
      description: >-
        The shape of each component in a value. The length of this attr must
                      be either 0 or the same as the length of component_types. If the length of
                      this attr is 0, the shapes of queue elements are not constrained, and
                      only one element may be dequeued at a time.
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: >-
        Optional argument
                      The type of each component in a value.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The upper bound on the number of elements in this queue.
                      Negative numbers mean no limit.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue will be shared under the given name
                      across multiple sessions.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'PriorityQueue'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to the queue.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.PriorityQueue*
  exceptions: []
- uid: TensorFlow.TFGraph.PriorityQueueV2(TensorFlow.TFShape[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String,System.String,System.String)
  id: PriorityQueueV2(TensorFlow.TFShape[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: PriorityQueueV2(TFShape[], TFDataType[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.PriorityQueueV2(TFShape[], TFDataType[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.PriorityQueueV2(TFShape[], TFDataType[], Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A queue that produces elements sorted by the first component value.
  remarks: >-
    Note that the PriorityQueue requires the first component of any element
                  to be a scalar int64, in addition to the other elements declared by
                  component_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue
                  and DequeueMany) on a PriorityQueue will all require (resp. output) one extra
                  entry in their input (resp. output) lists.
  syntax:
    content: public TensorFlow.TFOutput PriorityQueueV2 (TensorFlow.TFShape[] shapes, TensorFlow.TFDataType[] component_types = null, Nullable<long> capacity = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: shapes
      type: TensorFlow.TFShape[]
      description: >-
        The shape of each component in a value. The length of this attr must
                      be either 0 or the same as the length of component_types. If the length of
                      this attr is 0, the shapes of queue elements are not constrained, and
                      only one element may be dequeued at a time.
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: >-
        Optional argument
                      The type of each component in a value.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The upper bound on the number of elements in this queue.
                      Negative numbers mean no limit.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue will be shared under the given name
                      across multiple sessions.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'PriorityQueueV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to the queue.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.PriorityQueueV2*
  exceptions: []
- uid: TensorFlow.TFGraph.Prod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: Prod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Prod(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Prod(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Prod(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the product of elements across dimensions of a tensor.
  remarks: >-
    Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
                  <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
                  <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
                  retained with length 1.
  syntax:
    content: public TensorFlow.TFOutput Prod (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable<bool> keep_dims = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The tensor to reduce.
    - id: reduction_indices
      type: TensorFlow.TFOutput
      description: >-
        The dimensions to reduce. Must be in the range
                      <code>[-rank(input), rank(input))</code>.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, retain reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Prod'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The reduced tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Prod*
  exceptions: []
- uid: TensorFlow.TFGraph.Qr(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: Qr(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Qr(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Qr(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Qr(TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the QR decompositions of one or more matrices.
  remarks: >-
    Computes the QR decomposition of each inner matrix in <code>tensor</code> such that
                  <code>tensor[..., :, :] = q[..., :, :] * r[..., :,:])</code><pre><code>
                  # a is a tensor.
                  # q is a tensor of orthonormal matrices.
                  # r is a tensor of upper triangular matrices.
                  q, r = qr(a)
                  q_full, r_full = qr(a, full_matrices=True)
                   </code></pre>
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> Qr (TensorFlow.TFOutput input, Nullable<bool> full_matrices = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: >-
        A tensor of shape <code>[..., M, N]</code> whose inner-most 2 dimensions
                      form matrices of size <code>[M, N]</code>. Let <code>P</code> be the minimum of <code>M</code> and <code>N</code>.
    - id: full_matrices
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, compute full-sized <code>q</code> and <code>r</code>. If false
                      (the default), compute only the leading <code>P</code> columns of <code>q</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Qr'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      q: Orthonormal basis for range of <code>a</code>. If <code>full_matrices</code> is <code>False</code> then
                      shape is <code>[..., M, P]</code>; if <code>full_matrices</code> is <code>True</code> then shape is
                      <code>[..., M, M]</code>.
                      r: Triangular factor. If <code>full_matrices</code> is <code>False</code> then shape is
                      <code>[..., P, N]</code>. If <code>full_matrices</code> is <code>True</code> then shape is <code>[..., M, N]</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.Qr*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizeAndDequantize(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  id: QuantizeAndDequantize(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizeAndDequantize(TFOutput, Nullable<Boolean>, Nullable<Int64>, Nullable<Boolean>, Nullable<Single>, Nullable<Single>, String)
  nameWithType: TFGraph.QuantizeAndDequantize(TFOutput, Nullable<Boolean>, Nullable<Int64>, Nullable<Boolean>, Nullable<Single>, Nullable<Single>, String)
  fullName: TFGraph.QuantizeAndDequantize(TFOutput, Nullable<Boolean>, Nullable<Int64>, Nullable<Boolean>, Nullable<Single>, Nullable<Single>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Use QuantizeAndDequantizeV2 instead.
  syntax:
    content: public TensorFlow.TFOutput QuantizeAndDequantize (TensorFlow.TFOutput input, Nullable<bool> signed_input = null, Nullable<long> num_bits = null, Nullable<bool> range_given = null, Nullable<float> input_min = null, Nullable<float> input_max = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: signed_input
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: num_bits
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: range_given
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: input_min
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: input_max
      type: System.Nullable{System.Single}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeAndDequantize'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.QuantizeAndDequantize*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizeAndDequantizeV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: QuantizeAndDequantizeV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizeAndDequantizeV3(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.QuantizeAndDequantizeV3(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.QuantizeAndDequantizeV3(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Quantizes then dequantizes a tensor.
  remarks: >-
    This is almost identical to QuantizeAndDequantizeV2, except that num_bits is a
                  tensor, so its value can change during training.
  syntax:
    content: public TensorFlow.TFOutput QuantizeAndDequantizeV3 (TensorFlow.TFOutput input, TensorFlow.TFOutput input_min, TensorFlow.TFOutput input_max, TensorFlow.TFOutput num_bits, Nullable<bool> signed_input = null, Nullable<bool> range_given = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_min
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_max
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_bits
      type: TensorFlow.TFOutput
      description: To be added.
    - id: signed_input
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: range_given
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeAndDequantizeV3'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.QuantizeAndDequantizeV3*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: QuantizedAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.QuantizedAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.QuantizedAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns x + y element-wise, working on quantized buffers.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedAdd (TensorFlow.TFOutput x, TensorFlow.TFOutput y, TensorFlow.TFOutput min_x, TensorFlow.TFOutput max_x, TensorFlow.TFOutput min_y, TensorFlow.TFOutput max_y, Nullable<TensorFlow.TFDataType> Toutput = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: min_x
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized <code>x</code> value represents.
    - id: max_x
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized <code>x</code> value represents.
    - id: min_y
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized <code>y</code> value represents.
    - id: max_y
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized <code>y</code> value represents.
    - id: Toutput
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedAdd'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: "Returns a tuple with multiple values, as follows:\n              z:\n              min_z: The float value that the lowest quantized output value represents.\n              max_z: The float value that the highest quantized output value represents.\n              \n              *NOTE*: <code>QuantizedAdd</code> supports limited forms of broadcasting. More about\n              broadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)\n              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property."
  overload: TensorFlow.TFGraph.QuantizedAdd*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedAvgPool(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  id: QuantizedAvgPool(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedAvgPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.QuantizedAvgPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.QuantizedAvgPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Produces the average pool of the input tensor for quantized types.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedAvgPool (TensorFlow.TFOutput input, TensorFlow.TFOutput min_input, TensorFlow.TFOutput max_input, long[] ksize, long[] strides, string padding, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: min_input
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized input value represents.
    - id: max_input
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized input value represents.
    - id: ksize
      type: System.Int64[]
      description: >-
        The size of the window for each dimension of the input tensor.
                      The length must be 4 to match the number of dimensions of the input.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the input
                      tensor.  The length must be 4 to match the number of dimensions of the input.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedAvgPool'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output:
                      min_output: The float value that the lowest quantized output value represents.
                      max_output: The float value that the highest quantized output value represents.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizedAvgPool*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedBatchNormWithGlobalNormalization(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Single,System.Boolean,System.String)
  id: QuantizedBatchNormWithGlobalNormalization(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Single,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedBatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, Single, Boolean, String)
  nameWithType: TFGraph.QuantizedBatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, Single, Boolean, String)
  fullName: TFGraph.QuantizedBatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, Single, Boolean, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Quantized Batch normalization.
  remarks: >-
    This op is deprecated and will be removed in the future. Prefer
                  <code>tf.nn.batch_normalization</code>.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedBatchNormWithGlobalNormalization (TensorFlow.TFOutput t, TensorFlow.TFOutput t_min, TensorFlow.TFOutput t_max, TensorFlow.TFOutput m, TensorFlow.TFOutput m_min, TensorFlow.TFOutput m_max, TensorFlow.TFOutput v, TensorFlow.TFOutput v_min, TensorFlow.TFOutput v_max, TensorFlow.TFOutput beta, TensorFlow.TFOutput beta_min, TensorFlow.TFOutput beta_max, TensorFlow.TFOutput gamma, TensorFlow.TFOutput gamma_min, TensorFlow.TFOutput gamma_max, TensorFlow.TFDataType out_type, float variance_epsilon, bool scale_after_normalization, string operName = null);
    parameters:
    - id: t
      type: TensorFlow.TFOutput
      description: A 4D input Tensor.
    - id: t_min
      type: TensorFlow.TFOutput
      description: The value represented by the lowest quantized input.
    - id: t_max
      type: TensorFlow.TFOutput
      description: The value represented by the highest quantized input.
    - id: m
      type: TensorFlow.TFOutput
      description: >-
        A 1D mean Tensor with size matching the last dimension of t.
                      This is the first output from tf.nn.moments,
                      or a saved moving average thereof.
    - id: m_min
      type: TensorFlow.TFOutput
      description: The value represented by the lowest quantized mean.
    - id: m_max
      type: TensorFlow.TFOutput
      description: The value represented by the highest quantized mean.
    - id: v
      type: TensorFlow.TFOutput
      description: >-
        A 1D variance Tensor with size matching the last dimension of t.
                      This is the second output from tf.nn.moments,
                      or a saved moving average thereof.
    - id: v_min
      type: TensorFlow.TFOutput
      description: The value represented by the lowest quantized variance.
    - id: v_max
      type: TensorFlow.TFOutput
      description: The value represented by the highest quantized variance.
    - id: beta
      type: TensorFlow.TFOutput
      description: >-
        A 1D beta Tensor with size matching the last dimension of t.
                      An offset to be added to the normalized tensor.
    - id: beta_min
      type: TensorFlow.TFOutput
      description: The value represented by the lowest quantized offset.
    - id: beta_max
      type: TensorFlow.TFOutput
      description: The value represented by the highest quantized offset.
    - id: gamma
      type: TensorFlow.TFOutput
      description: >-
        A 1D gamma Tensor with size matching the last dimension of t.
                      If "scale_after_normalization" is true, this tensor will be multiplied
                      with the normalized tensor.
    - id: gamma_min
      type: TensorFlow.TFOutput
      description: The value represented by the lowest quantized gamma.
    - id: gamma_max
      type: TensorFlow.TFOutput
      description: The value represented by the highest quantized gamma.
    - id: out_type
      type: TensorFlow.TFDataType
      description: To be added.
    - id: variance_epsilon
      type: System.Single
      description: A small float number to avoid dividing by 0.
    - id: scale_after_normalization
      type: System.Boolean
      description: >-
        A bool indicating whether the resulted tensor
                      needs to be multiplied with gamma.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedBatchNormWithGlobalNormalization'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      result:
                      result_min:
                      result_max:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizedBatchNormWithGlobalNormalization*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedBiasAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: QuantizedBiasAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedBiasAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.QuantizedBiasAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.QuantizedBiasAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Adds Tensor 'bias' to Tensor 'input' for Quantized types.
  remarks: Broadcasts the values of bias on dimensions 0..N-2 of 'input'.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedBiasAdd (TensorFlow.TFOutput input, TensorFlow.TFOutput bias, TensorFlow.TFOutput min_input, TensorFlow.TFOutput max_input, TensorFlow.TFOutput min_bias, TensorFlow.TFOutput max_bias, TensorFlow.TFDataType out_type, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: bias
      type: TensorFlow.TFOutput
      description: A 1D bias Tensor with size matching the last dimension of 'input'.
    - id: min_input
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized input value represents.
    - id: max_input
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized input value represents.
    - id: min_bias
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized bias value represents.
    - id: max_bias
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized bias value represents.
    - id: out_type
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedBiasAdd'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output:
                      min_out: The float value that the lowest quantized output value represents.
                      max_out: The float value that the highest quantized output value represents.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizedBiasAdd*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedConcat(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  id: QuantizedConcat(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedConcat(TFOutput, TFOutput[], TFOutput[], TFOutput[], String)
  nameWithType: TFGraph.QuantizedConcat(TFOutput, TFOutput[], TFOutput[], TFOutput[], String)
  fullName: TFGraph.QuantizedConcat(TFOutput, TFOutput[], TFOutput[], TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Concatenates quantized tensors along one dimension.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedConcat (TensorFlow.TFOutput concat_dim, TensorFlow.TFOutput[] values, TensorFlow.TFOutput[] input_mins, TensorFlow.TFOutput[] input_maxes, string operName = null);
    parameters:
    - id: concat_dim
      type: TensorFlow.TFOutput
      description: >-
        0-D.  The dimension along which to concatenate.  Must be in the
                      range [0, rank(values)).
    - id: values
      type: TensorFlow.TFOutput[]
      description: >-
        The <code>N</code> Tensors to concatenate. Their ranks and types must match,
                      and their sizes must match in all dimensions except <code>concat_dim</code>.
    - id: input_mins
      type: TensorFlow.TFOutput[]
      description: The minimum scalar values for each of the input tensors.
    - id: input_maxes
      type: TensorFlow.TFOutput[]
      description: The maximum scalar values for each of the input tensors.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConcat'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output: A <code>Tensor</code> with the concatenation of values stacked along the
                      <code>concat_dim</code> dimension.  This tensor's shape matches that of <code>values</code> except
                      in <code>concat_dim</code> where it has the sum of the sizes.
                      output_min: The float value that the minimum quantized output value represents.
                      output_max: The float value that the maximum quantized output value represents.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizedConcat*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{TensorFlow.TFDataType},System.Int64[],System.String)
  id: QuantizedConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{TensorFlow.TFDataType},System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedConv2D(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<TFDataType>, Int64[], String)
  nameWithType: TFGraph.QuantizedConv2D(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<TFDataType>, Int64[], String)
  fullName: TFGraph.QuantizedConv2D(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<TFDataType>, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes a 2D convolution given quantized 4D input and filter tensors.
  remarks: >-
    The inputs are quantized tensors where the lowest value represents the real
                  number of the associated minimum, and the highest represents the maximum.
                  This means that you can only interpret the quantized output in the same way, by
                  taking the returned minimum and maximum values into account.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedConv2D (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, TensorFlow.TFOutput min_input, TensorFlow.TFOutput max_input, TensorFlow.TFOutput min_filter, TensorFlow.TFOutput max_filter, long[] strides, string padding, Nullable<TensorFlow.TFDataType> out_type = null, long[] dilations = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: filter
      type: TensorFlow.TFOutput
      description: filter's input_depth dimension must match input's depth dimensions.
    - id: min_input
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized input value represents.
    - id: max_input
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized input value represents.
    - id: min_filter
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized filter value represents.
    - id: max_filter
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized filter value represents.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the input
                      tensor.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: out_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: dilations
      type: System.Int64[]
      description: >-
        Optional argument
                      1-D tensor of length 4.  The dilation factor for each dimension of
                      <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each
                      filter element on that dimension. The dimension order is determined by the
                      value of <code>data_format</code>, see above for details. Dilations in the batch and
                      depth dimensions must be 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedConv2D'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output:
                      min_output: The float value that the lowest quantized output value represents.
                      max_output: The float value that the highest quantized output value represents.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizedConv2D*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedInstanceNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  id: QuantizedInstanceNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedInstanceNorm(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Single>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  nameWithType: TFGraph.QuantizedInstanceNorm(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Single>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  fullName: TFGraph.QuantizedInstanceNorm(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Single>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Quantized Instance normalization.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedInstanceNorm (TensorFlow.TFOutput x, TensorFlow.TFOutput x_min, TensorFlow.TFOutput x_max, Nullable<bool> output_range_given = null, Nullable<float> given_y_min = null, Nullable<float> given_y_max = null, Nullable<float> variance_epsilon = null, Nullable<float> min_separation = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: A 4D input Tensor.
    - id: x_min
      type: TensorFlow.TFOutput
      description: The value represented by the lowest quantized input.
    - id: x_max
      type: TensorFlow.TFOutput
      description: The value represented by the highest quantized input.
    - id: output_range_given
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, <code>given_y_min</code> and <code>given_y_min</code>
                      and <code>given_y_max</code> are used as the output range. Otherwise,
                      the implementation computes the output range.
    - id: given_y_min
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      Output in <code>y_min</code> if <code>output_range_given</code> is True.
    - id: given_y_max
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      Output in <code>y_max</code> if <code>output_range_given</code> is True.
    - id: variance_epsilon
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      A small float number to avoid dividing by 0.
    - id: min_separation
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      Minimum value of <code>y_max - y_min</code>
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedInstanceNorm'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      y: A 4D Tensor.
                      y_min: The value represented by the lowest quantized output.
                      y_max: The value represented by the highest quantized output.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizedInstanceNorm*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{TensorFlow.TFDataType},System.String)
  id: QuantizedMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedMatMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, Nullable<Boolean>, Nullable<Boolean>, Nullable<TFDataType>, String)
  nameWithType: TFGraph.QuantizedMatMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, Nullable<Boolean>, Nullable<Boolean>, Nullable<TFDataType>, String)
  fullName: TFGraph.QuantizedMatMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, Nullable<Boolean>, Nullable<Boolean>, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Perform a quantized matrix multiplication of  <code>a</code> by the matrix <code>b</code>.
  remarks: >-
    The inputs must be two-dimensional matrices and the inner dimension of
                  <code>a</code> (after being transposed if <code>transpose_a</code> is non-zero) must match the
                  outer dimension of <code>b</code> (after being transposed if <code>transposed_b</code> is
                  non-zero).
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedMatMul (TensorFlow.TFOutput a, TensorFlow.TFOutput b, TensorFlow.TFOutput min_a, TensorFlow.TFOutput max_a, TensorFlow.TFOutput min_b, TensorFlow.TFOutput max_b, Nullable<TensorFlow.TFDataType> Toutput = null, Nullable<bool> transpose_a = null, Nullable<bool> transpose_b = null, Nullable<TensorFlow.TFDataType> Tactivation = null, string operName = null);
    parameters:
    - id: a
      type: TensorFlow.TFOutput
      description: Must be a two-dimensional tensor.
    - id: b
      type: TensorFlow.TFOutput
      description: Must be a two-dimensional tensor.
    - id: min_a
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized <code>a</code> value represents.
    - id: max_a
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized <code>a</code> value represents.
    - id: min_b
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized <code>b</code> value represents.
    - id: max_b
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized <code>b</code> value represents.
    - id: Toutput
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: transpose_a
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, <code>a</code> is transposed before multiplication.
    - id: transpose_b
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, <code>b</code> is transposed before multiplication.
    - id: Tactivation
      type: System.Nullable{TensorFlow.TFDataType}
      description: >-
        Optional argument
                      The type of output produced by activation function
                      following this operation.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMatMul'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output:
                      min_out: The float value that the lowest quantized output value represents.
                      max_out: The float value that the highest quantized output value represents.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizedMatMul*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedMaxPool(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  id: QuantizedMaxPool(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedMaxPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.QuantizedMaxPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.QuantizedMaxPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Produces the max pool of the input tensor for quantized types.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedMaxPool (TensorFlow.TFOutput input, TensorFlow.TFOutput min_input, TensorFlow.TFOutput max_input, long[] ksize, long[] strides, string padding, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The 4D (batch x rows x cols x depth) Tensor to MaxReduce over.
    - id: min_input
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized input value represents.
    - id: max_input
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized input value represents.
    - id: ksize
      type: System.Int64[]
      description: >-
        The size of the window for each dimension of the input tensor.
                      The length must be 4 to match the number of dimensions of the input.
    - id: strides
      type: System.Int64[]
      description: >-
        The stride of the sliding window for each dimension of the input
                      tensor. The length must be 4 to match the number of dimensions of the input.
    - id: padding
      type: System.String
      description: The type of padding algorithm to use.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMaxPool'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output:
                      min_output: The float value that the lowest quantized output value represents.
                      max_output: The float value that the highest quantized output value represents.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizedMaxPool*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: QuantizedMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.QuantizedMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.QuantizedMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns x * y element-wise, working on quantized buffers.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedMul (TensorFlow.TFOutput x, TensorFlow.TFOutput y, TensorFlow.TFOutput min_x, TensorFlow.TFOutput max_x, TensorFlow.TFOutput min_y, TensorFlow.TFOutput max_y, Nullable<TensorFlow.TFDataType> Toutput = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: min_x
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized <code>x</code> value represents.
    - id: max_x
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized <code>x</code> value represents.
    - id: min_y
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized <code>y</code> value represents.
    - id: max_y
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized <code>y</code> value represents.
    - id: Toutput
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedMul'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: "Returns a tuple with multiple values, as follows:\n              z:\n              min_z: The float value that the lowest quantized output value represents.\n              max_z: The float value that the highest quantized output value represents.\n              \n              *NOTE*: <code>QuantizedMul</code> supports limited forms of broadcasting. More about\n              broadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)\n              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property."
  overload: TensorFlow.TFGraph.QuantizedMul*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizeDownAndShrinkRange(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: QuantizeDownAndShrinkRange(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizeDownAndShrinkRange(TFOutput, TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.QuantizeDownAndShrinkRange(TFOutput, TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.QuantizeDownAndShrinkRange(TFOutput, TFOutput, TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Convert the quantized 'input' tensor into a lower-precision 'output', using the
  remarks: "actual distribution of the values to maximize the usage of the lower bit depth\n              and adjusting the output min and max ranges accordingly.\n              \n              [input_min, input_max] are scalar floats that specify the range for the float\n              interpretation of the 'input' data. For example, if input_min is -1.0f and\n              input_max is 1.0f, and we are dealing with quint16 quantized data, then a 0\n              value in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.\n              \n              This operator tries to squeeze as much precision as possible into an output with\n              a lower bit depth by calculating the actual min and max values found in the\n              data. For example, maybe that quint16 input has no values lower than 16,384 and\n              none higher than 49,152. That means only half the range is actually needed, all\n              the float interpretations are between -0.5f and 0.5f, so if we want to compress\n              the data into a quint8 output, we can use that range rather than the theoretical\n              -1.0f to 1.0f that is suggested by the input min and max.\n              \n              In practice, this is most useful for taking output from operations like\n              QuantizedMatMul that can produce higher bit-depth outputs than their inputs and\n              may have large potential output ranges, but in practice have a distribution of\n              input values that only uses a small fraction of the possible range. By feeding\n              that output into this operator, we can reduce it from 32 bits down to 8 with\n              minimal loss of accuracy."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizeDownAndShrinkRange (TensorFlow.TFOutput input, TensorFlow.TFOutput input_min, TensorFlow.TFOutput input_max, TensorFlow.TFDataType out_type, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_min
      type: TensorFlow.TFOutput
      description: The float value that the minimum quantized input value represents.
    - id: input_max
      type: TensorFlow.TFOutput
      description: The float value that the maximum quantized input value represents.
    - id: out_type
      type: TensorFlow.TFDataType
      description: The type of the output. Should be a lower bit depth than Tinput.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeDownAndShrinkRange'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output:
                      output_min: The float value that the minimum quantized output value represents.
                      output_max: The float value that the maximum quantized output value represents.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizeDownAndShrinkRange*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedRelu(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: QuantizedRelu(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedRelu(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.QuantizedRelu(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.QuantizedRelu(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Computes Quantized Rectified Linear: <code>max(features, 0)</code>'
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedRelu (TensorFlow.TFOutput features, TensorFlow.TFOutput min_features, TensorFlow.TFOutput max_features, Nullable<TensorFlow.TFDataType> out_type = null, string operName = null);
    parameters:
    - id: features
      type: TensorFlow.TFOutput
      description: To be added.
    - id: min_features
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized value represents.
    - id: max_features
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized value represents.
    - id: out_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedRelu'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      activations: Has the same output shape as "features".
                      min_activations: The float value that the lowest quantized value represents.
                      max_activations: The float value that the highest quantized value represents.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizedRelu*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedRelu6(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: QuantizedRelu6(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedRelu6(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.QuantizedRelu6(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.QuantizedRelu6(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Computes Quantized Rectified Linear 6: <code>min(max(features, 0), 6)</code>'
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedRelu6 (TensorFlow.TFOutput features, TensorFlow.TFOutput min_features, TensorFlow.TFOutput max_features, Nullable<TensorFlow.TFDataType> out_type = null, string operName = null);
    parameters:
    - id: features
      type: TensorFlow.TFOutput
      description: To be added.
    - id: min_features
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized value represents.
    - id: max_features
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized value represents.
    - id: out_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedRelu6'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      activations: Has the same output shape as "features".
                      min_activations: The float value that the lowest quantized value represents.
                      max_activations: The float value that the highest quantized value represents.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizedRelu6*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedReluX(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: QuantizedReluX(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedReluX(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.QuantizedReluX(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.QuantizedReluX(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Computes Quantized Rectified Linear X: <code>min(max(features, 0), max_value)</code>'
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedReluX (TensorFlow.TFOutput features, TensorFlow.TFOutput max_value, TensorFlow.TFOutput min_features, TensorFlow.TFOutput max_features, Nullable<TensorFlow.TFDataType> out_type = null, string operName = null);
    parameters:
    - id: features
      type: TensorFlow.TFOutput
      description: To be added.
    - id: max_value
      type: TensorFlow.TFOutput
      description: To be added.
    - id: min_features
      type: TensorFlow.TFOutput
      description: The float value that the lowest quantized value represents.
    - id: max_features
      type: TensorFlow.TFOutput
      description: The float value that the highest quantized value represents.
    - id: out_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedReluX'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      activations: Has the same output shape as "features".
                      min_activations: The float value that the lowest quantized value represents.
                      max_activations: The float value that the highest quantized value represents.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizedReluX*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedReshape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: QuantizedReshape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedReshape(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.QuantizedReshape(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.QuantizedReshape(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedReshape (TensorFlow.TFOutput tensor, TensorFlow.TFOutput shape, TensorFlow.TFOutput input_min, TensorFlow.TFOutput input_max, string operName = null);
    parameters:
    - id: tensor
      type: TensorFlow.TFOutput
      description: To be added.
    - id: shape
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_min
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_max
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: To be added.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: To be added.
  overload: TensorFlow.TFGraph.QuantizedReshape*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizedResizeBilinear(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: QuantizedResizeBilinear(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizedResizeBilinear(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.QuantizedResizeBilinear(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.QuantizedResizeBilinear(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Resize quantized <code>images</code> to <code>size</code> using quantized bilinear interpolation.
  remarks: Input images and output images must be quantized types.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizedResizeBilinear (TensorFlow.TFOutput images, TensorFlow.TFOutput size, TensorFlow.TFOutput min, TensorFlow.TFOutput max, Nullable<bool> align_corners = null, string operName = null);
    parameters:
    - id: images
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: size
      type: TensorFlow.TFOutput
      description: >-
        = A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
                      new size for the images.
    - id: min
      type: TensorFlow.TFOutput
      description: To be added.
    - id: max
      type: TensorFlow.TFOutput
      description: To be added.
    - id: align_corners
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, the centers of the 4 corner pixels of the input and output tensors are
                      aligned, preserving the values at the corner pixels. Defaults to false.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizedResizeBilinear'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      resized_images: 4-D with shape
                      <code>[batch, new_height, new_width, channels]</code>.
                      out_min:
                      out_max:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizedResizeBilinear*
  exceptions: []
- uid: TensorFlow.TFGraph.QuantizeV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.String)
  id: QuantizeV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QuantizeV2(TFOutput, TFOutput, TFOutput, TFDataType, String, String, String)
  nameWithType: TFGraph.QuantizeV2(TFOutput, TFOutput, TFOutput, TFDataType, String, String, String)
  fullName: TFGraph.QuantizeV2(TFOutput, TFOutput, TFOutput, TFDataType, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Quantize the 'input' tensor of type float to 'output' tensor of type 'T'.
  remarks: "[min_range, max_range] are scalar floats that specify the range for\n              the 'input' data. The 'mode' attribute controls exactly which calculations are\n              used to convert the float values to their quantized equivalents.  The\n              'round_mode' attribute controls which rounding tie-breaking algorithm is used\n              when rounding float values to their quantized equivalents.\n              \n              In 'MIN_COMBINED' mode, each value of the tensor will undergo the following:\n              \n               <pre><code>\n              out[i] = (in[i] - min_range) * range(T) / (max_range - min_range)\n              if T == qint8: out[i] -= (range(T) + 1) / 2.0\n               </code></pre>\n              \n              here <code>range(T) = numeric_limits&lt;T&gt;::max() - numeric_limits&lt;T&gt;::min()</code>\n              \n              *MIN_COMBINED Mode Example*\n              \n              Assume the input is type float and has a possible range of [0.0, 6.0] and the\n              output type is quint8 ([0, 255]). The min_range and max_range values should be\n              specified as 0.0 and 6.0. Quantizing from float to quint8 will multiply each\n              value of the input by 255/6 and cast to quint8.\n              \n              If the output type was qint8 ([-128, 127]), the operation will additionally\n              subtract each value by 128 prior to casting, so that the range of values aligns\n              with the range of qint8.\n              \n              If the mode is 'MIN_FIRST', then this approach is used:\n              \n               <pre><code>\n              num_discrete_values = 1 &lt;&lt; (# of bits in T)\n              range_adjust = num_discrete_values / (num_discrete_values - 1)\n              range = (range_max - range_min) * range_adjust\n              range_scale = num_discrete_values / range\n              quantized = round(input * range_scale) - round(range_min * range_scale) +\n              numeric_limits&lt;T&gt;::min()\n              quantized = max(quantized, numeric_limits&lt;T&gt;::min())\n              quantized = min(quantized, numeric_limits&lt;T&gt;::max())\n               </code></pre>\n              \n              The biggest difference between this and MIN_COMBINED is that the minimum range\n              is rounded first, before it's subtracted from the rounded value. With\n              MIN_COMBINED, a small bias is introduced where repeated iterations of quantizing\n              and dequantizing will introduce a larger and larger error.\n              \n              *SCALED mode Example*\n              \n              <code>SCALED</code> mode matches the quantization approach used in\n              <code>QuantizeAndDequantize{V2|V3}</code>.\n              \n              If the mode is <code>SCALED</code>, we do not use the full range of the output type,\n              choosing to elide the lowest possible value for symmetry (e.g., output range is\n              -127 to 127, not -128 to 127 for signed 8 bit quantization), so that 0.0 maps to\n              0.\n              \n              We first find the range of values in our tensor. The\n              range we use is always centered on 0, so we find m such that\n              \n               <pre><code>\n              m = max(abs(input_min), abs(input_max))\n               </code></pre>\n              \n              Our input tensor range is then <code>[-m, m]</code>.\n              \n              Next, we choose our fixed-point quantization buckets, <code>[min_fixed, max_fixed]</code>.\n              If T is signed, this is\n              \n               <pre><code>\n              num_bits = sizeof(T) * 8\n              [min_fixed, max_fixed] =\n              [-(1 &lt;&lt; (num_bits - 1) - 1), (1 &lt;&lt; (num_bits - 1)) - 1]\n               </code></pre>\n              \n              Otherwise, if T is unsigned, the fixed-point range is\n              \n               <pre><code>\n              [min_fixed, max_fixed] = [0, (1 &lt;&lt; num_bits) - 1]\n               </code></pre>\n              \n              From this we compute our scaling factor, s:\n              \n               <pre><code>\n              s = (max_fixed - min_fixed) / (2 * m)\n               </code></pre>\n              \n              Now we can quantize the elements of our tensor:\n              \n               <pre><code>\n              result = round(input * s)\n               </code></pre>\n              \n              One thing to watch out for is that the operator may choose to adjust the\n              requested minimum and maximum values slightly during the quantization process,\n              so you should always use the output ports as the range for further calculations.\n              For example, if the requested minimum and maximum values are close to equal,\n              they will be separated by a small epsilon value to prevent ill-formed quantized\n              buffers from being created. Otherwise, you can end up with buffers where all the\n              quantized values map to the same float value, which causes problems for\n              operations that have to perform further calculations on them."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> QuantizeV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput min_range, TensorFlow.TFOutput max_range, TensorFlow.TFDataType T, string mode = null, string round_mode = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: min_range
      type: TensorFlow.TFOutput
      description: The minimum scalar value possibly produced for the input.
    - id: max_range
      type: TensorFlow.TFOutput
      description: The maximum scalar value possibly produced for the input.
    - id: T
      type: TensorFlow.TFDataType
      description: To be added.
    - id: mode
      type: System.String
      description: Optional argument
    - id: round_mode
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QuantizeV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output: The quantized data produced from the float input.
                      output_min: The actual minimum scalar value used for the output.
                      output_max: The actual maximum scalar value used for the output.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.QuantizeV2*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueClose(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: QueueClose(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueClose(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.QueueClose(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.QueueClose(TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Closes the given queue.
  remarks: >-
    This operation signals that no more elements will be enqueued in the
                  given queue. Subsequent Enqueue(Many) operations will fail.
                  Subsequent Dequeue(Many) operations will continue to succeed if
                  sufficient elements remain in the queue. Subsequent Dequeue(Many)
                  operations that would block will fail immediately.
  syntax:
    content: public TensorFlow.TFOperation QueueClose (TensorFlow.TFOutput handle, Nullable<bool> cancel_pending_enqueues = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: cancel_pending_enqueues
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, all pending enqueue requests that are
                      blocked on the given queue will be canceled.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueClose'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.QueueClose*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueCloseV2(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: QueueCloseV2(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueCloseV2(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.QueueCloseV2(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.QueueCloseV2(TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Closes the given queue.
  remarks: >-
    This operation signals that no more elements will be enqueued in the
                  given queue. Subsequent Enqueue(Many) operations will fail.
                  Subsequent Dequeue(Many) operations will continue to succeed if
                  sufficient elements remain in the queue. Subsequent Dequeue(Many)
                  operations that would block will fail immediately.
  syntax:
    content: public TensorFlow.TFOperation QueueCloseV2 (TensorFlow.TFOutput handle, Nullable<bool> cancel_pending_enqueues = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: cancel_pending_enqueues
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, all pending enqueue requests that are
                      blocked on the given queue will be canceled.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueCloseV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.QueueCloseV2*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueDequeue(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  id: QueueDequeue(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueDequeue(TFOutput, TFDataType[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueDequeue(TFOutput, TFDataType[], Nullable<Int64>, String)
  fullName: TFGraph.QueueDequeue(TFOutput, TFDataType[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Dequeues a tuple of one or more tensors from the given queue.
  remarks: "This operation has k outputs, where k is the number of components\n              in the tuples stored in the given queue, and output i is the ith\n              component of the dequeued tuple.\n              \n              N.B. If the queue is empty, this operation will block until an element\n              has been dequeued (or 'timeout_ms' elapses, if specified)."
  syntax:
    content: public TensorFlow.TFOutput[] QueueDequeue (TensorFlow.TFOutput handle, TensorFlow.TFDataType[] component_types, Nullable<long> timeout_ms = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a tuple.
    - id: timeout_ms
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If the queue is empty, this operation will block for up to
                      timeout_ms milliseconds.
                      Note: This option is not supported yet.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeue'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        One or more tensors that were dequeued as a tuple.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.QueueDequeue*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueDequeueMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  id: QueueDequeueMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueDequeueMany(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueDequeueMany(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  fullName: TFGraph.QueueDequeueMany(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Dequeues <code>n</code> tuples of one or more tensors from the given queue.
  remarks: "If the queue is closed and there are fewer than <code>n</code> elements, then an\n              OutOfRange error is returned.\n              \n              This operation concatenates queue-element component tensors along the\n              0th dimension to make a single component tensor.  All of the components\n              in the dequeued tuple will have size <code>n</code> in the 0th dimension.\n              \n              This operation has <code>k</code> outputs, where <code>k</code> is the number of components in\n              the tuples stored in the given queue, and output <code>i</code> is the ith\n              component of the dequeued tuple.\n              \n              N.B. If the queue is empty, this operation will block until <code>n</code> elements\n              have been dequeued (or 'timeout_ms' elapses, if specified)."
  syntax:
    content: public TensorFlow.TFOutput[] QueueDequeueMany (TensorFlow.TFOutput handle, TensorFlow.TFOutput n, TensorFlow.TFDataType[] component_types, Nullable<long> timeout_ms = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: n
      type: TensorFlow.TFOutput
      description: The number of tuples to dequeue.
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a tuple.
    - id: timeout_ms
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If the queue has fewer than n elements, this operation
                      will block for up to timeout_ms milliseconds.
                      Note: This option is not supported yet.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueMany'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        One or more tensors that were dequeued as a tuple.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.QueueDequeueMany*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueDequeueManyV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  id: QueueDequeueManyV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueDequeueManyV2(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueDequeueManyV2(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  fullName: TFGraph.QueueDequeueManyV2(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Dequeues <code>n</code> tuples of one or more tensors from the given queue.
  remarks: "If the queue is closed and there are fewer than <code>n</code> elements, then an\n              OutOfRange error is returned.\n              \n              This operation concatenates queue-element component tensors along the\n              0th dimension to make a single component tensor.  All of the components\n              in the dequeued tuple will have size <code>n</code> in the 0th dimension.\n              \n              This operation has <code>k</code> outputs, where <code>k</code> is the number of components in\n              the tuples stored in the given queue, and output <code>i</code> is the ith\n              component of the dequeued tuple.\n              \n              N.B. If the queue is empty, this operation will block until <code>n</code> elements\n              have been dequeued (or 'timeout_ms' elapses, if specified)."
  syntax:
    content: public TensorFlow.TFOutput[] QueueDequeueManyV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput n, TensorFlow.TFDataType[] component_types, Nullable<long> timeout_ms = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: n
      type: TensorFlow.TFOutput
      description: The number of tuples to dequeue.
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a tuple.
    - id: timeout_ms
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If the queue has fewer than n elements, this operation
                      will block for up to timeout_ms milliseconds.
                      Note: This option is not supported yet.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueManyV2'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        One or more tensors that were dequeued as a tuple.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.QueueDequeueManyV2*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueDequeueUpTo(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  id: QueueDequeueUpTo(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueDequeueUpTo(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueDequeueUpTo(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  fullName: TFGraph.QueueDequeueUpTo(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Dequeues <code>n</code> tuples of one or more tensors from the given queue.
  remarks: "This operation is not supported by all queues.  If a queue does not support\n              DequeueUpTo, then an Unimplemented error is returned.\n              \n              If the queue is closed and there are more than 0 but less than <code>n</code>\n              elements remaining, then instead of returning an OutOfRange error like\n              QueueDequeueMany, less than <code>n</code> elements are returned immediately.  If\n              the queue is closed and there are 0 elements left in the queue, then\n              an OutOfRange error is returned just like in QueueDequeueMany.\n              Otherwise the behavior is identical to QueueDequeueMany:\n              \n              This operation concatenates queue-element component tensors along the\n              0th dimension to make a single component tensor.  All of the components\n              in the dequeued tuple will have size <code>n</code> in the 0th dimension.\n              \n              This operation has k outputs, where <code>k</code> is the number of components in\n              the tuples stored in the given queue, and output <code>i</code> is the ith\n              component of the dequeued tuple."
  syntax:
    content: public TensorFlow.TFOutput[] QueueDequeueUpTo (TensorFlow.TFOutput handle, TensorFlow.TFOutput n, TensorFlow.TFDataType[] component_types, Nullable<long> timeout_ms = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: n
      type: TensorFlow.TFOutput
      description: The number of tuples to dequeue.
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a tuple.
    - id: timeout_ms
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If the queue has fewer than n elements, this operation
                      will block for up to timeout_ms milliseconds.
                      Note: This option is not supported yet.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueUpTo'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        One or more tensors that were dequeued as a tuple.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.QueueDequeueUpTo*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueDequeueUpToV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  id: QueueDequeueUpToV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueDequeueUpToV2(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueDequeueUpToV2(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  fullName: TFGraph.QueueDequeueUpToV2(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Dequeues <code>n</code> tuples of one or more tensors from the given queue.
  remarks: "This operation is not supported by all queues.  If a queue does not support\n              DequeueUpTo, then an Unimplemented error is returned.\n              \n              If the queue is closed and there are more than 0 but less than <code>n</code>\n              elements remaining, then instead of returning an OutOfRange error like\n              QueueDequeueMany, less than <code>n</code> elements are returned immediately.  If\n              the queue is closed and there are 0 elements left in the queue, then\n              an OutOfRange error is returned just like in QueueDequeueMany.\n              Otherwise the behavior is identical to QueueDequeueMany:\n              \n              This operation concatenates queue-element component tensors along the\n              0th dimension to make a single component tensor.  All of the components\n              in the dequeued tuple will have size n in the 0th dimension.\n              \n              This operation has <code>k</code> outputs, where <code>k</code> is the number of components in\n              the tuples stored in the given queue, and output <code>i</code> is the ith\n              component of the dequeued tuple."
  syntax:
    content: public TensorFlow.TFOutput[] QueueDequeueUpToV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput n, TensorFlow.TFDataType[] component_types, Nullable<long> timeout_ms = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: n
      type: TensorFlow.TFOutput
      description: The number of tuples to dequeue.
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a tuple.
    - id: timeout_ms
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If the queue has fewer than n elements, this operation
                      will block for up to timeout_ms milliseconds.
                      Note: This option is not supported yet.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueUpToV2'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        One or more tensors that were dequeued as a tuple.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.QueueDequeueUpToV2*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueDequeueV2(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  id: QueueDequeueV2(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueDequeueV2(TFOutput, TFDataType[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueDequeueV2(TFOutput, TFDataType[], Nullable<Int64>, String)
  fullName: TFGraph.QueueDequeueV2(TFOutput, TFDataType[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Dequeues a tuple of one or more tensors from the given queue.
  remarks: "This operation has k outputs, where k is the number of components\n              in the tuples stored in the given queue, and output i is the ith\n              component of the dequeued tuple.\n              \n              N.B. If the queue is empty, this operation will block until an element\n              has been dequeued (or 'timeout_ms' elapses, if specified)."
  syntax:
    content: public TensorFlow.TFOutput[] QueueDequeueV2 (TensorFlow.TFOutput handle, TensorFlow.TFDataType[] component_types, Nullable<long> timeout_ms = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a tuple.
    - id: timeout_ms
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If the queue is empty, this operation will block for up to
                      timeout_ms milliseconds.
                      Note: This option is not supported yet.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueDequeueV2'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        One or more tensors that were dequeued as a tuple.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.QueueDequeueV2*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueEnqueue(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  id: QueueEnqueue(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueEnqueue(TFOutput, TFOutput[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueEnqueue(TFOutput, TFOutput[], Nullable<Int64>, String)
  fullName: TFGraph.QueueEnqueue(TFOutput, TFOutput[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Enqueues a tuple of one or more tensors in the given queue.
  remarks: "The components input has k elements, which correspond to the components of\n              tuples stored in the given queue.\n              \n              N.B. If the queue is full, this operation will block until the given\n              element has been enqueued (or 'timeout_ms' elapses, if specified)."
  syntax:
    content: public TensorFlow.TFOperation QueueEnqueue (TensorFlow.TFOutput handle, TensorFlow.TFOutput[] components, Nullable<long> timeout_ms = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: components
      type: TensorFlow.TFOutput[]
      description: One or more tensors from which the enqueued tensors should be taken.
    - id: timeout_ms
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If the queue is full, this operation will block for up to
                      timeout_ms milliseconds.
                      Note: This option is not supported yet.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueue'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.QueueEnqueue*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueEnqueueMany(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  id: QueueEnqueueMany(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueEnqueueMany(TFOutput, TFOutput[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueEnqueueMany(TFOutput, TFOutput[], Nullable<Int64>, String)
  fullName: TFGraph.QueueEnqueueMany(TFOutput, TFOutput[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Enqueues zero or more tuples of one or more tensors in the given queue.
  remarks: "This operation slices each component tensor along the 0th dimension to\n              make multiple queue elements. All of the tuple components must have the\n              same size in the 0th dimension.\n              \n              The components input has k elements, which correspond to the components of\n              tuples stored in the given queue.\n              \n              N.B. If the queue is full, this operation will block until the given\n              elements have been enqueued (or 'timeout_ms' elapses, if specified)."
  syntax:
    content: public TensorFlow.TFOperation QueueEnqueueMany (TensorFlow.TFOutput handle, TensorFlow.TFOutput[] components, Nullable<long> timeout_ms = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: components
      type: TensorFlow.TFOutput[]
      description: >-
        One or more tensors from which the enqueued tensors should
                      be taken.
    - id: timeout_ms
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If the queue is too full, this operation will block for up
                      to timeout_ms milliseconds.
                      Note: This option is not supported yet.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueMany'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.QueueEnqueueMany*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueEnqueueManyV2(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  id: QueueEnqueueManyV2(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueEnqueueManyV2(TFOutput, TFOutput[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueEnqueueManyV2(TFOutput, TFOutput[], Nullable<Int64>, String)
  fullName: TFGraph.QueueEnqueueManyV2(TFOutput, TFOutput[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Enqueues zero or more tuples of one or more tensors in the given queue.
  remarks: "This operation slices each component tensor along the 0th dimension to\n              make multiple queue elements. All of the tuple components must have the\n              same size in the 0th dimension.\n              \n              The components input has k elements, which correspond to the components of\n              tuples stored in the given queue.\n              \n              N.B. If the queue is full, this operation will block until the given\n              elements have been enqueued (or 'timeout_ms' elapses, if specified)."
  syntax:
    content: public TensorFlow.TFOperation QueueEnqueueManyV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput[] components, Nullable<long> timeout_ms = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: components
      type: TensorFlow.TFOutput[]
      description: >-
        One or more tensors from which the enqueued tensors should
                      be taken.
    - id: timeout_ms
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If the queue is too full, this operation will block for up
                      to timeout_ms milliseconds.
                      Note: This option is not supported yet.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueManyV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.QueueEnqueueManyV2*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueEnqueueV2(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  id: QueueEnqueueV2(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueEnqueueV2(TFOutput, TFOutput[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueEnqueueV2(TFOutput, TFOutput[], Nullable<Int64>, String)
  fullName: TFGraph.QueueEnqueueV2(TFOutput, TFOutput[], Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Enqueues a tuple of one or more tensors in the given queue.
  remarks: "The components input has k elements, which correspond to the components of\n              tuples stored in the given queue.\n              \n              N.B. If the queue is full, this operation will block until the given\n              element has been enqueued (or 'timeout_ms' elapses, if specified)."
  syntax:
    content: public TensorFlow.TFOperation QueueEnqueueV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput[] components, Nullable<long> timeout_ms = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: components
      type: TensorFlow.TFOutput[]
      description: One or more tensors from which the enqueued tensors should be taken.
    - id: timeout_ms
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If the queue is full, this operation will block for up to
                      timeout_ms milliseconds.
                      Note: This option is not supported yet.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueEnqueueV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.QueueEnqueueV2*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueIsClosed(TensorFlow.TFOutput,System.String)
  id: QueueIsClosed(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueIsClosed(TFOutput, String)
  nameWithType: TFGraph.QueueIsClosed(TFOutput, String)
  fullName: TFGraph.QueueIsClosed(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns true if queue is closed.
  remarks: >-
    This operation returns true if the queue is closed and false if the queue
                  is open.
  syntax:
    content: public TensorFlow.TFOutput QueueIsClosed (TensorFlow.TFOutput handle, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueIsClosed'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.QueueIsClosed*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueIsClosedV2(TensorFlow.TFOutput,System.String)
  id: QueueIsClosedV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueIsClosedV2(TFOutput, String)
  nameWithType: TFGraph.QueueIsClosedV2(TFOutput, String)
  fullName: TFGraph.QueueIsClosedV2(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns true if queue is closed.
  remarks: >-
    This operation returns true if the queue is closed and false if the queue
                  is open.
  syntax:
    content: public TensorFlow.TFOutput QueueIsClosedV2 (TensorFlow.TFOutput handle, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueIsClosedV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.QueueIsClosedV2*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueSize(TensorFlow.TFOutput,System.String)
  id: QueueSize(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueSize(TFOutput, String)
  nameWithType: TFGraph.QueueSize(TFOutput, String)
  fullName: TFGraph.QueueSize(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the number of elements in the given queue.
  syntax:
    content: public TensorFlow.TFOutput QueueSize (TensorFlow.TFOutput handle, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueSize'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The number of elements in the given queue.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.QueueSize*
  exceptions: []
- uid: TensorFlow.TFGraph.QueueSizeV2(TensorFlow.TFOutput,System.String)
  id: QueueSizeV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: QueueSizeV2(TFOutput, String)
  nameWithType: TFGraph.QueueSizeV2(TFOutput, String)
  fullName: TFGraph.QueueSizeV2(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the number of elements in the given queue.
  syntax:
    content: public TensorFlow.TFOutput QueueSizeV2 (TensorFlow.TFOutput handle, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a queue.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'QueueSizeV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The number of elements in the given queue.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.QueueSizeV2*
  exceptions: []
- uid: TensorFlow.TFGraph.RandomCrop(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: RandomCrop(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RandomCrop(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomCrop(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomCrop(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Randomly crop <code>image</code>.
  remarks: "<code>size</code> is a 1-D int64 tensor with 2 elements representing the crop height and\n              width.  The values must be non negative.\n              \n              This Op picks a random location in <code>image</code> and crops a <code>height</code> by <code>width</code>\n              rectangle from that location.  The random location is picked so the cropped\n              area will fit inside the original image."
  syntax:
    content: public TensorFlow.TFOutput RandomCrop (TensorFlow.TFOutput image, TensorFlow.TFOutput size, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: image
      type: TensorFlow.TFOutput
      description: 3-D of shape <code>[height, width, channels]</code>.
    - id: size
      type: TensorFlow.TFOutput
      description: '1-D of length 2 containing: <code>crop_height</code>, <code>crop_width</code>..'
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either seed or seed2 are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      An second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomCrop'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        3-D of shape <code>[crop_height, crop_width, channels].</code>
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RandomCrop*
  exceptions: []
- uid: TensorFlow.TFGraph.RandomGamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: RandomGamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RandomGamma(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomGamma(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomGamma(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs random values from the Gamma distribution(s) described by alpha.
  remarks: >-
    This op uses the algorithm by Marsaglia et al. to acquire samples via
                  transformation-rejection from pairs of uniform and normal random variables.
                  See http://dl.acm.org/citation.cfm?id=358414
  syntax:
    content: public TensorFlow.TFOutput RandomGamma (TensorFlow.TFOutput shape, TensorFlow.TFOutput alpha, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFOutput
      description: >-
        1-D integer tensor. Shape of independent samples to draw from each
                      distribution described by the shape parameters given in alpha.
    - id: alpha
      type: TensorFlow.TFOutput
      description: >-
        A tensor in which each scalar is a "shape" parameter describing the
                      associated gamma distribution.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomGamma'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A tensor with shape <code>shape + shape(alpha)</code>. Each slice
                      <code>[:, ..., :, i0, i1, ...iN]</code> contains the samples drawn for
                      <code>alpha[i0, i1, ...iN]</code>. The dtype of the output matches the dtype of alpha.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RandomGamma*
  exceptions: []
- uid: TensorFlow.TFGraph.RandomGammaGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: RandomGammaGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RandomGammaGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RandomGammaGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.RandomGammaGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the derivative of a Gamma random sample w.r.t. <code>alpha</code>.
  syntax:
    content: public TensorFlow.TFOutput RandomGammaGrad (TensorFlow.TFOutput alpha, TensorFlow.TFOutput sample, string operName = null);
    parameters:
    - id: alpha
      type: TensorFlow.TFOutput
      description: To be added.
    - id: sample
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomGammaGrad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RandomGammaGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.RandomNormal(TensorFlow.TFShape,System.Double,System.Double,System.Nullable{System.Int32},System.String)
  id: RandomNormal(TensorFlow.TFShape,System.Double,System.Double,System.Nullable{System.Int32},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RandomNormal(TFShape, Double, Double, Nullable<Int32>, String)
  nameWithType: TFGraph.RandomNormal(TFShape, Double, Double, Nullable<Int32>, String)
  fullName: TFGraph.RandomNormal(TFShape, Double, Double, Nullable<Int32>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs random values from a normal distribution
  syntax:
    content: public TensorFlow.TFOutput RandomNormal (TensorFlow.TFShape shape, double mean = 0, double stddev = 1, Nullable<int> seed = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFShape
      description: Shape of the output tensor.
    - id: mean
      type: System.Double
      description: The mean of the standard distribution.
    - id: stddev
      type: System.Double
      description: The standard deviation of the normal distribution.
    - id: seed
      type: System.Nullable{System.Int32}
      description: Integer seed used for the random distribution, using the TensorFlow SetRandomSeed .
    - id: operName
      type: System.String
      description: Operation name, optional.
    return:
      type: TensorFlow.TFOutput
      description: A tensor of the specified shape filled with random normal values.
  overload: TensorFlow.TFGraph.RandomNormal*
  exceptions: []
- uid: TensorFlow.TFGraph.RandomPoisson(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: RandomPoisson(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RandomPoisson(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomPoisson(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomPoisson(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Use RandomPoissonV2 instead.
  syntax:
    content: public TensorFlow.TFOutput RandomPoisson (TensorFlow.TFOutput shape, TensorFlow.TFOutput rate, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFOutput
      description: To be added.
    - id: rate
      type: TensorFlow.TFOutput
      description: To be added.
    - id: seed
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: seed2
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomPoisson'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RandomPoisson*
  exceptions: []
- uid: TensorFlow.TFGraph.RandomPoissonV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)
  id: RandomPoissonV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RandomPoissonV2(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<TFDataType>, String)
  nameWithType: TFGraph.RandomPoissonV2(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<TFDataType>, String)
  fullName: TFGraph.RandomPoissonV2(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs random values from the Poisson distribution(s) described by rate.
  remarks: "This op uses two algorithms, depending on rate. If rate &gt;= 10, then\n              the algorithm by Hormann is used to acquire samples via\n              transformation-rejection.\n              See http://www.sciencedirect.com/science/article/pii/0167668793909974.\n              \n              Otherwise, Knuth's algorithm is used to acquire samples via multiplying uniform\n              random variables.\n              See Donald E. Knuth (1969). Seminumerical Algorithms. The Art of Computer\n              Programming, Volume 2. Addison Wesley"
  syntax:
    content: public TensorFlow.TFOutput RandomPoissonV2 (TensorFlow.TFOutput shape, TensorFlow.TFOutput rate, Nullable<long> seed = null, Nullable<long> seed2 = null, Nullable<TensorFlow.TFDataType> dtype = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFOutput
      description: >-
        1-D integer tensor. Shape of independent samples to draw from each
                      distribution described by the shape parameters given in rate.
    - id: rate
      type: TensorFlow.TFOutput
      description: >-
        A tensor in which each scalar is a "rate" parameter describing the
                      associated poisson distribution.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A second seed to avoid seed collision.
    - id: dtype
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomPoissonV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A tensor with shape <code>shape + shape(rate)</code>. Each slice
                      <code>[:, ..., :, i0, i1, ...iN]</code> contains the samples drawn for
                      <code>rate[i0, i1, ...iN]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RandomPoissonV2*
  exceptions: []
- uid: TensorFlow.TFGraph.RandomShuffle(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: RandomShuffle(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RandomShuffle(TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomShuffle(TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomShuffle(TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Randomly shuffles a tensor along its first dimension.
  remarks: "The tensor is shuffled along dimension 0, such that each <code>value[j]</code> is mapped\n              to one and only one <code>output[i]</code>. For example, a mapping that might occur for a\n              3x2 tensor is:\n              \n               <pre><code>\n              [[1, 2],       [[5, 6],\n              [3, 4],  ==&gt;   [1, 2],\n              [5, 6]]        [3, 4]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput RandomShuffle (TensorFlow.TFOutput value, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: value
      type: TensorFlow.TFOutput
      description: The tensor to be shuffled.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomShuffle'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A tensor of same shape and type as <code>value</code>, shuffled along its first
                      dimension.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RandomShuffle*
  exceptions: []
- uid: TensorFlow.TFGraph.RandomShuffleQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: RandomShuffleQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RandomShuffleQueue(TFDataType[], TFShape[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.RandomShuffleQueue(TFDataType[], TFShape[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.RandomShuffleQueue(TFDataType[], TFShape[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A queue that randomizes the order of elements.
  syntax:
    content: public TensorFlow.TFOutput RandomShuffleQueue (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable<long> capacity = null, Nullable<long> min_after_dequeue = null, Nullable<long> seed = null, Nullable<long> seed2 = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a value.
    - id: shapes
      type: TensorFlow.TFShape[]
      description: >-
        Optional argument
                      The shape of each component in a value. The length of this attr must
                      be either 0 or the same as the length of component_types. If the length of
                      this attr is 0, the shapes of queue elements are not constrained, and
                      only one element may be dequeued at a time.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The upper bound on the number of elements in this queue.
                      Negative numbers mean no limit.
    - id: min_after_dequeue
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Dequeue will block unless there would be this
                      many elements after the dequeue or the queue is closed. This
                      ensures a minimum level of mixing of elements.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either seed or seed2 is set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, a random seed is used.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A second seed to avoid seed collision.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue will be shared under the given name
                      across multiple sessions.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomShuffleQueue'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to the queue.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RandomShuffleQueue*
  exceptions: []
- uid: TensorFlow.TFGraph.RandomShuffleQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: RandomShuffleQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RandomShuffleQueueV2(TFDataType[], TFShape[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.RandomShuffleQueueV2(TFDataType[], TFShape[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.RandomShuffleQueueV2(TFDataType[], TFShape[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A queue that randomizes the order of elements.
  syntax:
    content: public TensorFlow.TFOutput RandomShuffleQueueV2 (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable<long> capacity = null, Nullable<long> min_after_dequeue = null, Nullable<long> seed = null, Nullable<long> seed2 = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: component_types
      type: TensorFlow.TFDataType[]
      description: The type of each component in a value.
    - id: shapes
      type: TensorFlow.TFShape[]
      description: >-
        Optional argument
                      The shape of each component in a value. The length of this attr must
                      be either 0 or the same as the length of component_types. If the length of
                      this attr is 0, the shapes of queue elements are not constrained, and
                      only one element may be dequeued at a time.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The upper bound on the number of elements in this queue.
                      Negative numbers mean no limit.
    - id: min_after_dequeue
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Dequeue will block unless there would be this
                      many elements after the dequeue or the queue is closed. This
                      ensures a minimum level of mixing of elements.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either seed or seed2 is set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, a random seed is used.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A second seed to avoid seed collision.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue will be shared under the given name
                      across multiple sessions.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomShuffleQueueV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to the queue.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RandomShuffleQueueV2*
  exceptions: []
- uid: TensorFlow.TFGraph.RandomStandardNormal(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: RandomStandardNormal(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RandomStandardNormal(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomStandardNormal(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomStandardNormal(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs random values from a normal distribution.
  remarks: The generated values will have mean 0 and standard deviation 1.
  syntax:
    content: public TensorFlow.TFOutput RandomStandardNormal (TensorFlow.TFOutput shape, TensorFlow.TFDataType dtype, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFOutput
      description: The shape of the output tensor.
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of the output.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomStandardNormal'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A tensor of the specified shape filled with random normal values.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RandomStandardNormal*
  exceptions: []
- uid: TensorFlow.TFGraph.RandomUniform(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: RandomUniform(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RandomUniform(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomUniform(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomUniform(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs random values from a uniform distribution.
  remarks: >-
    The generated values follow a uniform distribution in the range <code>[0, 1)</code>. The
                  lower bound 0 is included in the range, while the upper bound 1 is excluded.
  syntax:
    content: public TensorFlow.TFOutput RandomUniform (TensorFlow.TFOutput shape, TensorFlow.TFDataType dtype, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFOutput
      description: The shape of the output tensor.
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of the output.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomUniform'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A tensor of the specified shape filled with uniform random values.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RandomUniform*
  exceptions: []
- uid: TensorFlow.TFGraph.RandomUniform(TensorFlow.TFShape,System.Double,System.Double,System.Nullable{System.Int32},System.String)
  id: RandomUniform(TensorFlow.TFShape,System.Double,System.Double,System.Nullable{System.Int32},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RandomUniform(TFShape, Double, Double, Nullable<Int32>, String)
  nameWithType: TFGraph.RandomUniform(TFShape, Double, Double, Nullable<Int32>, String)
  fullName: TFGraph.RandomUniform(TFShape, Double, Double, Nullable<Int32>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Randoms the uniform.
  syntax:
    content: public TensorFlow.TFOutput RandomUniform (TensorFlow.TFShape shape, double minval = 0, double maxval = 1, Nullable<int> seed = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFShape
      description: Shape.
    - id: minval
      type: System.Double
      description: Minval.
    - id: maxval
      type: System.Double
      description: Maxval.
    - id: seed
      type: System.Nullable{System.Int32}
      description: Seed.
    - id: operName
      type: System.String
      description: Oper name.
    return:
      type: TensorFlow.TFOutput
      description: The uniform.
  overload: TensorFlow.TFGraph.RandomUniform*
  exceptions: []
- uid: TensorFlow.TFGraph.RandomUniformInt(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: RandomUniformInt(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RandomUniformInt(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomUniformInt(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomUniformInt(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs random integers from a uniform distribution.
  remarks: "The generated values are uniform integers in the range <code>[minval, maxval)</code>.\n              The lower bound <code>minval</code> is included in the range, while the upper bound\n              <code>maxval</code> is excluded.\n              \n              The random integers are slightly biased unless <code>maxval - minval</code> is an exact\n              power of two.  The bias is small for values of <code>maxval - minval</code> significantly\n              smaller than the range of the output (either <code>2^32</code> or <code>2^64</code>)."
  syntax:
    content: public TensorFlow.TFOutput RandomUniformInt (TensorFlow.TFOutput shape, TensorFlow.TFOutput minval, TensorFlow.TFOutput maxval, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFOutput
      description: The shape of the output tensor.
    - id: minval
      type: TensorFlow.TFOutput
      description: 0-D.  Inclusive lower bound on the generated integers.
    - id: maxval
      type: TensorFlow.TFOutput
      description: 0-D.  Exclusive upper bound on the generated integers.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RandomUniformInt'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A tensor of the specified shape filled with uniform random integers.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RandomUniformInt*
  exceptions: []
- uid: TensorFlow.TFGraph.Range(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Range(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Range(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.Range(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.Range(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a sequence of numbers.
  remarks: "This operation creates a sequence of numbers that begins at <code>start</code> and\n              extends by increments of <code>delta</code> up to but not including <code>limit</code>.\n              \n              For example:\n              \n               <pre><code>\n              # 'start' is 3\n              # 'limit' is 18\n              # 'delta' is 3\n              tf.range(start, limit, delta) ==&gt; [3, 6, 9, 12, 15]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Range (TensorFlow.TFOutput start, TensorFlow.TFOutput limit, TensorFlow.TFOutput delta, string operName = null);
    parameters:
    - id: start
      type: TensorFlow.TFOutput
      description: 0-D (scalar). First entry in the sequence.
    - id: limit
      type: TensorFlow.TFOutput
      description: 0-D (scalar). Upper limit of sequence, exclusive.
    - id: delta
      type: TensorFlow.TFOutput
      description: 0-D (scalar). Optional. Default is 1. Number that increments <code>start</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Range'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        1-D.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Range*
  exceptions: []
- uid: TensorFlow.TFGraph.Range(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFDataType},System.String)
  id: Range(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Range(TFOutput, Nullable<TFOutput>, Nullable<TFOutput>, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Range(TFOutput, Nullable<TFOutput>, Nullable<TFOutput>, Nullable<TFDataType>, String)
  fullName: TFGraph.Range(TFOutput, Nullable<TFOutput>, Nullable<TFOutput>, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a sequence of numbers.
  remarks: "Creates a sequence of numbers that begins at `start` and extends by increments of `delta` up to but not including \n            `limit`. The dtype of the resulting tensor is inferred from the inputs unless it is provided explicitly."
  syntax:
    content: public TensorFlow.TFOutput Range (TensorFlow.TFOutput start, Nullable<TensorFlow.TFOutput> limit = null, Nullable<TensorFlow.TFOutput> delta = null, Nullable<TensorFlow.TFDataType> dataType = null, string operName = "range");
    parameters:
    - id: start
      type: TensorFlow.TFOutput
      description: A 0 - D `Tensor` (scalar).Acts as first entry in the range if `limit` is not None; otherwise, acts as range limit and first entry defaults to 0.
    - id: limit
      type: System.Nullable{TensorFlow.TFOutput}
      description: A 0 - D `Tensor` (scalar).Upper limit of sequence, exclusive. If None, defaults to the value of `start` while the first entry of the range defaults to 0.
    - id: delta
      type: System.Nullable{TensorFlow.TFOutput}
      description: A 0 - D `Tensor` (scalar).Number that increments `start`. Defaults to 1.
    - id: dataType
      type: System.Nullable{TensorFlow.TFDataType}
      description: The type of the elements of the resulting tensor.
    - id: operName
      type: System.String
      description: A name for the operation.Defaults to "range".
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.Range*
  exceptions: []
- uid: TensorFlow.TFGraph.RangeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: RangeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RangeDataset(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.RangeDataset(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.RangeDataset(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset with a range of values. Corresponds to python's xrange.
  syntax:
    content: public TensorFlow.TFOutput RangeDataset (TensorFlow.TFOutput start, TensorFlow.TFOutput stop, TensorFlow.TFOutput step, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: start
      type: TensorFlow.TFOutput
      description: corresponds to start in python's xrange().
    - id: stop
      type: TensorFlow.TFOutput
      description: corresponds to stop in python's xrange().
    - id: step
      type: TensorFlow.TFOutput
      description: corresponds to step in python's xrange().
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RangeDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RangeDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.Rank(TensorFlow.TFOutput,System.String)
  id: Rank(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Rank(TFOutput, String)
  nameWithType: TFGraph.Rank(TFOutput, String)
  fullName: TFGraph.Rank(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the rank of a tensor.
  remarks: "This operation returns an integer representing the rank of <code>input</code>.\n              \n              For example:\n              \n               <pre><code>\n              # 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\n              # shape of tensor 't' is [2, 2, 3]\n              rank(t) ==&gt; 3\n               </code></pre>\n              \n              **Note**: The rank of a tensor is not the same as the rank of a matrix. The rank\n              of a tensor is the number of indices required to uniquely select each element\n              of the tensor. Rank is also known as \"order\", \"degree\", or \"ndims.\""
  syntax:
    content: public TensorFlow.TFOutput Rank (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Rank'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Rank*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderNumRecordsProduced(TensorFlow.TFOutput,System.String)
  id: ReaderNumRecordsProduced(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderNumRecordsProduced(TFOutput, String)
  nameWithType: TFGraph.ReaderNumRecordsProduced(TFOutput, String)
  fullName: TFGraph.ReaderNumRecordsProduced(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the number of records this Reader has produced.
  remarks: >-
    This is the same as the number of ReaderRead executions that have
                  succeeded.
  syntax:
    content: public TensorFlow.TFOutput ReaderNumRecordsProduced (TensorFlow.TFOutput reader_handle, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a Reader.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumRecordsProduced'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ReaderNumRecordsProduced*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderNumRecordsProducedV2(TensorFlow.TFOutput,System.String)
  id: ReaderNumRecordsProducedV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderNumRecordsProducedV2(TFOutput, String)
  nameWithType: TFGraph.ReaderNumRecordsProducedV2(TFOutput, String)
  fullName: TFGraph.ReaderNumRecordsProducedV2(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the number of records this Reader has produced.
  remarks: >-
    This is the same as the number of ReaderRead executions that have
                  succeeded.
  syntax:
    content: public TensorFlow.TFOutput ReaderNumRecordsProducedV2 (TensorFlow.TFOutput reader_handle, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a Reader.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumRecordsProducedV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ReaderNumRecordsProducedV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderNumWorkUnitsCompleted(TensorFlow.TFOutput,System.String)
  id: ReaderNumWorkUnitsCompleted(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderNumWorkUnitsCompleted(TFOutput, String)
  nameWithType: TFGraph.ReaderNumWorkUnitsCompleted(TFOutput, String)
  fullName: TFGraph.ReaderNumWorkUnitsCompleted(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the number of work units this Reader has finished processing.
  syntax:
    content: public TensorFlow.TFOutput ReaderNumWorkUnitsCompleted (TensorFlow.TFOutput reader_handle, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a Reader.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumWorkUnitsCompleted'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ReaderNumWorkUnitsCompleted*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderNumWorkUnitsCompletedV2(TensorFlow.TFOutput,System.String)
  id: ReaderNumWorkUnitsCompletedV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderNumWorkUnitsCompletedV2(TFOutput, String)
  nameWithType: TFGraph.ReaderNumWorkUnitsCompletedV2(TFOutput, String)
  fullName: TFGraph.ReaderNumWorkUnitsCompletedV2(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the number of work units this Reader has finished processing.
  syntax:
    content: public TensorFlow.TFOutput ReaderNumWorkUnitsCompletedV2 (TensorFlow.TFOutput reader_handle, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a Reader.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderNumWorkUnitsCompletedV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ReaderNumWorkUnitsCompletedV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderRead(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ReaderRead(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderRead(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReaderRead(TFOutput, TFOutput, String)
  fullName: TFGraph.ReaderRead(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the next record (key, value pair) produced by a Reader.
  remarks: >-
    Will dequeue from the input queue if necessary (e.g. when the
                  Reader needs to start reading from a new file since it has finished
                  with the previous file).
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> ReaderRead (TensorFlow.TFOutput reader_handle, TensorFlow.TFOutput queue_handle, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a Reader.
    - id: queue_handle
      type: TensorFlow.TFOutput
      description: Handle to a Queue, with string work items.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderRead'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      key: A scalar.
                      value: A scalar.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.ReaderRead*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderReadUpTo(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ReaderReadUpTo(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderReadUpTo(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReaderReadUpTo(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ReaderReadUpTo(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns up to <code>num_records</code> (key, value) pairs produced by a Reader.
  remarks: >-
    Will dequeue from the input queue if necessary (e.g. when the
                  Reader needs to start reading from a new file since it has finished
                  with the previous file).
                  It may return less than <code>num_records</code> even before the last batch.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> ReaderReadUpTo (TensorFlow.TFOutput reader_handle, TensorFlow.TFOutput queue_handle, TensorFlow.TFOutput num_records, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a <code>Reader</code>.
    - id: queue_handle
      type: TensorFlow.TFOutput
      description: Handle to a <code>Queue</code>, with string work items.
    - id: num_records
      type: TensorFlow.TFOutput
      description: number of records to read from <code>Reader</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReadUpTo'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      keys: A 1-D tensor.
                      values: A 1-D tensor.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.ReaderReadUpTo*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderReadUpToV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ReaderReadUpToV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderReadUpToV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReaderReadUpToV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ReaderReadUpToV2(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns up to <code>num_records</code> (key, value) pairs produced by a Reader.
  remarks: >-
    Will dequeue from the input queue if necessary (e.g. when the
                  Reader needs to start reading from a new file since it has finished
                  with the previous file).
                  It may return less than <code>num_records</code> even before the last batch.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> ReaderReadUpToV2 (TensorFlow.TFOutput reader_handle, TensorFlow.TFOutput queue_handle, TensorFlow.TFOutput num_records, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a <code>Reader</code>.
    - id: queue_handle
      type: TensorFlow.TFOutput
      description: Handle to a <code>Queue</code>, with string work items.
    - id: num_records
      type: TensorFlow.TFOutput
      description: number of records to read from <code>Reader</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReadUpToV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      keys: A 1-D tensor.
                      values: A 1-D tensor.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.ReaderReadUpToV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderReadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ReaderReadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderReadV2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReaderReadV2(TFOutput, TFOutput, String)
  fullName: TFGraph.ReaderReadV2(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the next record (key, value pair) produced by a Reader.
  remarks: >-
    Will dequeue from the input queue if necessary (e.g. when the
                  Reader needs to start reading from a new file since it has finished
                  with the previous file).
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> ReaderReadV2 (TensorFlow.TFOutput reader_handle, TensorFlow.TFOutput queue_handle, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a Reader.
    - id: queue_handle
      type: TensorFlow.TFOutput
      description: Handle to a Queue, with string work items.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReadV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      key: A scalar.
                      value: A scalar.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.ReaderReadV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderReset(TensorFlow.TFOutput,System.String)
  id: ReaderReset(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderReset(TFOutput, String)
  nameWithType: TFGraph.ReaderReset(TFOutput, String)
  fullName: TFGraph.ReaderReset(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Restore a Reader to its initial clean state.
  syntax:
    content: public TensorFlow.TFOperation ReaderReset (TensorFlow.TFOutput reader_handle, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a Reader.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderReset'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ReaderReset*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderResetV2(TensorFlow.TFOutput,System.String)
  id: ReaderResetV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderResetV2(TFOutput, String)
  nameWithType: TFGraph.ReaderResetV2(TFOutput, String)
  fullName: TFGraph.ReaderResetV2(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Restore a Reader to its initial clean state.
  syntax:
    content: public TensorFlow.TFOperation ReaderResetV2 (TensorFlow.TFOutput reader_handle, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a Reader.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderResetV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ReaderResetV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderRestoreState(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ReaderRestoreState(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderRestoreState(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReaderRestoreState(TFOutput, TFOutput, String)
  fullName: TFGraph.ReaderRestoreState(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Restore a reader to a previously saved state.
  remarks: >-
    Not all Readers support being restored, so this can produce an
                  Unimplemented error.
  syntax:
    content: public TensorFlow.TFOperation ReaderRestoreState (TensorFlow.TFOutput reader_handle, TensorFlow.TFOutput state, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a Reader.
    - id: state
      type: TensorFlow.TFOutput
      description: >-
        Result of a ReaderSerializeState of a Reader with type
                      matching reader_handle.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderRestoreState'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ReaderRestoreState*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderRestoreStateV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ReaderRestoreStateV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderRestoreStateV2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReaderRestoreStateV2(TFOutput, TFOutput, String)
  fullName: TFGraph.ReaderRestoreStateV2(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Restore a reader to a previously saved state.
  remarks: >-
    Not all Readers support being restored, so this can produce an
                  Unimplemented error.
  syntax:
    content: public TensorFlow.TFOperation ReaderRestoreStateV2 (TensorFlow.TFOutput reader_handle, TensorFlow.TFOutput state, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a Reader.
    - id: state
      type: TensorFlow.TFOutput
      description: >-
        Result of a ReaderSerializeState of a Reader with type
                      matching reader_handle.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderRestoreStateV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ReaderRestoreStateV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderSerializeState(TensorFlow.TFOutput,System.String)
  id: ReaderSerializeState(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderSerializeState(TFOutput, String)
  nameWithType: TFGraph.ReaderSerializeState(TFOutput, String)
  fullName: TFGraph.ReaderSerializeState(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Produce a string tensor that encodes the state of a Reader.
  remarks: >-
    Not all Readers support being serialized, so this can produce an
                  Unimplemented error.
  syntax:
    content: public TensorFlow.TFOutput ReaderSerializeState (TensorFlow.TFOutput reader_handle, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a Reader.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderSerializeState'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ReaderSerializeState*
  exceptions: []
- uid: TensorFlow.TFGraph.ReaderSerializeStateV2(TensorFlow.TFOutput,System.String)
  id: ReaderSerializeStateV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReaderSerializeStateV2(TFOutput, String)
  nameWithType: TFGraph.ReaderSerializeStateV2(TFOutput, String)
  fullName: TFGraph.ReaderSerializeStateV2(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Produce a string tensor that encodes the state of a Reader.
  remarks: >-
    Not all Readers support being serialized, so this can produce an
                  Unimplemented error.
  syntax:
    content: public TensorFlow.TFOutput ReaderSerializeStateV2 (TensorFlow.TFOutput reader_handle, string operName = null);
    parameters:
    - id: reader_handle
      type: TensorFlow.TFOutput
      description: Handle to a Reader.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReaderSerializeStateV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ReaderSerializeStateV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ReadFile(TensorFlow.TFOutput,System.String)
  id: ReadFile(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReadFile(TFOutput, String)
  nameWithType: TFGraph.ReadFile(TFOutput, String)
  fullName: TFGraph.ReadFile(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reads and outputs the entire contents of the input filename.
  syntax:
    content: public TensorFlow.TFOutput ReadFile (TensorFlow.TFOutput filename, string operName = null);
    parameters:
    - id: filename
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReadFile'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ReadFile*
  exceptions: []
- uid: TensorFlow.TFGraph.ReadVariableOp(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: ReadVariableOp(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReadVariableOp(TFOutput, TFDataType, String)
  nameWithType: TFGraph.ReadVariableOp(TFOutput, TFDataType, String)
  fullName: TFGraph.ReadVariableOp(TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reads the value of a variable.
  remarks: "The tensor returned by this operation is immutable.\n              \n              The value returned by this operation is guaranteed to be influenced by all the\n              writes on which this operation depends directly or indirectly, and to not be\n              influenced by any of the writes which depend directly or indirectly on this\n              operation."
  syntax:
    content: public TensorFlow.TFOutput ReadVariableOp (TensorFlow.TFOutput resource, TensorFlow.TFDataType dtype, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: handle to the resource in which to store the variable.
    - id: dtype
      type: TensorFlow.TFDataType
      description: the dtype of the value.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReadVariableOp'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ReadVariableOp*
  exceptions: []
- uid: TensorFlow.TFGraph.Real(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: Real(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Real(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Real(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Real(TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the real part of a complex number.
  remarks: "Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of\n              type <code>float</code> that is the real part of each element in <code>input</code>. All elements in\n              <code>input</code> must be complex numbers of the form \\\\(a + bj\\\\), where *a* is the real\n              part returned by this operation and *b* is the imaginary part.\n              \n              For example:\n              \n               <pre><code>\n              # tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\n              tf.real(input) ==&gt; [-2.25, 3.25]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Real (TensorFlow.TFOutput input, Nullable<TensorFlow.TFDataType> Tout = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: Tout
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Real'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Real*
  exceptions: []
- uid: TensorFlow.TFGraph.RealDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: RealDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RealDiv(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RealDiv(TFOutput, TFOutput, String)
  fullName: TFGraph.RealDiv(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns x / y element-wise for real types.
  remarks: "If <code>x</code> and <code>y</code> are reals, this will return the floating-point division.\n              \n              *NOTE*: <code>Div</code> supports broadcasting. More about broadcasting\n              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)"
  syntax:
    content: public TensorFlow.TFOutput RealDiv (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RealDiv'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RealDiv*
  exceptions: []
- uid: TensorFlow.TFGraph.Reciprocal(TensorFlow.TFOutput,System.String)
  id: Reciprocal(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Reciprocal(TFOutput, String)
  nameWithType: TFGraph.Reciprocal(TFOutput, String)
  fullName: TFGraph.Reciprocal(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the reciprocal of x element-wise.
  remarks: I.e., \\(y = 1 / x\\).
  syntax:
    content: public TensorFlow.TFOutput Reciprocal (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Reciprocal'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Reciprocal*
  exceptions: []
- uid: TensorFlow.TFGraph.ReciprocalGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ReciprocalGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReciprocalGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReciprocalGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.ReciprocalGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradient for the inverse of <code>x</code> wrt its input.
  remarks: >-
    Specifically, <code>grad = -dy * y*y</code>, where <code>y = 1/x</code>, and <code>dy</code>
                  is the corresponding input gradient.
  syntax:
    content: public TensorFlow.TFOutput ReciprocalGrad (TensorFlow.TFOutput y, TensorFlow.TFOutput dy, string operName = null);
    parameters:
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dy
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReciprocalGrad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ReciprocalGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.RecordInput(System.String,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String)
  id: RecordInput(System.String,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RecordInput(String, Nullable<Int64>, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RecordInput(String, Nullable<Int64>, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String)
  fullName: TFGraph.RecordInput(String, Nullable<Int64>, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Emits randomized records.
  syntax:
    content: public TensorFlow.TFOutput RecordInput (string file_pattern, Nullable<long> file_random_seed = null, Nullable<float> file_shuffle_shift_ratio = null, Nullable<long> file_buffer_size = null, Nullable<long> file_parallelism = null, Nullable<long> batch_size = null, string compression_type = null, string operName = null);
    parameters:
    - id: file_pattern
      type: System.String
      description: Glob pattern for the data files.
    - id: file_random_seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Random seeds used to produce randomized records.
    - id: file_shuffle_shift_ratio
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      Shifts the list of files after the list is randomly
                      shuffled.
    - id: file_buffer_size
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The randomization shuffling buffer.
    - id: file_parallelism
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      How many sstables are opened and concurrently iterated over.
    - id: batch_size
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The batch size.
    - id: compression_type
      type: System.String
      description: >-
        Optional argument
                      The type of compression for the file. Currently ZLIB and
                      GZIP are supported. Defaults to none.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RecordInput'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A tensor of shape [batch_size].
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RecordInput*
  exceptions: []
- uid: TensorFlow.TFGraph.RecvTPUEmbeddingActivations(System.Int64,System.String,System.String)
  id: RecvTPUEmbeddingActivations(System.Int64,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RecvTPUEmbeddingActivations(Int64, String, String)
  nameWithType: TFGraph.RecvTPUEmbeddingActivations(Int64, String, String)
  fullName: TFGraph.RecvTPUEmbeddingActivations(Int64, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An op that receives embedding activations on the TPU.
  remarks: >-
    The TPU system performs the embedding lookups and aggregations specified by
                  the arguments to TPUEmbeddingEnqueue(Integer/Sparse/SparseTensor)Batch. The
                  results of these aggregations are visible to the Tensorflow Graph as the
                  outputs of a RecvTPUEmbeddingActivations op. This op returns a list containing
                  one Tensor of activations per table specified in the model. There can be at
                  most one RecvTPUEmbeddingActivations op in the TPU graph.
  syntax:
    content: public TensorFlow.TFOutput[] RecvTPUEmbeddingActivations (long num_outputs, string config, string operName = null);
    parameters:
    - id: num_outputs
      type: System.Int64
      description: >-
        The number of output activation tensors, equal to the number of
                      embedding tables in the model.
    - id: config
      type: System.String
      description: Serialized TPUEmbeddingConfiguration proto.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RecvTPUEmbeddingActivations'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        A TensorList of embedding activations containing one Tensor per
                      embedding table in the model.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RecvTPUEmbeddingActivations*
  exceptions: []
- uid: TensorFlow.TFGraph.ReduceJoin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String,System.String)
  id: ReduceJoin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReduceJoin(TFOutput, TFOutput, Nullable<Boolean>, String, String)
  nameWithType: TFGraph.ReduceJoin(TFOutput, TFOutput, Nullable<Boolean>, String, String)
  fullName: TFGraph.ReduceJoin(TFOutput, TFOutput, Nullable<Boolean>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Joins a string Tensor across the given dimensions.
  remarks: "Computes the string join across dimensions in the given string Tensor of shape\n              <code>[\\\\(d_0, d_1, ..., d_{n-1}\\\\)]</code>.  Returns a new Tensor created by joining the input\n              strings with the given separator (default: empty string).  Negative indices are\n              counted backwards from the end, with <code>-1</code> being equivalent to <code>n - 1</code>.  If\n              indices are not specified, joins across all dimensions beginning from <code>n - 1</code>\n              through <code>0</code>.\n              \n              For example:\n              \n               <pre><code>\n              # tensor <code>a</code> is [[\"a\", \"b\"], [\"c\", \"d\"]]\n              tf.reduce_join(a, 0) ==&gt; [\"ac\", \"bd\"]\n              tf.reduce_join(a, 1) ==&gt; [\"ab\", \"cd\"]\n              tf.reduce_join(a, -2) = tf.reduce_join(a, 0) ==&gt; [\"ac\", \"bd\"]\n              tf.reduce_join(a, -1) = tf.reduce_join(a, 1) ==&gt; [\"ab\", \"cd\"]\n              tf.reduce_join(a, 0, keep_dims=True) ==&gt; [[\"ac\", \"bd\"]]\n              tf.reduce_join(a, 1, keep_dims=True) ==&gt; [[\"ab\"], [\"cd\"]]\n              tf.reduce_join(a, 0, separator=\".\") ==&gt; [\"a.c\", \"b.d\"]\n              tf.reduce_join(a, [0, 1]) ==&gt; \"acbd\"\n              tf.reduce_join(a, [1, 0]) ==&gt; \"abcd\"\n              tf.reduce_join(a, []) ==&gt; [[\"a\", \"b\"], [\"c\", \"d\"]]\n              tf.reduce_join(a) = tf.reduce_join(a, [1, 0]) ==&gt; \"abcd\"\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput ReduceJoin (TensorFlow.TFOutput inputs, TensorFlow.TFOutput reduction_indices, Nullable<bool> keep_dims = null, string separator = null, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput
      description: The input to be joined.  All reduced indices must have non-zero size.
    - id: reduction_indices
      type: TensorFlow.TFOutput
      description: >-
        The dimensions to reduce over.  Dimensions are reduced in the
                      order specified.  Omitting <code>reduction_indices</code> is equivalent to passing
                      <code>[n-1, n-2, ..., 0]</code>.  Negative indices from <code>-n</code> to <code>-1</code> are supported.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, retain reduced dimensions with length <code>1</code>.
    - id: separator
      type: System.String
      description: >-
        Optional argument
                      The separator to use when joining.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReduceJoin'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has shape equal to that of the input with reduced dimensions removed or
                      set to <code>1</code> depending on <code>keep_dims</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ReduceJoin*
  exceptions: []
- uid: TensorFlow.TFGraph.ReduceMean(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)
  id: ReduceMean(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReduceMean(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ReduceMean(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  fullName: TFGraph.ReduceMean(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the mean of elements across dimensions of a tensor.
  remarks: >-
    <p>
                  Reduces input_tensor along the dimensions given in axis.
                Unless keep_dims is true, the rank of the tensor is reduced by 1 for each
                entry in axis. If keep_dims is true, the reduced dimensions
                are retained with length 1.</p>
        <p>
                If axis has no entries, all dimensions are reduced, and a
                tensor with a single element is returned.</p>
  syntax:
    content: public TensorFlow.TFOutput ReduceMean (TensorFlow.TFOutput input, Nullable<TensorFlow.TFOutput> axis = null, Nullable<bool> keep_dims = false, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The tensor to reduce. Should have numeric type.
    - id: axis
      type: System.Nullable{TensorFlow.TFOutput}
      description: The dimensions to reduce. If not set (the default), reduces all dimensions.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: If set to <code>true</code> retains reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: A name for the operation, optional.
    return:
      type: TensorFlow.TFOutput
      description: The reduced tensor.
  overload: TensorFlow.TFGraph.ReduceMean*
  exceptions: []
- uid: TensorFlow.TFGraph.ReduceProd(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)
  id: ReduceProd(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReduceProd(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ReduceProd(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  fullName: TFGraph.ReduceProd(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the product of elements across dimensions of a tensor.
  remarks: "Reduces input_tensor along the dimensions given in axis.\n            Unless keep_dims is true, the rank of the tensor is reduced by 1 for each\n            entry in axis. If keep_dims is true, the reduced dimensions\n            are retained with length 1.\n            \n            If axis has no entries, all dimensions are reduced, and a\n            tensor with a single element is returned."
  syntax:
    content: public TensorFlow.TFOutput ReduceProd (TensorFlow.TFOutput input, Nullable<TensorFlow.TFOutput> axis = null, Nullable<bool> keep_dims = false, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The tensor to reduce. Should have numeric type.
    - id: axis
      type: System.Nullable{TensorFlow.TFOutput}
      description: The dimensions to reduce. If not se (the default), reduces all dimensions.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: If set to <code>true</code> retains reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: A name for the operation, optional.
    return:
      type: TensorFlow.TFOutput
      description: The reduced tensor.
  overload: TensorFlow.TFGraph.ReduceProd*
  exceptions: []
- uid: TensorFlow.TFGraph.ReduceSum(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)
  id: ReduceSum(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReduceSum(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ReduceSum(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  fullName: TFGraph.ReduceSum(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the sum of elements across dimensions of a tensor.
  remarks: "Reduces input_tensor along the dimensions given in axis.\n            Unless keep_dims is true, the rank of the tensor is reduced by 1 for each\n            entry in axis. If keep_dims is true, the reduced dimensions\n            are retained with length 1.\n            \n            If axis has no entries, all dimensions are reduced, and a\n            tensor with a single element is returned."
  syntax:
    content: public TensorFlow.TFOutput ReduceSum (TensorFlow.TFOutput input, Nullable<TensorFlow.TFOutput> axis = null, Nullable<bool> keep_dims = false, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The tensor to reduce. Should have numeric type.
    - id: axis
      type: System.Nullable{TensorFlow.TFOutput}
      description: The dimensions to reduce. If not se (the default), reduces all dimensions.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: If set to <code>true</code> retains reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: A name for the operation, optional.
    return:
      type: TensorFlow.TFOutput
      description: The reduced tensor.
  overload: TensorFlow.TFGraph.ReduceSum*
  exceptions: []
- uid: TensorFlow.TFGraph.RefEnter(TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  id: RefEnter(TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RefEnter(TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  nameWithType: TFGraph.RefEnter(TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  fullName: TFGraph.RefEnter(TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates or finds a child frame, and makes <code>data</code> available to the child frame.
  remarks: >-
    The unique <code>frame_name</code> is used by the <code>Executor</code> to identify frames. If
                  <code>is_constant</code> is true, <code>output</code> is a constant in the child frame; otherwise
                  it may be changed in the child frame. At most <code>parallel_iterations</code> iterations
                  are run in parallel in the child frame.
  syntax:
    content: public TensorFlow.TFOutput RefEnter (TensorFlow.TFOutput data, string frame_name, Nullable<bool> is_constant = null, Nullable<long> parallel_iterations = null, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: The tensor to be made available to the child frame.
    - id: frame_name
      type: System.String
      description: The name of the child frame.
    - id: is_constant
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, the output is constant within the child frame.
    - id: parallel_iterations
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The number of iterations allowed to run in parallel.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RefEnter'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The same tensor as <code>data</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RefEnter*
  exceptions: []
- uid: TensorFlow.TFGraph.RefExit(TensorFlow.TFOutput,System.String)
  id: RefExit(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RefExit(TFOutput, String)
  nameWithType: TFGraph.RefExit(TFOutput, String)
  fullName: TFGraph.RefExit(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Exits the current frame to its parent frame.
  remarks: Exit makes its input <code>data</code> available to the parent frame.
  syntax:
    content: public TensorFlow.TFOutput RefExit (TensorFlow.TFOutput data, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: The tensor to be made available to the parent frame.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RefExit'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The same tensor as <code>data</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RefExit*
  exceptions: []
- uid: TensorFlow.TFGraph.RefIdentity(TensorFlow.TFOutput,System.String)
  id: RefIdentity(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RefIdentity(TFOutput, String)
  nameWithType: TFGraph.RefIdentity(TFOutput, String)
  fullName: TFGraph.RefIdentity(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Return the same ref tensor as the input ref tensor.
  syntax:
    content: public TensorFlow.TFOutput RefIdentity (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RefIdentity'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RefIdentity*
  exceptions: []
- uid: TensorFlow.TFGraph.RefMerge(TensorFlow.TFOutput[],System.String)
  id: RefMerge(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RefMerge(TFOutput[], String)
  nameWithType: TFGraph.RefMerge(TFOutput[], String)
  fullName: TFGraph.RefMerge(TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Forwards the value of an available tensor from <code>inputs</code> to <code>output</code>.
  remarks: "<code>Merge</code> waits for at least one of the tensors in <code>inputs</code> to become available.\n              It is usually combined with <code>Switch</code> to implement branching.\n              \n              <code>Merge</code> forwards the first tensor for become available to <code>output</code>, and sets\n              <code>value_index</code> to its index in <code>inputs</code>."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> RefMerge (TensorFlow.TFOutput[] inputs, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: The input tensors, exactly one of which will become available.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RefMerge'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output: Will be set to the available input tensor.
                      value_index: The index of the chosen input tensor in <code>inputs</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RefMerge*
  exceptions: []
- uid: TensorFlow.TFGraph.RefNextIteration(TensorFlow.TFOutput,System.String)
  id: RefNextIteration(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RefNextIteration(TFOutput, String)
  nameWithType: TFGraph.RefNextIteration(TFOutput, String)
  fullName: TFGraph.RefNextIteration(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Makes its input available to the next iteration.
  syntax:
    content: public TensorFlow.TFOutput RefNextIteration (TensorFlow.TFOutput data, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: The tensor to be made available to the next iteration.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RefNextIteration'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The same tensor as <code>data</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RefNextIteration*
  exceptions: []
- uid: TensorFlow.TFGraph.RefSelect(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  id: RefSelect(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RefSelect(TFOutput, TFOutput[], String)
  nameWithType: TFGraph.RefSelect(TFOutput, TFOutput[], String)
  fullName: TFGraph.RefSelect(TFOutput, TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Forwards the <code>index</code>th element of <code>inputs</code> to <code>output</code>.
  syntax:
    content: public TensorFlow.TFOutput RefSelect (TensorFlow.TFOutput index, TensorFlow.TFOutput[] inputs, string operName = null);
    parameters:
    - id: index
      type: TensorFlow.TFOutput
      description: A scalar that determines the input that gets selected.
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: A list of ref tensors, one of which will be forwarded to <code>output</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RefSelect'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The forwarded tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RefSelect*
  exceptions: []
- uid: TensorFlow.TFGraph.RefSwitch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: RefSwitch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RefSwitch(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RefSwitch(TFOutput, TFOutput, String)
  fullName: TFGraph.RefSwitch(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Forwards the ref tensor <code>data</code> to the output port determined by <code>pred</code>.
  remarks: "If <code>pred</code> is true, the <code>data</code> input is forwarded to <code>output_true</code>. Otherwise,\n              the data goes to <code>output_false</code>.\n              \n              See also <code>Switch</code> and <code>Merge</code>."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> RefSwitch (TensorFlow.TFOutput data, TensorFlow.TFOutput pred, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: The ref tensor to be forwarded to the appropriate output.
    - id: pred
      type: TensorFlow.TFOutput
      description: A scalar that specifies which output port will receive data.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RefSwitch'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_false: If <code>pred</code> is false, data will be forwarded to this output.
                      output_true: If <code>pred</code> is true, data will be forwarded to this output.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RefSwitch*
  exceptions: []
- uid: TensorFlow.TFGraph.RegexFullMatch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: RegexFullMatch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RegexFullMatch(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RegexFullMatch(TFOutput, TFOutput, String)
  fullName: TFGraph.RegexFullMatch(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Check if the input matches the regex pattern.
  remarks: "The input is a string tensor of any shape. The pattern is a scalar\n              string tensor which is applied to every element of the input tensor.\n              The boolean values (True or False) of the output tensor indicate\n              if the input matches the regex pattern provided.\n              \n              The pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)"
  syntax:
    content: public TensorFlow.TFOutput RegexFullMatch (TensorFlow.TFOutput input, TensorFlow.TFOutput pattern, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A string tensor of the text to be processed.
    - id: pattern
      type: TensorFlow.TFOutput
      description: A scalar string tensor containing the regular expression to match the input.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RegexFullMatch'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A bool tensor with the same shape as <code>input</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RegexFullMatch*
  exceptions: []
- uid: TensorFlow.TFGraph.RegexReplace(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: RegexReplace(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RegexReplace(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.RegexReplace(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.RegexReplace(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Replaces the match of pattern in input with rewrite.
  remarks: It follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)
  syntax:
    content: public TensorFlow.TFOutput RegexReplace (TensorFlow.TFOutput input, TensorFlow.TFOutput pattern, TensorFlow.TFOutput rewrite, Nullable<bool> replace_global = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The text to be processed.
    - id: pattern
      type: TensorFlow.TFOutput
      description: The regular expression to match the input.
    - id: rewrite
      type: TensorFlow.TFOutput
      description: The rewrite to be applied to the matched expresion.
    - id: replace_global
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the replacement is global, otherwise the replacement
                      is done only on the first match.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RegexReplace'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The text after applying pattern and rewrite.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RegexReplace*
  exceptions: []
- uid: TensorFlow.TFGraph.Relu(TensorFlow.TFOutput,System.String)
  id: Relu(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Relu(TFOutput, String)
  nameWithType: TFGraph.Relu(TFOutput, String)
  fullName: TFGraph.Relu(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Computes rectified linear: <code>max(features, 0)</code>.'
  syntax:
    content: public TensorFlow.TFOutput Relu (TensorFlow.TFOutput features, string operName = null);
    parameters:
    - id: features
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Relu'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Relu*
  exceptions: []
- uid: TensorFlow.TFGraph.Relu6(TensorFlow.TFOutput,System.String)
  id: Relu6(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Relu6(TFOutput, String)
  nameWithType: TFGraph.Relu6(TFOutput, String)
  fullName: TFGraph.Relu6(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Computes rectified linear 6: <code>min(max(features, 0), 6)</code>.'
  syntax:
    content: public TensorFlow.TFOutput Relu6 (TensorFlow.TFOutput features, string operName = null);
    parameters:
    - id: features
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Relu6'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Relu6*
  exceptions: []
- uid: TensorFlow.TFGraph.Relu6Grad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Relu6Grad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Relu6Grad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Relu6Grad(TFOutput, TFOutput, String)
  fullName: TFGraph.Relu6Grad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes rectified linear 6 gradients for a Relu6 operation.
  syntax:
    content: public TensorFlow.TFOutput Relu6Grad (TensorFlow.TFOutput gradients, TensorFlow.TFOutput features, string operName = null);
    parameters:
    - id: gradients
      type: TensorFlow.TFOutput
      description: The backpropagated gradients to the corresponding Relu6 operation.
    - id: features
      type: TensorFlow.TFOutput
      description: >-
        The features passed as input to the corresponding Relu6 operation, or
                      its output; using either one produces the same result.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Relu6Grad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The gradients:
                      <code>gradients * (features &gt; 0) * (features &lt; 6)</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Relu6Grad*
  exceptions: []
- uid: TensorFlow.TFGraph.ReluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ReluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReluGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReluGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.ReluGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes rectified linear gradients for a Relu operation.
  syntax:
    content: public TensorFlow.TFOutput ReluGrad (TensorFlow.TFOutput gradients, TensorFlow.TFOutput features, string operName = null);
    parameters:
    - id: gradients
      type: TensorFlow.TFOutput
      description: The backpropagated gradients to the corresponding Relu operation.
    - id: features
      type: TensorFlow.TFOutput
      description: >-
        The features passed as input to the corresponding Relu operation, OR
                      the outputs of that operation (both work equivalently).
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReluGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        <code>gradients * (features &gt; 0)</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ReluGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.RemoteFusedGraphExecute(TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.String,System.String)
  id: RemoteFusedGraphExecute(TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RemoteFusedGraphExecute(TFOutput[], TFDataType[], String, String)
  nameWithType: TFGraph.RemoteFusedGraphExecute(TFOutput[], TFDataType[], String, String)
  fullName: TFGraph.RemoteFusedGraphExecute(TFOutput[], TFDataType[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Execute a sub graph on a remote processor.
  remarks: >-
    The graph specifications(such as graph itself, input tensors and output names)
                  are stored as a serialized protocol buffer of RemoteFusedGraphExecuteInfo
                  as serialized_remote_fused_graph_execute_info.
                  The specifications will be passed to a dedicated registered
                  remote fused graph executor.  The executor will send the graph specifications
                  to a remote processor and execute that graph.  The execution results
                  will be passed to consumer nodes as outputs of this node.
  syntax:
    content: public TensorFlow.TFOutput[] RemoteFusedGraphExecute (TensorFlow.TFOutput[] inputs, TensorFlow.TFDataType[] Toutputs, string serialized_remote_fused_graph_execute_info, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: Arbitrary number of tensors with arbitrary data types
    - id: Toutputs
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: serialized_remote_fused_graph_execute_info
      type: System.String
      description: >-
        Serialized protocol buffer
                      of RemoteFusedGraphExecuteInfo which contains graph specifications.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RemoteFusedGraphExecute'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        Arbitrary number of tensors with arbitrary data types
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RemoteFusedGraphExecute*
  exceptions: []
- uid: TensorFlow.TFGraph.RepeatDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: RepeatDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RepeatDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.RepeatDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.RepeatDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that emits the outputs of <code>input_dataset</code><code>count</code> times.
  syntax:
    content: public TensorFlow.TFOutput RepeatDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput count, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: count
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing the number of times that <code>input_dataset</code> should
                      be repeated. A value of <code>-1</code> indicates that it should be repeated infinitely.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RepeatDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RepeatDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.RequantizationRange(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: RequantizationRange(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RequantizationRange(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.RequantizationRange(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.RequantizationRange(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Given a quantized tensor described by (input, input_min, input_max), outputs a
  remarks: >-
    range that covers the actual values present in that tensor.  This op is
                  typically used to produce the requested_output_min and requested_output_max for
                  Requantize.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> RequantizationRange (TensorFlow.TFOutput input, TensorFlow.TFOutput input_min, TensorFlow.TFOutput input_max, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_min
      type: TensorFlow.TFOutput
      description: The float value that the minimum quantized input value represents.
    - id: input_max
      type: TensorFlow.TFOutput
      description: The float value that the maximum quantized input value represents.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RequantizationRange'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_min: The computed min output.
                      output_max: the computed max output.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RequantizationRange*
  exceptions: []
- uid: TensorFlow.TFGraph.Requantize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: Requantize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Requantize(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.Requantize(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.Requantize(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Convert the quantized 'input' tensor into a lower-precision 'output', using the
  remarks: "output range specified with 'requested_output_min' and 'requested_output_max'.\n              \n              [input_min, input_max] are scalar floats that specify the range for the float\n              interpretation of the 'input' data. For example, if input_min is -1.0f and\n              input_max is 1.0f, and we are dealing with quint16 quantized data, then a 0\n              value in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> Requantize (TensorFlow.TFOutput input, TensorFlow.TFOutput input_min, TensorFlow.TFOutput input_max, TensorFlow.TFOutput requested_output_min, TensorFlow.TFOutput requested_output_max, TensorFlow.TFDataType out_type, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: input_min
      type: TensorFlow.TFOutput
      description: The float value that the minimum quantized input value represents.
    - id: input_max
      type: TensorFlow.TFOutput
      description: The float value that the maximum quantized input value represents.
    - id: requested_output_min
      type: TensorFlow.TFOutput
      description: The float value that the minimum quantized output value represents.
    - id: requested_output_max
      type: TensorFlow.TFOutput
      description: The float value that the maximum quantized output value represents.
    - id: out_type
      type: TensorFlow.TFDataType
      description: The type of the output. Should be a lower bit depth than Tinput.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Requantize'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output:
                      output_min: The requested_output_min value is copied into this output.
                      output_max: The requested_output_max value is copied into this output.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.Requantize*
  exceptions: []
- uid: TensorFlow.TFGraph.Reshape(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Reshape(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Reshape(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Reshape(TFOutput, TFOutput, String)
  fullName: TFGraph.Reshape(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reshapes a tensor.
  remarks: "Given <code>tensor</code>, this operation returns a tensor that has the same values\n              as <code>tensor</code> with shape <code>shape</code>.\n              \n              If one component of <code>shape</code> is the special value -1, the size of that dimension\n              is computed so that the total size remains constant.  In particular, a <code>shape</code>\n              of <code>[-1]</code> flattens into 1-D.  At most one component of <code>shape</code> can be -1.\n              \n              If <code>shape</code> is 1-D or higher, then the operation returns a tensor with shape\n              <code>shape</code> filled with the values of <code>tensor</code>. In this case, the number of elements\n              implied by <code>shape</code> must be the same as the number of elements in <code>tensor</code>.\n              \n              For example:\n              \n               <pre><code>\n              # tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]\n              # tensor 't' has shape [9]\n              reshape(t, [3, 3]) ==&gt; [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]]\n              \n              # tensor 't' is [[[1, 1], [2, 2]],\n              #                [[3, 3], [4, 4]]]\n              # tensor 't' has shape [2, 2, 2]\n              reshape(t, [2, 4]) ==&gt; [[1, 1, 2, 2],\n              [3, 3, 4, 4]]\n              \n              # tensor 't' is [[[1, 1, 1],\n              #                 [2, 2, 2]],\n              #                [[3, 3, 3],\n              #                 [4, 4, 4]],\n              #                [[5, 5, 5],\n              #                 [6, 6, 6]]]\n              # tensor 't' has shape [3, 2, 3]\n              # pass '[-1]' to flatten 't'\n              reshape(t, [-1]) ==&gt; [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]\n              \n              # -1 can also be used to infer the shape\n              \n              # -1 is inferred to be 9:\n              reshape(t, [2, -1]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],\n              [4, 4, 4, 5, 5, 5, 6, 6, 6]]\n              # -1 is inferred to be 2:\n              reshape(t, [-1, 9]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],\n              [4, 4, 4, 5, 5, 5, 6, 6, 6]]\n              # -1 is inferred to be 3:\n              reshape(t, [ 2, -1, 3]) ==&gt; [[[1, 1, 1],\n              [2, 2, 2],\n              [3, 3, 3]],\n              [[4, 4, 4],\n              [5, 5, 5],\n              [6, 6, 6]]]\n              \n              # tensor 't' is [7]\n              # shape <code>[]</code> reshapes to a scalar\n              reshape(t, []) ==&gt; 7\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Reshape (TensorFlow.TFOutput tensor, TensorFlow.TFOutput shape, string operName = null);
    parameters:
    - id: tensor
      type: TensorFlow.TFOutput
      description: To be added.
    - id: shape
      type: TensorFlow.TFOutput
      description: Defines the shape of the output tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Reshape'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Reshape*
  exceptions: []
- uid: TensorFlow.TFGraph.ResizeArea(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResizeArea(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResizeArea(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeArea(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeArea(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Resize <code>images</code> to <code>size</code> using area interpolation.
  remarks: "Input images can be of different types but output images are always float.\n              \n              The range of pixel values for the output image might be slightly different\n              from the range for the input image because of limited numerical precision.\n              To guarantee an output range, for example <code>[0.0, 1.0]</code>, apply\n              <code>tf.clip_by_value</code> to the output.\n              \n              Each output pixel is computed by first transforming the pixel's footprint into\n              the input tensor and then averaging the pixels that intersect the footprint. An\n              input pixel's contribution to the average is weighted by the fraction of its\n              area that intersects the footprint.  This is the same as OpenCV's INTER_AREA."
  syntax:
    content: public TensorFlow.TFOutput ResizeArea (TensorFlow.TFOutput images, TensorFlow.TFOutput size, Nullable<bool> align_corners = null, string operName = null);
    parameters:
    - id: images
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: size
      type: TensorFlow.TFOutput
      description: >-
        = A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
                      new size for the images.
    - id: align_corners
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, the centers of the 4 corner pixels of the input and output tensors are
                      aligned, preserving the values at the corner pixels. Defaults to false.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeArea'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape
                      <code>[batch, new_height, new_width, channels]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ResizeArea*
  exceptions: []
- uid: TensorFlow.TFGraph.ResizeBicubic(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResizeBicubic(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResizeBicubic(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeBicubic(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeBicubic(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Resize <code>images</code> to <code>size</code> using bicubic interpolation.
  remarks: Input images can be of different types but output images are always float.
  syntax:
    content: public TensorFlow.TFOutput ResizeBicubic (TensorFlow.TFOutput images, TensorFlow.TFOutput size, Nullable<bool> align_corners = null, string operName = null);
    parameters:
    - id: images
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: size
      type: TensorFlow.TFOutput
      description: >-
        = A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
                      new size for the images.
    - id: align_corners
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, the centers of the 4 corner pixels of the input and output tensors are
                      aligned, preserving the values at the corner pixels. Defaults to false.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBicubic'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape
                      <code>[batch, new_height, new_width, channels]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ResizeBicubic*
  exceptions: []
- uid: TensorFlow.TFGraph.ResizeBicubicGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResizeBicubicGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResizeBicubicGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeBicubicGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeBicubicGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradient of bicubic interpolation.
  syntax:
    content: public TensorFlow.TFOutput ResizeBicubicGrad (TensorFlow.TFOutput grads, TensorFlow.TFOutput original_image, Nullable<bool> align_corners = null, string operName = null);
    parameters:
    - id: grads
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: original_image
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, orig_height, orig_width, channels]</code>,
                      The image tensor that was resized.
    - id: align_corners
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, the centers of the 4 corner pixels of the input and grad tensors are
                      aligned. Defaults to false.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBicubicGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, orig_height, orig_width, channels]</code>.
                      Gradients with respect to the input image. Input image must have been
                      float or double.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ResizeBicubicGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.ResizeBilinear(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResizeBilinear(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResizeBilinear(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeBilinear(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeBilinear(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Resize <code>images</code> to <code>size</code> using bilinear interpolation.
  remarks: Input images can be of different types but output images are always float.
  syntax:
    content: public TensorFlow.TFOutput ResizeBilinear (TensorFlow.TFOutput images, TensorFlow.TFOutput size, Nullable<bool> align_corners = null, string operName = null);
    parameters:
    - id: images
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: size
      type: TensorFlow.TFOutput
      description: >-
        = A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
                      new size for the images.
    - id: align_corners
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, the centers of the 4 corner pixels of the input and output tensors are
                      aligned, preserving the values at the corner pixels. Defaults to false.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBilinear'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape
                      <code>[batch, new_height, new_width, channels]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ResizeBilinear*
  exceptions: []
- uid: TensorFlow.TFGraph.ResizeBilinearGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResizeBilinearGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResizeBilinearGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeBilinearGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeBilinearGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradient of bilinear interpolation.
  syntax:
    content: public TensorFlow.TFOutput ResizeBilinearGrad (TensorFlow.TFOutput grads, TensorFlow.TFOutput original_image, Nullable<bool> align_corners = null, string operName = null);
    parameters:
    - id: grads
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: original_image
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, orig_height, orig_width, channels]</code>,
                      The image tensor that was resized.
    - id: align_corners
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, the centers of the 4 corner pixels of the input and grad tensors are
                      aligned. Defaults to false.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeBilinearGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, orig_height, orig_width, channels]</code>.
                      Gradients with respect to the input image. Input image must have been
                      float or double.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ResizeBilinearGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.ResizeNearestNeighbor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResizeNearestNeighbor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResizeNearestNeighbor(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeNearestNeighbor(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeNearestNeighbor(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Resize <code>images</code> to <code>size</code> using nearest neighbor interpolation.
  syntax:
    content: public TensorFlow.TFOutput ResizeNearestNeighbor (TensorFlow.TFOutput images, TensorFlow.TFOutput size, Nullable<bool> align_corners = null, string operName = null);
    parameters:
    - id: images
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: size
      type: TensorFlow.TFOutput
      description: >-
        = A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
                      new size for the images.
    - id: align_corners
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, the centers of the 4 corner pixels of the input and output tensors are
                      aligned, preserving the values at the corner pixels. Defaults to false.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeNearestNeighbor'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape
                      <code>[batch, new_height, new_width, channels]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ResizeNearestNeighbor*
  exceptions: []
- uid: TensorFlow.TFGraph.ResizeNearestNeighborGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResizeNearestNeighborGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResizeNearestNeighborGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeNearestNeighborGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeNearestNeighborGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradient of nearest neighbor interpolation.
  syntax:
    content: public TensorFlow.TFOutput ResizeNearestNeighborGrad (TensorFlow.TFOutput grads, TensorFlow.TFOutput size, Nullable<bool> align_corners = null, string operName = null);
    parameters:
    - id: grads
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, channels]</code>.
    - id: size
      type: TensorFlow.TFOutput
      description: >-
        = A 1-D int32 Tensor of 2 elements: <code>orig_height, orig_width</code>. The
                      original input size.
    - id: align_corners
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, the centers of the 4 corner pixels of the input and grad tensors are
                      aligned. Defaults to false.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResizeNearestNeighborGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        4-D with shape <code>[batch, orig_height, orig_width, channels]</code>. Gradients
                      with respect to the input image.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ResizeNearestNeighborGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the adadelta scheme.
  remarks: >-
    accum = rho() * accum + (1 - rho()) * grad.square();
                  update = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;
                  update_accum = rho() * update_accum + (1 - rho()) * update.square();
                  var -= update;
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyAdadelta (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput accum_update, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum_update
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: rho
      type: TensorFlow.TFOutput
      description: Decay factor. Must be a scalar.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Constant factor. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, updating of the var, accum and update_accum tensors will be protected by
                      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdadelta'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyAdadelta*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: ResourceApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the adagrad scheme.
  remarks: >-
    accum += grad * grad
                  var -= lr * grad * (1 / sqrt(accum))
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, Nullable<bool> update_slots = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: update_slots
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdagrad'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyAdagrad*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the proximal adagrad scheme.
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyAdagradDA (TensorFlow.TFOutput var, TensorFlow.TFOutput gradient_accumulator, TensorFlow.TFOutput gradient_squared_accumulator, TensorFlow.TFOutput grad, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput global_step, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: gradient_accumulator
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: gradient_squared_accumulator
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: global_step
      type: TensorFlow.TFOutput
      description: Training step number. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, updating of the var and accum tensors will be protected by
                      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdagradDA'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyAdagradDA*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyAdam(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: ResourceApplyAdam(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the Adam algorithm.
  remarks: >-
    $$lr_t := \text{learning\_rate} * \sqrt{1 - beta_2^t} / (1 - beta_1^t)$$
                  $$m_t := beta_1 * m_{t-1} + (1 - beta_1) * g$$
                  $$v_t := beta_2 * v_{t-1} + (1 - beta_2) * g * g$$
                  $$variable := variable - lr_t * m_t / (\sqrt{v_t} + \epsilon)$$
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyAdam (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput v, TensorFlow.TFOutput beta1_power, TensorFlow.TFOutput beta2_power, TensorFlow.TFOutput lr, TensorFlow.TFOutput beta1, TensorFlow.TFOutput beta2, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, Nullable<bool> use_nesterov = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: m
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: v
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: beta1_power
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: beta2_power
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: beta1
      type: TensorFlow.TFOutput
      description: Momentum factor. Must be a scalar.
    - id: beta2
      type: TensorFlow.TFOutput
      description: Momentum factor. Must be a scalar.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Ridge term. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var, m, and v tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: use_nesterov
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, uses the nesterov update.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdam'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyAdam*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyAdaMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceApplyAdaMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the AdaMax algorithm.
  remarks: >-
    m_t &lt;- beta1 * m_{t-1} + (1 - beta1) * g
                  v_t &lt;- max(beta2 * v_{t-1}, abs(g))
                  variable &lt;- variable - learning_rate / (1 - beta1^t) * m_t / (v_t + epsilon)
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyAdaMax (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput v, TensorFlow.TFOutput beta1_power, TensorFlow.TFOutput lr, TensorFlow.TFOutput beta1, TensorFlow.TFOutput beta2, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: m
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: v
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: beta1_power
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: beta1
      type: TensorFlow.TFOutput
      description: Momentum factor. Must be a scalar.
    - id: beta2
      type: TensorFlow.TFOutput
      description: Momentum factor. Must be a scalar.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Ridge term. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var, m, and v tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAdaMax'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyAdaMax*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyAddSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceApplyAddSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the AddSign update.
  remarks: >-
    m_t &lt;- beta1 * m_{t-1} + (1 - beta1) * g
                  update &lt;- (alpha + sign_decay * sign(g) *sign(m)) * g
                  variable &lt;- variable - lr_t * update
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyAddSign (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput lr, TensorFlow.TFOutput alpha, TensorFlow.TFOutput sign_decay, TensorFlow.TFOutput beta, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: m
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: alpha
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: sign_decay
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: beta
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and m tensors is
                      protected by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyAddSign'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyAddSign*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the centered RMSProp algorithm.
  remarks: "The centered RMSProp algorithm uses an estimate of the centered second moment\n              (i.e., the variance) for normalization, as opposed to regular RMSProp, which\n              uses the (uncentered) second moment. This often helps with training, but is\n              slightly more expensive in terms of computation and memory.\n              \n              Note that in dense implementation of this algorithm, mg, ms, and mom will\n              update even if the grad is zero, but in this sparse implementation, mg, ms,\n              and mom will not update in iterations during which the grad is zero.\n              \n              mean_square = decay * mean_square + (1-decay) * gradient ** 2\n              mean_grad = decay * mean_grad + (1-decay) * gradient\n              \n              Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n              \n              mg &lt;- rho * mg_{t-1} + (1-rho) * grad\n              ms &lt;- rho * ms_{t-1} + (1-rho) * grad * grad\n              mom &lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)\n              var &lt;- var - mom"
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyCenteredRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput mg, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: mg
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: ms
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: mom
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: rho
      type: TensorFlow.TFOutput
      description: Decay rate. Must be a scalar.
    - id: momentum
      type: TensorFlow.TFOutput
      description: To be added.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Ridge term. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var, mg, ms, and mom tensors is
                      protected by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyCenteredRMSProp'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyCenteredRMSProp*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the Ftrl-proximal scheme.
  remarks: >-
    accum_new = accum + grad * grad
                  linear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
                  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
                  var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
                  accum = accum_new
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyFtrl (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput lr_power, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: linear
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regulariation. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regulariation. Must be a scalar.
    - id: lr_power
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyFtrl'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyFtrl*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the Ftrl-proximal scheme.
  remarks: >-
    grad_with_shrinkage = grad + 2 * l2_shrinkage * var
                  accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
                  linear += grad_with_shrinkage +
                  (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
                  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
                  var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
                  accum = accum_new
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyFtrlV2 (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput l2_shrinkage, TensorFlow.TFOutput lr_power, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: linear
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regulariation. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 shrinkage regulariation. Must be a scalar.
    - id: l2_shrinkage
      type: TensorFlow.TFOutput
      description: To be added.
    - id: lr_power
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyFtrlV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyFtrlV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceApplyGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' by subtracting 'alpha' * 'delta' from it.
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyGradientDescent (TensorFlow.TFOutput var, TensorFlow.TFOutput alpha, TensorFlow.TFOutput delta, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: alpha
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: delta
      type: TensorFlow.TFOutput
      description: The change.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, the subtraction will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyGradientDescent'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyGradientDescent*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: ResourceApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the momentum scheme. Set use_nesterov = True if you
  remarks: "want to use Nesterov momentum.\n              \n              accum = accum * momentum + grad\n              var -= lr * accum"
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyMomentum (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, TensorFlow.TFOutput momentum, Nullable<bool> use_locking = null, Nullable<bool> use_nesterov = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: momentum
      type: TensorFlow.TFOutput
      description: Momentum. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: use_nesterov
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, the tensor passed to compute grad will be
                      var - lr * momentum * accum, so in the end, the var you get is actually
                      var - lr * momentum * accum.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyMomentum'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyMomentum*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyPowerSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceApplyPowerSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the AddSign update.
  remarks: >-
    m_t &lt;- beta1 * m_{t-1} + (1 - beta1) * g
                  update &lt;- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g
                  variable &lt;- variable - lr_t * update
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyPowerSign (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput lr, TensorFlow.TFOutput logbase, TensorFlow.TFOutput sign_decay, TensorFlow.TFOutput beta, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: m
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: logbase
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: sign_decay
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: beta
      type: TensorFlow.TFOutput
      description: Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and m tensors is
                      protected by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyPowerSign'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyPowerSign*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.
  remarks: >-
    accum += grad * grad
                  prox_v = var - lr * grad * (1 / sqrt(accum))
                  var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyProximalAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, updating of the var and accum tensors will be protected by
                      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyProximalAdagrad'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyProximalAdagrad*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' as FOBOS algorithm with fixed learning rate.
  remarks: >-
    prox_v = var - alpha * delta
                  var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyProximalGradientDescent (TensorFlow.TFOutput var, TensorFlow.TFOutput alpha, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput delta, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: alpha
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: delta
      type: TensorFlow.TFOutput
      description: The change.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the subtraction will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyProximalGradientDescent'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyProximalGradientDescent*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the RMSProp algorithm.
  remarks: "Note that in dense implementation of this algorithm, ms and mom will\n              update even if the grad is zero, but in this sparse implementation, ms\n              and mom will not update in iterations during which the grad is zero.\n              \n              mean_square = decay * mean_square + (1-decay) * gradient ** 2\n              Delta = learning_rate * gradient / sqrt(mean_square + epsilon)\n              \n              ms &lt;- rho * ms_{t-1} + (1-rho) * grad * grad\n              mom &lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\n              var &lt;- var - mom"
  syntax:
    content: public TensorFlow.TFOperation ResourceApplyRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: ms
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: mom
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: rho
      type: TensorFlow.TFOutput
      description: Decay rate. Must be a scalar.
    - id: momentum
      type: TensorFlow.TFOutput
      description: To be added.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Ridge term. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var, ms, and mom tensors is protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceApplyRMSProp'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceApplyRMSProp*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceCountUpTo(TensorFlow.TFOutput,System.Int64,TensorFlow.TFDataType,System.String)
  id: ResourceCountUpTo(TensorFlow.TFOutput,System.Int64,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceCountUpTo(TFOutput, Int64, TFDataType, String)
  nameWithType: TFGraph.ResourceCountUpTo(TFOutput, Int64, TFDataType, String)
  fullName: TFGraph.ResourceCountUpTo(TFOutput, Int64, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Increments variable pointed to by 'resource' until it reaches 'limit'.
  syntax:
    content: public TensorFlow.TFOutput ResourceCountUpTo (TensorFlow.TFOutput resource, long limit, TensorFlow.TFDataType T, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: Should be from a scalar <code>Variable</code> node.
    - id: limit
      type: System.Int64
      description: >-
        If incrementing ref would bring it above limit, instead generates an
                      'OutOfRange' error.
    - id: T
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceCountUpTo'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A copy of the input before increment. If nothing else modifies the
                      input, the values produced will all be distinct.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ResourceCountUpTo*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceGather(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  id: ResourceGather(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceGather(TFOutput, TFOutput, TFDataType, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceGather(TFOutput, TFOutput, TFDataType, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceGather(TFOutput, TFOutput, TFDataType, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gather slices from the variable pointed to by <code>resource</code> according to <code>indices</code>.
  remarks: "<code>indices</code> must be an integer tensor of any dimension (usually 0-D or 1-D).\n              Produces an output tensor with shape <code>indices.shape + params.shape[1:]</code> where:\n              \n               <pre><code>\n              # Scalar indices\n              output[:, ..., :] = params[indices, :, ... :]\n              \n              # Vector indices\n              output[i, :, ..., :] = params[indices[i], :, ... :]\n              \n              # Higher rank indices\n              output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput ResourceGather (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFDataType dtype, Nullable<bool> validate_indices = null, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: validate_indices
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceGather'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ResourceGather*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceScatterAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ResourceScatterAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceScatterAdd(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterAdd(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterAdd(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Adds sparse updates to the variable referenced by <code>resource</code>.
  remarks: "This operation computes\n              \n              # Scalar indices\n              ref[indices, ...] += updates[...]\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] += updates[i, ...]\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]\n              \n              Duplicate entries are handled correctly: if multiple <code>indices</code> reference\n              the same location, their contributions add.\n              \n              Requires <code>updates.shape = indices.shape + ref.shape[1:]</code> or <code>updates.shape = []</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOperation ResourceScatterAdd (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of updated values to add to <code>ref</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterAdd'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceScatterAdd*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceScatterDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ResourceScatterDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceScatterDiv(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterDiv(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterDiv(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Divides sparse updates into the variable referenced by <code>resource</code>.
  remarks: "This operation computes\n              \n              # Scalar indices\n              ref[indices, ...] /= updates[...]\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] /= updates[i, ...]\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]\n              \n              Duplicate entries are handled correctly: if multiple <code>indices</code> reference\n              the same location, their contributions multiply.\n              \n              Requires <code>updates.shape = indices.shape + ref.shape[1:]</code> or <code>updates.shape = []</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOperation ResourceScatterDiv (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of updated values to add to <code>ref</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterDiv'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceScatterDiv*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceScatterMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ResourceScatterMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceScatterMax(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterMax(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterMax(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reduces sparse updates into the variable referenced by <code>resource</code> using the <code>max</code> operation.
  remarks: "This operation computes\n              \n              # Scalar indices\n              ref[indices, ...] = max(ref[indices, ...], updates[...])\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] = max(ref[indices[i], ...], updates[i, ...])\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] = max(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])\n              \n              Duplicate entries are handled correctly: if multiple <code>indices</code> reference\n              the same location, their contributions are combined.\n              \n              Requires <code>updates.shape = indices.shape + ref.shape[1:]</code> or <code>updates.shape = []</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOperation ResourceScatterMax (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of updated values to add to <code>ref</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterMax'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceScatterMax*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceScatterMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ResourceScatterMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceScatterMin(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterMin(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterMin(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reduces sparse updates into the variable referenced by <code>resource</code> using the <code>min</code> operation.
  remarks: "This operation computes\n              \n              # Scalar indices\n              ref[indices, ...] = min(ref[indices, ...], updates[...])\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] = min(ref[indices[i], ...], updates[i, ...])\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] = min(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])\n              \n              Duplicate entries are handled correctly: if multiple <code>indices</code> reference\n              the same location, their contributions are combined.\n              \n              Requires <code>updates.shape = indices.shape + ref.shape[1:]</code> or <code>updates.shape = []</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOperation ResourceScatterMin (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of updated values to add to <code>ref</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterMin'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceScatterMin*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceScatterMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ResourceScatterMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceScatterMul(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterMul(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterMul(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Multiplies sparse updates into the variable referenced by <code>resource</code>.
  remarks: "This operation computes\n              \n              # Scalar indices\n              ref[indices, ...] *= updates[...]\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] *= updates[i, ...]\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]\n              \n              Duplicate entries are handled correctly: if multiple <code>indices</code> reference\n              the same location, their contributions multiply.\n              \n              Requires <code>updates.shape = indices.shape + ref.shape[1:]</code> or <code>updates.shape = []</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOperation ResourceScatterMul (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of updated values to add to <code>ref</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterMul'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceScatterMul*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceScatterNdAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceScatterNdAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Adds sparse <code>updates</code> to individual values or slices within a given
  remarks: "variable according to <code>indices</code>.\n              \n              <code>ref</code> is a <code>Tensor</code> with rank <code>P</code> and <code>indices</code> is a <code>Tensor</code> of rank <code>Q</code>.\n              \n              <code>indices</code> must be integer tensor, containing indices into <code>ref</code>.\n              It must be shape <code>[d_0, ..., d_{Q-2}, K]</code> where <code>0 &lt; K &lt;= P</code>.\n              \n              The innermost dimension of <code>indices</code> (with length <code>K</code>) corresponds to\n              indices into elements (if <code>K = P</code>) or slices (if <code>K &lt; P</code>) along the <code>K</code>th\n              dimension of <code>ref</code>.\n              \n              <code>updates</code> is <code>Tensor</code> of rank <code>Q-1+P-K</code> with shape:\n              \n               <pre><code>\n              [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].\n               </code></pre>\n              \n              For example, say we want to update 4 scattered elements to a rank-1 tensor to\n              8 elements. In Python, that update would look like this:\n              \n               <pre><code>\n              ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8], use_resource=True)\n              indices = tf.constant([[4], [3], [1] ,[7]])\n              updates = tf.constant([9, 10, 11, 12])\n              update = tf.scatter_nd_add(ref, indices, updates)\n              with tf.Session() as sess:\n              print sess.run(update)\n               </code></pre>\n              \n              The resulting update to ref would look like this:\n              \n              [1, 12, 3, 14, 14, 6, 7, 20]\n              \n              See <code>tf.scatter_nd</code> for more details about how to make updates to\n              slices."
  syntax:
    content: public TensorFlow.TFOperation ResourceScatterNdAdd (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: A resource handle. Must be from a VarHandleOp.
    - id: indices
      type: TensorFlow.TFOutput
      description: >-
        A Tensor. Must be one of the following types: int32, int64.
                      A tensor of indices into ref.
    - id: updates
      type: TensorFlow.TFOutput
      description: >-
        A Tensor. Must have the same type as ref. A tensor of
                      values to add to ref.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      An optional bool. Defaults to True. If True, the assignment will
                      be protected by a lock; otherwise the behavior is undefined,
                      but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterNdAdd'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceScatterNdAdd*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceScatterNdUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceScatterNdUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies sparse <code>updates</code> to individual values or slices within a given
  remarks: "variable according to <code>indices</code>.\n              \n              <code>ref</code> is a <code>Tensor</code> with rank <code>P</code> and <code>indices</code> is a <code>Tensor</code> of rank <code>Q</code>.\n              \n              <code>indices</code> must be integer tensor, containing indices into <code>ref</code>.\n              It must be shape <code>[d_0, ..., d_{Q-2}, K]</code> where <code>0 &lt; K &lt;= P</code>.\n              \n              The innermost dimension of <code>indices</code> (with length <code>K</code>) corresponds to\n              indices into elements (if <code>K = P</code>) or slices (if <code>K &lt; P</code>) along the <code>K</code>th\n              dimension of <code>ref</code>.\n              \n              <code>updates</code> is <code>Tensor</code> of rank <code>Q-1+P-K</code> with shape:\n              \n               <pre><code>\n              [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].\n               </code></pre>\n              \n              For example, say we want to update 4 scattered elements to a rank-1 tensor to\n              8 elements. In Python, that update would look like this:\n              \n               <pre><code>\n              ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n              indices = tf.constant([[4], [3], [1] ,[7]])\n              updates = tf.constant([9, 10, 11, 12])\n              update = tf.scatter_nd_update(ref, indices, updates)\n              with tf.Session() as sess:\n              print sess.run(update)\n               </code></pre>\n              \n              The resulting update to ref would look like this:\n              \n              [1, 11, 3, 10, 9, 6, 7, 12]\n              \n              See <code>tf.scatter_nd</code> for more details about how to make updates to\n              slices."
  syntax:
    content: public TensorFlow.TFOperation ResourceScatterNdUpdate (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: A resource handle. Must be from a VarHandleOp.
    - id: indices
      type: TensorFlow.TFOutput
      description: >-
        A Tensor. Must be one of the following types: int32, int64.
                      A tensor of indices into ref.
    - id: updates
      type: TensorFlow.TFOutput
      description: >-
        A Tensor. Must have the same type as ref. A tensor of updated
                      values to add to ref.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      An optional bool. Defaults to True. If True, the assignment will
                      be protected by a lock; otherwise the behavior is undefined,
                      but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterNdUpdate'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceScatterNdUpdate*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceScatterSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ResourceScatterSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceScatterSub(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterSub(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterSub(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Subtracts sparse updates from the variable referenced by <code>resource</code>.
  remarks: "This operation computes\n              \n              # Scalar indices\n              ref[indices, ...] -= updates[...]\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] -= updates[i, ...]\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]\n              \n              Duplicate entries are handled correctly: if multiple <code>indices</code> reference\n              the same location, their contributions add.\n              \n              Requires <code>updates.shape = indices.shape + ref.shape[1:]</code> or <code>updates.shape = []</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOperation ResourceScatterSub (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of updated values to add to <code>ref</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterSub'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceScatterSub*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceScatterUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ResourceScatterUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceScatterUpdate(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterUpdate(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterUpdate(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Assigns sparse updates to the variable referenced by <code>resource</code>.
  remarks: "This operation computes\n              \n              # Scalar indices\n              ref[indices, ...] = updates[...]\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] = updates[i, ...]\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]"
  syntax:
    content: public TensorFlow.TFOperation ResourceScatterUpdate (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of updated values to add to <code>ref</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceScatterUpdate'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceScatterUpdate*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceSparseApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceSparseApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceSparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'var: Should be from a Variable().'
  syntax:
    content: public TensorFlow.TFOperation ResourceSparseApplyAdadelta (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput accum_update, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: To be added.
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum_update
      type: TensorFlow.TFOutput
      description: ': Should be from a Variable().'
    - id: lr
      type: TensorFlow.TFOutput
      description: Learning rate. Must be a scalar.
    - id: rho
      type: TensorFlow.TFOutput
      description: Decay factor. Must be a scalar.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Constant factor. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, updating of the var and accum tensors will be protected by
                      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdadelta'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceSparseApplyAdadelta*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceSparseApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: ResourceSparseApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceSparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update relevant entries in '*var' and '*accum' according to the adagrad scheme.
  remarks: >-
    That is for rows we have grad for, we update var and accum as follows:
                  accum += grad * grad
                  var -= lr * grad * (1 / sqrt(accum))
  syntax:
    content: public TensorFlow.TFOperation ResourceSparseApplyAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable<bool> use_locking = null, Nullable<bool> update_slots = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Learning rate. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: update_slots
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdagrad'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceSparseApplyAdagrad*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceSparseApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceSparseApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceSparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update entries in '*var' and '*accum' according to the proximal adagrad scheme.
  syntax:
    content: public TensorFlow.TFOperation ResourceSparseApplyAdagradDA (TensorFlow.TFOutput var, TensorFlow.TFOutput gradient_accumulator, TensorFlow.TFOutput gradient_squared_accumulator, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput global_step, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: gradient_accumulator
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: gradient_squared_accumulator
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: lr
      type: TensorFlow.TFOutput
      description: Learning rate. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: global_step
      type: TensorFlow.TFOutput
      description: Training step number. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, updating of the var and accum tensors will be protected by
                      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyAdagradDA'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceSparseApplyAdagradDA*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceSparseApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceSparseApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceSparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the centered RMSProp algorithm.
  remarks: "The centered RMSProp algorithm uses an estimate of the centered second moment\n              (i.e., the variance) for normalization, as opposed to regular RMSProp, which\n              uses the (uncentered) second moment. This often helps with training, but is\n              slightly more expensive in terms of computation and memory.\n              \n              Note that in dense implementation of this algorithm, mg, ms, and mom will\n              update even if the grad is zero, but in this sparse implementation, mg, ms,\n              and mom will not update in iterations during which the grad is zero.\n              \n              mean_square = decay * mean_square + (1-decay) * gradient ** 2\n              mean_grad = decay * mean_grad + (1-decay) * gradient\n              Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n              \n              ms &lt;- rho * ms_{t-1} + (1-rho) * grad * grad\n              mom &lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\n              var &lt;- var - mom"
  syntax:
    content: public TensorFlow.TFOperation ResourceSparseApplyCenteredRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput mg, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: mg
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: ms
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: mom
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: rho
      type: TensorFlow.TFOutput
      description: Decay rate. Must be a scalar.
    - id: momentum
      type: TensorFlow.TFOutput
      description: To be added.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Ridge term. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var, ms and mom.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var, mg, ms, and mom tensors is
                      protected by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyCenteredRMSProp'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceSparseApplyCenteredRMSProp*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceSparseApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceSparseApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceSparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update relevant entries in '*var' according to the Ftrl-proximal scheme.
  remarks: >-
    That is for rows we have grad for, we update var, accum and linear as follows:
                  accum_new = accum + grad * grad
                  linear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
                  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
                  var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
                  accum = accum_new
  syntax:
    content: public TensorFlow.TFOperation ResourceSparseApplyFtrl (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput lr_power, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: linear
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: lr_power
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyFtrl'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceSparseApplyFtrl*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceSparseApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceSparseApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceSparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update relevant entries in '*var' according to the Ftrl-proximal scheme.
  remarks: >-
    That is for rows we have grad for, we update var, accum and linear as follows:
                  grad_with_shrinkage = grad + 2 * l2_shrinkage * var
                  accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
                  linear += grad_with_shrinkage +
                  (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
                  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
                  var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
                  accum = accum_new
  syntax:
    content: public TensorFlow.TFOperation ResourceSparseApplyFtrlV2 (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput l2_shrinkage, TensorFlow.TFOutput lr_power, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: linear
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 shrinkage regulariation. Must be a scalar.
    - id: l2_shrinkage
      type: TensorFlow.TFOutput
      description: To be added.
    - id: lr_power
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyFtrlV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceSparseApplyFtrlV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceSparseApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: ResourceSparseApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceSparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update relevant entries in '*var' and '*accum' according to the momentum scheme.
  remarks: "Set use_nesterov = True if you want to use Nesterov momentum.\n              \n              That is for rows we have grad for, we update var and accum as follows:\n              \n              accum = accum * momentum + grad\n              var -= lr * accum"
  syntax:
    content: public TensorFlow.TFOperation ResourceSparseApplyMomentum (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput momentum, Nullable<bool> use_locking = null, Nullable<bool> use_nesterov = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Learning rate. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: momentum
      type: TensorFlow.TFOutput
      description: Momentum. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: use_nesterov
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, the tensor passed to compute grad will be
                      var - lr * momentum * accum, so in the end, the var you get is actually
                      var - lr * momentum * accum.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyMomentum'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceSparseApplyMomentum*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceSparseApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceSparseApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceSparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.
  remarks: >-
    That is for rows we have grad for, we update var and accum as follows:
                  accum += grad * grad
                  prox_v = var
                  prox_v -= lr * grad * (1 / sqrt(accum))
                  var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}
  syntax:
    content: public TensorFlow.TFOperation ResourceSparseApplyProximalAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Learning rate. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, updating of the var and accum tensors will be protected by
                      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyProximalAdagrad'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceSparseApplyProximalAdagrad*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceSparseApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceSparseApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceSparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Sparse update '*var' as FOBOS algorithm with fixed learning rate.
  remarks: >-
    That is for rows we have grad for, we update var as follows:
                  prox_v = var - alpha * grad
                  var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}
  syntax:
    content: public TensorFlow.TFOperation ResourceSparseApplyProximalGradientDescent (TensorFlow.TFOutput var, TensorFlow.TFOutput alpha, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: alpha
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the subtraction will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyProximalGradientDescent'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceSparseApplyProximalGradientDescent*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceSparseApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ResourceSparseApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceSparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the RMSProp algorithm.
  remarks: "Note that in dense implementation of this algorithm, ms and mom will\n              update even if the grad is zero, but in this sparse implementation, ms\n              and mom will not update in iterations during which the grad is zero.\n              \n              mean_square = decay * mean_square + (1-decay) * gradient ** 2\n              Delta = learning_rate * gradient / sqrt(mean_square + epsilon)\n              \n              ms &lt;- rho * ms_{t-1} + (1-rho) * grad * grad\n              mom &lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\n              var &lt;- var - mom"
  syntax:
    content: public TensorFlow.TFOperation ResourceSparseApplyRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: ms
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: mom
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: rho
      type: TensorFlow.TFOutput
      description: Decay rate. Must be a scalar.
    - id: momentum
      type: TensorFlow.TFOutput
      description: To be added.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Ridge term. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var, ms and mom.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var, ms, and mom tensors is protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ResourceSparseApplyRMSProp'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ResourceSparseApplyRMSProp*
  exceptions: []
- uid: TensorFlow.TFGraph.ResourceStridedSliceAssign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: ResourceStridedSliceAssign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ResourceStridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.ResourceStridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.ResourceStridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  syntax:
    content: public TensorFlow.TFOperation ResourceStridedSliceAssign (TensorFlow.TFOutput reference, TensorFlow.TFOutput begin, TensorFlow.TFOutput end, TensorFlow.TFOutput strides, TensorFlow.TFOutput value, Nullable<long> begin_mask = null, Nullable<long> end_mask = null, Nullable<long> ellipsis_mask = null, Nullable<long> new_axis_mask = null, Nullable<long> shrink_axis_mask = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: To be added.
    - id: begin
      type: TensorFlow.TFOutput
      description: To be added.
    - id: end
      type: TensorFlow.TFOutput
      description: To be added.
    - id: strides
      type: TensorFlow.TFOutput
      description: To be added.
    - id: value
      type: TensorFlow.TFOutput
      description: To be added.
    - id: begin_mask
      type: System.Nullable{System.Int64}
      description: To be added.
    - id: end_mask
      type: System.Nullable{System.Int64}
      description: To be added.
    - id: ellipsis_mask
      type: System.Nullable{System.Int64}
      description: To be added.
    - id: new_axis_mask
      type: System.Nullable{System.Int64}
      description: To be added.
    - id: shrink_axis_mask
      type: System.Nullable{System.Int64}
      description: To be added.
    - id: operName
      type: System.String
      description: To be added.
    return:
      type: TensorFlow.TFOperation
      description: To be added.
  overload: TensorFlow.TFGraph.ResourceStridedSliceAssign*
  exceptions: []
- uid: TensorFlow.TFGraph.Restore(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)
  id: Restore(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Restore(TFOutput, TFOutput, TFDataType, Nullable<Int64>, String)
  nameWithType: TFGraph.Restore(TFOutput, TFOutput, TFDataType, Nullable<Int64>, String)
  fullName: TFGraph.Restore(TFOutput, TFOutput, TFDataType, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Restores a tensor from checkpoint files.
  remarks: "Reads a tensor stored in one or several files. If there are several files (for\n              instance because a tensor was saved as slices), <code>file_pattern</code> may contain\n              wildcard symbols (<code>*</code> and <code>?</code>) in the filename portion only, not in the\n              directory portion.\n              \n              If a <code>file_pattern</code> matches several files, <code>preferred_shard</code> can be used to hint\n              in which file the requested tensor is likely to be found. This op will first\n              open the file at index <code>preferred_shard</code> in the list of matching files and try\n              to restore tensors from that file.  Only if some tensors or tensor slices are\n              not found in that first file, then the Op opens all the files. Setting\n              <code>preferred_shard</code> to match the value passed as the <code>shard</code> input\n              of a matching <code>Save</code> Op may speed up Restore.  This attribute only affects\n              performance, not correctness.  The default value -1 means files are processed in\n              order.\n              \n              See also <code>RestoreSlice</code>."
  syntax:
    content: public TensorFlow.TFOutput Restore (TensorFlow.TFOutput file_pattern, TensorFlow.TFOutput tensor_name, TensorFlow.TFDataType dt, Nullable<long> preferred_shard = null, string operName = null);
    parameters:
    - id: file_pattern
      type: TensorFlow.TFOutput
      description: >-
        Must have a single element. The pattern of the files from
                      which we read the tensor.
    - id: tensor_name
      type: TensorFlow.TFOutput
      description: >-
        Must have a single element. The name of the tensor to be
                      restored.
    - id: dt
      type: TensorFlow.TFDataType
      description: The type of the tensor to be restored.
    - id: preferred_shard
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Index of file to open first if multiple files match
                      <code>file_pattern</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Restore'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The restored tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Restore*
  exceptions: []
- uid: TensorFlow.TFGraph.RestoreSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)
  id: RestoreSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RestoreSlice(TFOutput, TFOutput, TFOutput, TFDataType, Nullable<Int64>, String)
  nameWithType: TFGraph.RestoreSlice(TFOutput, TFOutput, TFOutput, TFDataType, Nullable<Int64>, String)
  fullName: TFGraph.RestoreSlice(TFOutput, TFOutput, TFOutput, TFDataType, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Restores a tensor from checkpoint files.
  remarks: "This is like <code>Restore</code> except that restored tensor can be listed as filling\n              only a slice of a larger tensor.  <code>shape_and_slice</code> specifies the shape of the\n              larger tensor and the slice that the restored tensor covers.\n              \n              The <code>shape_and_slice</code> input has the same format as the\n              elements of the <code>shapes_and_slices</code> input of the <code>SaveSlices</code> op."
  syntax:
    content: public TensorFlow.TFOutput RestoreSlice (TensorFlow.TFOutput file_pattern, TensorFlow.TFOutput tensor_name, TensorFlow.TFOutput shape_and_slice, TensorFlow.TFDataType dt, Nullable<long> preferred_shard = null, string operName = null);
    parameters:
    - id: file_pattern
      type: TensorFlow.TFOutput
      description: >-
        Must have a single element. The pattern of the files from
                      which we read the tensor.
    - id: tensor_name
      type: TensorFlow.TFOutput
      description: >-
        Must have a single element. The name of the tensor to be
                      restored.
    - id: shape_and_slice
      type: TensorFlow.TFOutput
      description: >-
        Scalar. The shapes and slice specifications to use when
                      restoring a tensors.
    - id: dt
      type: TensorFlow.TFDataType
      description: The type of the tensor to be restored.
    - id: preferred_shard
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Index of file to open first if multiple files match
                      <code>file_pattern</code>. See the documentation for <code>Restore</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RestoreSlice'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The restored tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RestoreSlice*
  exceptions: []
- uid: TensorFlow.TFGraph.RestoreV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.String)
  id: RestoreV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RestoreV2(TFOutput, TFOutput, TFOutput, TFDataType[], String)
  nameWithType: TFGraph.RestoreV2(TFOutput, TFOutput, TFOutput, TFDataType[], String)
  fullName: TFGraph.RestoreV2(TFOutput, TFOutput, TFOutput, TFDataType[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Restores tensors from a V2 checkpoint.
  remarks: "For backward compatibility with the V1 format, this Op currently allows\n              restoring from a V1 checkpoint as well:\n              - This Op first attempts to find the V2 index file pointed to by \"prefix\", and\n              if found proceed to read it as a V2 checkpoint;\n              - Otherwise the V1 read path is invoked.\n              Relying on this behavior is not recommended, as the ability to fall back to read\n              V1 might be deprecated and eventually removed.\n              \n              By default, restores the named tensors in full.  If the caller wishes to restore\n              specific slices of stored tensors, \"shape_and_slices\" should be non-empty\n              strings and correspondingly well-formed.\n              \n              Callers must ensure all the named tensors are indeed stored in the checkpoint."
  syntax:
    content: public TensorFlow.TFOutput[] RestoreV2 (TensorFlow.TFOutput prefix, TensorFlow.TFOutput tensor_names, TensorFlow.TFOutput shape_and_slices, TensorFlow.TFDataType[] dtypes, string operName = null);
    parameters:
    - id: prefix
      type: TensorFlow.TFOutput
      description: Must have a single element.  The prefix of a V2 checkpoint.
    - id: tensor_names
      type: TensorFlow.TFOutput
      description: shape {N}.  The names of the tensors to be restored.
    - id: shape_and_slices
      type: TensorFlow.TFOutput
      description: >-
        shape {N}.  The slice specs of the tensors to be restored.
                      Empty strings indicate that they are non-partitioned tensors.
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: >-
        shape {N}.  The list of expected dtype for the tensors.  Must match
                      those stored in the checkpoint.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RestoreV2'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        shape {N}.  The restored tensors, whose shapes are read from the
                      checkpoint directly.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RestoreV2*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingAdadeltaParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingAdadeltaParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingAdadeltaParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingAdadeltaParameters(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the Adadelta optimization algorithm.\n              accumulators: A tensor containing the embedding table accumulators to store with the\n              parameters from embedding updates using the Adadelta optimization algorithm.\n              updates: A tensor containing the embedding table updates to store with the\n              parameters from embedding updates using the Adadelta optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingAdadeltaParameters (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingAdadeltaParameters'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the Adadelta optimization algorithm.
                      accumulators: Parameter accumulators updated by the Adadelta optimization algorithm.
                      updates: Parameter updates updated by the Adadelta optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the Adadelta optimization algorithm.\n              accumulators: A tensor containing the embedding table accumulators to store with the\n              parameters from embedding updates using the Adadelta optimization algorithm.\n              updates: A tensor containing the embedding table updates to store with the\n              parameters from embedding updates using the Adadelta optimization algorithm.\n              gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the\n              parameters from embedding updates using the Adadelta optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the Adadelta optimization algorithm.
                      accumulators: Parameter accumulators updated by the Adadelta optimization algorithm.
                      updates: Parameter updates updated by the Adadelta optimization algorithm.
                      gradient_accumulators: Parameter gradient_accumulators updated by the Adadelta optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingAdagradParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingAdagradParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingAdagradParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingAdagradParameters(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the Adagrad optimization algorithm.\n              accumulators: A tensor containing the embedding table accumulators to store with the\n              parameters from embedding updates using the Adagrad optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingAdagradParameters (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingAdagradParameters'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the Adagrad optimization algorithm.
                      accumulators: Parameter accumulators updated by the Adagrad optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingAdagradParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingAdagradParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the Adagrad optimization algorithm.\n              accumulators: A tensor containing the embedding table accumulators to store with the\n              parameters from embedding updates using the Adagrad optimization algorithm.\n              gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the\n              parameters from embedding updates using the Adagrad optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingAdagradParametersGradAccumDebug (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingAdagradParametersGradAccumDebug'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the Adagrad optimization algorithm.
                      accumulators: Parameter accumulators updated by the Adagrad optimization algorithm.
                      gradient_accumulators: Parameter gradient_accumulators updated by the Adagrad optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingADAMParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingADAMParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingADAMParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingADAMParameters(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the ADAM optimization algorithm.\n              momenta: A tensor containing the embedding table momenta to store with the\n              parameters from embedding updates using the ADAM optimization algorithm.\n              velocities: A tensor containing the embedding table velocities to store with the\n              parameters from embedding updates using the ADAM optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingADAMParameters (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingADAMParameters'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the ADAM optimization algorithm.
                      momenta: Parameter momenta updated by the ADAM optimization algorithm.
                      velocities: Parameter velocities updated by the ADAM optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingADAMParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingADAMParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingADAMParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingADAMParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the ADAM optimization algorithm.\n              momenta: A tensor containing the embedding table momenta to store with the\n              parameters from embedding updates using the ADAM optimization algorithm.\n              velocities: A tensor containing the embedding table velocities to store with the\n              parameters from embedding updates using the ADAM optimization algorithm.\n              gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the\n              parameters from embedding updates using the ADAM optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingADAMParametersGradAccumDebug (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingADAMParametersGradAccumDebug'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the ADAM optimization algorithm.
                      momenta: Parameter momenta updated by the ADAM optimization algorithm.
                      velocities: Parameter velocities updated by the ADAM optimization algorithm.
                      gradient_accumulators: Parameter gradient_accumulators updated by the ADAM optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingCenteredRMSPropParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingCenteredRMSPropParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingCenteredRMSPropParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingCenteredRMSPropParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingCenteredRMSPropParameters(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the centered RMSProp optimization algorithm.\n              ms: A tensor containing the embedding table ms to store with the\n              parameters from embedding updates using the centered RMSProp optimization algorithm.\n              mom: A tensor containing the embedding table mom to store with the\n              parameters from embedding updates using the centered RMSProp optimization algorithm.\n              mg: A tensor containing the embedding table mg to store with the\n              parameters from embedding updates using the centered RMSProp optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingCenteredRMSPropParameters (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingCenteredRMSPropParameters'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the centered RMSProp optimization algorithm.
                      ms: Parameter ms updated by the centered RMSProp optimization algorithm.
                      mom: Parameter mom updated by the centered RMSProp optimization algorithm.
                      mg: Parameter mg updated by the centered RMSProp optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingCenteredRMSPropParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingFTRLParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingFTRLParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingFTRLParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingFTRLParameters(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the FTRL optimization algorithm.\n              accumulators: A tensor containing the embedding table accumulators to store with the\n              parameters from embedding updates using the FTRL optimization algorithm.\n              linears: A tensor containing the embedding table linears to store with the\n              parameters from embedding updates using the FTRL optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingFTRLParameters (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingFTRLParameters'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the FTRL optimization algorithm.
                      accumulators: Parameter accumulators updated by the FTRL optimization algorithm.
                      linears: Parameter linears updated by the FTRL optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingFTRLParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingFTRLParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the FTRL optimization algorithm.\n              accumulators: A tensor containing the embedding table accumulators to store with the\n              parameters from embedding updates using the FTRL optimization algorithm.\n              linears: A tensor containing the embedding table linears to store with the\n              parameters from embedding updates using the FTRL optimization algorithm.\n              gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the\n              parameters from embedding updates using the FTRL optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingFTRLParametersGradAccumDebug (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingFTRLParametersGradAccumDebug'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the FTRL optimization algorithm.
                      accumulators: Parameter accumulators updated by the FTRL optimization algorithm.
                      linears: Parameter linears updated by the FTRL optimization algorithm.
                      gradient_accumulators: Parameter gradient_accumulators updated by the FTRL optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingMDLAdagradLightParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingMDLAdagradLightParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingMDLAdagradLightParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingMDLAdagradLightParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingMDLAdagradLightParameters(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the MDL Adagrad Light optimization algorithm.\n              accumulators: A tensor containing the embedding table accumulators to store with the\n              parameters from embedding updates using the MDL Adagrad Light optimization algorithm.\n              weights: A tensor containing the embedding table weights to store with the\n              parameters from embedding updates using the MDL Adagrad Light optimization algorithm.\n              benefits: A tensor containing the embedding table benefits to store with the\n              parameters from embedding updates using the MDL Adagrad Light optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingMDLAdagradLightParameters (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingMDLAdagradLightParameters'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the MDL Adagrad Light optimization algorithm.
                      accumulators: Parameter accumulators updated by the MDL Adagrad Light optimization algorithm.
                      weights: Parameter weights updated by the MDL Adagrad Light optimization algorithm.
                      benefits: Parameter benefits updated by the MDL Adagrad Light optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingMDLAdagradLightParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingMomentumParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingMomentumParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingMomentumParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingMomentumParameters(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the Momentum optimization algorithm.\n              momenta: A tensor containing the embedding table momenta to store with the\n              parameters from embedding updates using the Momentum optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingMomentumParameters (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingMomentumParameters'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the Momentum optimization algorithm.
                      momenta: Parameter momenta updated by the Momentum optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingMomentumParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingMomentumParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the Momentum optimization algorithm.\n              momenta: A tensor containing the embedding table momenta to store with the\n              parameters from embedding updates using the Momentum optimization algorithm.\n              gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the\n              parameters from embedding updates using the Momentum optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingMomentumParametersGradAccumDebug (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingMomentumParametersGradAccumDebug'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the Momentum optimization algorithm.
                      momenta: Parameter momenta updated by the Momentum optimization algorithm.
                      gradient_accumulators: Parameter gradient_accumulators updated by the Momentum optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingProximalAdagradParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingProximalAdagradParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingProximalAdagradParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingProximalAdagradParameters(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the proximal Adagrad optimization algorithm.\n              accumulators: A tensor containing the embedding table accumulators to store with the\n              parameters from embedding updates using the proximal Adagrad optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingProximalAdagradParameters (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingProximalAdagradParameters'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the proximal Adagrad optimization algorithm.
                      accumulators: Parameter accumulators updated by the proximal Adagrad optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the proximal Adagrad optimization algorithm.\n              accumulators: A tensor containing the embedding table accumulators to store with the\n              parameters from embedding updates using the proximal Adagrad optimization algorithm.\n              gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the\n              parameters from embedding updates using the proximal Adagrad optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the proximal Adagrad optimization algorithm.
                      accumulators: Parameter accumulators updated by the proximal Adagrad optimization algorithm.
                      gradient_accumulators: Parameter gradient_accumulators updated by the proximal Adagrad optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingRMSPropParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingRMSPropParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingRMSPropParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingRMSPropParameters(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the RMSProp optimization algorithm.\n              ms: A tensor containing the embedding table ms to store with the\n              parameters from embedding updates using the RMSProp optimization algorithm.\n              mom: A tensor containing the embedding table mom to store with the\n              parameters from embedding updates using the RMSProp optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingRMSPropParameters (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingRMSPropParameters'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the RMSProp optimization algorithm.
                      ms: Parameter ms updated by the RMSProp optimization algorithm.
                      mom: Parameter mom updated by the RMSProp optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the RMSProp optimization algorithm.\n              ms: A tensor containing the embedding table ms to store with the\n              parameters from embedding updates using the RMSProp optimization algorithm.\n              mom: A tensor containing the embedding table mom to store with the\n              parameters from embedding updates using the RMSProp optimization algorithm.\n              gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the\n              parameters from embedding updates using the RMSProp optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      parameters: Parameter parameters updated by the RMSProp optimization algorithm.
                      ms: Parameter ms updated by the RMSProp optimization algorithm.
                      mom: Parameter mom updated by the RMSProp optimization algorithm.
                      gradient_accumulators: Parameter gradient_accumulators updated by the RMSProp optimization algorithm.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug*
  exceptions: []
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingStochasticGradientDescentParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  id: RetrieveTPUEmbeddingStochasticGradientDescentParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RetrieveTPUEmbeddingStochasticGradientDescentParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingStochasticGradientDescentParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingStochasticGradientDescentParameters(Int64, Int64, Nullable<Int64>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Retrieve embedding parameters for a single table.
  remarks: "An op that retrieves optimization parameters from embedding to host\n              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up\n              the correct embedding table configuration. For example, this op is\n              used to retrieve updated parameters before saving a checkpoint.\n              \n              parameters: A tensor containing the embedding table parameters to store with the\n              parameters from embedding updates using the stochastic gradient descent optimization algorithm.\n              table_name: Name of this table; must match a name in the\n              TPUEmbeddingConfiguration proto (overrides table_id).\n              num_shards: Number of shards into which the embedding tables are divided.\n              shard_id: Identifier of shard for this operation.\n              table_id: Index of this table in the EmbeddingLayerConfiguration proto\n              (deprecated)."
  syntax:
    content: public TensorFlow.TFOutput RetrieveTPUEmbeddingStochasticGradientDescentParameters (long num_shards, long shard_id, Nullable<long> table_id = null, string table_name = null, string operName = null);
    parameters:
    - id: num_shards
      type: System.Int64
      description: To be added.
    - id: shard_id
      type: System.Int64
      description: To be added.
    - id: table_id
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: table_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RetrieveTPUEmbeddingStochasticGradientDescentParameters'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Parameter parameters updated by the stochastic gradient descent optimization algorithm.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RetrieveTPUEmbeddingStochasticGradientDescentParameters*
  exceptions: []
- uid: TensorFlow.TFGraph.Reverse(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Reverse(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Reverse(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Reverse(TFOutput, TFOutput, String)
  fullName: TFGraph.Reverse(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reverses specific dimensions of a tensor.
  remarks: "Given a <code>tensor</code>, and a <code>bool</code> tensor <code>dims</code> representing the dimensions\n              of <code>tensor</code>, this operation reverses each dimension i of <code>tensor</code> where\n              <code>dims[i]</code> is <code>True</code>.\n              \n              <code>tensor</code> can have up to 8 dimensions. The number of dimensions\n              of <code>tensor</code> must equal the number of elements in <code>dims</code>. In other words:\n              \n              <code>rank(tensor) = size(dims)</code>\n              \n              For example:\n              \n               <pre><code>\n              # tensor 't' is [[[[ 0,  1,  2,  3],\n              #                  [ 4,  5,  6,  7],\n              #                  [ 8,  9, 10, 11]],\n              #                 [[12, 13, 14, 15],\n              #                  [16, 17, 18, 19],\n              #                  [20, 21, 22, 23]]]]\n              # tensor 't' shape is [1, 2, 3, 4]\n              \n              # 'dims' is [False, False, False, True]\n              reverse(t, dims) ==&gt; [[[[ 3,  2,  1,  0],\n              [ 7,  6,  5,  4],\n              [ 11, 10, 9, 8]],\n              [[15, 14, 13, 12],\n              [19, 18, 17, 16],\n              [23, 22, 21, 20]]]]\n              \n              # 'dims' is [False, True, False, False]\n              reverse(t, dims) ==&gt; [[[[12, 13, 14, 15],\n              [16, 17, 18, 19],\n              [20, 21, 22, 23]\n              [[ 0,  1,  2,  3],\n              [ 4,  5,  6,  7],\n              [ 8,  9, 10, 11]]]]\n              \n              # 'dims' is [False, False, True, False]\n              reverse(t, dims) ==&gt; [[[[8, 9, 10, 11],\n              [4, 5, 6, 7],\n              [0, 1, 2, 3]]\n              [[20, 21, 22, 23],\n              [16, 17, 18, 19],\n              [12, 13, 14, 15]]]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Reverse (TensorFlow.TFOutput tensor, TensorFlow.TFOutput dims, string operName = null);
    parameters:
    - id: tensor
      type: TensorFlow.TFOutput
      description: Up to 8-D.
    - id: dims
      type: TensorFlow.TFOutput
      description: 1-D. The dimensions to reverse.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Reverse'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The same shape as <code>tensor</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Reverse*
  exceptions: []
- uid: TensorFlow.TFGraph.ReverseSequence(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.String)
  id: ReverseSequence(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReverseSequence(TFOutput, TFOutput, Int64, Nullable<Int64>, String)
  nameWithType: TFGraph.ReverseSequence(TFOutput, TFOutput, Int64, Nullable<Int64>, String)
  fullName: TFGraph.ReverseSequence(TFOutput, TFOutput, Int64, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reverses variable length slices.
  remarks: "This op first slices <code>input</code> along the dimension <code>batch_dim</code>, and for each\n              slice <code>i</code>, reverses the first <code>seq_lengths[i]</code> elements along\n              the dimension <code>seq_dim</code>.\n              \n              The elements of <code>seq_lengths</code> must obey <code>seq_lengths[i] &lt;= input.dims[seq_dim]</code>,\n              and <code>seq_lengths</code> must be a vector of length <code>input.dims[batch_dim]</code>.\n              \n              The output slice <code>i</code> along dimension <code>batch_dim</code> is then given by input\n              slice <code>i</code>, with the first <code>seq_lengths[i]</code> slices along dimension\n              <code>seq_dim</code> reversed.\n              \n              For example:\n              \n               <pre><code>\n              # Given this:\n              batch_dim = 0\n              seq_dim = 1\n              input.dims = (4, 8, ...)\n              seq_lengths = [7, 2, 3, 5]\n              \n              # then slices of input are reversed on seq_dim, but only up to seq_lengths:\n              output[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]\n              output[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]\n              output[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]\n              output[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]\n              \n              # while entries past seq_lens are copied through:\n              output[0, 7:, :, ...] = input[0, 7:, :, ...]\n              output[1, 2:, :, ...] = input[1, 2:, :, ...]\n              output[2, 3:, :, ...] = input[2, 3:, :, ...]\n              output[3, 2:, :, ...] = input[3, 2:, :, ...]\n               </code></pre>\n              \n              In contrast, if:\n              \n               <pre><code>\n              # Given this:\n              batch_dim = 2\n              seq_dim = 0\n              input.dims = (8, ?, 4, ...)\n              seq_lengths = [7, 2, 3, 5]\n              \n              # then slices of input are reversed on seq_dim, but only up to seq_lengths:\n              output[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...]\n              output[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...]\n              output[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...]\n              output[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]\n              \n              # while entries past seq_lens are copied through:\n              output[7:, :, 0, :, ...] = input[7:, :, 0, :, ...]\n              output[2:, :, 1, :, ...] = input[2:, :, 1, :, ...]\n              output[3:, :, 2, :, ...] = input[3:, :, 2, :, ...]\n              output[2:, :, 3, :, ...] = input[2:, :, 3, :, ...]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput ReverseSequence (TensorFlow.TFOutput input, TensorFlow.TFOutput seq_lengths, long seq_dim, Nullable<long> batch_dim = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The input to reverse.
    - id: seq_lengths
      type: TensorFlow.TFOutput
      description: >-
        1-D with length <code>input.dims(batch_dim)</code> and
                      <code>max(seq_lengths) &lt;= input.dims(seq_dim)</code>
    - id: seq_dim
      type: System.Int64
      description: The dimension which is partially reversed.
    - id: batch_dim
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The dimension along which reversal is performed.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReverseSequence'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The partially reversed input. It has the same shape as <code>input</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ReverseSequence*
  exceptions: []
- uid: TensorFlow.TFGraph.ReverseV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ReverseV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ReverseV2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReverseV2(TFOutput, TFOutput, String)
  fullName: TFGraph.ReverseV2(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reverses specific dimensions of a tensor.
  remarks: "NOTE <code>tf.reverse</code> has now changed behavior in preparation for 1.0.\n              <code>tf.reverse_v2</code> is currently an alias that will be deprecated before TF 1.0.\n              \n              Given a <code>tensor</code>, and a <code>int32</code> tensor <code>axis</code> representing the set of\n              dimensions of <code>tensor</code> to reverse. This operation reverses each dimension\n              <code>i</code> for which there exists <code>j</code> s.t. <code>axis[j] == i</code>.\n              \n              <code>tensor</code> can have up to 8 dimensions. The number of dimensions specified\n              in <code>axis</code> may be 0 or more entries. If an index is specified more than\n              once, a InvalidArgument error is raised.\n              \n              For example:\n              \n               <pre><code>\n              # tensor 't' is [[[[ 0,  1,  2,  3],\n              #                  [ 4,  5,  6,  7],\n              #                  [ 8,  9, 10, 11]],\n              #                 [[12, 13, 14, 15],\n              #                  [16, 17, 18, 19],\n              #                  [20, 21, 22, 23]]]]\n              # tensor 't' shape is [1, 2, 3, 4]\n              \n              # 'dims' is [3] or 'dims' is [-1]\n              reverse(t, dims) ==&gt; [[[[ 3,  2,  1,  0],\n              [ 7,  6,  5,  4],\n              [ 11, 10, 9, 8]],\n              [[15, 14, 13, 12],\n              [19, 18, 17, 16],\n              [23, 22, 21, 20]]]]\n              \n              # 'dims' is '[1]' (or 'dims' is '[-3]')\n              reverse(t, dims) ==&gt; [[[[12, 13, 14, 15],\n              [16, 17, 18, 19],\n              [20, 21, 22, 23]\n              [[ 0,  1,  2,  3],\n              [ 4,  5,  6,  7],\n              [ 8,  9, 10, 11]]]]\n              \n              # 'dims' is '[2]' (or 'dims' is '[-2]')\n              reverse(t, dims) ==&gt; [[[[8, 9, 10, 11],\n              [4, 5, 6, 7],\n              [0, 1, 2, 3]]\n              [[20, 21, 22, 23],\n              [16, 17, 18, 19],\n              [12, 13, 14, 15]]]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput ReverseV2 (TensorFlow.TFOutput tensor, TensorFlow.TFOutput axis, string operName = null);
    parameters:
    - id: tensor
      type: TensorFlow.TFOutput
      description: Up to 8-D.
    - id: axis
      type: TensorFlow.TFOutput
      description: >-
        1-D. The indices of the dimensions to reverse. Must be in the range
                      <code>[-rank(tensor), rank(tensor))</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ReverseV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The same shape as <code>tensor</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ReverseV2*
  exceptions: []
- uid: TensorFlow.TFGraph.RFFT(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: RFFT(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RFFT(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RFFT(TFOutput, TFOutput, String)
  fullName: TFGraph.RFFT(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Real-valued fast Fourier transform.
  remarks: "Computes the 1-dimensional discrete Fourier transform of a real-valued signal\n              over the inner-most dimension of <code>input</code>.\n              \n              Since the DFT of a real signal is Hermitian-symmetric, <code>RFFT</code> only returns the\n              <code>fft_length / 2 + 1</code> unique components of the FFT: the zero-frequency term,\n              followed by the <code>fft_length / 2</code> positive-frequency terms.\n              \n              Along the axis <code>RFFT</code> is computed on, if <code>fft_length</code> is smaller than the\n              corresponding dimension of <code>input</code>, the dimension is cropped. If it is larger,\n              the dimension is padded with zeros."
  syntax:
    content: public TensorFlow.TFOutput RFFT (TensorFlow.TFOutput input, TensorFlow.TFOutput fft_length, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A float32 tensor.
    - id: fft_length
      type: TensorFlow.TFOutput
      description: An int32 tensor of shape [1]. The FFT length.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RFFT'.
    return:
      type: TensorFlow.TFOutput
      description: "A complex64 tensor of the same rank as <code>input</code>. The inner-most\n              dimension of <code>input</code> is replaced with the <code>fft_length / 2 + 1</code> unique\n              frequency components of its 1D Fourier transform.\n              \n              @compatibility(numpy)\n              Equivalent to np.fft.rfft\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.RFFT*
  exceptions: []
- uid: TensorFlow.TFGraph.RFFT2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: RFFT2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RFFT2D(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RFFT2D(TFOutput, TFOutput, String)
  fullName: TFGraph.RFFT2D(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 2D real-valued fast Fourier transform.
  remarks: "Computes the 2-dimensional discrete Fourier transform of a real-valued signal\n              over the inner-most 2 dimensions of <code>input</code>.\n              \n              Since the DFT of a real signal is Hermitian-symmetric, <code>RFFT2D</code> only returns the\n              <code>fft_length / 2 + 1</code> unique components of the FFT for the inner-most dimension\n              of <code>output</code>: the zero-frequency term, followed by the <code>fft_length / 2</code>\n              positive-frequency terms.\n              \n              Along each axis <code>RFFT2D</code> is computed on, if <code>fft_length</code> is smaller than the\n              corresponding dimension of <code>input</code>, the dimension is cropped. If it is larger,\n              the dimension is padded with zeros."
  syntax:
    content: public TensorFlow.TFOutput RFFT2D (TensorFlow.TFOutput input, TensorFlow.TFOutput fft_length, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A float32 tensor.
    - id: fft_length
      type: TensorFlow.TFOutput
      description: An int32 tensor of shape [2]. The FFT length for each dimension.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RFFT2D'.
    return:
      type: TensorFlow.TFOutput
      description: "A complex64 tensor of the same rank as <code>input</code>. The inner-most 2\n              dimensions of <code>input</code> are replaced with their 2D Fourier transform. The\n              inner-most dimension contains <code>fft_length / 2 + 1</code> unique frequency\n              components.\n              \n              @compatibility(numpy)\n              Equivalent to np.fft.rfft2\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.RFFT2D*
  exceptions: []
- uid: TensorFlow.TFGraph.RFFT3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: RFFT3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RFFT3D(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RFFT3D(TFOutput, TFOutput, String)
  fullName: TFGraph.RFFT3D(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 3D real-valued fast Fourier transform.
  remarks: "Computes the 3-dimensional discrete Fourier transform of a real-valued signal\n              over the inner-most 3 dimensions of <code>input</code>.\n              \n              Since the DFT of a real signal is Hermitian-symmetric, <code>RFFT3D</code> only returns the\n              <code>fft_length / 2 + 1</code> unique components of the FFT for the inner-most dimension\n              of <code>output</code>: the zero-frequency term, followed by the <code>fft_length / 2</code>\n              positive-frequency terms.\n              \n              Along each axis <code>RFFT3D</code> is computed on, if <code>fft_length</code> is smaller than the\n              corresponding dimension of <code>input</code>, the dimension is cropped. If it is larger,\n              the dimension is padded with zeros."
  syntax:
    content: public TensorFlow.TFOutput RFFT3D (TensorFlow.TFOutput input, TensorFlow.TFOutput fft_length, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A float32 tensor.
    - id: fft_length
      type: TensorFlow.TFOutput
      description: An int32 tensor of shape [3]. The FFT length for each dimension.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RFFT3D'.
    return:
      type: TensorFlow.TFOutput
      description: "A complex64 tensor of the same rank as <code>input</code>. The inner-most 3\n              dimensions of <code>input</code> are replaced with the their 3D Fourier transform. The\n              inner-most dimension contains <code>fft_length / 2 + 1</code> unique frequency\n              components.\n              \n              @compatibility(numpy)\n              Equivalent to np.fft.rfftn with 3 dimensions.\n              @end_compatibility\n              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result."
  overload: TensorFlow.TFGraph.RFFT3D*
  exceptions: []
- uid: TensorFlow.TFGraph.RGBToHSV(TensorFlow.TFOutput,System.String)
  id: RGBToHSV(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RGBToHSV(TFOutput, String)
  nameWithType: TFGraph.RGBToHSV(TFOutput, String)
  fullName: TFGraph.RGBToHSV(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts one or more images from RGB to HSV.
  remarks: "Outputs a tensor of the same shape as the <code>images</code> tensor, containing the HSV\n              value of the pixels. The output is only well defined if the value in <code>images</code>\n              are in <code>[0,1]</code>.\n              \n              <code>output[..., 0]</code> contains hue, <code>output[..., 1]</code> contains saturation, and\n              <code>output[..., 2]</code> contains value. All HSV values are in <code>[0,1]</code>. A hue of 0\n              corresponds to pure red, hue 1/3 is pure green, and 2/3 is pure blue."
  syntax:
    content: public TensorFlow.TFOutput RGBToHSV (TensorFlow.TFOutput images, string operName = null);
    parameters:
    - id: images
      type: TensorFlow.TFOutput
      description: 1-D or higher rank. RGB data to convert. Last dimension must be size 3.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RGBToHSV'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        <code>images</code> converted to HSV.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RGBToHSV*
  exceptions: []
- uid: TensorFlow.TFGraph.RightShift(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: RightShift(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RightShift(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RightShift(TFOutput, TFOutput, String)
  fullName: TFGraph.RightShift(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Elementwise computes the bitwise right-shift of <code>x</code> and <code>y</code>.
  remarks: "Performs a logical shift for unsigned integer types, and an arithmetic shift\n              for signed integer types.\n              \n              If <code>y</code> is negative, or greater than or equal to than the width of <code>x</code> in bits\n              the result is implementation defined."
  syntax:
    content: public TensorFlow.TFOutput RightShift (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RightShift'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RightShift*
  exceptions: []
- uid: TensorFlow.TFGraph.Rint(TensorFlow.TFOutput,System.String)
  id: Rint(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Rint(TFOutput, String)
  nameWithType: TFGraph.Rint(TFOutput, String)
  fullName: TFGraph.Rint(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns element-wise integer closest to x.
  remarks: "If the result is midway between two representable values,\n              the even representable is chosen.\n              For example:\n              \n               <pre><code>\n              rint(-1.5) ==&gt; -2.0\n              rint(0.5000001) ==&gt; 1.0\n              rint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) ==&gt; [-2., -2., -0., 0., 2., 2., 2.]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Rint (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Rint'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Rint*
  exceptions: []
- uid: TensorFlow.TFGraph.Roll(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Roll(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Roll(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.Roll(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.Roll(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Rolls the elements of a tensor along an axis.
  remarks: "The elements are shifted positively (towards larger indices) by the offset of\n              <code>shift</code> along the dimension of <code>axis</code>. Negative <code>shift</code> values will shift\n              elements in the opposite direction. Elements that roll passed the last position\n              will wrap around to the first and vice versa. Multiple shifts along multiple\n              axes may be specified.\n              \n              For example:\n              \n               <pre><code>\n              # 't' is [0, 1, 2, 3, 4]\n              roll(t, shift=2, axis=0) ==&gt; [3, 4, 0, 1, 2]\n              \n              # shifting along multiple dimensions\n              # 't' is [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]\n              roll(t, shift=[1, -2], axis=[0, 1]) ==&gt; [[7, 8, 9, 5, 6], [2, 3, 4, 0, 1]]\n              \n              # shifting along the same axis multiple times\n              # 't' is [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]\n              roll(t, shift=[2, -3], axis=[1, 1]) ==&gt; [[1, 2, 3, 4, 0], [6, 7, 8, 9, 5]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Roll (TensorFlow.TFOutput input, TensorFlow.TFOutput shift, TensorFlow.TFOutput axis, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: shift
      type: TensorFlow.TFOutput
      description: >-
        Dimension must be 0-D or 1-D. <code>shift[i]</code> specifies the number of places by which
                      elements are shifted positively (towards larger indices) along the dimension
                      specified by <code>axis[i]</code>. Negative shifts will roll the elements in the opposite
                      direction.
    - id: axis
      type: TensorFlow.TFOutput
      description: >-
        Dimension must be 0-D or 1-D. <code>axis[i]</code> specifies the dimension that the shift
                      <code>shift[i]</code> should occur. If the same axis is referenced more than once, the
                      total shift for that axis will be the sum of all the shifts that belong to that
                      axis.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Roll'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has the same shape and size as the input. The elements are shifted
                      positively (towards larger indices) by the offsets of <code>shift</code> along the
                      dimensions of <code>axis</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Roll*
  exceptions: []
- uid: TensorFlow.TFGraph.Round(TensorFlow.TFOutput,System.String)
  id: Round(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Round(TFOutput, String)
  nameWithType: TFGraph.Round(TFOutput, String)
  fullName: TFGraph.Round(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Rounds the values of a tensor to the nearest integer, element-wise.
  remarks: >-
    Rounds half to even.  Also known as bankers rounding. If you want to round
                  according to the current system rounding mode use std::cint.
  syntax:
    content: public TensorFlow.TFOutput Round (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Round'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Round*
  exceptions: []
- uid: TensorFlow.TFGraph.Rpc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  id: Rpc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Rpc(TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  nameWithType: TFGraph.Rpc(TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  fullName: TFGraph.Rpc(TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Perform batches of RPC requests.
  remarks: "This op asynchronously performs either a single RPC request, or a batch\n              of requests.  RPC requests are defined by three main parameters:\n              \n              - <code>address</code> (the host+port or BNS address of the request)\n              - <code>method</code> (the RPC method name for the request)\n              - <code>request</code> (the serialized proto string, or vector of strings,\n              of the RPC request argument).\n              \n              For example, if you have an RPC service running on port localhost:2345,\n              and its interface is configured with the following proto declaration:\n              \n               <pre><code>\n              service MyService {\n              rpc MyMethod(MyRequestProto) returns (MyResponseProto) {\n              }\n              };\n               </code></pre>\n              \n              then call this op with arguments:\n              \n               <pre><code>\n              address = \"localhost:2345\"\n              method = \"MyService/MyMethod\"\n               </code></pre>\n              \n              The <code>request</code> tensor is a string tensor representing serialized <code>MyRequestProto</code>\n              strings; and the output string tensor <code>response</code> will have the same shape\n              and contain (upon successful completion) corresponding serialized\n              <code>MyResponseProto</code> strings.\n              \n              For example, to send a single, empty, <code>MyRequestProto</code>, call\n              this op with <code>request = \"\"</code>.  To send 5 **parallel** empty requests,\n              call this op with <code>request = [\"\", \"\", \"\", \"\", \"\"]</code>.\n              \n              More generally, one can create a batch of <code>MyRequestProto</code> serialized protos\n              from regular batched tensors using the <code>encode_proto</code> op, and convert\n              the response <code>MyResponseProto</code> serialized protos to batched tensors\n              using the <code>decode_proto</code> op.\n              \n              **NOTE** Working with serialized proto strings is faster than instantiating\n              actual proto objects in memory, so no performance degradation is expected\n              compared to writing custom kernels for this workflow.\n              \n              If the connection fails or the remote worker returns an error\n              status, the op reraises this exception locally.\n              \n              See the <code>TryRpc</code> op if you prefer to handle RPC failures manually in the graph."
  syntax:
    content: public TensorFlow.TFOutput Rpc (TensorFlow.TFOutput address, TensorFlow.TFOutput method, TensorFlow.TFOutput request, string protocol = null, Nullable<bool> fail_fast = null, Nullable<long> timeout_in_ms = null, string operName = null);
    parameters:
    - id: address
      type: TensorFlow.TFOutput
      description: >-
        <code>0-D</code> or <code>1-D</code>.  The address (i.e. host_name:port) of the RPC server.
                      If this tensor has more than 1 element, then multiple parallel rpc requests
                      are sent.  This argument broadcasts with <code>method</code> and <code>request</code>.
    - id: method
      type: TensorFlow.TFOutput
      description: >-
        <code>0-D</code> or <code>1-D</code>.  The method address on the RPC server.
                      If this tensor has more than 1 element, then multiple parallel rpc requests
                      are sent.  This argument broadcasts with <code>address</code> and <code>request</code>.
    - id: request
      type: TensorFlow.TFOutput
      description: >-
        <code>0-D</code> or <code>1-D</code>.  Serialized proto strings: the rpc request argument.
                      If this tensor has more than 1 element, then multiple parallel rpc requests
                      are sent.  This argument broadcasts with <code>address</code> and <code>method</code>.
    - id: protocol
      type: System.String
      description: >-
        Optional argument
                      RPC protocol to use.  Empty string means use the default protocol.
                      Options include 'grpc'.
    - id: fail_fast
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      <code>boolean</code>. If <code>true</code> (default), then failures to connect
                      (i.e., the server does not immediately respond) cause an RPC failure.
    - id: timeout_in_ms
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      <code>int</code>. If <code>0</code> (default), then the kernel will run the RPC
                      request and only time out if the RPC deadline passes or the session times out.
                      If this value is greater than <code>0</code>, then the op will raise an exception if
                      the RPC takes longer than <code>timeout_in_ms</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Rpc'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same shape as <code>request</code>. Serialized proto strings: the rpc responses.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Rpc*
  exceptions: []
- uid: TensorFlow.TFGraph.Rsqrt(TensorFlow.TFOutput,System.String)
  id: Rsqrt(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Rsqrt(TFOutput, String)
  nameWithType: TFGraph.Rsqrt(TFOutput, String)
  fullName: TFGraph.Rsqrt(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes reciprocal of square root of x element-wise.
  remarks: I.e., \\(y = 1 / \sqrt{x}\\).
  syntax:
    content: public TensorFlow.TFOutput Rsqrt (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Rsqrt'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Rsqrt*
  exceptions: []
- uid: TensorFlow.TFGraph.RsqrtGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: RsqrtGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: RsqrtGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RsqrtGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.RsqrtGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradient for the rsqrt of <code>x</code> wrt its input.
  remarks: >-
    Specifically, <code>grad = dy * -0.5 * y^3</code>, where <code>y = rsqrt(x)</code>, and <code>dy</code>
                  is the corresponding input gradient.
  syntax:
    content: public TensorFlow.TFOutput RsqrtGrad (TensorFlow.TFOutput y, TensorFlow.TFOutput dy, string operName = null);
    parameters:
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dy
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'RsqrtGrad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.RsqrtGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.SampleDistortedBoundingBox(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Single},System.Single[],System.Single[],System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  id: SampleDistortedBoundingBox(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Single},System.Single[],System.Single[],System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SampleDistortedBoundingBox(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Single>, Single[], Single[], Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.SampleDistortedBoundingBox(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Single>, Single[], Single[], Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.SampleDistortedBoundingBox(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Single>, Single[], Single[], Nullable<Int64>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generate a single randomly distorted bounding box for an image.
  remarks: "Bounding box annotations are often supplied in addition to ground-truth labels\n              in image recognition or object localization tasks. A common technique for\n              training such a system is to randomly distort an image while preserving\n              its content, i.e. *data augmentation*. This Op outputs a randomly distorted\n              localization of an object, i.e. bounding box, given an <code>image_size</code>,\n              <code>bounding_boxes</code> and a series of constraints.\n              \n              The output of this Op is a single bounding box that may be used to crop the\n              original image. The output is returned as 3 tensors: <code>begin</code>, <code>size</code> and\n              <code>bboxes</code>. The first 2 tensors can be fed directly into <code>tf.slice</code> to crop the\n              image. The latter may be supplied to <code>tf.image.draw_bounding_boxes</code> to visualize\n              what the bounding box looks like.\n              \n              Bounding boxes are supplied and returned as <code>[y_min, x_min, y_max, x_max]</code>. The\n              bounding box coordinates are floats in <code>[0.0, 1.0]</code> relative to the width and\n              height of the underlying image.\n              \n              For example,\n              \n               <pre><code>\n              # Generate a single distorted bounding box.\n              begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(\n              tf.shape(image),\n              bounding_boxes=bounding_boxes)\n              \n              # Draw the bounding box in an image summary.\n              image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),\n              bbox_for_draw)\n              tf.summary.image('images_with_box', image_with_box)\n              \n              # Employ the bounding box to distort the image.\n              distorted_image = tf.slice(image, begin, size)\n               </code></pre>\n              \n              Note that if no bounding box information is available, setting\n              <code>use_image_if_no_bounding_boxes = true</code> will assume there is a single implicit\n              bounding box covering the whole image. If <code>use_image_if_no_bounding_boxes</code> is\n              false and no bounding boxes are supplied, an error is raised."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> SampleDistortedBoundingBox (TensorFlow.TFOutput image_size, TensorFlow.TFOutput bounding_boxes, Nullable<long> seed = null, Nullable<long> seed2 = null, Nullable<float> min_object_covered = null, float[] aspect_ratio_range = null, float[] area_range = null, Nullable<long> max_attempts = null, Nullable<bool> use_image_if_no_bounding_boxes = null, string operName = null);
    parameters:
    - id: image_size
      type: TensorFlow.TFOutput
      description: 1-D, containing <code>[height, width, channels]</code>.
    - id: bounding_boxes
      type: TensorFlow.TFOutput
      description: >-
        3-D with shape <code>[batch, N, 4]</code> describing the N bounding boxes
                      associated with the image.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either <code>seed</code> or <code>seed2</code> are set to non-zero, the random number
                      generator is seeded by the given <code>seed</code>.  Otherwise, it is seeded by a random
                      seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A second seed to avoid seed collision.
    - id: min_object_covered
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      The cropped area of the image must contain at least this
                      fraction of any bounding box supplied. The value of this parameter should be
                      non-negative. In the case of 0, the cropped area does not need to overlap
                      any of the bounding boxes supplied.
    - id: aspect_ratio_range
      type: System.Single[]
      description: >-
        Optional argument
                      The cropped area of the image must have an aspect ratio =
                      width / height within this range.
    - id: area_range
      type: System.Single[]
      description: >-
        Optional argument
                      The cropped area of the image must contain a fraction of the
                      supplied image within this range.
    - id: max_attempts
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of attempts at generating a cropped region of the image
                      of the specified constraints. After <code>max_attempts</code> failures, return the entire
                      image.
    - id: use_image_if_no_bounding_boxes
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Controls behavior if no bounding boxes supplied.
                      If true, assume an implicit bounding box covering the whole input. If false,
                      raise an error.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SampleDistortedBoundingBox'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      begin: 1-D, containing <code>[offset_height, offset_width, 0]</code>. Provide as input to
                      <code>tf.slice</code>.
                      size: 1-D, containing <code>[target_height, target_width, -1]</code>. Provide as input to
                      <code>tf.slice</code>.
                      bboxes: 3-D with shape <code>[1, 1, 4]</code> containing the distorted bounding box.
                      Provide as input to <code>tf.image.draw_bounding_boxes</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SampleDistortedBoundingBox*
  exceptions: []
- uid: TensorFlow.TFGraph.SampleDistortedBoundingBoxV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Single[],System.Single[],System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  id: SampleDistortedBoundingBoxV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Single[],System.Single[],System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SampleDistortedBoundingBoxV2(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Single[], Single[], Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.SampleDistortedBoundingBoxV2(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Single[], Single[], Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.SampleDistortedBoundingBoxV2(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Single[], Single[], Nullable<Int64>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generate a single randomly distorted bounding box for an image.
  remarks: "Bounding box annotations are often supplied in addition to ground-truth labels\n              in image recognition or object localization tasks. A common technique for\n              training such a system is to randomly distort an image while preserving\n              its content, i.e. *data augmentation*. This Op outputs a randomly distorted\n              localization of an object, i.e. bounding box, given an <code>image_size</code>,\n              <code>bounding_boxes</code> and a series of constraints.\n              \n              The output of this Op is a single bounding box that may be used to crop the\n              original image. The output is returned as 3 tensors: <code>begin</code>, <code>size</code> and\n              <code>bboxes</code>. The first 2 tensors can be fed directly into <code>tf.slice</code> to crop the\n              image. The latter may be supplied to <code>tf.image.draw_bounding_boxes</code> to visualize\n              what the bounding box looks like.\n              \n              Bounding boxes are supplied and returned as <code>[y_min, x_min, y_max, x_max]</code>. The\n              bounding box coordinates are floats in <code>[0.0, 1.0]</code> relative to the width and\n              height of the underlying image.\n              \n              For example,\n              \n               <pre><code>\n              # Generate a single distorted bounding box.\n              begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(\n              tf.shape(image),\n              bounding_boxes=bounding_boxes)\n              \n              # Draw the bounding box in an image summary.\n              image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),\n              bbox_for_draw)\n              tf.summary.image('images_with_box', image_with_box)\n              \n              # Employ the bounding box to distort the image.\n              distorted_image = tf.slice(image, begin, size)\n               </code></pre>\n              \n              Note that if no bounding box information is available, setting\n              <code>use_image_if_no_bounding_boxes = true</code> will assume there is a single implicit\n              bounding box covering the whole image. If <code>use_image_if_no_bounding_boxes</code> is\n              false and no bounding boxes are supplied, an error is raised."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> SampleDistortedBoundingBoxV2 (TensorFlow.TFOutput image_size, TensorFlow.TFOutput bounding_boxes, TensorFlow.TFOutput min_object_covered, Nullable<long> seed = null, Nullable<long> seed2 = null, float[] aspect_ratio_range = null, float[] area_range = null, Nullable<long> max_attempts = null, Nullable<bool> use_image_if_no_bounding_boxes = null, string operName = null);
    parameters:
    - id: image_size
      type: TensorFlow.TFOutput
      description: 1-D, containing <code>[height, width, channels]</code>.
    - id: bounding_boxes
      type: TensorFlow.TFOutput
      description: >-
        3-D with shape <code>[batch, N, 4]</code> describing the N bounding boxes
                      associated with the image.
    - id: min_object_covered
      type: TensorFlow.TFOutput
      description: >-
        The cropped area of the image must contain at least this
                      fraction of any bounding box supplied. The value of this parameter should be
                      non-negative. In the case of 0, the cropped area does not need to overlap
                      any of the bounding boxes supplied.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either <code>seed</code> or <code>seed2</code> are set to non-zero, the random number
                      generator is seeded by the given <code>seed</code>.  Otherwise, it is seeded by a random
                      seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A second seed to avoid seed collision.
    - id: aspect_ratio_range
      type: System.Single[]
      description: >-
        Optional argument
                      The cropped area of the image must have an aspect ratio =
                      width / height within this range.
    - id: area_range
      type: System.Single[]
      description: >-
        Optional argument
                      The cropped area of the image must contain a fraction of the
                      supplied image within this range.
    - id: max_attempts
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of attempts at generating a cropped region of the image
                      of the specified constraints. After <code>max_attempts</code> failures, return the entire
                      image.
    - id: use_image_if_no_bounding_boxes
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Controls behavior if no bounding boxes supplied.
                      If true, assume an implicit bounding box covering the whole input. If false,
                      raise an error.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SampleDistortedBoundingBoxV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      begin: 1-D, containing <code>[offset_height, offset_width, 0]</code>. Provide as input to
                      <code>tf.slice</code>.
                      size: 1-D, containing <code>[target_height, target_width, -1]</code>. Provide as input to
                      <code>tf.slice</code>.
                      bboxes: 3-D with shape <code>[1, 1, 4]</code> containing the distorted bounding box.
                      Provide as input to <code>tf.image.draw_bounding_boxes</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SampleDistortedBoundingBoxV2*
  exceptions: []
- uid: TensorFlow.TFGraph.Save(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  id: Save(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Save(TFOutput, TFOutput, TFOutput[], String)
  nameWithType: TFGraph.Save(TFOutput, TFOutput, TFOutput[], String)
  fullName: TFGraph.Save(TFOutput, TFOutput, TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Saves the input tensors to disk.
  remarks: "The size of <code>tensor_names</code> must match the number of tensors in <code>data</code>. <code>data[i]</code>\n              is written to <code>filename</code> with name <code>tensor_names[i]</code>.\n              \n              See also <code>SaveSlices</code>."
  syntax:
    content: public TensorFlow.TFOperation Save (TensorFlow.TFOutput filename, TensorFlow.TFOutput tensor_names, TensorFlow.TFOutput[] data, string operName = null);
    parameters:
    - id: filename
      type: TensorFlow.TFOutput
      description: >-
        Must have a single element. The name of the file to which we write
                      the tensor.
    - id: tensor_names
      type: TensorFlow.TFOutput
      description: Shape <code>[N]</code>. The names of the tensors to be saved.
    - id: data
      type: TensorFlow.TFOutput[]
      description: <code>N</code> tensors to save.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Save'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.Save*
  exceptions: []
- uid: TensorFlow.TFGraph.SaveSlices(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  id: SaveSlices(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SaveSlices(TFOutput, TFOutput, TFOutput, TFOutput[], String)
  nameWithType: TFGraph.SaveSlices(TFOutput, TFOutput, TFOutput, TFOutput[], String)
  fullName: TFGraph.SaveSlices(TFOutput, TFOutput, TFOutput, TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Saves input tensors slices to disk.
  remarks: "This is like <code>Save</code> except that tensors can be listed in the saved file as being\n              a slice of a larger tensor.  <code>shapes_and_slices</code> specifies the shape of the\n              larger tensor and the slice that this tensor covers. <code>shapes_and_slices</code> must\n              have as many elements as <code>tensor_names</code>.\n              \n              Elements of the <code>shapes_and_slices</code> input must either be:\n              \n              *  The empty string, in which case the corresponding tensor is\n              saved normally.\n              *  A string of the form <code>dim0 dim1 ... dimN-1 slice-spec</code> where the\n              <code>dimI</code> are the dimensions of the larger tensor and <code>slice-spec</code>\n              specifies what part is covered by the tensor to save.\n              \n              <code>slice-spec</code> itself is a <code>:</code>-separated list: <code>slice0:slice1:...:sliceN-1</code>\n              where each <code>sliceI</code> is either:\n              \n              *  The string <code>-</code> meaning that the slice covers all indices of this dimension\n              *  <code>start,length</code> where <code>start</code> and <code>length</code> are integers.  In that\n              case the slice covers <code>length</code> indices starting at <code>start</code>.\n              \n              See also <code>Save</code>."
  syntax:
    content: public TensorFlow.TFOperation SaveSlices (TensorFlow.TFOutput filename, TensorFlow.TFOutput tensor_names, TensorFlow.TFOutput shapes_and_slices, TensorFlow.TFOutput[] data, string operName = null);
    parameters:
    - id: filename
      type: TensorFlow.TFOutput
      description: >-
        Must have a single element. The name of the file to which we write the
                      tensor.
    - id: tensor_names
      type: TensorFlow.TFOutput
      description: Shape <code>[N]</code>. The names of the tensors to be saved.
    - id: shapes_and_slices
      type: TensorFlow.TFOutput
      description: >-
        Shape <code>[N]</code>.  The shapes and slice specifications to use when
                      saving the tensors.
    - id: data
      type: TensorFlow.TFOutput[]
      description: <code>N</code> tensors to save.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SaveSlices'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.SaveSlices*
  exceptions: []
- uid: TensorFlow.TFGraph.SaveV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  id: SaveV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SaveV2(TFOutput, TFOutput, TFOutput, TFOutput[], String)
  nameWithType: TFGraph.SaveV2(TFOutput, TFOutput, TFOutput, TFOutput[], String)
  fullName: TFGraph.SaveV2(TFOutput, TFOutput, TFOutput, TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Saves tensors in V2 checkpoint format.
  remarks: >-
    By default, saves the named tensors in full.  If the caller wishes to save
                  specific slices of full tensors, "shape_and_slices" should be non-empty strings
                  and correspondingly well-formed.
  syntax:
    content: public TensorFlow.TFOperation SaveV2 (TensorFlow.TFOutput prefix, TensorFlow.TFOutput tensor_names, TensorFlow.TFOutput shape_and_slices, TensorFlow.TFOutput[] tensors, string operName = null);
    parameters:
    - id: prefix
      type: TensorFlow.TFOutput
      description: >-
        Must have a single element. The prefix of the V2 checkpoint to which we
                      write the tensors.
    - id: tensor_names
      type: TensorFlow.TFOutput
      description: shape {N}. The names of the tensors to be saved.
    - id: shape_and_slices
      type: TensorFlow.TFOutput
      description: >-
        shape {N}.  The slice specs of the tensors to be saved.
                      Empty strings indicate that they are non-partitioned tensors.
    - id: tensors
      type: TensorFlow.TFOutput[]
      description: <code>N</code> tensors to save.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SaveV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.SaveV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ScalarSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ScalarSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ScalarSummary(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ScalarSummary(TFOutput, TFOutput, String)
  fullName: TFGraph.ScalarSummary(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  syntax:
    content: public TensorFlow.TFOutput ScalarSummary (TensorFlow.TFOutput tags, TensorFlow.TFOutput values, string operName = null);
    parameters:
    - id: tags
      type: TensorFlow.TFOutput
      description: To be added.
    - id: values
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: To be added.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.ScalarSummary*
  exceptions: []
- uid: TensorFlow.TFGraph.ScatterAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ScatterAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ScatterAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Adds sparse updates to a variable reference.
  remarks: "This operation computes\n              \n              # Scalar indices\n              ref[indices, ...] += updates[...]\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] += updates[i, ...]\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]\n              \n              This operation outputs <code>ref</code> after the update is done.\n              This makes it easier to chain operations that need to use the reset value.\n              \n              Duplicate entries are handled correctly: if multiple <code>indices</code> reference\n              the same location, their contributions add.\n              \n              Requires <code>updates.shape = indices.shape + ref.shape[1:]</code> or <code>updates.shape = []</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterAdd.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput ScatterAdd (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of updated values to add to <code>ref</code>.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the addition will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterAdd'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        = Same as <code>ref</code>.  Returned as a convenience for operations that want
                      to use the updated values after the update is done.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ScatterAdd*
  exceptions: []
- uid: TensorFlow.TFGraph.ScatterDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ScatterDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ScatterDiv(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterDiv(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterDiv(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Divides a variable reference by sparse updates.
  remarks: "This operation computes\n              \n               <pre><code>\n              # Scalar indices\n              ref[indices, ...] /= updates[...]\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] /= updates[i, ...]\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]\n               </code></pre>\n              \n              This operation outputs <code>ref</code> after the update is done.\n              This makes it easier to chain operations that need to use the reset value.\n              \n              Duplicate entries are handled correctly: if multiple <code>indices</code> reference\n              the same location, their contributions divide.\n              \n              Requires <code>updates.shape = indices.shape + ref.shape[1:]</code> or <code>updates.shape = []</code>."
  syntax:
    content: public TensorFlow.TFOutput ScatterDiv (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of values that <code>ref</code> is divided by.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the operation will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterDiv'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        = Same as <code>ref</code>.  Returned as a convenience for operations that want
                      to use the updated values after the update is done.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ScatterDiv*
  exceptions: []
- uid: TensorFlow.TFGraph.ScatterMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ScatterMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ScatterMax(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterMax(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterMax(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reduces sparse updates into a variable reference using the <code>max</code> operation.
  remarks: "This operation computes\n              \n              # Scalar indices\n              ref[indices, ...] = max(ref[indices, ...], updates[...])\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] = max(ref[indices[i], ...], updates[i, ...])\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] = max(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])\n              \n              This operation outputs <code>ref</code> after the update is done.\n              This makes it easier to chain operations that need to use the reset value.\n              \n              Duplicate entries are handled correctly: if multiple <code>indices</code> reference\n              the same location, their contributions combine.\n              \n              Requires <code>updates.shape = indices.shape + ref.shape[1:]</code> or <code>updates.shape = []</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterAdd.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput ScatterMax (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of updated values to reduce into <code>ref</code>.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the update will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterMax'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        = Same as <code>ref</code>.  Returned as a convenience for operations that want
                      to use the updated values after the update is done.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ScatterMax*
  exceptions: []
- uid: TensorFlow.TFGraph.ScatterMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ScatterMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ScatterMin(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterMin(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterMin(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reduces sparse updates into a variable reference using the <code>min</code> operation.
  remarks: "This operation computes\n              \n              # Scalar indices\n              ref[indices, ...] = min(ref[indices, ...], updates[...])\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] = min(ref[indices[i], ...], updates[i, ...])\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] = min(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])\n              \n              This operation outputs <code>ref</code> after the update is done.\n              This makes it easier to chain operations that need to use the reset value.\n              \n              Duplicate entries are handled correctly: if multiple <code>indices</code> reference\n              the same location, their contributions combine.\n              \n              Requires <code>updates.shape = indices.shape + ref.shape[1:]</code> or <code>updates.shape = []</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterAdd.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput ScatterMin (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of updated values to reduce into <code>ref</code>.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the update will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterMin'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        = Same as <code>ref</code>.  Returned as a convenience for operations that want
                      to use the updated values after the update is done.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ScatterMin*
  exceptions: []
- uid: TensorFlow.TFGraph.ScatterMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ScatterMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ScatterMul(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterMul(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterMul(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Multiplies sparse updates into a variable reference.
  remarks: "This operation computes\n              \n               <pre><code>\n              # Scalar indices\n              ref[indices, ...] *= updates[...]\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] *= updates[i, ...]\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]\n               </code></pre>\n              \n              This operation outputs <code>ref</code> after the update is done.\n              This makes it easier to chain operations that need to use the reset value.\n              \n              Duplicate entries are handled correctly: if multiple <code>indices</code> reference\n              the same location, their contributions multiply.\n              \n              Requires <code>updates.shape = indices.shape + ref.shape[1:]</code> or <code>updates.shape = []</code>."
  syntax:
    content: public TensorFlow.TFOutput ScatterMul (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of updated values to multiply to <code>ref</code>.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the operation will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterMul'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        = Same as <code>ref</code>.  Returned as a convenience for operations that want
                      to use the updated values after the update is done.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ScatterMul*
  exceptions: []
- uid: TensorFlow.TFGraph.ScatterNd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ScatterNd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ScatterNd(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ScatterNd(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ScatterNd(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Scatter <code>updates</code> into a new tensor according to <code>indices</code>.
  remarks: "Creates a new tensor by applying sparse <code>updates</code> to individual values or\n              slices within a tensor (initially zero for numeric, empty for string) of\n              the given <code>shape</code> according to indices.  This operator is the inverse of the\n              <code>tf.gather_nd</code> operator which extracts values or slices from a given tensor.\n              \n              This operation is similar to tensor_scatter_add, except that the tensor is\n              zero-initialized. Calling <code>tf.scatter_nd(indices, values, shape)</code> is identical\n              to <code>tensor_scatter_add(tf.zeros(shape, values.dtype), indices, values)</code>\n              \n              If <code>indices</code> contains duplicates, then their updates are accumulated (summed).\n              \n              **WARNING**: The order in which updates are applied is nondeterministic, so the\n              output will be nondeterministic if <code>indices</code> contains duplicates -- because\n              of some numerical approximation issues, numbers summed in different order\n              may yield different results.\n              \n              <code>indices</code> is an integer tensor containing indices into a new tensor of shape\n              <code>shape</code>.  The last dimension of <code>indices</code> can be at most the rank of <code>shape</code>:\n              \n              indices.shape[-1] &lt;= shape.rank\n              \n              The last dimension of <code>indices</code> corresponds to indices into elements\n              (if <code>indices.shape[-1] = shape.rank</code>) or slices\n              (if <code>indices.shape[-1] &lt; shape.rank</code>) along dimension <code>indices.shape[-1]</code> of\n              <code>shape</code>.  <code>updates</code> is a tensor with shape\n              \n              indices.shape[:-1] + shape[indices.shape[-1]:]\n              \n              The simplest form of scatter is to insert individual elements in a tensor by\n              index. For example, say we want to insert 4 scattered elements in a rank-1\n              tensor with 8 elements.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterNd1.png\" alt&gt;\n              &lt;/div&gt;\n              \n              In Python, this scatter operation would look like this:\n              \n               <pre><code>\n              indices = tf.constant([[4], [3], [1], [7]])\n              updates = tf.constant([9, 10, 11, 12])\n              shape = tf.constant([8])\n              scatter = tf.scatter_nd(indices, updates, shape)\n              with tf.Session() as sess:\n              print(sess.run(scatter))\n               </code></pre>\n              \n              The resulting tensor would look like this:\n              \n              [0, 11, 0, 10, 9, 0, 0, 12]\n              \n              We can also, insert entire slices of a higher rank tensor all at once. For\n              example, if we wanted to insert two slices in the first dimension of a\n              rank-3 tensor with two matrices of new values.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterNd2.png\" alt&gt;\n              &lt;/div&gt;\n              \n              In Python, this scatter operation would look like this:\n              \n               <pre><code>\n              indices = tf.constant([[0], [2]])\n              updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],\n              [7, 7, 7, 7], [8, 8, 8, 8]],\n              [[5, 5, 5, 5], [6, 6, 6, 6],\n              [7, 7, 7, 7], [8, 8, 8, 8]]])\n              shape = tf.constant([4, 4, 4])\n              scatter = tf.scatter_nd(indices, updates, shape)\n              with tf.Session() as sess:\n              print(sess.run(scatter))\n               </code></pre>\n              \n              The resulting tensor would look like this:\n              \n              [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],\n              [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],\n              [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],\n              [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]]\n              \n              Note that on CPU, if an out of bound index is found, an error is returned.\n              On GPU, if an out of bound index is found, the index is ignored."
  syntax:
    content: public TensorFlow.TFOutput ScatterNd (TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, TensorFlow.TFOutput shape, string operName = null);
    parameters:
    - id: indices
      type: TensorFlow.TFOutput
      description: Index tensor.
    - id: updates
      type: TensorFlow.TFOutput
      description: Updates to scatter into output.
    - id: shape
      type: TensorFlow.TFOutput
      description: 1-D. The shape of the resulting tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNd'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A new tensor with the given shape and updates applied according
                      to the indices.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ScatterNd*
  exceptions: []
- uid: TensorFlow.TFGraph.ScatterNdAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ScatterNdAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies sparse addition between <code>updates</code> and individual values or slices
  remarks: "within a given variable according to <code>indices</code>.\n              \n              <code>ref</code> is a <code>Tensor</code> with rank <code>P</code> and <code>indices</code> is a <code>Tensor</code> of rank <code>Q</code>.\n              \n              <code>indices</code> must be integer tensor, containing indices into <code>ref</code>.\n              It must be shape <code>\\\\([d_0, ..., d_{Q-2}, K]\\\\)</code> where <code>0 &lt; K &lt;= P</code>.\n              \n              The innermost dimension of <code>indices</code> (with length <code>K</code>) corresponds to\n              indices into elements (if <code>K = P</code>) or slices (if <code>K &lt; P</code>) along the <code>K</code>th\n              dimension of <code>ref</code>.\n              \n              <code>updates</code> is <code>Tensor</code> of rank <code>Q-1+P-K</code> with shape:\n              \n              $$[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].$$\n              \n              For example, say we want to add 4 scattered elements to a rank-1 tensor to 8\n              elements. In Python, that addition would look like this:\n              \n              ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n              indices = tf.constant([[4], [3], [1], [7]])\n              updates = tf.constant([9, 10, 11, 12])\n              add = tf.scatter_nd_add(ref, indices, updates)\n              with tf.Session() as sess:\n              print sess.run(add)\n              \n              The resulting update to ref would look like this:\n              \n              [1, 13, 3, 14, 14, 6, 7, 20]\n              \n              See <code>tf.scatter_nd</code> for more details about how to make updates to\n              slices."
  syntax:
    content: public TensorFlow.TFOutput ScatterNdAdd (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: A mutable Tensor. Should be from a Variable node.
    - id: indices
      type: TensorFlow.TFOutput
      description: >-
        A Tensor. Must be one of the following types: int32, int64.
                      A tensor of indices into ref.
    - id: updates
      type: TensorFlow.TFOutput
      description: >-
        A Tensor. Must have the same type as ref. A tensor of updated values
                      to add to ref.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      An optional bool. Defaults to True. If True, the assignment will
                      be protected by a lock; otherwise the behavior is undefined,
                      but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdAdd'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as ref. Returned as a convenience for operations that want
                      to use the updated values after the update is done.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ScatterNdAdd*
  exceptions: []
- uid: TensorFlow.TFGraph.ScatterNdNonAliasingAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ScatterNdNonAliasingAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ScatterNdNonAliasingAdd(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ScatterNdNonAliasingAdd(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ScatterNdNonAliasingAdd(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies sparse addition to <code>input</code> using individual values or slices
  remarks: "from <code>updates</code> according to indices <code>indices</code>.  The updates are non-aliasing:\n              <code>input</code> is only modified in-place if no other operations will use it.\n              Otherwise, a copy of <code>input</code> is made.  This operation has a gradient with\n              respect to both <code>input</code> and <code>updates</code>.\n              \n              <code>input</code> is a <code>Tensor</code> with rank <code>P</code> and <code>indices</code> is a <code>Tensor</code> of rank <code>Q</code>.\n              \n              <code>indices</code> must be integer tensor, containing indices into <code>input</code>.\n              It must be shape \\\\([d_0, ..., d_{Q-2}, K]\\\\) where <code>0 &lt; K &lt;= P</code>.\n              \n              The innermost dimension of <code>indices</code> (with length <code>K</code>) corresponds to\n              indices into elements (if <code>K = P</code>) or <code>(P-K)</code>-dimensional slices\n              (if <code>K &lt; P</code>) along the <code>K</code>th dimension of <code>input</code>.\n              \n              <code>updates</code> is <code>Tensor</code> of rank <code>Q-1+P-K</code> with shape:\n              \n              $$[d_0, ..., d_{Q-2}, input.shape[K], ..., input.shape[P-1]].$$\n              \n              For example, say we want to add 4 scattered elements to a rank-1 tensor to 8\n              elements. In Python, that addition would look like this:\n              \n              input = tf.constant([1, 2, 3, 4, 5, 6, 7, 8])\n              indices = tf.constant([[4], [3], [1], [7]])\n              updates = tf.constant([9, 10, 11, 12])\n              output = tf.scatter_nd_non_aliasing_add(input, indices, updates)\n              with tf.Session() as sess:\n              print(sess.run(output))\n              \n              The resulting value <code>output</code> would look like this:\n              \n              [1, 13, 3, 14, 14, 6, 7, 20]\n              \n              See <code>tf.scatter_nd</code> for more details about how to make updates to slices."
  syntax:
    content: public TensorFlow.TFOutput ScatterNdNonAliasingAdd (TensorFlow.TFOutput input, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A Tensor.
    - id: indices
      type: TensorFlow.TFOutput
      description: >-
        A Tensor. Must be one of the following types: <code>int32</code>, <code>int64</code>.
                      A tensor of indices into <code>input</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: >-
        A Tensor. Must have the same type as ref. A tensor of updated values
                      to add to <code>input</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdNonAliasingAdd'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A <code>Tensor</code> with the same shape as <code>input</code>, containing values of <code>input</code>
                      updated with <code>updates</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ScatterNdNonAliasingAdd*
  exceptions: []
- uid: TensorFlow.TFGraph.ScatterNdSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ScatterNdSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ScatterNdSub(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterNdSub(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterNdSub(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies sparse subtraction between <code>updates</code> and individual values or slices
  remarks: "within a given variable according to <code>indices</code>.\n              \n              <code>ref</code> is a <code>Tensor</code> with rank <code>P</code> and <code>indices</code> is a <code>Tensor</code> of rank <code>Q</code>.\n              \n              <code>indices</code> must be integer tensor, containing indices into <code>ref</code>.\n              It must be shape \\\\([d_0, ..., d_{Q-2}, K]\\\\) where <code>0 &lt; K &lt;= P</code>.\n              \n              The innermost dimension of <code>indices</code> (with length <code>K</code>) corresponds to\n              indices into elements (if <code>K = P</code>) or slices (if <code>K &lt; P</code>) along the <code>K</code>th\n              dimension of <code>ref</code>.\n              \n              <code>updates</code> is <code>Tensor</code> of rank <code>Q-1+P-K</code> with shape:\n              \n              $$[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].$$\n              \n              For example, say we want to subtract 4 scattered elements from a rank-1 tensor\n              with 8 elements. In Python, that subtraction would look like this:\n              \n              ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n              indices = tf.constant([[4], [3], [1], [7]])\n              updates = tf.constant([9, 10, 11, 12])\n              sub = tf.scatter_nd_sub(ref, indices, updates)\n              with tf.Session() as sess:\n              print sess.run(sub)\n              \n              The resulting update to ref would look like this:\n              \n              [1, -9, 3, -6, -4, 6, 7, -4]\n              \n              See <code>tf.scatter_nd</code> for more details about how to make updates to\n              slices."
  syntax:
    content: public TensorFlow.TFOutput ScatterNdSub (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: A mutable Tensor. Should be from a Variable node.
    - id: indices
      type: TensorFlow.TFOutput
      description: >-
        A Tensor. Must be one of the following types: int32, int64.
                      A tensor of indices into ref.
    - id: updates
      type: TensorFlow.TFOutput
      description: >-
        A Tensor. Must have the same type as ref. A tensor of updated values
                      to subtract from ref.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      An optional bool. Defaults to True. If True, the assignment will
                      be protected by a lock; otherwise the behavior is undefined,
                      but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdSub'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as ref. Returned as a convenience for operations that want
                      to use the updated values after the update is done.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ScatterNdSub*
  exceptions: []
- uid: TensorFlow.TFGraph.ScatterNdUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ScatterNdUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies sparse <code>updates</code> to individual values or slices within a given
  remarks: "variable according to <code>indices</code>.\n              \n              <code>ref</code> is a <code>Tensor</code> with rank <code>P</code> and <code>indices</code> is a <code>Tensor</code> of rank <code>Q</code>.\n              \n              <code>indices</code> must be integer tensor, containing indices into <code>ref</code>.\n              It must be shape \\\\([d_0, ..., d_{Q-2}, K]\\\\) where <code>0 &lt; K &lt;= P</code>.\n              \n              The innermost dimension of <code>indices</code> (with length <code>K</code>) corresponds to\n              indices into elements (if <code>K = P</code>) or slices (if <code>K &lt; P</code>) along the <code>K</code>th\n              dimension of <code>ref</code>.\n              \n              <code>updates</code> is <code>Tensor</code> of rank <code>Q-1+P-K</code> with shape:\n              \n              $$[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].$$\n              \n              For example, say we want to update 4 scattered elements to a rank-1 tensor to\n              8 elements. In Python, that update would look like this:\n              \n               <pre><code>\n              ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n              indices = tf.constant([[4], [3], [1] ,[7]])\n              updates = tf.constant([9, 10, 11, 12])\n              update = tf.scatter_nd_update(ref, indices, updates)\n              with tf.Session() as sess:\n              print sess.run(update)\n               </code></pre>\n              \n              The resulting update to ref would look like this:\n              \n              [1, 11, 3, 10, 9, 6, 7, 12]\n              \n              See <code>tf.scatter_nd</code> for more details about how to make updates to\n              slices.\n              \n              See also <code>tf.scatter_update</code> and <code>tf.batch_scatter_update</code>."
  syntax:
    content: public TensorFlow.TFOutput ScatterNdUpdate (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: A mutable Tensor. Should be from a Variable node.
    - id: indices
      type: TensorFlow.TFOutput
      description: >-
        A Tensor. Must be one of the following types: int32, int64.
                      A tensor of indices into ref.
    - id: updates
      type: TensorFlow.TFOutput
      description: >-
        A Tensor. Must have the same type as ref. A tensor of updated
                      values to add to ref.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      An optional bool. Defaults to True. If True, the assignment will
                      be protected by a lock; otherwise the behavior is undefined,
                      but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterNdUpdate'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as ref. Returned as a convenience for operations that want to
                      use the updated values after the update is done.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ScatterNdUpdate*
  exceptions: []
- uid: TensorFlow.TFGraph.ScatterSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ScatterSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ScatterSub(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterSub(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterSub(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Subtracts sparse updates to a variable reference.
  remarks: "<pre><code>\n              # Scalar indices\n              ref[indices, ...] -= updates[...]\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] -= updates[i, ...]\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]\n               </code></pre>\n              \n              This operation outputs <code>ref</code> after the update is done.\n              This makes it easier to chain operations that need to use the reset value.\n              \n              Duplicate entries are handled correctly: if multiple <code>indices</code> reference\n              the same location, their (negated) contributions add.\n              \n              Requires <code>updates.shape = indices.shape + ref.shape[1:]</code> or <code>updates.shape = []</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterSub.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput ScatterSub (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of updated values to subtract from <code>ref</code>.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the subtraction will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterSub'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        = Same as <code>ref</code>.  Returned as a convenience for operations that want
                      to use the updated values after the update is done.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ScatterSub*
  exceptions: []
- uid: TensorFlow.TFGraph.ScatterUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: ScatterUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ScatterUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies sparse updates to a variable reference.
  remarks: "This operation computes\n              \n               <pre><code>\n              # Scalar indices\n              ref[indices, ...] = updates[...]\n              \n              # Vector indices (for each i)\n              ref[indices[i], ...] = updates[i, ...]\n              \n              # High rank indices (for each i, ..., j)\n              ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]\n               </code></pre>\n              \n              This operation outputs <code>ref</code> after the update is done.\n              This makes it easier to chain operations that need to use the reset value.\n              \n              If values in <code>ref</code> is to be updated more than once, because there are\n              duplicate entries in <code>indices</code>, the order at which the updates happen\n              for each value is undefined.\n              \n              Requires <code>updates.shape = indices.shape + ref.shape[1:]</code> or <code>updates.shape = []</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterUpdate.png\" alt&gt;\n              &lt;/div&gt;\n              \n              See also <code>tf.batch_scatter_update</code> and <code>tf.scatter_nd_update</code>."
  syntax:
    content: public TensorFlow.TFOutput ScatterUpdate (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: Should be from a <code>Variable</code> node.
    - id: indices
      type: TensorFlow.TFOutput
      description: A tensor of indices into the first dimension of <code>ref</code>.
    - id: updates
      type: TensorFlow.TFOutput
      description: A tensor of updated values to store in <code>ref</code>.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the assignment will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ScatterUpdate'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        = Same as <code>ref</code>.  Returned as a convenience for operations that want
                      to use the updated values after the update is done.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ScatterUpdate*
  exceptions: []
- uid: TensorFlow.TFGraph.SdcaFprint(TensorFlow.TFOutput,System.String)
  id: SdcaFprint(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SdcaFprint(TFOutput, String)
  nameWithType: TFGraph.SdcaFprint(TFOutput, String)
  fullName: TFGraph.SdcaFprint(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes fingerprints of the input strings.
  syntax:
    content: public TensorFlow.TFOutput SdcaFprint (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: vector of strings to compute fingerprints on.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SdcaFprint'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        a (N,2) shaped matrix where N is the number of elements in the input
                      vector. Each row contains the low and high parts of the fingerprint.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SdcaFprint*
  exceptions: []
- uid: TensorFlow.TFGraph.SdcaOptimizer(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.String,System.Single,System.Single,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)
  id: SdcaOptimizer(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.String,System.Single,System.Single,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SdcaOptimizer(TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput, String, Single, Single, Int64, Int64, Nullable<Boolean>, String)
  nameWithType: TFGraph.SdcaOptimizer(TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput, String, Single, Single, Int64, Int64, Nullable<Boolean>, String)
  fullName: TFGraph.SdcaOptimizer(TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput, String, Single, Single, Int64, Int64, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Distributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for
  remarks: "linear models with L1 + L2 regularization. As global optimization objective is\n              strongly-convex, the optimizer optimizes the dual objective at each step. The\n              optimizer applies each update one example at a time. Examples are sampled\n              uniformly, and the optimizer is learning rate free and enjoys linear convergence\n              rate.\n              \n              [Proximal Stochastic Dual Coordinate Ascent](http://arxiv.org/pdf/1211.2717v1.pdf).&lt;br&gt;\n              Shai Shalev-Shwartz, Tong Zhang. 2012\n              \n              $$Loss Objective = \\sum f_{i} (wx_{i}) + (l2 / 2) * |w|^2 + l1 * |w|$$\n              \n              [Adding vs. Averaging in Distributed Primal-Dual Optimization](http://arxiv.org/abs/1502.03508).&lt;br&gt;\n              Chenxin Ma, Virginia Smith, Martin Jaggi, Michael I. Jordan,\n              Peter Richtarik, Martin Takac. 2015\n              \n              [Stochastic Dual Coordinate Ascent with Adaptive Probabilities](https://arxiv.org/abs/1502.08053).&lt;br&gt;\n              Dominik Csiba, Zheng Qu, Peter Richtarik. 2015"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[]> SdcaOptimizer (TensorFlow.TFOutput[] sparse_example_indices, TensorFlow.TFOutput[] sparse_feature_indices, TensorFlow.TFOutput[] sparse_feature_values, TensorFlow.TFOutput[] dense_features, TensorFlow.TFOutput example_weights, TensorFlow.TFOutput example_labels, TensorFlow.TFOutput[] sparse_indices, TensorFlow.TFOutput[] sparse_weights, TensorFlow.TFOutput[] dense_weights, TensorFlow.TFOutput example_state_data, string loss_type, float l1, float l2, long num_loss_partitions, long num_inner_iterations, Nullable<bool> adaptative = null, string operName = null);
    parameters:
    - id: sparse_example_indices
      type: TensorFlow.TFOutput[]
      description: a list of vectors which contain example indices.
    - id: sparse_feature_indices
      type: TensorFlow.TFOutput[]
      description: a list of vectors which contain feature indices.
    - id: sparse_feature_values
      type: TensorFlow.TFOutput[]
      description: >-
        a list of vectors which contains feature value
                      associated with each feature group.
    - id: dense_features
      type: TensorFlow.TFOutput[]
      description: a list of matrices which contains the dense feature values.
    - id: example_weights
      type: TensorFlow.TFOutput
      description: >-
        a vector which contains the weight associated with each
                      example.
    - id: example_labels
      type: TensorFlow.TFOutput
      description: >-
        a vector which contains the label/target associated with each
                      example.
    - id: sparse_indices
      type: TensorFlow.TFOutput[]
      description: >-
        a list of vectors where each value is the indices which has
                      corresponding weights in sparse_weights. This field maybe omitted for the
                      dense approach.
    - id: sparse_weights
      type: TensorFlow.TFOutput[]
      description: >-
        a list of vectors where each value is the weight associated with
                      a sparse feature group.
    - id: dense_weights
      type: TensorFlow.TFOutput[]
      description: >-
        a list of vectors where the values are the weights associated
                      with a dense feature group.
    - id: example_state_data
      type: TensorFlow.TFOutput
      description: a list of vectors containing the example state data.
    - id: loss_type
      type: System.String
      description: >-
        Type of the primal loss. Currently SdcaSolver supports logistic,
                      squared and hinge losses.
    - id: l1
      type: System.Single
      description: Symmetric l1 regularization strength.
    - id: l2
      type: System.Single
      description: Symmetric l2 regularization strength.
    - id: num_loss_partitions
      type: System.Int64
      description: Number of partitions of the global loss function.
    - id: num_inner_iterations
      type: System.Int64
      description: Number of iterations per mini-batch.
    - id: adaptative
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Whether to use Adaptive SDCA for the inner loop.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SdcaOptimizer'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[]}
      description: >-
        Returns a tuple with multiple values, as follows:
                      out_example_state_data: a list of vectors containing the updated example state
                      data.
                      out_delta_sparse_weights: a list of vectors where each value is the delta
                      weights associated with a sparse feature group.
                      out_delta_dense_weights: a list of vectors where the values are the delta
                      weights associated with a dense feature group.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SdcaOptimizer*
  exceptions: []
- uid: TensorFlow.TFGraph.SdcaShrinkL1(TensorFlow.TFOutput[],System.Single,System.Single,System.String)
  id: SdcaShrinkL1(TensorFlow.TFOutput[],System.Single,System.Single,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SdcaShrinkL1(TFOutput[], Single, Single, String)
  nameWithType: TFGraph.SdcaShrinkL1(TFOutput[], Single, Single, String)
  fullName: TFGraph.SdcaShrinkL1(TFOutput[], Single, Single, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies L1 regularization shrink step on the parameters.
  syntax:
    content: public TensorFlow.TFOperation SdcaShrinkL1 (TensorFlow.TFOutput[] weights, float l1, float l2, string operName = null);
    parameters:
    - id: weights
      type: TensorFlow.TFOutput[]
      description: >-
        a list of vectors where each value is the weight associated with a
                      feature group.
    - id: l1
      type: System.Single
      description: Symmetric l1 regularization strength.
    - id: l2
      type: System.Single
      description: Symmetric l2 regularization strength. Should be a positive float.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SdcaShrinkL1'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.SdcaShrinkL1*
  exceptions: []
- uid: TensorFlow.TFGraph.Seed
  id: Seed
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Seed
  nameWithType: TFGraph.Seed
  fullName: TFGraph.Seed
  type: Property
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gets or sets the graph random seed, see remarks for details.
  remarks: "Operations that rely on a random seed actually derive it from two seeds:\n              the graph-level and operation-level seeds.This sets the graph-level seed.\n            \n             Its interactions with operation-level seeds is as follows:\n             1. If neither the graph-level nor the operation seed is set:\n                A random seed is used for this op.\n             2. If the graph-level seed is set, but the operation seed is not:\n                The system deterministically picks an operation seed in conjunction\n                with the graph-level seed so that it gets a unique random sequence.\n             3. If the graph-level seed is not set, but the operation seed is set:\n                A default graph-level seed and the specified operation seed are used to\n                determine the random sequence.\n             4. If both the graph-level and the operation seed are set:\n                Both seeds are used in conjunction to determine the random sequence."
  syntax:
    content: public Nullable<int> Seed { get; set; }
    return:
      type: System.Nullable{System.Int32}
      description: The seed.
  overload: TensorFlow.TFGraph.Seed*
  exceptions: []
- uid: TensorFlow.TFGraph.SegmentMax(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SegmentMax(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SegmentMax(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SegmentMax(TFOutput, TFOutput, String)
  fullName: TFGraph.SegmentMax(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the maximum along segments of a tensor.
  remarks: "Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\n              for an explanation of segments.\n              \n              Computes a tensor such that\n              \\\\(output_i = \\max_j(data_j)\\\\) where <code>max</code> is over <code>j</code> such\n              that <code>segment_ids[j] == i</code>.\n              \n              If the max is empty for a given segment ID <code>i</code>, <code>output[i] = 0</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentMax.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput SegmentMax (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: >-
        A 1-D tensor whose size is equal to the size of <code>data</code>'s
                      first dimension.  Values should be sorted and can be repeated.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentMax'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for dimension 0 which
                      has size <code>k</code>, the number of segments.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SegmentMax*
  exceptions: []
- uid: TensorFlow.TFGraph.SegmentMean(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SegmentMean(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SegmentMean(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SegmentMean(TFOutput, TFOutput, String)
  fullName: TFGraph.SegmentMean(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the mean along segments of a tensor.
  remarks: "Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\n              for an explanation of segments.\n              \n              Computes a tensor such that\n              \\\\(output_i = \\frac{\\sum_j data_j}{N}\\\\) where <code>mean</code> is\n              over <code>j</code> such that <code>segment_ids[j] == i</code> and <code>N</code> is the total number of\n              values summed.\n              \n              If the mean is empty for a given segment ID <code>i</code>, <code>output[i] = 0</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentMean.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput SegmentMean (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: >-
        A 1-D tensor whose size is equal to the size of <code>data</code>'s
                      first dimension.  Values should be sorted and can be repeated.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentMean'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for dimension 0 which
                      has size <code>k</code>, the number of segments.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SegmentMean*
  exceptions: []
- uid: TensorFlow.TFGraph.SegmentMin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SegmentMin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SegmentMin(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SegmentMin(TFOutput, TFOutput, String)
  fullName: TFGraph.SegmentMin(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the minimum along segments of a tensor.
  remarks: "Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\n              for an explanation of segments.\n              \n              Computes a tensor such that\n              \\\\(output_i = \\min_j(data_j)\\\\) where <code>min</code> is over <code>j</code> such\n              that <code>segment_ids[j] == i</code>.\n              \n              If the min is empty for a given segment ID <code>i</code>, <code>output[i] = 0</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentMin.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput SegmentMin (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: >-
        A 1-D tensor whose size is equal to the size of <code>data</code>'s
                      first dimension.  Values should be sorted and can be repeated.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentMin'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for dimension 0 which
                      has size <code>k</code>, the number of segments.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SegmentMin*
  exceptions: []
- uid: TensorFlow.TFGraph.SegmentProd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SegmentProd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SegmentProd(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SegmentProd(TFOutput, TFOutput, String)
  fullName: TFGraph.SegmentProd(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the product along segments of a tensor.
  remarks: "Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\n              for an explanation of segments.\n              \n              Computes a tensor such that\n              \\\\(output_i = \\prod_j data_j\\\\) where the product is over <code>j</code> such\n              that <code>segment_ids[j] == i</code>.\n              \n              If the product is empty for a given segment ID <code>i</code>, <code>output[i] = 1</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentProd.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput SegmentProd (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: >-
        A 1-D tensor whose size is equal to the size of <code>data</code>'s
                      first dimension.  Values should be sorted and can be repeated.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentProd'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for dimension 0 which
                      has size <code>k</code>, the number of segments.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SegmentProd*
  exceptions: []
- uid: TensorFlow.TFGraph.SegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SegmentSum(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SegmentSum(TFOutput, TFOutput, String)
  fullName: TFGraph.SegmentSum(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the sum along segments of a tensor.
  remarks: "Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\n              for an explanation of segments.\n              \n              Computes a tensor such that\n              \\\\(output_i = \\sum_j data_j\\\\) where sum is over <code>j</code> such\n              that <code>segment_ids[j] == i</code>.\n              \n              If the sum is empty for a given segment ID <code>i</code>, <code>output[i] = 0</code>.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentSum.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput SegmentSum (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: >-
        A 1-D tensor whose size is equal to the size of <code>data</code>'s
                      first dimension.  Values should be sorted and can be repeated.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SegmentSum'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for dimension 0 which
                      has size <code>k</code>, the number of segments.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SegmentSum*
  exceptions: []
- uid: TensorFlow.TFGraph.Select(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Select(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Select(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.Select(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.Select(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Selects elements from <code>x</code> or <code>y</code>, depending on <code>condition</code>.
  remarks: "The <code>x</code>, and <code>y</code> tensors must all have the same shape, and the\n              output will also have that shape.\n              \n              The <code>condition</code> tensor must be a scalar if <code>x</code> and <code>y</code> are scalars.\n              If <code>x</code> and <code>y</code> are vectors or higher rank, then <code>condition</code> must be either a\n              scalar, a vector with size matching the first dimension of <code>x</code>, or must have\n              the same shape as <code>x</code>.\n              \n              The <code>condition</code> tensor acts as a mask that chooses, based on the value at each\n              element, whether the corresponding element / row in the output should be\n              taken from <code>x</code> (if true) or <code>y</code> (if false).\n              \n              If <code>condition</code> is a vector and <code>x</code> and <code>y</code> are higher rank matrices, then\n              it chooses which row (outer dimension) to copy from <code>x</code> and <code>y</code>.\n              If <code>condition</code> has the same shape as <code>x</code> and <code>y</code>, then it chooses which\n              element to copy from <code>x</code> and <code>y</code>.\n              \n              For example:\n              \n               <pre><code>\n              # 'condition' tensor is [[True,  False]\n              #                        [False, True]]\n              # 't' is [[1, 2],\n              #         [3, 4]]\n              # 'e' is [[5, 6],\n              #         [7, 8]]\n              select(condition, t, e)  # =&gt; [[1, 6], [7, 4]]\n              \n              \n              # 'condition' tensor is [True, False]\n              # 't' is [[1, 2],\n              #         [3, 4]]\n              # 'e' is [[5, 6],\n              #         [7, 8]]\n              select(condition, t, e) ==&gt; [[1, 2],\n              [7, 8]]\n              \n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Select (TensorFlow.TFOutput condition, TensorFlow.TFOutput t, TensorFlow.TFOutput e, string operName = null);
    parameters:
    - id: condition
      type: TensorFlow.TFOutput
      description: To be added.
    - id: t
      type: TensorFlow.TFOutput
      description: >-
        = A <code>Tensor</code> which may have the same shape as <code>condition</code>.
                      If <code>condition</code> is rank 1, <code>x</code> may have higher rank,
                      but its first dimension must match the size of <code>condition</code>.
    - id: e
      type: TensorFlow.TFOutput
      description: = A <code>Tensor</code> with the same type and shape as <code>x</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Select'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        = A <code>Tensor</code> with the same type and shape as <code>x</code> and <code>y</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Select*
  exceptions: []
- uid: TensorFlow.TFGraph.SelfAdjointEig(TensorFlow.TFOutput,System.String)
  id: SelfAdjointEig(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SelfAdjointEig(TFOutput, String)
  nameWithType: TFGraph.SelfAdjointEig(TFOutput, String)
  fullName: TFGraph.SelfAdjointEig(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the Eigen Decomposition of a batch of square self-adjoint matrices.
  remarks: "The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions\n              form square matrices, with the same constraints as the single matrix\n              SelfAdjointEig.\n              \n              The result is a [..., M+1, M] matrix with [..., 0,:] containing the\n              eigenvalues, and subsequent [...,1:, :] containing the eigenvectors. The eigenvalues\n              are sorted in non-decreasing order."
  syntax:
    content: public TensorFlow.TFOutput SelfAdjointEig (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: Shape is <code>[..., M, M]</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SelfAdjointEig'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Shape is <code>[..., M+1, M]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SelfAdjointEig*
  exceptions: []
- uid: TensorFlow.TFGraph.SelfAdjointEigV2(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SelfAdjointEigV2(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SelfAdjointEigV2(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SelfAdjointEigV2(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SelfAdjointEigV2(TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the eigen decomposition of one or more square self-adjoint matrices.
  remarks: "Computes the eigenvalues and (optionally) eigenvectors of each inner matrix in\n              <code>input</code> such that <code>input[..., :, :] = v[..., :, :] * diag(e[..., :])</code>. The eigenvalues\n              are sorted in non-decreasing order.\n              \n               <pre><code>\n              # a is a tensor.\n              # e is a tensor of eigenvalues.\n              # v is a tensor of eigenvectors.\n              e, v = self_adjoint_eig(a)\n              e = self_adjoint_eig(a, compute_v=False)\n               </code></pre>"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> SelfAdjointEigV2 (TensorFlow.TFOutput input, Nullable<bool> compute_v = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: <code>Tensor</code> input of shape <code>[N, N]</code>.
    - id: compute_v
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code> then eigenvectors will be computed and returned in <code>v</code>.
                      Otherwise, only the eigenvalues will be computed.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SelfAdjointEigV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      e: Eigenvalues. Shape is <code>[N]</code>.
                      v: Eigenvectors. Shape is <code>[N, N]</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SelfAdjointEigV2*
  exceptions: []
- uid: TensorFlow.TFGraph.Selu(TensorFlow.TFOutput,System.String)
  id: Selu(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Selu(TFOutput, String)
  nameWithType: TFGraph.Selu(TFOutput, String)
  fullName: TFGraph.Selu(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Computes scaled exponential linear: <code>scale * alpha * (exp(features) - 1)</code>'
  remarks: "if &lt; 0, <code>scale * features</code> otherwise.\n              \n              To be used together with\n              <code>initializer = tf.variance_scaling_initializer(factor=1.0, mode='FAN_IN')</code>.\n              For correct dropout, use <code>tf.contrib.nn.alpha_dropout</code>.\n              \n              See [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)"
  syntax:
    content: public TensorFlow.TFOutput Selu (TensorFlow.TFOutput features, string operName = null);
    parameters:
    - id: features
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Selu'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Selu*
  exceptions: []
- uid: TensorFlow.TFGraph.SeluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SeluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SeluGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SeluGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.SeluGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes gradients for the scaled exponential linear (Selu) operation.
  syntax:
    content: public TensorFlow.TFOutput SeluGrad (TensorFlow.TFOutput gradients, TensorFlow.TFOutput outputs, string operName = null);
    parameters:
    - id: gradients
      type: TensorFlow.TFOutput
      description: The backpropagated gradients to the corresponding Selu operation.
    - id: outputs
      type: TensorFlow.TFOutput
      description: The outputs of the corresponding Selu operation.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SeluGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The gradients: <code>gradients * (outputs + scale * alpha)</code>
                      if outputs &lt; 0, <code>scale * gradients</code> otherwise.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SeluGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.SendTPUEmbeddingGradients(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String,System.String)
  id: SendTPUEmbeddingGradients(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SendTPUEmbeddingGradients(TFOutput[], TFOutput[], String, String)
  nameWithType: TFGraph.SendTPUEmbeddingGradients(TFOutput[], TFOutput[], String, String)
  fullName: TFGraph.SendTPUEmbeddingGradients(TFOutput[], TFOutput[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An op that performs gradient updates of embedding tables.
  remarks: >-
    The TensorList argument has the same length and shapes as the return value of
                  TPUEmbeddingReceiveActivations, but contains gradients of the model's loss
                  with respect to the embedding activations. The embedding tables are updated
                  from these gradients via the optimizer specified in the configuration given
                  to tpu.initialize_system.
  syntax:
    content: public TensorFlow.TFOperation SendTPUEmbeddingGradients (TensorFlow.TFOutput[] inputs, TensorFlow.TFOutput[] learning_rates, string config, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: >-
        A TensorList of gradients with which to update embedding tables.
                      It contains one tensor per embedding table in the model.
    - id: learning_rates
      type: TensorFlow.TFOutput[]
      description: >-
        A list of float32 scalars, one for each embedding table,
                      containing the learning rates for each table when dynamic learning rate is
                      enabled through the OptimizationParameters in TPUEmbeddingConfiguration.
                      When the learning rate is constant, the list should be empty.
    - id: config
      type: System.String
      description: Serialized TPUEmbeddingConfiguration proto.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SendTPUEmbeddingGradients'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.SendTPUEmbeddingGradients*
  exceptions: []
- uid: TensorFlow.TFGraph.SerializeIterator(TensorFlow.TFOutput,System.String)
  id: SerializeIterator(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SerializeIterator(TFOutput, String)
  nameWithType: TFGraph.SerializeIterator(TFOutput, String)
  fullName: TFGraph.SerializeIterator(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts the given <code>resource_handle</code> representing an iterator to a variant tensor.
  syntax:
    content: public TensorFlow.TFOutput SerializeIterator (TensorFlow.TFOutput resource_handle, string operName = null);
    parameters:
    - id: resource_handle
      type: TensorFlow.TFOutput
      description: A handle to an iterator resource.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeIterator'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A variant tensor storing the state of the iterator contained in the
                      resource.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SerializeIterator*
  exceptions: []
- uid: TensorFlow.TFGraph.SerializeManySparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: SerializeManySparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SerializeManySparse(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.SerializeManySparse(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.SerializeManySparse(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Serialize an <code>N</code>-minibatch <code>SparseTensor</code> into an <code>[N, 3]</code><code>Tensor</code> object.
  remarks: "The <code>SparseTensor</code> must have rank <code>R</code> greater than 1, and the first dimension\n              is treated as the minibatch dimension.  Elements of the <code>SparseTensor</code>\n              must be sorted in increasing order of this first dimension.  The serialized\n              <code>SparseTensor</code> objects going into each row of <code>serialized_sparse</code> will have\n              rank <code>R-1</code>.\n              \n              The minibatch size <code>N</code> is extracted from <code>sparse_shape[0]</code>."
  syntax:
    content: public TensorFlow.TFOutput SerializeManySparse (TensorFlow.TFOutput sparse_indices, TensorFlow.TFOutput sparse_values, TensorFlow.TFOutput sparse_shape, Nullable<TensorFlow.TFDataType> out_type = null, string operName = null);
    parameters:
    - id: sparse_indices
      type: TensorFlow.TFOutput
      description: 2-D.  The <code>indices</code> of the minibatch <code>SparseTensor</code>.
    - id: sparse_values
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>values</code> of the minibatch <code>SparseTensor</code>.
    - id: sparse_shape
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>shape</code> of the minibatch <code>SparseTensor</code>.
    - id: out_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: >-
        Optional argument
                      The <code>dtype</code> to use for serialization; the supported types are <code>string</code>
                      (default) and <code>variant</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeManySparse'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SerializeManySparse*
  exceptions: []
- uid: TensorFlow.TFGraph.SerializeSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: SerializeSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SerializeSparse(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.SerializeSparse(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.SerializeSparse(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Serialize a <code>SparseTensor</code> into a <code>[3]</code><code>Tensor</code> object.
  syntax:
    content: public TensorFlow.TFOutput SerializeSparse (TensorFlow.TFOutput sparse_indices, TensorFlow.TFOutput sparse_values, TensorFlow.TFOutput sparse_shape, Nullable<TensorFlow.TFDataType> out_type = null, string operName = null);
    parameters:
    - id: sparse_indices
      type: TensorFlow.TFOutput
      description: 2-D.  The <code>indices</code> of the <code>SparseTensor</code>.
    - id: sparse_values
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>values</code> of the <code>SparseTensor</code>.
    - id: sparse_shape
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>shape</code> of the <code>SparseTensor</code>.
    - id: out_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: >-
        Optional argument
                      The <code>dtype</code> to use for serialization; the supported types are <code>string</code>
                      (default) and <code>variant</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeSparse'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SerializeSparse*
  exceptions: []
- uid: TensorFlow.TFGraph.SerializeTensor(TensorFlow.TFOutput,System.String)
  id: SerializeTensor(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SerializeTensor(TFOutput, String)
  nameWithType: TFGraph.SerializeTensor(TFOutput, String)
  fullName: TFGraph.SerializeTensor(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Transforms a Tensor into a serialized TensorProto proto.
  syntax:
    content: public TensorFlow.TFOutput SerializeTensor (TensorFlow.TFOutput tensor, string operName = null);
    parameters:
    - id: tensor
      type: TensorFlow.TFOutput
      description: A Tensor of type <code>T</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SerializeTensor'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A serialized TensorProto proto of the input tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SerializeTensor*
  exceptions: []
- uid: TensorFlow.TFGraph.SetSize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SetSize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SetSize(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SetSize(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SetSize(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Number of unique elements along last dimension of input <code>set</code>.
  remarks: "Input <code>set</code> is a <code>SparseTensor</code> represented by <code>set_indices</code>, <code>set_values</code>,\n              and <code>set_shape</code>. The last dimension contains values in a set, duplicates are\n              allowed but ignored.\n              \n              If <code>validate_indices</code> is <code>True</code>, this op validates the order and range of <code>set</code>\n              indices."
  syntax:
    content: public TensorFlow.TFOutput SetSize (TensorFlow.TFOutput set_indices, TensorFlow.TFOutput set_values, TensorFlow.TFOutput set_shape, Nullable<bool> validate_indices = null, string operName = null);
    parameters:
    - id: set_indices
      type: TensorFlow.TFOutput
      description: 2D <code>Tensor</code>, indices of a <code>SparseTensor</code>.
    - id: set_values
      type: TensorFlow.TFOutput
      description: 1D <code>Tensor</code>, values of a <code>SparseTensor</code>.
    - id: set_shape
      type: TensorFlow.TFOutput
      description: 1D <code>Tensor</code>, shape of a <code>SparseTensor</code>.
    - id: validate_indices
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SetSize'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        For <code>set</code> ranked <code>n</code>, this is a <code>Tensor</code> with rank <code>n-1</code>, and the same 1st
                      <code>n-1</code> dimensions as <code>set</code>. Each value is the number of unique elements in
                      the corresponding <code>[0...n-1]</code> dimension of <code>set</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SetSize*
  exceptions: []
- uid: TensorFlow.TFGraph.SetTensorShape(TensorFlow.TFOutput,System.Int64[],TensorFlow.TFStatus)
  id: SetTensorShape(TensorFlow.TFOutput,System.Int64[],TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SetTensorShape(TFOutput, Int64[], TFStatus)
  nameWithType: TFGraph.SetTensorShape(TFOutput, Int64[], TFStatus)
  fullName: TFGraph.SetTensorShape(TFOutput, Int64[], TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Sets the tensor shape of the tensor referenced by <code>output</code> to the shape described by <code>dims</code>.
  syntax:
    content: public void SetTensorShape (TensorFlow.TFOutput output, long[] dims, TensorFlow.TFStatus status = null);
    parameters:
    - id: output
      type: TensorFlow.TFOutput
      description: The tensor on which this method will operate in the graph.
    - id: dims
      type: System.Int64[]
      description: The tensor shape, specified as an array of dimensions.
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
  overload: TensorFlow.TFGraph.SetTensorShape*
  exceptions: []
- uid: TensorFlow.TFGraph.Shape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: Shape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Shape(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Shape(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Shape(TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the shape of a tensor.
  remarks: "This operation returns a 1-D integer tensor representing the shape of <code>input</code>.\n              \n              For example:\n              \n               <pre><code>\n              # 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\n              shape(t) ==&gt; [2, 2, 3]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Shape (TensorFlow.TFOutput input, Nullable<TensorFlow.TFDataType> out_type = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: out_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Shape'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Shape*
  exceptions: []
- uid: TensorFlow.TFGraph.ShapeN(TensorFlow.TFOutput[],System.Nullable{TensorFlow.TFDataType},System.String)
  id: ShapeN(TensorFlow.TFOutput[],System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ShapeN(TFOutput[], Nullable<TFDataType>, String)
  nameWithType: TFGraph.ShapeN(TFOutput[], Nullable<TFDataType>, String)
  fullName: TFGraph.ShapeN(TFOutput[], Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns shape of tensors.
  remarks: This operation returns N 1-D integer tensors representing shape of <code>input[i]s</code>.
  syntax:
    content: public TensorFlow.TFOutput[] ShapeN (TensorFlow.TFOutput[] input, Nullable<TensorFlow.TFDataType> out_type = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: out_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ShapeN'.
    return:
      type: TensorFlow.TFOutput[]
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ShapeN*
  exceptions: []
- uid: TensorFlow.TFGraph.ShardedFilename(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ShardedFilename(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ShardedFilename(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ShardedFilename(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ShardedFilename(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generate a sharded filename. The filename is printf formatted as
  remarks: '%s-%05d-of-%05d, basename, shard, num_shards.'
  syntax:
    content: public TensorFlow.TFOutput ShardedFilename (TensorFlow.TFOutput basename, TensorFlow.TFOutput shard, TensorFlow.TFOutput num_shards, string operName = null);
    parameters:
    - id: basename
      type: TensorFlow.TFOutput
      description: To be added.
    - id: shard
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_shards
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ShardedFilename'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ShardedFilename*
  exceptions: []
- uid: TensorFlow.TFGraph.ShardedFilespec(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: ShardedFilespec(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ShardedFilespec(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ShardedFilespec(TFOutput, TFOutput, String)
  fullName: TFGraph.ShardedFilespec(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generate a glob pattern matching all sharded file names.
  syntax:
    content: public TensorFlow.TFOutput ShardedFilespec (TensorFlow.TFOutput basename, TensorFlow.TFOutput num_shards, string operName = null);
    parameters:
    - id: basename
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_shards
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ShardedFilespec'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ShardedFilespec*
  exceptions: []
- uid: TensorFlow.TFGraph.ShuffleAndRepeatDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: ShuffleAndRepeatDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ShuffleAndRepeatDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ShuffleAndRepeatDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.ShuffleAndRepeatDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that shuffles and repeats elements from <code>input_dataset</code>
  remarks: pseudorandomly.
  syntax:
    content: public TensorFlow.TFOutput ShuffleAndRepeatDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput buffer_size, TensorFlow.TFOutput seed, TensorFlow.TFOutput seed2, TensorFlow.TFOutput count, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: buffer_size
      type: TensorFlow.TFOutput
      description: >-
        The number of output elements to buffer in an iterator over
                      this dataset. Compare with the <code>min_after_dequeue</code> attr when creating a
                      <code>RandomShuffleQueue</code>.
    - id: seed
      type: TensorFlow.TFOutput
      description: >-
        A scalar seed for the random number generator. If either <code>seed</code> or
                      <code>seed2</code> is set to be non-zero, the random number generator is seeded
                      by the given seed.  Otherwise, a random seed is used.
    - id: seed2
      type: TensorFlow.TFOutput
      description: A second scalar seed to avoid seed collision.
    - id: count
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing the number of times the underlying dataset
                      should be repeated. The default is <code>-1</code>, which results in infinite repetition.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ShuffleAndRepeatDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ShuffleAndRepeatDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.ShuffleDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Boolean},System.String)
  id: ShuffleDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ShuffleDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], Nullable<Boolean>, String)
  nameWithType: TFGraph.ShuffleDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], Nullable<Boolean>, String)
  fullName: TFGraph.ShuffleDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that shuffles elements from <code>input_dataset</code> pseudorandomly.
  syntax:
    content: public TensorFlow.TFOutput ShuffleDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput buffer_size, TensorFlow.TFOutput seed, TensorFlow.TFOutput seed2, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, Nullable<bool> reshuffle_each_iteration = null, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: buffer_size
      type: TensorFlow.TFOutput
      description: >-
        The number of output elements to buffer in an iterator over
                      this dataset. Compare with the <code>min_after_dequeue</code> attr when creating a
                      <code>RandomShuffleQueue</code>.
    - id: seed
      type: TensorFlow.TFOutput
      description: >-
        A scalar seed for the random number generator. If either <code>seed</code> or
                      <code>seed2</code> is set to be non-zero, the random number generator is seeded
                      by the given seed.  Otherwise, a random seed is used.
    - id: seed2
      type: TensorFlow.TFOutput
      description: A second scalar seed to avoid seed collision.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: reshuffle_each_iteration
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, each iterator over this dataset will be given
                      a different pseudorandomly generated seed, based on a sequence seeded by the
                      <code>seed</code> and <code>seed2</code> inputs. If false, each iterator will be given the same
                      seed, and repeated iteration over this dataset will yield the exact same
                      sequence of results.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ShuffleDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ShuffleDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.ShutdownDistributedTPU(System.String)
  id: ShutdownDistributedTPU(System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ShutdownDistributedTPU(String)
  nameWithType: TFGraph.ShutdownDistributedTPU(String)
  fullName: TFGraph.ShutdownDistributedTPU(String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An op that shuts down a running distributed TPU system. The Op returns
  remarks: an error if no system is running.
  syntax:
    content: public TensorFlow.TFOperation ShutdownDistributedTPU (string operName = null);
    parameters:
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ShutdownDistributedTPU'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.ShutdownDistributedTPU*
  exceptions: []
- uid: TensorFlow.TFGraph.Sigmoid(TensorFlow.TFOutput,System.String)
  id: Sigmoid(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Sigmoid(TFOutput, String)
  nameWithType: TFGraph.Sigmoid(TFOutput, String)
  fullName: TFGraph.Sigmoid(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes sigmoid of <code>x</code> element-wise.
  remarks: Specifically, <code>y = 1 / (1 + exp(-x))</code>.
  syntax:
    content: public TensorFlow.TFOutput Sigmoid (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Sigmoid'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Sigmoid*
  exceptions: []
- uid: TensorFlow.TFGraph.SigmoidCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SigmoidCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SigmoidCrossEntropyWithLogits(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SigmoidCrossEntropyWithLogits(TFOutput, TFOutput, String)
  fullName: TFGraph.SigmoidCrossEntropyWithLogits(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes sigmoid cross entropy given `logits`.
  remarks: >-
    Measures the probability error in discrete classification tasks in which each
                   class is independent and not mutually exclusive.For instance, one could
                   perform multilabel classification where a picture can contain both an elephant
                   and a dog at the same time.
  syntax:
    content: public TensorFlow.TFOutput SigmoidCrossEntropyWithLogits (TensorFlow.TFOutput labels, TensorFlow.TFOutput logits, string operName = null);
    parameters:
    - id: labels
      type: TensorFlow.TFOutput
      description: To be added.
    - id: logits
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: To be added.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.SigmoidCrossEntropyWithLogits*
  exceptions: []
- uid: TensorFlow.TFGraph.SigmoidGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SigmoidGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SigmoidGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SigmoidGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.SigmoidGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradient of the sigmoid of <code>x</code> wrt its input.
  remarks: >-
    Specifically, <code>grad = dy * y * (1 - y)</code>, where <code>y = sigmoid(x)</code>, and
                  <code>dy</code> is the corresponding input gradient.
  syntax:
    content: public TensorFlow.TFOutput SigmoidGrad (TensorFlow.TFOutput y, TensorFlow.TFOutput dy, string operName = null);
    parameters:
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dy
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SigmoidGrad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SigmoidGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.Sign(TensorFlow.TFOutput,System.String)
  id: Sign(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Sign(TFOutput, String)
  nameWithType: TFGraph.Sign(TFOutput, String)
  fullName: TFGraph.Sign(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns an element-wise indication of the sign of a number.
  remarks: "<code>y = sign(x) = -1</code> if <code>x &lt; 0</code>; 0 if <code>x == 0</code>; 1 if <code>x &gt; 0</code>.\n              \n              For complex numbers, <code>y = sign(x) = x / |x|</code> if <code>x != 0</code>, otherwise <code>y = 0</code>."
  syntax:
    content: public TensorFlow.TFOutput Sign (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Sign'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Sign*
  exceptions: []
- uid: TensorFlow.TFGraph.Sin(TensorFlow.TFOutput,System.String)
  id: Sin(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Sin(TFOutput, String)
  nameWithType: TFGraph.Sin(TFOutput, String)
  fullName: TFGraph.Sin(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes sin of x element-wise.
  syntax:
    content: public TensorFlow.TFOutput Sin (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Sin'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Sin*
  exceptions: []
- uid: TensorFlow.TFGraph.Sinh(TensorFlow.TFOutput,System.String)
  id: Sinh(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Sinh(TFOutput, String)
  nameWithType: TFGraph.Sinh(TFOutput, String)
  fullName: TFGraph.Sinh(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes hyperbolic sine of x element-wise.
  syntax:
    content: public TensorFlow.TFOutput Sinh (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Sinh'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Sinh*
  exceptions: []
- uid: TensorFlow.TFGraph.Size(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: Size(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Size(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Size(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Size(TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the size of a tensor.
  remarks: "This operation returns an integer representing the number of elements in\n              <code>input</code>.\n              \n              For example:\n              \n               <pre><code>\n              # 't' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]\n              size(t) ==&gt; 12\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Size (TensorFlow.TFOutput input, Nullable<TensorFlow.TFDataType> out_type = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: out_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Size'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Size*
  exceptions: []
- uid: TensorFlow.TFGraph.SkipDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: SkipDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SkipDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.SkipDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.SkipDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that skips <code>count</code> elements from the <code>input_dataset</code>.
  syntax:
    content: public TensorFlow.TFOutput SkipDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput count, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: count
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing the number of elements from the <code>input_dataset</code>
                      that should be skipped.  If count is -1, skips everything.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SkipDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SkipDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.Skipgram(System.String,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Single},System.String)
  id: Skipgram(System.String,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Skipgram(String, Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Single>, String)
  nameWithType: TFGraph.Skipgram(String, Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Single>, String)
  fullName: TFGraph.Skipgram(String, Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Single>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Parses a text file and creates a batch of examples.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> Skipgram (string filename, long batch_size, Nullable<long> window_size = null, Nullable<long> min_count = null, Nullable<float> subsample = null, string operName = null);
    parameters:
    - id: filename
      type: System.String
      description: The corpus's text file name.
    - id: batch_size
      type: System.Int64
      description: The size of produced batch.
    - id: window_size
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The number of words to predict to the left and right of the target.
    - id: min_count
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The minimum number of word occurrences for it to be included in the
                      vocabulary.
    - id: subsample
      type: System.Nullable{System.Single}
      description: >-
        Optional argument
                      Threshold for word occurrence. Words that appear with higher
                      frequency will be randomly down-sampled. Set to 0 to disable.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Skipgram'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      vocab_word: A vector of words in the corpus.
                      vocab_freq: Frequencies of words. Sorted in the non-ascending order.
                      words_per_epoch: Number of words per epoch in the data file.
                      current_epoch: The current epoch number.
                      total_words_processed: The total number of words processed so far.
                      examples: A vector of word ids.
                      labels: A vector of word ids.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.Skipgram*
  exceptions: []
- uid: TensorFlow.TFGraph.Slice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Slice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Slice(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.Slice(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.Slice(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Return a slice from 'input'.
  remarks: "The output tensor is a tensor with dimensions described by 'size'\n              whose values are extracted from 'input' starting at the offsets in\n              'begin'.\n              \n              *Requirements*:\n              0 &lt;= begin[i] &lt;= begin[i] + size[i] &lt;= Di  for i in [0, n)"
  syntax:
    content: public TensorFlow.TFOutput Slice (TensorFlow.TFOutput input, TensorFlow.TFOutput begin, TensorFlow.TFOutput size, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: begin
      type: TensorFlow.TFOutput
      description: >-
        begin[i] specifies the offset into the 'i'th dimension of
                      'input' to slice from.
    - id: size
      type: TensorFlow.TFOutput
      description: >-
        size[i] specifies the number of elements of the 'i'th dimension
                      of 'input' to slice. If size[i] is -1, all remaining elements in dimension
                      i are included in the slice (i.e. this is equivalent to setting
                      size[i] = input.dim_size(i) - begin[i]).
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Slice'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Slice*
  exceptions: []
- uid: TensorFlow.TFGraph.Snapshot(TensorFlow.TFOutput,System.String)
  id: Snapshot(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Snapshot(TFOutput, String)
  nameWithType: TFGraph.Snapshot(TFOutput, String)
  fullName: TFGraph.Snapshot(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns a copy of the input tensor.
  syntax:
    content: public TensorFlow.TFOutput Snapshot (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Snapshot'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Snapshot*
  exceptions: []
- uid: TensorFlow.TFGraph.Softmax(TensorFlow.TFOutput,System.String)
  id: Softmax(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Softmax(TFOutput, String)
  nameWithType: TFGraph.Softmax(TFOutput, String)
  fullName: TFGraph.Softmax(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes softmax activations.
  remarks: "For each batch <code>i</code> and class <code>j</code> we have\n              \n              $$softmax[i, j] = exp(logits[i, j]) / sum_j(exp(logits[i, j]))$$"
  syntax:
    content: public TensorFlow.TFOutput Softmax (TensorFlow.TFOutput logits, string operName = null);
    parameters:
    - id: logits
      type: TensorFlow.TFOutput
      description: 2-D with shape <code>[batch_size, num_classes]</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Softmax'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same shape as <code>logits</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Softmax*
  exceptions: []
- uid: TensorFlow.TFGraph.SoftmaxCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SoftmaxCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)
  fullName: TFGraph.SoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes softmax cross entropy cost and gradients to backpropagate.
  remarks: Inputs are the logits, not probabilities.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> SoftmaxCrossEntropyWithLogits (TensorFlow.TFOutput features, TensorFlow.TFOutput labels, string operName = null);
    parameters:
    - id: features
      type: TensorFlow.TFOutput
      description: batch_size x num_classes matrix
    - id: labels
      type: TensorFlow.TFOutput
      description: >-
        batch_size x num_classes matrix
                      The caller must ensure that each batch of labels represents a valid
                      probability distribution.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SoftmaxCrossEntropyWithLogits'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      loss: Per example loss (batch_size vector).
                      backprop: backpropagated gradients (batch_size x num_classes matrix).
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SoftmaxCrossEntropyWithLogits*
  exceptions: []
- uid: TensorFlow.TFGraph.Softplus(TensorFlow.TFOutput,System.String)
  id: Softplus(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Softplus(TFOutput, String)
  nameWithType: TFGraph.Softplus(TFOutput, String)
  fullName: TFGraph.Softplus(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Computes softplus: <code>log(exp(features) + 1)</code>.'
  syntax:
    content: public TensorFlow.TFOutput Softplus (TensorFlow.TFOutput features, string operName = null);
    parameters:
    - id: features
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Softplus'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Softplus*
  exceptions: []
- uid: TensorFlow.TFGraph.SoftplusGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SoftplusGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SoftplusGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SoftplusGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.SoftplusGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes softplus gradients for a softplus operation.
  syntax:
    content: public TensorFlow.TFOutput SoftplusGrad (TensorFlow.TFOutput gradients, TensorFlow.TFOutput features, string operName = null);
    parameters:
    - id: gradients
      type: TensorFlow.TFOutput
      description: The backpropagated gradients to the corresponding softplus operation.
    - id: features
      type: TensorFlow.TFOutput
      description: The features passed as input to the corresponding softplus operation.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SoftplusGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The gradients: <code>gradients / (1 + exp(-features))</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SoftplusGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.Softsign(TensorFlow.TFOutput,System.String)
  id: Softsign(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Softsign(TFOutput, String)
  nameWithType: TFGraph.Softsign(TFOutput, String)
  fullName: TFGraph.Softsign(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Computes softsign: <code>features / (abs(features) + 1)</code>.'
  syntax:
    content: public TensorFlow.TFOutput Softsign (TensorFlow.TFOutput features, string operName = null);
    parameters:
    - id: features
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Softsign'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Softsign*
  exceptions: []
- uid: TensorFlow.TFGraph.SoftsignGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SoftsignGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SoftsignGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SoftsignGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.SoftsignGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes softsign gradients for a softsign operation.
  syntax:
    content: public TensorFlow.TFOutput SoftsignGrad (TensorFlow.TFOutput gradients, TensorFlow.TFOutput features, string operName = null);
    parameters:
    - id: gradients
      type: TensorFlow.TFOutput
      description: The backpropagated gradients to the corresponding softsign operation.
    - id: features
      type: TensorFlow.TFOutput
      description: The features passed as input to the corresponding softsign operation.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SoftsignGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The gradients: <code>gradients / (1 + abs(features)) ** 2</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SoftsignGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.SpaceToBatch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  id: SpaceToBatch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SpaceToBatch(TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.SpaceToBatch(TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.SpaceToBatch(TFOutput, TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: SpaceToBatch for 4-D tensors of type T.
  remarks: "This is a legacy version of the more general SpaceToBatchND.\n              \n              Zero-pads and then rearranges (permutes) blocks of spatial data into batch.\n              More specifically, this op outputs a copy of the input tensor where values from\n              the <code>height</code> and <code>width</code> dimensions are moved to the <code>batch</code> dimension. After\n              the zero-padding, both <code>height</code> and <code>width</code> of the input must be divisible by the\n              block size."
  syntax:
    content: public TensorFlow.TFOutput SpaceToBatch (TensorFlow.TFOutput input, TensorFlow.TFOutput paddings, long block_size, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 4-D with shape <code>[batch, height, width, depth]</code>.
    - id: paddings
      type: TensorFlow.TFOutput
      description: "2-D tensor of non-negative integers with shape <code>[2, 2]</code>. It specifies\n              the padding of the input with zeros across the spatial dimensions as follows:\n              \n              paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]\n              \n              The effective spatial dimensions of the zero-padded input tensor will be:\n              \n              height_pad = pad_top + height + pad_bottom\n              width_pad = pad_left + width + pad_right\n              \n              The attr <code>block_size</code> must be greater than one. It indicates the block size.\n              \n              * Non-overlapping blocks of size <code>block_size x block size</code> in the height and\n              width dimensions are rearranged into the batch dimension at each location.\n              * The batch of the output tensor is <code>batch * block_size * block_size</code>.\n              * Both height_pad and width_pad must be divisible by block_size.\n              \n              The shape of the output will be:\n              \n              [batch*block_size*block_size, height_pad/block_size, width_pad/block_size,\n              depth]\n              \n              Some examples:\n              \n              (1) For the following input of shape <code>[1, 2, 2, 1]</code> and block_size of 2:\n              \n               <pre><code>\n              x = [[[[1], [2]], [[3], [4]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[4, 1, 1, 1]</code> and value:\n              \n               <pre><code>\n              [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n               </code></pre>\n              \n              (2) For the following input of shape <code>[1, 2, 2, 3]</code> and block_size of 2:\n              \n               <pre><code>\n              x = [[[[1, 2, 3], [4, 5, 6]],\n              [[7, 8, 9], [10, 11, 12]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[4, 1, 1, 3]</code> and value:\n              \n               <pre><code>\n              [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]\n               </code></pre>\n              \n              (3) For the following input of shape <code>[1, 4, 4, 1]</code> and block_size of 2:\n              \n               <pre><code>\n              x = [[[[1],   [2],  [3],  [4]],\n              [[5],   [6],  [7],  [8]],\n              [[9],  [10], [11],  [12]],\n              [[13], [14], [15],  [16]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[4, 2, 2, 1]</code> and value:\n              \n               <pre><code>\n              x = [[[[1], [3]], [[9], [11]]],\n              [[[2], [4]], [[10], [12]]],\n              [[[5], [7]], [[13], [15]]],\n              [[[6], [8]], [[14], [16]]]]\n               </code></pre>\n              \n              (4) For the following input of shape <code>[2, 2, 4, 1]</code> and block_size of 2:\n              \n               <pre><code>\n              x = [[[[1],   [2],  [3],  [4]],\n              [[5],   [6],  [7],  [8]]],\n              [[[9],  [10], [11],  [12]],\n              [[13], [14], [15],  [16]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[8, 1, 2, 1]</code> and value:\n              \n               <pre><code>\n              x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],\n              [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]\n               </code></pre>\n              \n              Among others, this operation is useful for reducing atrous convolution into\n              regular convolution."
    - id: block_size
      type: System.Int64
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SpaceToBatch'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SpaceToBatch*
  exceptions: []
- uid: TensorFlow.TFGraph.SpaceToBatchND(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SpaceToBatchND(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SpaceToBatchND(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SpaceToBatchND(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SpaceToBatchND(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: SpaceToBatch for N-D tensors of type T.
  remarks: >-
    This operation divides "spatial" dimensions <code>[1, ..., M]</code> of the input into a
                  grid of blocks of shape <code>block_shape</code>, and interleaves these blocks with the
                  "batch" dimension (0) such that in the output, the spatial dimensions
                  <code>[1, ..., M]</code> correspond to the position within the grid, and the batch
                  dimension combines both the position within a spatial block and the original
                  batch position.  Prior to division into blocks, the spatial dimensions of the
                  input are optionally zero padded according to <code>paddings</code>.  See below for a
                  precise description.
  syntax:
    content: public TensorFlow.TFOutput SpaceToBatchND (TensorFlow.TFOutput input, TensorFlow.TFOutput block_shape, TensorFlow.TFOutput paddings, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: >-
        N-D with shape <code>input_shape = [batch] + spatial_shape + remaining_shape</code>,
                      where spatial_shape has <code>M</code> dimensions.
    - id: block_shape
      type: TensorFlow.TFOutput
      description: 1-D with shape <code>[M]</code>, all values must be &gt;= 1.
    - id: paddings
      type: TensorFlow.TFOutput
      description: "2-D with shape <code>[M, 2]</code>, all values must be &gt;= 0.\n              <code>paddings[i] = [pad_start, pad_end]</code> specifies the padding for input dimension\n              <code>i + 1</code>, which corresponds to spatial dimension <code>i</code>.  It is required that\n              <code>block_shape[i]</code> divides <code>input_shape[i + 1] + pad_start + pad_end</code>.\n              \n              This operation is equivalent to the following steps:\n              \n              1. Zero-pad the start and end of dimensions <code>[1, ..., M]</code> of the\n              input according to <code>paddings</code> to produce <code>padded</code> of shape <code>padded_shape</code>.\n              \n              2. Reshape <code>padded</code> to <code>reshaped_padded</code> of shape:\n              \n              [batch] +\n              [padded_shape[1] / block_shape[0],\n              block_shape[0],\n              ...,\n              padded_shape[M] / block_shape[M-1],\n              block_shape[M-1]] +\n              remaining_shape\n              \n              3. Permute dimensions of <code>reshaped_padded</code> to produce\n              <code>permuted_reshaped_padded</code> of shape:\n              \n              block_shape +\n              [batch] +\n              [padded_shape[1] / block_shape[0],\n              ...,\n              padded_shape[M] / block_shape[M-1]] +\n              remaining_shape\n              \n              4. Reshape <code>permuted_reshaped_padded</code> to flatten <code>block_shape</code> into the batch\n              dimension, producing an output tensor of shape:\n              \n              [batch * prod(block_shape)] +\n              [padded_shape[1] / block_shape[0],\n              ...,\n              padded_shape[M] / block_shape[M-1]] +\n              remaining_shape\n              \n              Some examples:\n              \n              (1) For the following input of shape <code>[1, 2, 2, 1]</code>, <code>block_shape = [2, 2]</code>, and\n              <code>paddings = [[0, 0], [0, 0]]</code>:\n              \n               <pre><code>\n              x = [[[[1], [2]], [[3], [4]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[4, 1, 1, 1]</code> and value:\n              \n               <pre><code>\n              [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n               </code></pre>\n              \n              (2) For the following input of shape <code>[1, 2, 2, 3]</code>, <code>block_shape = [2, 2]</code>, and\n              <code>paddings = [[0, 0], [0, 0]]</code>:\n              \n               <pre><code>\n              x = [[[[1, 2, 3], [4, 5, 6]],\n              [[7, 8, 9], [10, 11, 12]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[4, 1, 1, 3]</code> and value:\n              \n               <pre><code>\n              [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]\n               </code></pre>\n              \n              (3) For the following input of shape <code>[1, 4, 4, 1]</code>, <code>block_shape = [2, 2]</code>, and\n              <code>paddings = [[0, 0], [0, 0]]</code>:\n              \n               <pre><code>\n              x = [[[[1],   [2],  [3],  [4]],\n              [[5],   [6],  [7],  [8]],\n              [[9],  [10], [11],  [12]],\n              [[13], [14], [15],  [16]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[4, 2, 2, 1]</code> and value:\n              \n               <pre><code>\n              x = [[[[1], [3]], [[9], [11]]],\n              [[[2], [4]], [[10], [12]]],\n              [[[5], [7]], [[13], [15]]],\n              [[[6], [8]], [[14], [16]]]]\n               </code></pre>\n              \n              (4) For the following input of shape <code>[2, 2, 4, 1]</code>, block_shape = <code>[2, 2]</code>, and\n              paddings = <code>[[0, 0], [2, 0]]</code>:\n              \n               <pre><code>\n              x = [[[[1],   [2],  [3],  [4]],\n              [[5],   [6],  [7],  [8]]],\n              [[[9],  [10], [11],  [12]],\n              [[13], [14], [15],  [16]]]]\n               </code></pre>\n              \n              The output tensor has shape <code>[8, 1, 3, 1]</code> and value:\n              \n               <pre><code>\n              x = [[[[0], [1], [3]]], [[[0], [9], [11]]],\n              [[[0], [2], [4]]], [[[0], [10], [12]]],\n              [[[0], [5], [7]]], [[[0], [13], [15]]],\n              [[[0], [6], [8]]], [[[0], [14], [16]]]]\n               </code></pre>\n              \n              Among others, this operation is useful for reducing atrous convolution into\n              regular convolution."
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SpaceToBatchND'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SpaceToBatchND*
  exceptions: []
- uid: TensorFlow.TFGraph.SpaceToDepth(TensorFlow.TFOutput,System.Int64,System.String,System.String)
  id: SpaceToDepth(TensorFlow.TFOutput,System.Int64,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SpaceToDepth(TFOutput, Int64, String, String)
  nameWithType: TFGraph.SpaceToDepth(TFOutput, Int64, String, String)
  fullName: TFGraph.SpaceToDepth(TFOutput, Int64, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: SpaceToDepth for tensors of type T.
  remarks: "Rearranges blocks of spatial data, into depth. More specifically,\n              this op outputs a copy of the input tensor where values from the <code>height</code>\n              and <code>width</code> dimensions are moved to the <code>depth</code> dimension.\n              The attr <code>block_size</code> indicates the input block size.\n              \n              * Non-overlapping blocks of size <code>block_size x block size</code> are rearranged\n              into depth at each location.\n              * The depth of the output tensor is <code>block_size * block_size * input_depth</code>.\n              * The Y, X coordinates within each block of the input become the high order\n              component of the output channel index.\n              * The input tensor's height and width must be divisible by block_size.\n              \n              The <code>data_format</code> attr specifies the layout of the input and output tensors\n              with the following options:\n              \"NHWC\": <code>[ batch, height, width, channels ]</code>\n              \"NCHW\": <code>[ batch, channels, height, width ]</code>\n              \"NCHW_VECT_C\":\n              <code>qint8 [ batch, channels / 4, height, width, 4 ]</code>\n              \n              It is useful to consider the operation as transforming a 6-D Tensor.\n              e.g. for data_format = NHWC,\n              Each element in the input tensor can be specified via 6 coordinates,\n              ordered by decreasing memory layout significance as:\n              n,oY,bY,oX,bX,iC  (where n=batch index, oX, oY means X or Y coordinates\n              within the output image, bX, bY means coordinates\n              within the input block, iC means input channels).\n              The output would be a transpose to the following layout:\n              n,oY,oX,bY,bX,iC\n              \n              This operation is useful for resizing the activations between convolutions\n              (but keeping all data), e.g. instead of pooling. It is also useful for training\n              purely convolutional models.\n              \n              For example, given an input of shape <code>[1, 2, 2, 1]</code>, data_format = \"NHWC\" and\n              block_size = 2:\n              \n               <pre><code>\n              x = [[[[1], [2]],\n              [[3], [4]]]]\n               </code></pre>\n              \n              This operation will output a tensor of shape <code>[1, 1, 1, 4]</code>:\n              \n               <pre><code>\n              [[[[1, 2, 3, 4]]]]\n               </code></pre>\n              \n              Here, the input has a batch of 1 and each batch element has shape <code>[2, 2, 1]</code>,\n              the corresponding output will have a single element (i.e. width and height are\n              both 1) and will have a depth of 4 channels (1 * block_size * block_size).\n              The output element shape is <code>[1, 1, 4]</code>.\n              \n              For an input tensor with larger depth, here of shape <code>[1, 2, 2, 3]</code>, e.g.\n              \n               <pre><code>\n              x = [[[[1, 2, 3], [4, 5, 6]],\n              [[7, 8, 9], [10, 11, 12]]]]\n               </code></pre>\n              \n              This operation, for block_size of 2, will return the following tensor of shape\n              <code>[1, 1, 1, 12]</code><pre><code>\n              [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]\n               </code></pre>\n              \n              Similarly, for the following input of shape <code>[1 4 4 1]</code>, and a block size of 2:\n              \n               <pre><code>\n              x = [[[[1],   [2],  [5],  [6]],\n              [[3],   [4],  [7],  [8]],\n              [[9],  [10], [13],  [14]],\n              [[11], [12], [15],  [16]]]]\n               </code></pre>\n              \n              the operator will return the following tensor of shape <code>[1 2 2 4]</code>:\n              \n               <pre><code>\n              x = [[[[1, 2, 3, 4],\n              [5, 6, 7, 8]],\n              [[9, 10, 11, 12],\n              [13, 14, 15, 16]]]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput SpaceToDepth (TensorFlow.TFOutput input, long block_size, string data_format = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: block_size
      type: System.Int64
      description: The size of the spatial block.
    - id: data_format
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SpaceToDepth'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SpaceToDepth*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseAccumulatorApplyGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Boolean,System.String)
  id: SparseAccumulatorApplyGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseAccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Boolean, String)
  nameWithType: TFGraph.SparseAccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Boolean, String)
  fullName: TFGraph.SparseAccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Boolean, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies a sparse gradient to a given accumulator.
  remarks: >-
    Does not add if local_step is smaller than the accumulator's
                  global_step.
  syntax:
    content: public TensorFlow.TFOperation SparseAccumulatorApplyGradient (TensorFlow.TFOutput handle, TensorFlow.TFOutput local_step, TensorFlow.TFOutput gradient_indices, TensorFlow.TFOutput gradient_values, TensorFlow.TFOutput gradient_shape, bool has_known_shape, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a accumulator.
    - id: local_step
      type: TensorFlow.TFOutput
      description: The local_step value at which the sparse gradient was computed.
    - id: gradient_indices
      type: TensorFlow.TFOutput
      description: >-
        Indices of the sparse gradient to be accumulated. Must be a
                      vector.
    - id: gradient_values
      type: TensorFlow.TFOutput
      description: >-
        Values are the non-zero slices of the gradient, and must have
                      the same first dimension as indices, i.e., the nnz represented by indices and
                      values must be consistent.
    - id: gradient_shape
      type: TensorFlow.TFOutput
      description: Shape of the sparse gradient to be accumulated.
    - id: has_known_shape
      type: System.Boolean
      description: >-
        Boolean indicating whether gradient_shape is unknown, in which
                      case the input is ignored during validation.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAccumulatorApplyGradient'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.SparseAccumulatorApplyGradient*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseAccumulatorTakeGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: SparseAccumulatorTakeGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseAccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.SparseAccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.SparseAccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Extracts the average sparse gradient in a SparseConditionalAccumulator.
  remarks: >-
    The op will blocks until sufficient (i.e., more than num_required)
                  gradients have been accumulated. If the accumulator has already
                  aggregated more than num_required gradients, it will return its
                  average of the accumulated gradients.  Also automatically increments
                  the recorded global_step in the accumulator by 1, and resets the
                  aggregate to 0.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> SparseAccumulatorTakeGradient (TensorFlow.TFOutput handle, TensorFlow.TFOutput num_required, TensorFlow.TFDataType dtype, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a SparseConditionalAccumulator.
    - id: num_required
      type: TensorFlow.TFOutput
      description: Number of gradients required before we return an aggregate.
    - id: dtype
      type: TensorFlow.TFDataType
      description: >-
        The data type of accumulated gradients. Needs to correspond to the type
                      of the accumulator.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAccumulatorTakeGradient'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      indices: Indices of the average of the accumulated sparse gradients.
                      values: Values of the average of the accumulated sparse gradients.
                      shape: Shape of the average of the accumulated sparse gradients.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseAccumulatorTakeGradient*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Adds two <code>SparseTensor</code> objects to produce another <code>SparseTensor</code>.
  remarks: "The input <code>SparseTensor</code> objects' indices are assumed ordered in standard\n              lexicographic order.  If this is not the case, before this step run\n              <code>SparseReorder</code> to restore index ordering.\n              \n              By default, if two values sum to zero at some index, the output <code>SparseTensor</code>\n              would still include that particular location in its index, storing a zero in the\n              corresponding value slot.  To override this, callers can specify <code>thresh</code>,\n              indicating that if the sum has a magnitude strictly smaller than <code>thresh</code>, its\n              corresponding value and index would then not be included.  In particular,\n              <code>thresh == 0</code> (default) means everything is kept and actual thresholding happens\n              only for a positive value.\n              \n              In the following shapes, <code>nnz</code> is the count after taking <code>thresh</code> into account."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> SparseAdd (TensorFlow.TFOutput a_indices, TensorFlow.TFOutput a_values, TensorFlow.TFOutput a_shape, TensorFlow.TFOutput b_indices, TensorFlow.TFOutput b_values, TensorFlow.TFOutput b_shape, TensorFlow.TFOutput thresh, string operName = null);
    parameters:
    - id: a_indices
      type: TensorFlow.TFOutput
      description: 2-D.  The <code>indices</code> of the first <code>SparseTensor</code>, size <code>[nnz, ndims]</code> Matrix.
    - id: a_values
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>values</code> of the first <code>SparseTensor</code>, size <code>[nnz]</code> Vector.
    - id: a_shape
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>shape</code> of the first <code>SparseTensor</code>, size <code>[ndims]</code> Vector.
    - id: b_indices
      type: TensorFlow.TFOutput
      description: 2-D.  The <code>indices</code> of the second <code>SparseTensor</code>, size <code>[nnz, ndims]</code> Matrix.
    - id: b_values
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>values</code> of the second <code>SparseTensor</code>, size <code>[nnz]</code> Vector.
    - id: b_shape
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>shape</code> of the second <code>SparseTensor</code>, size <code>[ndims]</code> Vector.
    - id: thresh
      type: TensorFlow.TFOutput
      description: >-
        0-D.  The magnitude threshold that determines if an output value/index
                      pair takes space.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAdd'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sum_indices:
                      sum_values:
                      sum_shape:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseAdd*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseAddGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseAddGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseAddGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseAddGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseAddGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: The gradient operator for the SparseAdd op.
  remarks: >-
    The SparseAdd op calculates A + B, where A, B, and the sum are all represented
                  as <code>SparseTensor</code> objects.  This op takes in the upstream gradient w.r.t.
                  non-empty values of the sum, and outputs the gradients w.r.t. the non-empty
                  values of A and B.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> SparseAddGrad (TensorFlow.TFOutput backprop_val_grad, TensorFlow.TFOutput a_indices, TensorFlow.TFOutput b_indices, TensorFlow.TFOutput sum_indices, string operName = null);
    parameters:
    - id: backprop_val_grad
      type: TensorFlow.TFOutput
      description: >-
        1-D with shape <code>[nnz(sum)]</code>.  The gradient with respect to
                      the non-empty values of the sum.
    - id: a_indices
      type: TensorFlow.TFOutput
      description: 2-D.  The <code>indices</code> of the <code>SparseTensor</code> A, size <code>[nnz(A), ndims]</code>.
    - id: b_indices
      type: TensorFlow.TFOutput
      description: 2-D.  The <code>indices</code> of the <code>SparseTensor</code> B, size <code>[nnz(B), ndims]</code>.
    - id: sum_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  The <code>indices</code> of the sum <code>SparseTensor</code>, size
                      <code>[nnz(sum), ndims]</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseAddGrad'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      a_val_grad: 1-D with shape <code>[nnz(A)]</code>. The gradient with respect to the
                      non-empty values of A.
                      b_val_grad: 1-D with shape <code>[nnz(B)]</code>. The gradient with respect to the
                      non-empty values of B.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseAddGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SparseApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'var: Should be from a Variable().'
  syntax:
    content: public TensorFlow.TFOutput SparseApplyAdadelta (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput accum_update, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: To be added.
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum_update
      type: TensorFlow.TFOutput
      description: ': Should be from a Variable().'
    - id: lr
      type: TensorFlow.TFOutput
      description: Learning rate. Must be a scalar.
    - id: rho
      type: TensorFlow.TFOutput
      description: Decay factor. Must be a scalar.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Constant factor. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, updating of the var and accum tensors will be protected by
                      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdadelta'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseApplyAdadelta*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: SparseApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update relevant entries in '*var' and '*accum' according to the adagrad scheme.
  remarks: >-
    That is for rows we have grad for, we update var and accum as follows:
                  $$accum += grad * grad$$
                  $$var -= lr * grad * (1 / sqrt(accum))$$
  syntax:
    content: public TensorFlow.TFOutput SparseApplyAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable<bool> use_locking = null, Nullable<bool> update_slots = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Learning rate. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: update_slots
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdagrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseApplyAdagrad*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SparseApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update entries in '*var' and '*accum' according to the proximal adagrad scheme.
  syntax:
    content: public TensorFlow.TFOutput SparseApplyAdagradDA (TensorFlow.TFOutput var, TensorFlow.TFOutput gradient_accumulator, TensorFlow.TFOutput gradient_squared_accumulator, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput global_step, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: gradient_accumulator
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: gradient_squared_accumulator
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: lr
      type: TensorFlow.TFOutput
      description: Learning rate. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: global_step
      type: TensorFlow.TFOutput
      description: Training step number. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, updating of the var and accum tensors will be protected by
                      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyAdagradDA'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseApplyAdagradDA*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SparseApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the centered RMSProp algorithm.
  remarks: "The centered RMSProp algorithm uses an estimate of the centered second moment\n              (i.e., the variance) for normalization, as opposed to regular RMSProp, which\n              uses the (uncentered) second moment. This often helps with training, but is\n              slightly more expensive in terms of computation and memory.\n              \n              Note that in dense implementation of this algorithm, mg, ms, and mom will\n              update even if the grad is zero, but in this sparse implementation, mg, ms,\n              and mom will not update in iterations during which the grad is zero.\n              \n              mean_square = decay * mean_square + (1-decay) * gradient ** 2\n              mean_grad = decay * mean_grad + (1-decay) * gradient\n              Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n              \n              $$ms &lt;- rho * ms_{t-1} + (1-rho) * grad * grad$$\n              $$mom &lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)$$\n              $$var &lt;- var - mom$$"
  syntax:
    content: public TensorFlow.TFOutput SparseApplyCenteredRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput mg, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: mg
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: ms
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: mom
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: rho
      type: TensorFlow.TFOutput
      description: Decay rate. Must be a scalar.
    - id: momentum
      type: TensorFlow.TFOutput
      description: To be added.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Ridge term. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var, ms and mom.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var, mg, ms, and mom tensors is
                      protected by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyCenteredRMSProp'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseApplyCenteredRMSProp*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SparseApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update relevant entries in '*var' according to the Ftrl-proximal scheme.
  remarks: >-
    That is for rows we have grad for, we update var, accum and linear as follows:
                  $$accum_new = accum + grad * grad$$
                  $$linear += grad + (accum_{new}^{-lr_{power}} - accum^{-lr_{power}} / lr * var$$
                  $$quadratic = 1.0 / (accum_{new}^{lr_{power}} * lr) + 2 * l2$$
                  $$var = (sign(linear) * l1 - linear) / quadratic\ if\ |linear| &gt; l1\ else\ 0.0$$
                  $$accum = accum_{new}$$
  syntax:
    content: public TensorFlow.TFOutput SparseApplyFtrl (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput lr_power, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: linear
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: lr_power
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyFtrl'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseApplyFtrl*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SparseApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update relevant entries in '*var' according to the Ftrl-proximal scheme.
  remarks: >-
    That is for rows we have grad for, we update var, accum and linear as follows:
                  grad_with_shrinkage = grad + 2 * l2_shrinkage * var
                  accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
                  linear += grad_with_shrinkage +
                  (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
                  quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
                  var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
                  accum = accum_new
  syntax:
    content: public TensorFlow.TFOutput SparseApplyFtrlV2 (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput l2_shrinkage, TensorFlow.TFOutput lr_power, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: linear
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 shrinkage regulariation. Must be a scalar.
    - id: l2_shrinkage
      type: TensorFlow.TFOutput
      description: To be added.
    - id: lr_power
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyFtrlV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseApplyFtrlV2*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: SparseApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update relevant entries in '*var' and '*accum' according to the momentum scheme.
  remarks: "Set use_nesterov = True if you want to use Nesterov momentum.\n              \n              That is for rows we have grad for, we update var and accum as follows:\n              \n              $$accum = accum * momentum + grad$$\n              $$var -= lr * accum$$"
  syntax:
    content: public TensorFlow.TFOutput SparseApplyMomentum (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput momentum, Nullable<bool> use_locking = null, Nullable<bool> use_nesterov = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Learning rate. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: momentum
      type: TensorFlow.TFOutput
      description: Momentum. Must be a scalar.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var and accum tensors will be protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: use_nesterov
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, the tensor passed to compute grad will be
                      var - lr * momentum * accum, so in the end, the var you get is actually
                      var - lr * momentum * accum.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyMomentum'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseApplyMomentum*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SparseApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.
  remarks: >-
    That is for rows we have grad for, we update var and accum as follows:
                  $$accum += grad * grad$$
                  $$prox_v = var$$
                  $$prox_v -= lr * grad * (1 / sqrt(accum))$$
                  $$var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}$$
  syntax:
    content: public TensorFlow.TFOutput SparseApplyProximalAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: accum
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Learning rate. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, updating of the var and accum tensors will be protected by
                      a lock; otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyProximalAdagrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseApplyProximalAdagrad*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SparseApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Sparse update '*var' as FOBOS algorithm with fixed learning rate.
  remarks: >-
    That is for rows we have grad for, we update var as follows:
                  $$prox_v = var - alpha * grad$$
                  $$var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}$$
  syntax:
    content: public TensorFlow.TFOutput SparseApplyProximalGradientDescent (TensorFlow.TFOutput var, TensorFlow.TFOutput alpha, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: alpha
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: l1
      type: TensorFlow.TFOutput
      description: L1 regularization. Must be a scalar.
    - id: l2
      type: TensorFlow.TFOutput
      description: L2 regularization. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var and accum.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the subtraction will be protected by a lock;
                      otherwise the behavior is undefined, but may exhibit less contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyProximalGradientDescent'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseApplyProximalGradientDescent*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SparseApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Update '*var' according to the RMSProp algorithm.
  remarks: "Note that in dense implementation of this algorithm, ms and mom will\n              update even if the grad is zero, but in this sparse implementation, ms\n              and mom will not update in iterations during which the grad is zero.\n              \n              mean_square = decay * mean_square + (1-decay) * gradient ** 2\n              Delta = learning_rate * gradient / sqrt(mean_square + epsilon)\n              \n              $$ms &lt;- rho * ms_{t-1} + (1-rho) * grad * grad$$\n              $$mom &lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)$$\n              $$var &lt;- var - mom$$"
  syntax:
    content: public TensorFlow.TFOutput SparseApplyRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable<bool> use_locking = null, string operName = null);
    parameters:
    - id: var
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: ms
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: mom
      type: TensorFlow.TFOutput
      description: Should be from a Variable().
    - id: lr
      type: TensorFlow.TFOutput
      description: Scaling factor. Must be a scalar.
    - id: rho
      type: TensorFlow.TFOutput
      description: Decay rate. Must be a scalar.
    - id: momentum
      type: TensorFlow.TFOutput
      description: To be added.
    - id: epsilon
      type: TensorFlow.TFOutput
      description: Ridge term. Must be a scalar.
    - id: grad
      type: TensorFlow.TFOutput
      description: The gradient.
    - id: indices
      type: TensorFlow.TFOutput
      description: A vector of indices into the first dimension of var, ms and mom.
    - id: use_locking
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If <code>True</code>, updating of the var, ms, and mom tensors is protected
                      by a lock; otherwise the behavior is undefined, but may exhibit less
                      contention.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseApplyRMSProp'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Same as "var".
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseApplyRMSProp*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseConcat(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.Int64,System.String)
  id: SparseConcat(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseConcat(TFOutput[], TFOutput[], TFOutput[], Int64, String)
  nameWithType: TFGraph.SparseConcat(TFOutput[], TFOutput[], TFOutput[], Int64, String)
  fullName: TFGraph.SparseConcat(TFOutput[], TFOutput[], TFOutput[], Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Concatenates a list of <code>SparseTensor</code> along the specified dimension.
  remarks: "Concatenation is with respect to the dense versions of these sparse tensors.\n              It is assumed that each input is a <code>SparseTensor</code> whose elements are ordered\n              along increasing dimension number.\n              \n              All inputs' shapes must match, except for the concat dimension.  The\n              <code>indices</code>, <code>values</code>, and <code>shapes</code> lists must have the same length.\n              \n              The output shape is identical to the inputs', except along the concat\n              dimension, where it is the sum of the inputs' sizes along that dimension.\n              \n              The output elements will be resorted to preserve the sort order along\n              increasing dimension number.\n              \n              This op runs in <code>O(M log M)</code> time, where <code>M</code> is the total number of non-empty\n              values across all inputs. This is due to the need for an internal sort in\n              order to concatenate efficiently across an arbitrary dimension.\n              \n              For example, if <code>concat_dim = 1</code> and the inputs are\n              \n              sp_inputs[0]: shape = [2, 3]\n              [0, 2]: \"a\"\n              [1, 0]: \"b\"\n              [1, 1]: \"c\"\n              \n              sp_inputs[1]: shape = [2, 4]\n              [0, 1]: \"d\"\n              [0, 2]: \"e\"\n              \n              then the output will be\n              \n              shape = [2, 7]\n              [0, 2]: \"a\"\n              [0, 4]: \"d\"\n              [0, 5]: \"e\"\n              [1, 0]: \"b\"\n              [1, 1]: \"c\"\n              \n              Graphically this is equivalent to doing\n              \n              [    a] concat [  d e  ] = [    a   d e  ]\n              [b c  ]        [       ]   [b c          ]"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> SparseConcat (TensorFlow.TFOutput[] indices, TensorFlow.TFOutput[] values, TensorFlow.TFOutput[] shapes, long concat_dim, string operName = null);
    parameters:
    - id: indices
      type: TensorFlow.TFOutput[]
      description: 2-D.  Indices of each input <code>SparseTensor</code>.
    - id: values
      type: TensorFlow.TFOutput[]
      description: 1-D.  Non-empty values of each <code>SparseTensor</code>.
    - id: shapes
      type: TensorFlow.TFOutput[]
      description: 1-D.  Shapes of each <code>SparseTensor</code>.
    - id: concat_dim
      type: System.Int64
      description: >-
        Dimension to concatenate along. Must be in range [-rank, rank),
                      where rank is the number of dimensions in each input <code>SparseTensor</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseConcat'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_indices: 2-D.  Indices of the concatenated <code>SparseTensor</code>.
                      output_values: 1-D.  Non-empty values of the concatenated <code>SparseTensor</code>.
                      output_shape: 1-D.  Shape of the concatenated <code>SparseTensor</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseConcat*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseConditionalAccumulator(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String,System.String)
  id: SparseConditionalAccumulator(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseConditionalAccumulator(TFDataType, TFShape, String, String, String, String)
  nameWithType: TFGraph.SparseConditionalAccumulator(TFDataType, TFShape, String, String, String, String)
  fullName: TFGraph.SparseConditionalAccumulator(TFDataType, TFShape, String, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A conditional accumulator for aggregating sparse gradients.
  remarks: >-
    The accumulator accepts gradients marked with local_step greater or
                  equal to the most recent global_step known to the accumulator. The
                  average can be extracted from the accumulator, provided sufficient
                  gradients have been accumulated. Extracting the average automatically
                  resets the aggregate to 0, and increments the global_step recorded by
                  the accumulator.
  syntax:
    content: public TensorFlow.TFOutput SparseConditionalAccumulator (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string container = null, string shared_name = null, string reduction_type = null, string operName = null);
    parameters:
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of the value being accumulated.
    - id: shape
      type: TensorFlow.TFShape
      description: The shape of the values.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this accumulator is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this accumulator will be shared under the given name
                      across multiple sessions.
    - id: reduction_type
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseConditionalAccumulator'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to the accumulator.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseConditionalAccumulator*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseCross(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.Boolean,System.Int64,System.Int64,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)
  id: SparseCross(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.Boolean,System.Int64,System.Int64,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseCross(TFOutput[], TFOutput[], TFOutput[], TFOutput[], Boolean, Int64, Int64, TFDataType, TFDataType, String)
  nameWithType: TFGraph.SparseCross(TFOutput[], TFOutput[], TFOutput[], TFOutput[], Boolean, Int64, Int64, TFDataType, TFDataType, String)
  fullName: TFGraph.SparseCross(TFOutput[], TFOutput[], TFOutput[], TFOutput[], Boolean, Int64, Int64, TFDataType, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generates sparse cross from a list of sparse and dense tensors.
  remarks: "The op takes two lists, one of 2D <code>SparseTensor</code> and one of 2D <code>Tensor</code>, each\n              representing features of one feature column. It outputs a 2D <code>SparseTensor</code> with\n              the batchwise crosses of these features.\n              \n              For example, if the inputs are\n              \n              inputs[0]: SparseTensor with shape = [2, 2]\n              [0, 0]: \"a\"\n              [1, 0]: \"b\"\n              [1, 1]: \"c\"\n              \n              inputs[1]: SparseTensor with shape = [2, 1]\n              [0, 0]: \"d\"\n              [1, 0]: \"e\"\n              \n              inputs[2]: Tensor [[\"f\"], [\"g\"]]\n              \n              then the output will be\n              \n              shape = [2, 2]\n              [0, 0]: \"a_X_d_X_f\"\n              [1, 0]: \"b_X_e_X_g\"\n              [1, 1]: \"c_X_e_X_g\"\n              \n              if hashed_output=true then the output will be\n              \n              shape = [2, 2]\n              [0, 0]: FingerprintCat64(\n              Fingerprint64(\"f\"), FingerprintCat64(\n              Fingerprint64(\"d\"), Fingerprint64(\"a\")))\n              [1, 0]: FingerprintCat64(\n              Fingerprint64(\"g\"), FingerprintCat64(\n              Fingerprint64(\"e\"), Fingerprint64(\"b\")))\n              [1, 1]: FingerprintCat64(\n              Fingerprint64(\"g\"), FingerprintCat64(\n              Fingerprint64(\"e\"), Fingerprint64(\"c\")))"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> SparseCross (TensorFlow.TFOutput[] indices, TensorFlow.TFOutput[] values, TensorFlow.TFOutput[] shapes, TensorFlow.TFOutput[] dense_inputs, bool hashed_output, long num_buckets, long hash_key, TensorFlow.TFDataType out_type, TensorFlow.TFDataType internal_type, string operName = null);
    parameters:
    - id: indices
      type: TensorFlow.TFOutput[]
      description: 2-D.  Indices of each input <code>SparseTensor</code>.
    - id: values
      type: TensorFlow.TFOutput[]
      description: 1-D.   values of each <code>SparseTensor</code>.
    - id: shapes
      type: TensorFlow.TFOutput[]
      description: 1-D.   Shapes of each <code>SparseTensor</code>.
    - id: dense_inputs
      type: TensorFlow.TFOutput[]
      description: 2-D.    Columns represented by dense <code>Tensor</code>.
    - id: hashed_output
      type: System.Boolean
      description: >-
        If true, returns the hash of the cross instead of the string.
                      This will allow us avoiding string manipulations.
    - id: num_buckets
      type: System.Int64
      description: >-
        It is used if hashed_output is true.
                      output = hashed_value%num_buckets if num_buckets &gt; 0 else hashed_value.
    - id: hash_key
      type: System.Int64
      description: >-
        Specify the hash_key that will be used by the <code>FingerprintCat64</code>
                      function to combine the crosses fingerprints.
    - id: out_type
      type: TensorFlow.TFDataType
      description: To be added.
    - id: internal_type
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseCross'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_indices: 2-D.  Indices of the concatenated <code>SparseTensor</code>.
                      output_values: 1-D.  Non-empty values of the concatenated or hashed
                      <code>SparseTensor</code>.
                      output_shape: 1-D.  Shape of the concatenated <code>SparseTensor</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseCross*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseDenseCwiseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseDenseCwiseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseDenseCwiseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseDenseCwiseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseDenseCwiseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: 'Adds up a SparseTensor and a dense Tensor, using these special rules:'
  remarks: "(1) Broadcasts the dense side to have the same shape as the sparse side, if\n              eligible;\n              (2) Then, only the dense values pointed to by the indices of the SparseTensor\n              participate in the cwise addition.\n              \n              By these rules, the result is a logical SparseTensor with exactly the same\n              indices and shape, but possibly with different non-zero values.  The output of\n              this Op is the resultant non-zero values."
  syntax:
    content: public TensorFlow.TFOutput SparseDenseCwiseAdd (TensorFlow.TFOutput sp_indices, TensorFlow.TFOutput sp_values, TensorFlow.TFOutput sp_shape, TensorFlow.TFOutput dense, string operName = null);
    parameters:
    - id: sp_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
                      SparseTensor, possibly not in canonical ordering.
    - id: sp_values
      type: TensorFlow.TFOutput
      description: 1-D.  <code>N</code> non-empty values corresponding to <code>sp_indices</code>.
    - id: sp_shape
      type: TensorFlow.TFOutput
      description: 1-D.  Shape of the input SparseTensor.
    - id: dense
      type: TensorFlow.TFOutput
      description: <code>R</code>-D.  The dense Tensor operand.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseDenseCwiseAdd'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        1-D.  The <code>N</code> values that are operated on.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseDenseCwiseAdd*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseDenseCwiseDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseDenseCwiseDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseDenseCwiseDiv(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseDenseCwiseDiv(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseDenseCwiseDiv(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Component-wise divides a SparseTensor by a dense Tensor.
  remarks: >-
    *Limitation*: this Op only broadcasts the dense side to the sparse side, but not
                  the other direction.
  syntax:
    content: public TensorFlow.TFOutput SparseDenseCwiseDiv (TensorFlow.TFOutput sp_indices, TensorFlow.TFOutput sp_values, TensorFlow.TFOutput sp_shape, TensorFlow.TFOutput dense, string operName = null);
    parameters:
    - id: sp_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
                      SparseTensor, possibly not in canonical ordering.
    - id: sp_values
      type: TensorFlow.TFOutput
      description: 1-D.  <code>N</code> non-empty values corresponding to <code>sp_indices</code>.
    - id: sp_shape
      type: TensorFlow.TFOutput
      description: 1-D.  Shape of the input SparseTensor.
    - id: dense
      type: TensorFlow.TFOutput
      description: <code>R</code>-D.  The dense Tensor operand.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseDenseCwiseDiv'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        1-D.  The <code>N</code> values that are operated on.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseDenseCwiseDiv*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseDenseCwiseMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseDenseCwiseMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseDenseCwiseMul(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseDenseCwiseMul(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseDenseCwiseMul(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Component-wise multiplies a SparseTensor by a dense Tensor.
  remarks: "The output locations corresponding to the implicitly zero elements in the sparse\n              tensor will be zero (i.e., will not take up storage space), regardless of the\n              contents of the dense tensor (even if it's +/-INF and that INF*0 == NaN).\n              \n              *Limitation*: this Op only broadcasts the dense side to the sparse side, but not\n              the other direction."
  syntax:
    content: public TensorFlow.TFOutput SparseDenseCwiseMul (TensorFlow.TFOutput sp_indices, TensorFlow.TFOutput sp_values, TensorFlow.TFOutput sp_shape, TensorFlow.TFOutput dense, string operName = null);
    parameters:
    - id: sp_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
                      SparseTensor, possibly not in canonical ordering.
    - id: sp_values
      type: TensorFlow.TFOutput
      description: 1-D.  <code>N</code> non-empty values corresponding to <code>sp_indices</code>.
    - id: sp_shape
      type: TensorFlow.TFOutput
      description: 1-D.  Shape of the input SparseTensor.
    - id: dense
      type: TensorFlow.TFOutput
      description: <code>R</code>-D.  The dense Tensor operand.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseDenseCwiseMul'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        1-D.  The <code>N</code> values that are operated on.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseDenseCwiseMul*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseFillEmptyRows(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseFillEmptyRows(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseFillEmptyRows(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseFillEmptyRows(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseFillEmptyRows(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Fills empty rows in the input 2-D <code>SparseTensor</code> with a default value.
  remarks: "The input <code>SparseTensor</code> is represented via the tuple of inputs\n              (<code>indices</code>, <code>values</code>, <code>dense_shape</code>).  The output <code>SparseTensor</code> has the\n              same <code>dense_shape</code> but with indices <code>output_indices</code> and values\n              <code>output_values</code>.\n              \n              This op inserts a single entry for every row that doesn't have any values.\n              The index is created as <code>[row, 0, ..., 0]</code> and the inserted value\n              is <code>default_value</code>.\n              \n              For example, suppose <code>sp_input</code> has shape <code>[5, 6]</code> and non-empty values:\n              \n              [0, 1]: a\n              [0, 3]: b\n              [2, 0]: c\n              [3, 1]: d\n              \n              Rows 1 and 4 are empty, so the output will be of shape <code>[5, 6]</code> with values:\n              \n              [0, 1]: a\n              [0, 3]: b\n              [1, 0]: default_value\n              [2, 0]: c\n              [3, 1]: d\n              [4, 0]: default_value\n              \n              The output <code>SparseTensor</code> will be in row-major order and will have the\n              same shape as the input.\n              \n              This op also returns an indicator vector shaped <code>[dense_shape[0]]</code> such that\n              \n              empty_row_indicator[i] = True iff row i was an empty row.\n              \n              And a reverse index map vector shaped <code>[indices.shape[0]]</code> that is used during\n              backpropagation,\n              \n              reverse_index_map[j] = out_j s.t. indices[j, :] == output_indices[out_j, :]"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> SparseFillEmptyRows (TensorFlow.TFOutput indices, TensorFlow.TFOutput values, TensorFlow.TFOutput dense_shape, TensorFlow.TFOutput default_value, string operName = null);
    parameters:
    - id: indices
      type: TensorFlow.TFOutput
      description: 2-D. the indices of the sparse tensor.
    - id: values
      type: TensorFlow.TFOutput
      description: 1-D. the values of the sparse tensor.
    - id: dense_shape
      type: TensorFlow.TFOutput
      description: 1-D. the shape of the sparse tensor.
    - id: default_value
      type: TensorFlow.TFOutput
      description: >-
        0-D. default value to insert into location <code>[row, 0, ..., 0]</code>
                      for rows missing from the input sparse tensor.
                      output indices: 2-D. the indices of the filled sparse tensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseFillEmptyRows'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_indices:
                      output_values: 1-D. the values of the filled sparse tensor.
                      empty_row_indicator: 1-D. whether the dense row was missing in the
                      input sparse tensor.
                      reverse_index_map: 1-D. a map from the input indices to the output indices.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseFillEmptyRows*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseFillEmptyRowsGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseFillEmptyRowsGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseFillEmptyRowsGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseFillEmptyRowsGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.SparseFillEmptyRowsGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: The gradient of SparseFillEmptyRows.
  remarks: "Takes vectors reverse_index_map, shaped <code>[N]</code>, and grad_values,\n              shaped <code>[N_full]</code>, where <code>N_full &gt;= N</code> and copies data into either\n              <code>d_values</code> or <code>d_default_value</code>.  Here <code>d_values</code> is shaped <code>[N]</code> and\n              <code>d_default_value</code> is a scalar.\n              \n              d_values[j] = grad_values[reverse_index_map[j]]\n              d_default_value = sum_{k : 0 .. N_full - 1} (\n              grad_values[k] * 1{k not in reverse_index_map})"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> SparseFillEmptyRowsGrad (TensorFlow.TFOutput reverse_index_map, TensorFlow.TFOutput grad_values, string operName = null);
    parameters:
    - id: reverse_index_map
      type: TensorFlow.TFOutput
      description: 1-D.  The reverse index map from SparseFillEmptyRows.
    - id: grad_values
      type: TensorFlow.TFOutput
      description: 1-D.  The gradients from backprop.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseFillEmptyRowsGrad'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      d_values: 1-D.  The backprop into values.
                      d_default_value: 0-D.  The backprop into default_value.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseFillEmptyRowsGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: SparseMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseMatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseMatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.SparseMatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Multiply matrix "a" by matrix "b".
  remarks: "The inputs must be two-dimensional matrices and the inner dimension of \"a\" must\n              match the outer dimension of \"b\". Both \"a\" and \"b\" must be <code>Tensor</code>s not\n              <code>SparseTensor</code>s.  This op is optimized for the case where at least one of \"a\" or\n              \"b\" is sparse, in the sense that they have a large proportion of zero values.\n              The breakeven for using this versus a dense matrix multiply on one platform was\n              30% zero values in the sparse matrix.\n              \n              The gradient computation of this operation will only take advantage of sparsity\n              in the input gradient when that gradient comes from a Relu."
  syntax:
    content: public TensorFlow.TFOutput SparseMatMul (TensorFlow.TFOutput a, TensorFlow.TFOutput b, Nullable<bool> transpose_a = null, Nullable<bool> transpose_b = null, Nullable<bool> a_is_sparse = null, Nullable<bool> b_is_sparse = null, string operName = null);
    parameters:
    - id: a
      type: TensorFlow.TFOutput
      description: To be added.
    - id: b
      type: TensorFlow.TFOutput
      description: To be added.
    - id: transpose_a
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: transpose_b
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: a_is_sparse
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: b_is_sparse
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseMatMul'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseMatMul*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseReduceMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SparseReduceMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseReduceMax(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseReduceMax(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseReduceMax(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the max of elements across dimensions of a SparseTensor.
  remarks: "This Op takes a SparseTensor and is the sparse counterpart to\n              <code>tf.reduce_max()</code>.  In particular, this Op also returns a dense <code>Tensor</code>\n              instead of a sparse one.\n              \n              Reduces <code>sp_input</code> along the dimensions given in <code>reduction_axes</code>.  Unless\n              <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in\n              <code>reduction_axes</code>. If <code>keep_dims</code> is true, the reduced dimensions are retained\n              with length 1.\n              \n              If <code>reduction_axes</code> has no entries, all dimensions are reduced, and a tensor\n              with a single element is returned.  Additionally, the axes can be negative,\n              which are interpreted according to the indexing rules in Python."
  syntax:
    content: public TensorFlow.TFOutput SparseReduceMax (TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_values, TensorFlow.TFOutput input_shape, TensorFlow.TFOutput reduction_axes, Nullable<bool> keep_dims = null, string operName = null);
    parameters:
    - id: input_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
                      SparseTensor, possibly not in canonical ordering.
    - id: input_values
      type: TensorFlow.TFOutput
      description: 1-D.  <code>N</code> non-empty values corresponding to <code>input_indices</code>.
    - id: input_shape
      type: TensorFlow.TFOutput
      description: 1-D.  Shape of the input SparseTensor.
    - id: reduction_axes
      type: TensorFlow.TFOutput
      description: 1-D.  Length-<code>K</code> vector containing the reduction axes.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, retain reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceMax'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        <code>R-K</code>-D.  The reduced Tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseReduceMax*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseReduceMaxSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SparseReduceMaxSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseReduceMaxSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseReduceMaxSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseReduceMaxSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the max of elements across dimensions of a SparseTensor.
  remarks: "This Op takes a SparseTensor and is the sparse counterpart to\n              <code>tf.reduce_max()</code>.  In contrast to SparseReduceMax, this Op returns a\n              SparseTensor.\n              \n              Reduces <code>sp_input</code> along the dimensions given in <code>reduction_axes</code>.  Unless\n              <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in\n              <code>reduction_axes</code>. If <code>keep_dims</code> is true, the reduced dimensions are retained\n              with length 1.\n              \n              If <code>reduction_axes</code> has no entries, all dimensions are reduced, and a tensor\n              with a single element is returned.  Additionally, the axes can be negative,\n              which are interpreted according to the indexing rules in Python."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> SparseReduceMaxSparse (TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_values, TensorFlow.TFOutput input_shape, TensorFlow.TFOutput reduction_axes, Nullable<bool> keep_dims = null, string operName = null);
    parameters:
    - id: input_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
                      SparseTensor, possibly not in canonical ordering.
    - id: input_values
      type: TensorFlow.TFOutput
      description: 1-D.  <code>N</code> non-empty values corresponding to <code>input_indices</code>.
    - id: input_shape
      type: TensorFlow.TFOutput
      description: 1-D.  Shape of the input SparseTensor.
    - id: reduction_axes
      type: TensorFlow.TFOutput
      description: 1-D.  Length-<code>K</code> vector containing the reduction axes.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, retain reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceMaxSparse'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_indices:
                      output_values:
                      output_shape:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseReduceMaxSparse*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseReduceSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SparseReduceSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseReduceSum(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseReduceSum(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseReduceSum(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the sum of elements across dimensions of a SparseTensor.
  remarks: "This Op takes a SparseTensor and is the sparse counterpart to\n              <code>tf.reduce_sum()</code>.  In particular, this Op also returns a dense <code>Tensor</code>\n              instead of a sparse one.\n              \n              Reduces <code>sp_input</code> along the dimensions given in <code>reduction_axes</code>.  Unless\n              <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in\n              <code>reduction_axes</code>. If <code>keep_dims</code> is true, the reduced dimensions are retained\n              with length 1.\n              \n              If <code>reduction_axes</code> has no entries, all dimensions are reduced, and a tensor\n              with a single element is returned.  Additionally, the axes can be negative,\n              which are interpreted according to the indexing rules in Python."
  syntax:
    content: public TensorFlow.TFOutput SparseReduceSum (TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_values, TensorFlow.TFOutput input_shape, TensorFlow.TFOutput reduction_axes, Nullable<bool> keep_dims = null, string operName = null);
    parameters:
    - id: input_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
                      SparseTensor, possibly not in canonical ordering.
    - id: input_values
      type: TensorFlow.TFOutput
      description: 1-D.  <code>N</code> non-empty values corresponding to <code>input_indices</code>.
    - id: input_shape
      type: TensorFlow.TFOutput
      description: 1-D.  Shape of the input SparseTensor.
    - id: reduction_axes
      type: TensorFlow.TFOutput
      description: 1-D.  Length-<code>K</code> vector containing the reduction axes.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, retain reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceSum'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        <code>R-K</code>-D.  The reduced Tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseReduceSum*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseReduceSumSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SparseReduceSumSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseReduceSumSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseReduceSumSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseReduceSumSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the sum of elements across dimensions of a SparseTensor.
  remarks: "This Op takes a SparseTensor and is the sparse counterpart to\n              <code>tf.reduce_sum()</code>.  In contrast to SparseReduceSum, this Op returns a\n              SparseTensor.\n              \n              Reduces <code>sp_input</code> along the dimensions given in <code>reduction_axes</code>.  Unless\n              <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in\n              <code>reduction_axes</code>. If <code>keep_dims</code> is true, the reduced dimensions are retained\n              with length 1.\n              \n              If <code>reduction_axes</code> has no entries, all dimensions are reduced, and a tensor\n              with a single element is returned.  Additionally, the axes can be negative,\n              which are interpreted according to the indexing rules in Python."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> SparseReduceSumSparse (TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_values, TensorFlow.TFOutput input_shape, TensorFlow.TFOutput reduction_axes, Nullable<bool> keep_dims = null, string operName = null);
    parameters:
    - id: input_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
                      SparseTensor, possibly not in canonical ordering.
    - id: input_values
      type: TensorFlow.TFOutput
      description: 1-D.  <code>N</code> non-empty values corresponding to <code>input_indices</code>.
    - id: input_shape
      type: TensorFlow.TFOutput
      description: 1-D.  Shape of the input SparseTensor.
    - id: reduction_axes
      type: TensorFlow.TFOutput
      description: 1-D.  Length-<code>K</code> vector containing the reduction axes.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, retain reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReduceSumSparse'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_indices:
                      output_values:
                      output_shape:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseReduceSumSparse*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseReorder(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseReorder(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseReorder(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseReorder(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseReorder(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reorders a SparseTensor into the canonical, row-major ordering.
  remarks: "Note that by convention, all sparse ops preserve the canonical ordering along\n              increasing dimension number. The only time ordering can be violated is during\n              manual manipulation of the indices and values vectors to add entries.\n              \n              Reordering does not affect the shape of the SparseTensor.\n              \n              If the tensor has rank <code>R</code> and <code>N</code> non-empty values, <code>input_indices</code> has\n              shape <code>[N, R]</code>, input_values has length <code>N</code>, and input_shape has length <code>R</code>."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> SparseReorder (TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_values, TensorFlow.TFOutput input_shape, string operName = null);
    parameters:
    - id: input_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
                      SparseTensor, possibly not in canonical ordering.
    - id: input_values
      type: TensorFlow.TFOutput
      description: 1-D.  <code>N</code> non-empty values corresponding to <code>input_indices</code>.
    - id: input_shape
      type: TensorFlow.TFOutput
      description: 1-D.  Shape of the input SparseTensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReorder'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_indices: 2-D.  <code>N x R</code> matrix with the same indices as input_indices, but
                      in canonical row-major ordering.
                      output_values: 1-D.  <code>N</code> non-empty values corresponding to <code>output_indices</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseReorder*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseReshape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseReshape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseReshape(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseReshape(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseReshape(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reshapes a SparseTensor to represent values in a new dense shape.
  remarks: "This operation has the same semantics as reshape on the represented dense\n              tensor.  The <code>input_indices</code> are recomputed based on the requested <code>new_shape</code>.\n              \n              If one component of <code>new_shape</code> is the special value -1, the size of that\n              dimension is computed so that the total dense size remains constant.  At\n              most one component of <code>new_shape</code> can be -1.  The number of dense elements\n              implied by <code>new_shape</code> must be the same as the number of dense elements\n              originally implied by <code>input_shape</code>.\n              \n              Reshaping does not affect the order of values in the SparseTensor.\n              \n              If the input tensor has rank <code>R_in</code> and <code>N</code> non-empty values, and <code>new_shape</code>\n              has length <code>R_out</code>, then <code>input_indices</code> has shape <code>[N, R_in]</code>,\n              <code>input_shape</code> has length <code>R_in</code>, <code>output_indices</code> has shape <code>[N, R_out]</code>, and\n              <code>output_shape</code> has length <code>R_out</code>."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> SparseReshape (TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_shape, TensorFlow.TFOutput new_shape, string operName = null);
    parameters:
    - id: input_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  <code>N x R_in</code> matrix with the indices of non-empty values in a
                      SparseTensor.
    - id: input_shape
      type: TensorFlow.TFOutput
      description: 1-D.  <code>R_in</code> vector with the input SparseTensor's dense shape.
    - id: new_shape
      type: TensorFlow.TFOutput
      description: 1-D.  <code>R_out</code> vector with the requested new dense shape.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseReshape'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_indices: 2-D.  <code>N x R_out</code> matrix with the updated indices of non-empty
                      values in the output SparseTensor.
                      output_shape: 1-D.  <code>R_out</code> vector with the full dense shape of the output
                      SparseTensor.  This is the same as <code>new_shape</code> but with any -1 dimensions
                      filled in.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseReshape*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSegmentMean(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSegmentMean(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSegmentMean(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentMean(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentMean(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the mean along sparse segments of a tensor.
  remarks: "Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\n              for an explanation of segments.\n              \n              Like <code>SegmentMean</code>, but <code>segment_ids</code> can have rank less than <code>data</code>'s first\n              dimension, selecting a subset of dimension 0, specified by <code>indices</code>."
  syntax:
    content: public TensorFlow.TFOutput SparseSegmentMean (TensorFlow.TFOutput data, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: A 1-D tensor. Has same rank as <code>segment_ids</code>.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: A 1-D tensor. Values should be sorted and can be repeated.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentMean'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for dimension 0 which
                      has size <code>k</code>, the number of segments.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseSegmentMean*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSegmentMeanGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSegmentMeanGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSegmentMeanGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentMeanGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentMeanGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes gradients for SparseSegmentMean.
  remarks: >-
    Returns tensor "output" with same shape as grad, except for dimension 0 whose
                  value is output_dim0.
  syntax:
    content: public TensorFlow.TFOutput SparseSegmentMeanGrad (TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput output_dim0, string operName = null);
    parameters:
    - id: grad
      type: TensorFlow.TFOutput
      description: gradient propagated to the SparseSegmentMean op.
    - id: indices
      type: TensorFlow.TFOutput
      description: indices passed to the corresponding SparseSegmentMean op.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: segment_ids passed to the corresponding SparseSegmentMean op.
    - id: output_dim0
      type: TensorFlow.TFOutput
      description: dimension 0 of "data" passed to SparseSegmentMean op.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentMeanGrad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseSegmentMeanGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSegmentMeanWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSegmentMeanWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSegmentMeanWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentMeanWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentMeanWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the mean along sparse segments of a tensor.
  remarks: "Like <code>SparseSegmentMean</code>, but allows missing ids in <code>segment_ids</code>. If an id is\n              misisng, the <code>output</code> tensor at that position will be zeroed.\n              \n              Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\n              for an explanation of segments."
  syntax:
    content: public TensorFlow.TFOutput SparseSegmentMeanWithNumSegments (TensorFlow.TFOutput data, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: A 1-D tensor. Has same rank as <code>segment_ids</code>.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: A 1-D tensor. Values should be sorted and can be repeated.
    - id: num_segments
      type: TensorFlow.TFOutput
      description: Should equal the number of distinct segment IDs.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentMeanWithNumSegments'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for dimension 0 which has size
                      <code>num_segments</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseSegmentMeanWithNumSegments*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSegmentSqrtN(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSegmentSqrtN(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSegmentSqrtN(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentSqrtN(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentSqrtN(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the sum along sparse segments of a tensor divided by the sqrt of N.
  remarks: "N is the size of the segment being reduced.\n              \n              Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\n              for an explanation of segments."
  syntax:
    content: public TensorFlow.TFOutput SparseSegmentSqrtN (TensorFlow.TFOutput data, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: A 1-D tensor. Has same rank as <code>segment_ids</code>.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: A 1-D tensor. Values should be sorted and can be repeated.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSqrtN'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for dimension 0 which
                      has size <code>k</code>, the number of segments.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseSegmentSqrtN*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSegmentSqrtNGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSegmentSqrtNGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSegmentSqrtNGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentSqrtNGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentSqrtNGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes gradients for SparseSegmentSqrtN.
  remarks: >-
    Returns tensor "output" with same shape as grad, except for dimension 0 whose
                  value is output_dim0.
  syntax:
    content: public TensorFlow.TFOutput SparseSegmentSqrtNGrad (TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput output_dim0, string operName = null);
    parameters:
    - id: grad
      type: TensorFlow.TFOutput
      description: gradient propagated to the SparseSegmentSqrtN op.
    - id: indices
      type: TensorFlow.TFOutput
      description: indices passed to the corresponding SparseSegmentSqrtN op.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: segment_ids passed to the corresponding SparseSegmentSqrtN op.
    - id: output_dim0
      type: TensorFlow.TFOutput
      description: dimension 0 of "data" passed to SparseSegmentSqrtN op.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSqrtNGrad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseSegmentSqrtNGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSegmentSqrtNWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSegmentSqrtNWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSegmentSqrtNWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentSqrtNWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentSqrtNWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the sum along sparse segments of a tensor divided by the sqrt of N.
  remarks: "N is the size of the segment being reduced.\n              \n              Like <code>SparseSegmentSqrtN</code>, but allows missing ids in <code>segment_ids</code>. If an id is\n              misisng, the <code>output</code> tensor at that position will be zeroed.\n              \n              Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\n              for an explanation of segments."
  syntax:
    content: public TensorFlow.TFOutput SparseSegmentSqrtNWithNumSegments (TensorFlow.TFOutput data, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: A 1-D tensor. Has same rank as <code>segment_ids</code>.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: A 1-D tensor. Values should be sorted and can be repeated.
    - id: num_segments
      type: TensorFlow.TFOutput
      description: Should equal the number of distinct segment IDs.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSqrtNWithNumSegments'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for dimension 0 which
                      has size <code>k</code>, the number of segments.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseSegmentSqrtNWithNumSegments*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSegmentSum(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentSum(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentSum(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the sum along sparse segments of a tensor.
  remarks: "Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\n              for an explanation of segments.\n              \n              Like <code>SegmentSum</code>, but <code>segment_ids</code> can have rank less than <code>data</code>'s first\n              dimension, selecting a subset of dimension 0, specified by <code>indices</code>.\n              \n              For example:\n              \n               <pre><code>\n              c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])\n              \n              # Select two rows, one segment.\n              tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))\n              # =&gt; [[0 0 0 0]]\n              \n              # Select two rows, two segment.\n              tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))\n              # =&gt; [[ 1  2  3  4]\n              #     [-1 -2 -3 -4]]\n              \n              # Select all rows, two segments.\n              tf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))\n              # =&gt; [[0 0 0 0]\n              #     [5 6 7 8]]\n              \n              # Which is equivalent to:\n              tf.segment_sum(c, tf.constant([0, 0, 1]))\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput SparseSegmentSum (TensorFlow.TFOutput data, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: A 1-D tensor. Has same rank as <code>segment_ids</code>.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: A 1-D tensor. Values should be sorted and can be repeated.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSum'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for dimension 0 which
                      has size <code>k</code>, the number of segments.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseSegmentSum*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSegmentSumWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSegmentSumWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSegmentSumWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentSumWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentSumWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the sum along sparse segments of a tensor.
  remarks: "Like <code>SparseSegmentSum</code>, but allows missing ids in <code>segment_ids</code>. If an id is\n              misisng, the <code>output</code> tensor at that position will be zeroed.\n              \n              Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\n              for an explanation of segments.\n              \n              For example:\n              \n               <pre><code>\n              c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])\n              \n              tf.sparse_segment_sum_with_num_segments(\n              c, tf.constant([0, 1]), tf.constant([0, 0]), num_segments=3)\n              # =&gt; [[0 0 0 0]\n              #     [0 0 0 0]\n              #     [0 0 0 0]]\n              \n              tf.sparse_segment_sum_with_num_segments(c,\n              tf.constant([0, 1]),\n              tf.constant([0, 2],\n              num_segments=4))\n              # =&gt; [[ 1  2  3  4]\n              #     [ 0  0  0  0]\n              #     [-1 -2 -3 -4]\n              #     [ 0  0  0  0]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput SparseSegmentSumWithNumSegments (TensorFlow.TFOutput data, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: A 1-D tensor. Has same rank as <code>segment_ids</code>.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: A 1-D tensor. Values should be sorted and can be repeated.
    - id: num_segments
      type: TensorFlow.TFOutput
      description: Should equal the number of distinct segment IDs.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSegmentSumWithNumSegments'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for dimension 0 which
                      has size <code>num_segments</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseSegmentSumWithNumSegments*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSlice(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSlice(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSlice(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Slice a <code>SparseTensor</code> based on the <code>start</code> and <code>size</code>.
  remarks: "For example, if the input is\n              \n              input_tensor = shape = [2, 7]\n              [    a   d e  ]\n              [b c          ]\n              \n              Graphically the output tensors are:\n              \n              sparse_slice([0, 0], [2, 4]) = shape = [2, 4]\n              [    a  ]\n              [b c    ]\n              \n              sparse_slice([0, 4], [2, 3]) = shape = [2, 3]\n              [ d e  ]\n              [      ]"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> SparseSlice (TensorFlow.TFOutput indices, TensorFlow.TFOutput values, TensorFlow.TFOutput shape, TensorFlow.TFOutput start, TensorFlow.TFOutput size, string operName = null);
    parameters:
    - id: indices
      type: TensorFlow.TFOutput
      description: 2-D tensor represents the indices of the sparse tensor.
    - id: values
      type: TensorFlow.TFOutput
      description: 1-D tensor represents the values of the sparse tensor.
    - id: shape
      type: TensorFlow.TFOutput
      description: 1-D. tensor represents the shape of the sparse tensor.
    - id: start
      type: TensorFlow.TFOutput
      description: 1-D. tensor represents the start of the slice.
    - id: size
      type: TensorFlow.TFOutput
      description: >-
        1-D. tensor represents the size of the slice.
                      output indices: A list of 1-D tensors represents the indices of the output
                      sparse tensors.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSlice'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_indices:
                      output_values: A list of 1-D tensors represents the values of the output sparse
                      tensors.
                      output_shape: A list of 1-D tensors represents the shape of the output sparse
                      tensors.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseSlice*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSliceGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSliceGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: The gradient operator for the SparseSlice op.
  remarks: >-
    This op takes in the upstream gradient w.r.t. non-empty values of
                  the sliced <code>SparseTensor</code>, and outputs the gradients w.r.t.
                  the non-empty values of input <code>SparseTensor</code>.
  syntax:
    content: public TensorFlow.TFOutput SparseSliceGrad (TensorFlow.TFOutput backprop_val_grad, TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_start, TensorFlow.TFOutput output_indices, string operName = null);
    parameters:
    - id: backprop_val_grad
      type: TensorFlow.TFOutput
      description: >-
        1-D. The gradient with respect to
                      the non-empty values of the sliced <code>SparseTensor</code>.
    - id: input_indices
      type: TensorFlow.TFOutput
      description: 2-D.  The <code>indices</code> of the input <code>SparseTensor</code>.
    - id: input_start
      type: TensorFlow.TFOutput
      description: 1-D. tensor represents the start of the slice.
    - id: output_indices
      type: TensorFlow.TFOutput
      description: 2-D.  The <code>indices</code> of the sliced <code>SparseTensor</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSliceGrad'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        1-D. The gradient with respect to the non-empty values of input <code>SparseTensor</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseSliceGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSoftmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSoftmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSoftmax(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSoftmax(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSoftmax(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies softmax to a batched N-D <code>SparseTensor</code>.
  remarks: "The inputs represent an N-D SparseTensor  with logical shape <code>[..., B, C]</code>\n              (where <code>N &gt;= 2</code>), and with indices sorted in the canonical lexicographic order.\n              \n              This op is equivalent to applying the normal <code>tf.nn.softmax()</code> to each innermost\n              logical submatrix with shape <code>[B, C]</code>, but with the catch that *the implicitly\n              zero elements do not participate*.  Specifically, the algorithm is equivalent\n              to the following:\n              \n              (1) Applies <code>tf.nn.softmax()</code> to a densified view of each innermost submatrix\n              with shape <code>[B, C]</code>, along the size-C dimension;\n              (2) Masks out the original implicitly-zero locations;\n              (3) Renormalizes the remaining elements.\n              \n              Hence, the <code>SparseTensor</code> result has exactly the same non-zero indices and\n              shape."
  syntax:
    content: public TensorFlow.TFOutput SparseSoftmax (TensorFlow.TFOutput sp_indices, TensorFlow.TFOutput sp_values, TensorFlow.TFOutput sp_shape, string operName = null);
    parameters:
    - id: sp_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  <code>NNZ x R</code> matrix with the indices of non-empty values in a
                      SparseTensor, in canonical ordering.
    - id: sp_values
      type: TensorFlow.TFOutput
      description: 1-D.  <code>NNZ</code> non-empty values corresponding to <code>sp_indices</code>.
    - id: sp_shape
      type: TensorFlow.TFOutput
      description: 1-D.  Shape of the input SparseTensor.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSoftmax'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        1-D.  The <code>NNZ</code> values for the result <code>SparseTensor</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseSoftmax*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSoftmaxCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSoftmaxCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes softmax cross entropy cost and gradients to backpropagate.
  remarks: "Unlike <code>SoftmaxCrossEntropyWithLogits</code>, this operation does not accept\n              a matrix of label probabilities, but rather a single label per row\n              of features.  This label is considered to have probability 1.0 for the\n              given row.\n              \n              Inputs are the logits, not probabilities."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> SparseSoftmaxCrossEntropyWithLogits (TensorFlow.TFOutput features, TensorFlow.TFOutput labels, string operName = null);
    parameters:
    - id: features
      type: TensorFlow.TFOutput
      description: batch_size x num_classes matrix
    - id: labels
      type: TensorFlow.TFOutput
      description: >-
        batch_size vector with values in [0, num_classes).
                      This is the label for the given minibatch entry.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSoftmaxCrossEntropyWithLogits'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      loss: Per example loss (batch_size vector).
                      backprop: backpropagated gradients (batch_size x num_classes matrix).
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseSoftmaxCrossEntropyWithLogits*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSparseMaximum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSparseMaximum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSparseMaximum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSparseMaximum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSparseMaximum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the element-wise max of two SparseTensors.
  remarks: Assumes the two SparseTensors have the same shape, i.e., no broadcasting.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> SparseSparseMaximum (TensorFlow.TFOutput a_indices, TensorFlow.TFOutput a_values, TensorFlow.TFOutput a_shape, TensorFlow.TFOutput b_indices, TensorFlow.TFOutput b_values, TensorFlow.TFOutput b_shape, string operName = null);
    parameters:
    - id: a_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
                      SparseTensor, in the canonical lexicographic ordering.
    - id: a_values
      type: TensorFlow.TFOutput
      description: 1-D.  <code>N</code> non-empty values corresponding to <code>a_indices</code>.
    - id: a_shape
      type: TensorFlow.TFOutput
      description: 1-D.  Shape of the input SparseTensor.
    - id: b_indices
      type: TensorFlow.TFOutput
      description: counterpart to <code>a_indices</code> for the other operand.
    - id: b_values
      type: TensorFlow.TFOutput
      description: counterpart to <code>a_values</code> for the other operand; must be of the same dtype.
    - id: b_shape
      type: TensorFlow.TFOutput
      description: counterpart to <code>a_shape</code> for the other operand; the two shapes must be equal.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSparseMaximum'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_indices: 2-D.  The indices of the output SparseTensor.
                      output_values: 1-D.  The values of the output SparseTensor.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseSparseMaximum*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSparseMinimum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseSparseMinimum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSparseMinimum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSparseMinimum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSparseMinimum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the element-wise min of two SparseTensors.
  remarks: Assumes the two SparseTensors have the same shape, i.e., no broadcasting.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> SparseSparseMinimum (TensorFlow.TFOutput a_indices, TensorFlow.TFOutput a_values, TensorFlow.TFOutput a_shape, TensorFlow.TFOutput b_indices, TensorFlow.TFOutput b_values, TensorFlow.TFOutput b_shape, string operName = null);
    parameters:
    - id: a_indices
      type: TensorFlow.TFOutput
      description: >-
        2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
                      SparseTensor, in the canonical lexicographic ordering.
    - id: a_values
      type: TensorFlow.TFOutput
      description: 1-D.  <code>N</code> non-empty values corresponding to <code>a_indices</code>.
    - id: a_shape
      type: TensorFlow.TFOutput
      description: 1-D.  Shape of the input SparseTensor.
    - id: b_indices
      type: TensorFlow.TFOutput
      description: counterpart to <code>a_indices</code> for the other operand.
    - id: b_values
      type: TensorFlow.TFOutput
      description: counterpart to <code>a_values</code> for the other operand; must be of the same dtype.
    - id: b_shape
      type: TensorFlow.TFOutput
      description: counterpart to <code>a_shape</code> for the other operand; the two shapes must be equal.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSparseMinimum'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_indices: 2-D.  The indices of the output SparseTensor.
                      output_values: 1-D.  The values of the output SparseTensor.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseSparseMinimum*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseSplit(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  id: SparseSplit(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseSplit(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.SparseSplit(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.SparseSplit(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Split a <code>SparseTensor</code> into <code>num_split</code> tensors along one dimension.
  remarks: "If the <code>shape[split_dim]</code> is not an integer multiple of <code>num_split</code>. Slices\n              <code>[0 : shape[split_dim] % num_split]</code> gets one extra dimension.\n              For example, if <code>split_dim = 1</code> and <code>num_split = 2</code> and the input is\n              \n              input_tensor = shape = [2, 7]\n              [    a   d e  ]\n              [b c          ]\n              \n              Graphically the output tensors are:\n              \n              output_tensor[0] = shape = [2, 4]\n              [    a  ]\n              [b c    ]\n              \n              output_tensor[1] = shape = [2, 3]\n              [ d e  ]\n              [      ]"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]> SparseSplit (TensorFlow.TFOutput split_dim, TensorFlow.TFOutput indices, TensorFlow.TFOutput values, TensorFlow.TFOutput shape, long num_split, string operName = null);
    parameters:
    - id: split_dim
      type: TensorFlow.TFOutput
      description: >-
        0-D.  The dimension along which to split.  Must be in the range
                      <code>[0, rank(shape))</code>.
    - id: indices
      type: TensorFlow.TFOutput
      description: 2-D tensor represents the indices of the sparse tensor.
    - id: values
      type: TensorFlow.TFOutput
      description: 1-D tensor represents the values of the sparse tensor.
    - id: shape
      type: TensorFlow.TFOutput
      description: >-
        1-D. tensor represents the shape of the sparse tensor.
                      output indices: A list of 1-D tensors represents the indices of the output
                      sparse tensors.
    - id: num_split
      type: System.Int64
      description: The number of ways to split.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseSplit'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_indices:
                      output_values: A list of 1-D tensors represents the values of the output sparse
                      tensors.
                      output_shape: A list of 1-D tensors represents the shape of the output sparse
                      tensors.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseSplit*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseTensorDenseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseTensorDenseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseTensorDenseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseTensorDenseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseTensorDenseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Adds up a <code>SparseTensor</code> and a dense <code>Tensor</code>, producing a dense <code>Tensor</code>.
  remarks: This Op does not require <code>a_indices</code> be sorted in standard lexicographic order.
  syntax:
    content: public TensorFlow.TFOutput SparseTensorDenseAdd (TensorFlow.TFOutput a_indices, TensorFlow.TFOutput a_values, TensorFlow.TFOutput a_shape, TensorFlow.TFOutput b, string operName = null);
    parameters:
    - id: a_indices
      type: TensorFlow.TFOutput
      description: 2-D.  The <code>indices</code> of the <code>SparseTensor</code>, with shape <code>[nnz, ndims]</code>.
    - id: a_values
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>values</code> of the <code>SparseTensor</code>, with shape <code>[nnz]</code>.
    - id: a_shape
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>shape</code> of the <code>SparseTensor</code>, with shape <code>[ndims]</code>.
    - id: b
      type: TensorFlow.TFOutput
      description: <code>ndims</code>-D Tensor.  With shape <code>a_shape</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseTensorDenseAdd'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseTensorDenseAdd*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseTensorDenseMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: SparseTensorDenseMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseTensorDenseMatMul(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseTensorDenseMatMul(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.SparseTensorDenseMatMul(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Multiply SparseTensor (of rank 2) "A" by dense matrix "B".
  remarks: "No validity checking is performed on the indices of A.  However, the following\n              input format is recommended for optimal behavior:\n              \n              if adjoint_a == false:\n              A should be sorted in lexicographically increasing order.  Use SparseReorder\n              if you're not sure.\n              if adjoint_a == true:\n              A should be sorted in order of increasing dimension 1 (i.e., \"column major\"\n              order instead of \"row major\" order)."
  syntax:
    content: public TensorFlow.TFOutput SparseTensorDenseMatMul (TensorFlow.TFOutput a_indices, TensorFlow.TFOutput a_values, TensorFlow.TFOutput a_shape, TensorFlow.TFOutput b, Nullable<bool> adjoint_a = null, Nullable<bool> adjoint_b = null, string operName = null);
    parameters:
    - id: a_indices
      type: TensorFlow.TFOutput
      description: 2-D.  The <code>indices</code> of the <code>SparseTensor</code>, size <code>[nnz, 2]</code> Matrix.
    - id: a_values
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>values</code> of the <code>SparseTensor</code>, size <code>[nnz]</code> Vector.
    - id: a_shape
      type: TensorFlow.TFOutput
      description: 1-D.  The <code>shape</code> of the <code>SparseTensor</code>, size <code>[2]</code> Vector.
    - id: b
      type: TensorFlow.TFOutput
      description: 2-D.  A dense Matrix.
    - id: adjoint_a
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Use the adjoint of A in the matrix multiply.  If A is complex, this
                      is transpose(conj(A)).  Otherwise it's transpose(A).
    - id: adjoint_b
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Use the adjoint of B in the matrix multiply.  If B is complex, this
                      is transpose(conj(B)).  Otherwise it's transpose(B).
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseTensorDenseMatMul'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseTensorDenseMatMul*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseTensorSliceDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SparseTensorSliceDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseTensorSliceDataset(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseTensorSliceDataset(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseTensorSliceDataset(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that splits a SparseTensor into elements row-wise.
  syntax:
    content: public TensorFlow.TFOutput SparseTensorSliceDataset (TensorFlow.TFOutput indices, TensorFlow.TFOutput values, TensorFlow.TFOutput dense_shape, string operName = null);
    parameters:
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: values
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dense_shape
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseTensorSliceDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseTensorSliceDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseToDense(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: SparseToDense(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseToDense(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseToDense(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseToDense(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts a sparse representation into a dense tensor.
  remarks: "Builds an array <code>dense</code> with shape <code>output_shape</code> such that\n              \n               <pre><code>\n              # If sparse_indices is scalar\n              dense[i] = (i == sparse_indices ? sparse_values : default_value)\n              \n              # If sparse_indices is a vector, then for each i\n              dense[sparse_indices[i]] = sparse_values[i]\n              \n              # If sparse_indices is an n by d matrix, then for each i in [0, n)\n              dense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]\n               </code></pre>\n              \n              All other values in <code>dense</code> are set to <code>default_value</code>.  If <code>sparse_values</code> is a\n              scalar, all sparse indices are set to this single value.\n              \n              Indices should be sorted in lexicographic order, and indices must not\n              contain any repeats. If <code>validate_indices</code> is true, these properties\n              are checked during execution."
  syntax:
    content: public TensorFlow.TFOutput SparseToDense (TensorFlow.TFOutput sparse_indices, TensorFlow.TFOutput output_shape, TensorFlow.TFOutput sparse_values, TensorFlow.TFOutput default_value, Nullable<bool> validate_indices = null, string operName = null);
    parameters:
    - id: sparse_indices
      type: TensorFlow.TFOutput
      description: >-
        0-D, 1-D, or 2-D.  <code>sparse_indices[i]</code> contains the complete
                      index where <code>sparse_values[i]</code> will be placed.
    - id: output_shape
      type: TensorFlow.TFOutput
      description: 1-D.  Shape of the dense output tensor.
    - id: sparse_values
      type: TensorFlow.TFOutput
      description: >-
        1-D.  Values corresponding to each row of <code>sparse_indices</code>,
                      or a scalar value to be used for all sparse indices.
    - id: default_value
      type: TensorFlow.TFOutput
      description: >-
        Scalar value to set for indices not specified in
                      <code>sparse_indices</code>.
    - id: validate_indices
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, indices are checked to make sure they are sorted in
                      lexicographic order and that there are no repeats.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseToDense'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Dense output tensor of shape <code>output_shape</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SparseToDense*
  exceptions: []
- uid: TensorFlow.TFGraph.SparseToSparseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)
  id: SparseToSparseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SparseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, String)
  fullName: TFGraph.SparseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies set operation along last dimension of 2 <code>SparseTensor</code> inputs.
  remarks: "See SetOperationOp::SetOperationFromContext for values of <code>set_operation</code>.\n              \n              If <code>validate_indices</code> is <code>True</code>, <code>SparseToSparseSetOperation</code> validates the\n              order and range of <code>set1</code> and <code>set2</code> indices.\n              \n              Input <code>set1</code> is a <code>SparseTensor</code> represented by <code>set1_indices</code>, <code>set1_values</code>,\n              and <code>set1_shape</code>. For <code>set1</code> ranked <code>n</code>, 1st <code>n-1</code> dimensions must be the same\n              as <code>set2</code>. Dimension <code>n</code> contains values in a set, duplicates are allowed but\n              ignored.\n              \n              Input <code>set2</code> is a <code>SparseTensor</code> represented by <code>set2_indices</code>, <code>set2_values</code>,\n              and <code>set2_shape</code>. For <code>set2</code> ranked <code>n</code>, 1st <code>n-1</code> dimensions must be the same\n              as <code>set1</code>. Dimension <code>n</code> contains values in a set, duplicates are allowed but\n              ignored.\n              \n              If <code>validate_indices</code> is <code>True</code>, this op validates the order and range of <code>set1</code>\n              and <code>set2</code> indices.\n              \n              Output <code>result</code> is a <code>SparseTensor</code> represented by <code>result_indices</code>,\n              <code>result_values</code>, and <code>result_shape</code>. For <code>set1</code> and <code>set2</code> ranked <code>n</code>, this\n              has rank <code>n</code> and the same 1st <code>n-1</code> dimensions as <code>set1</code> and <code>set2</code>. The <code>nth</code>\n              dimension contains the result of <code>set_operation</code> applied to the corresponding\n              <code>[0...n-1]</code> dimension of <code>set</code>."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> SparseToSparseSetOperation (TensorFlow.TFOutput set1_indices, TensorFlow.TFOutput set1_values, TensorFlow.TFOutput set1_shape, TensorFlow.TFOutput set2_indices, TensorFlow.TFOutput set2_values, TensorFlow.TFOutput set2_shape, string set_operation, Nullable<bool> validate_indices = null, string operName = null);
    parameters:
    - id: set1_indices
      type: TensorFlow.TFOutput
      description: >-
        2D <code>Tensor</code>, indices of a <code>SparseTensor</code>. Must be in row-major
                      order.
    - id: set1_values
      type: TensorFlow.TFOutput
      description: >-
        1D <code>Tensor</code>, values of a <code>SparseTensor</code>. Must be in row-major
                      order.
    - id: set1_shape
      type: TensorFlow.TFOutput
      description: >-
        1D <code>Tensor</code>, shape of a <code>SparseTensor</code>. <code>set1_shape[0...n-1]</code> must
                      be the same as <code>set2_shape[0...n-1]</code>, <code>set1_shape[n]</code> is the
                      max set size across <code>0...n-1</code> dimensions.
    - id: set2_indices
      type: TensorFlow.TFOutput
      description: >-
        2D <code>Tensor</code>, indices of a <code>SparseTensor</code>. Must be in row-major
                      order.
    - id: set2_values
      type: TensorFlow.TFOutput
      description: >-
        1D <code>Tensor</code>, values of a <code>SparseTensor</code>. Must be in row-major
                      order.
    - id: set2_shape
      type: TensorFlow.TFOutput
      description: >-
        1D <code>Tensor</code>, shape of a <code>SparseTensor</code>. <code>set2_shape[0...n-1]</code> must
                      be the same as <code>set1_shape[0...n-1]</code>, <code>set2_shape[n]</code> is the
                      max set size across <code>0...n-1</code> dimensions.
    - id: set_operation
      type: System.String
      description: To be added.
    - id: validate_indices
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SparseToSparseSetOperation'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      result_indices: 2D indices of a <code>SparseTensor</code>.
                      result_values: 1D values of a <code>SparseTensor</code>.
                      result_shape: 1D <code>Tensor</code> shape of a <code>SparseTensor</code>. <code>result_shape[0...n-1]</code> is
                      the same as the 1st <code>n-1</code> dimensions of <code>set1</code> and <code>set2</code>, <code>result_shape[n]</code>
                      is the max result set size across all <code>0...n-1</code> dimensions.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.SparseToSparseSetOperation*
  exceptions: []
- uid: TensorFlow.TFGraph.Split(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  id: Split(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Split(TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.Split(TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.Split(TFOutput, TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Splits a tensor into <code>num_split</code> tensors along one dimension.
  syntax:
    content: public TensorFlow.TFOutput[] Split (TensorFlow.TFOutput split_dim, TensorFlow.TFOutput value, long num_split, string operName = null);
    parameters:
    - id: split_dim
      type: TensorFlow.TFOutput
      description: >-
        0-D.  The dimension along which to split.  Must be in the range
                      <code>[-rank(value), rank(value))</code>.
    - id: value
      type: TensorFlow.TFOutput
      description: The tensor to split.
    - id: num_split
      type: System.Int64
      description: >-
        The number of ways to split.  Must evenly divide
                      <code>value.shape[split_dim]</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Split'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        They are identically shaped tensors, whose shape matches that of <code>value</code>
                      except along <code>axis</code>, where their sizes are
                      <code>values.shape[split_dim] / num_split</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Split*
  exceptions: []
- uid: TensorFlow.TFGraph.SplitV(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  id: SplitV(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SplitV(TFOutput, TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.SplitV(TFOutput, TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.SplitV(TFOutput, TFOutput, TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Splits a tensor into <code>num_split</code> tensors along one dimension.
  syntax:
    content: public TensorFlow.TFOutput[] SplitV (TensorFlow.TFOutput value, TensorFlow.TFOutput size_splits, TensorFlow.TFOutput split_dim, long num_split, string operName = null);
    parameters:
    - id: value
      type: TensorFlow.TFOutput
      description: The tensor to split.
    - id: size_splits
      type: TensorFlow.TFOutput
      description: >-
        list containing the sizes of each output tensor along the split
                      dimension. Must sum to the dimension of value along split_dim.
                      Can contain one -1 indicating that dimension is to be inferred.
    - id: split_dim
      type: TensorFlow.TFOutput
      description: >-
        0-D.  The dimension along which to split.  Must be in the range
                      <code>[-rank(value), rank(value))</code>.
    - id: num_split
      type: System.Int64
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SplitV'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        Tensors whose shape matches that of <code>value</code>
                      except along <code>axis</code>, where their sizes are
                      <code>size_splits[i]</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SplitV*
  exceptions: []
- uid: TensorFlow.TFGraph.Sqrt(TensorFlow.TFOutput,System.String)
  id: Sqrt(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Sqrt(TFOutput, String)
  nameWithType: TFGraph.Sqrt(TFOutput, String)
  fullName: TFGraph.Sqrt(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes square root of x element-wise.
  remarks: I.e., \\(y = \sqrt{x} = x^{1/2}\\).
  syntax:
    content: public TensorFlow.TFOutput Sqrt (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Sqrt'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Sqrt*
  exceptions: []
- uid: TensorFlow.TFGraph.SqrtGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SqrtGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SqrtGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SqrtGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.SqrtGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradient for the sqrt of <code>x</code> wrt its input.
  remarks: >-
    Specifically, <code>grad = dy * 0.5 / y</code>, where <code>y = sqrt(x)</code>, and <code>dy</code>
                  is the corresponding input gradient.
  syntax:
    content: public TensorFlow.TFOutput SqrtGrad (TensorFlow.TFOutput y, TensorFlow.TFOutput dy, string operName = null);
    parameters:
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dy
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SqrtGrad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SqrtGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.Square(TensorFlow.TFOutput,System.String)
  id: Square(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Square(TFOutput, String)
  nameWithType: TFGraph.Square(TFOutput, String)
  fullName: TFGraph.Square(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes square of x element-wise.
  remarks: I.e., \\(y = x * x = x^2\\).
  syntax:
    content: public TensorFlow.TFOutput Square (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Square'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Square*
  exceptions: []
- uid: TensorFlow.TFGraph.SquaredDifference(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: SquaredDifference(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: SquaredDifference(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SquaredDifference(TFOutput, TFOutput, String)
  fullName: TFGraph.SquaredDifference(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns (x - y)(x - y) element-wise.
  remarks: >-
    *NOTE*: <code>SquaredDifference</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput SquaredDifference (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'SquaredDifference'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.SquaredDifference*
  exceptions: []
- uid: TensorFlow.TFGraph.Squeeze(TensorFlow.TFOutput,System.Int64[],System.String)
  id: Squeeze(TensorFlow.TFOutput,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Squeeze(TFOutput, Int64[], String)
  nameWithType: TFGraph.Squeeze(TFOutput, Int64[], String)
  fullName: TFGraph.Squeeze(TFOutput, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Removes dimensions of size 1 from the shape of a tensor.
  remarks: "Given a tensor <code>input</code>, this operation returns a tensor of the same type with\n              all dimensions of size 1 removed. If you don't want to remove all size 1\n              dimensions, you can remove specific size 1 dimensions by specifying\n              <code>axis</code>.\n              \n              For example:\n              \n               <pre><code>\n              # 't' is a tensor of shape [1, 2, 1, 3, 1, 1]\n              shape(squeeze(t)) ==&gt; [2, 3]\n               </code></pre>\n              \n              Or, to remove specific size 1 dimensions:\n              \n               <pre><code>\n              # 't' is a tensor of shape [1, 2, 1, 3, 1, 1]\n              shape(squeeze(t, [2, 4])) ==&gt; [1, 2, 3, 1]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Squeeze (TensorFlow.TFOutput input, long[] squeeze_dims = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The <code>input</code> to squeeze.
    - id: squeeze_dims
      type: System.Int64[]
      description: >-
        Optional argument
                      If specified, only squeezes the dimensions listed. The dimension
                      index starts at 0. It is an error to squeeze a dimension that is not 1. Must
                      be in the range <code>[-rank(input), rank(input))</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Squeeze'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Contains the same data as <code>input</code>, but has one or more dimensions of
                      size 1 removed.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Squeeze*
  exceptions: []
- uid: TensorFlow.TFGraph.Stack(TensorFlow.TFDataType,System.String,System.String)
  id: Stack(TensorFlow.TFDataType,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Stack(TFDataType, String, String)
  nameWithType: TFGraph.Stack(TFDataType, String, String)
  fullName: TFGraph.Stack(TFDataType, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated, use StackV2.
  syntax:
    content: public TensorFlow.TFOutput Stack (TensorFlow.TFDataType elem_type, string stack_name = null, string operName = null);
    parameters:
    - id: elem_type
      type: TensorFlow.TFDataType
      description: To be added.
    - id: stack_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Stack'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Stack*
  exceptions: []
- uid: TensorFlow.TFGraph.Stack(TensorFlow.TFOutput[],System.Nullable{System.Int32},System.String)
  id: Stack(TensorFlow.TFOutput[],System.Nullable{System.Int32},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Stack(TFOutput[], Nullable<Int32>, String)
  nameWithType: TFGraph.Stack(TFOutput[], Nullable<Int32>, String)
  fullName: TFGraph.Stack(TFOutput[], Nullable<Int32>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Stacks a list of rank-`R` tensors into one rank-`(R+1)` tensor.
  remarks: "Packs the list of tensors in <code>values</code> into a tensor with rank one higher than\n             each tensor in <code>values</code>, by packing them along the <code>axis</code> dimension.\n             Given a list of length <code>N</code> of tensors of shape <code>(A, B, C)</code>: if <code>axis == 0</code> then the \n             <code>output</code> tensor will have the shape <code>(N, A, B, C)</code>; if <code>axis == 1</code> then the <code>output</code>\n             tensor will have the shape <code>(A, N, B, C)</code>; etc."
  syntax:
    content: public TensorFlow.TFOutput Stack (TensorFlow.TFOutput[] values, Nullable<int> axis = 0, string operName = "stack");
    parameters:
    - id: values
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: axis
      type: System.Nullable{System.Int32}
      description: To be added.
    - id: operName
      type: System.String
      description: To be added.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.Stack*
  exceptions: []
- uid: TensorFlow.TFGraph.StackClose(TensorFlow.TFOutput,System.String)
  id: StackClose(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StackClose(TFOutput, String)
  nameWithType: TFGraph.StackClose(TFOutput, String)
  fullName: TFGraph.StackClose(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated, use StackCloseV2.
  syntax:
    content: public TensorFlow.TFOperation StackClose (TensorFlow.TFOutput handle, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StackClose'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.StackClose*
  exceptions: []
- uid: TensorFlow.TFGraph.StackCloseV2(TensorFlow.TFOutput,System.String)
  id: StackCloseV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StackCloseV2(TFOutput, String)
  nameWithType: TFGraph.StackCloseV2(TFOutput, String)
  fullName: TFGraph.StackCloseV2(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Delete the stack from its resource container.
  syntax:
    content: public TensorFlow.TFOperation StackCloseV2 (TensorFlow.TFOutput handle, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a stack.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StackCloseV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.StackCloseV2*
  exceptions: []
- uid: TensorFlow.TFGraph.StackPop(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: StackPop(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StackPop(TFOutput, TFDataType, String)
  nameWithType: TFGraph.StackPop(TFOutput, TFDataType, String)
  fullName: TFGraph.StackPop(TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated, use StackPopV2.
  syntax:
    content: public TensorFlow.TFOutput StackPop (TensorFlow.TFOutput handle, TensorFlow.TFDataType elem_type, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: elem_type
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPop'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StackPop*
  exceptions: []
- uid: TensorFlow.TFGraph.StackPopV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: StackPopV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StackPopV2(TFOutput, TFDataType, String)
  nameWithType: TFGraph.StackPopV2(TFOutput, TFDataType, String)
  fullName: TFGraph.StackPopV2(TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Pop the element at the top of the stack.
  syntax:
    content: public TensorFlow.TFOutput StackPopV2 (TensorFlow.TFOutput handle, TensorFlow.TFDataType elem_type, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a stack.
    - id: elem_type
      type: TensorFlow.TFDataType
      description: The type of the elem that is popped.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPopV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The tensor that is popped from the top of the stack.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StackPopV2*
  exceptions: []
- uid: TensorFlow.TFGraph.StackPush(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: StackPush(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StackPush(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.StackPush(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.StackPush(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated, use StackPushV2.
  syntax:
    content: public TensorFlow.TFOutput StackPush (TensorFlow.TFOutput handle, TensorFlow.TFOutput elem, Nullable<bool> swap_memory = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: elem
      type: TensorFlow.TFOutput
      description: To be added.
    - id: swap_memory
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPush'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StackPush*
  exceptions: []
- uid: TensorFlow.TFGraph.StackPushV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: StackPushV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StackPushV2(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.StackPushV2(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.StackPushV2(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Push an element onto the stack.
  syntax:
    content: public TensorFlow.TFOutput StackPushV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput elem, Nullable<bool> swap_memory = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a stack.
    - id: elem
      type: TensorFlow.TFOutput
      description: The tensor to be pushed onto the stack.
    - id: swap_memory
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      Swap <code>elem</code> to CPU. Default to false.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StackPushV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The same tensor as the input 'elem'.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StackPushV2*
  exceptions: []
- uid: TensorFlow.TFGraph.StackV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String)
  id: StackV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StackV2(TFOutput, TFDataType, String, String)
  nameWithType: TFGraph.StackV2(TFOutput, TFDataType, String, String)
  fullName: TFGraph.StackV2(TFOutput, TFDataType, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A stack that produces elements in first-in last-out order.
  syntax:
    content: public TensorFlow.TFOutput StackV2 (TensorFlow.TFOutput max_size, TensorFlow.TFDataType elem_type, string stack_name = null, string operName = null);
    parameters:
    - id: max_size
      type: TensorFlow.TFOutput
      description: >-
        The maximum size of the stack if non-negative. If negative, the stack
                      size is unlimited.
    - id: elem_type
      type: TensorFlow.TFDataType
      description: The type of the elements on the stack.
    - id: stack_name
      type: System.String
      description: >-
        Optional argument
                      Overrides the name used for the temporary stack resource. Default
                      value is the name of the 'Stack' op (which is guaranteed unique).
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StackV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to the stack.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StackV2*
  exceptions: []
- uid: TensorFlow.TFGraph.Stage(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: Stage(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Stage(TFOutput[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.Stage(TFOutput[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.Stage(TFOutput[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Stage values similar to a lightweight Enqueue.
  remarks: >-
    The basic functionality of this Op is similar to a queue with many
                  fewer capabilities and options.  This Op is optimized for performance.
  syntax:
    content: public TensorFlow.TFOperation Stage (TensorFlow.TFOutput[] values, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: values
      type: TensorFlow.TFOutput[]
      description: >-
        a list of tensors
                      dtypes A list of data types that inserted values should adhere to.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Maximum number of elements in the Staging Area. If &gt; 0, inserts
                      on the container will block when the capacity is reached.
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      The maximum number of bytes allowed for Tensors in the Staging Area.
                      If &gt; 0, inserts will block until sufficient space is available.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this queue is placed in the given container. Otherwise,
                      a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      It is necessary to match this name to the matching Unstage Op.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Stage'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.Stage*
  exceptions: []
- uid: TensorFlow.TFGraph.StageClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: StageClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StageClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.StageClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.StageClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op removes all elements in the underlying container.
  syntax:
    content: public TensorFlow.TFOperation StageClear (TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StageClear'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.StageClear*
  exceptions: []
- uid: TensorFlow.TFGraph.StagePeek(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: StagePeek(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StagePeek(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.StagePeek(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.StagePeek(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op peeks at the values at the specified index.  If the
  remarks: >-
    underlying container does not contain sufficient elements
                  this op will block until it does.   This Op is optimized for
                  performance.
  syntax:
    content: public TensorFlow.TFOutput[] StagePeek (TensorFlow.TFOutput index, TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: index
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StagePeek'.
    return:
      type: TensorFlow.TFOutput[]
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StagePeek*
  exceptions: []
- uid: TensorFlow.TFGraph.StageSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: StageSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StageSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.StageSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.StageSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op returns the number of elements in the underlying container.
  syntax:
    content: public TensorFlow.TFOutput StageSize (TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StageSize'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StageSize*
  exceptions: []
- uid: TensorFlow.TFGraph.StatelessMultinomial(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: StatelessMultinomial(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StatelessMultinomial(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.StatelessMultinomial(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.StatelessMultinomial(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Draws samples from a multinomial distribution.
  syntax:
    content: public TensorFlow.TFOutput StatelessMultinomial (TensorFlow.TFOutput logits, TensorFlow.TFOutput num_samples, TensorFlow.TFOutput seed, Nullable<TensorFlow.TFDataType> output_dtype = null, string operName = null);
    parameters:
    - id: logits
      type: TensorFlow.TFOutput
      description: >-
        2-D Tensor with shape <code>[batch_size, num_classes]</code>.  Each slice <code>[i, :]</code>
                      represents the unnormalized log probabilities for all classes.
    - id: num_samples
      type: TensorFlow.TFOutput
      description: 0-D.  Number of independent samples to draw for each row slice.
    - id: seed
      type: TensorFlow.TFOutput
      description: 2 seeds (shape [2]).
    - id: output_dtype
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessMultinomial'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        2-D Tensor with shape <code>[batch_size, num_samples]</code>.  Each slice <code>[i, :]</code>
                      contains the drawn class labels with range <code>[0, num_classes)</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StatelessMultinomial*
  exceptions: []
- uid: TensorFlow.TFGraph.StatelessRandomNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: StatelessRandomNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StatelessRandomNormal(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.StatelessRandomNormal(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.StatelessRandomNormal(TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs deterministic pseudorandom values from a normal distribution.
  remarks: "The generated values will have mean 0 and standard deviation 1.\n              \n              The outputs are a deterministic function of <code>shape</code> and <code>seed</code>."
  syntax:
    content: public TensorFlow.TFOutput StatelessRandomNormal (TensorFlow.TFOutput shape, TensorFlow.TFOutput seed, Nullable<TensorFlow.TFDataType> dtype = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFOutput
      description: The shape of the output tensor.
    - id: seed
      type: TensorFlow.TFOutput
      description: 2 seeds (shape [2]).
    - id: dtype
      type: System.Nullable{TensorFlow.TFDataType}
      description: >-
        Optional argument
                      The type of the output.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessRandomNormal'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Random values with specified shape.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StatelessRandomNormal*
  exceptions: []
- uid: TensorFlow.TFGraph.StatelessRandomUniform(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: StatelessRandomUniform(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StatelessRandomUniform(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.StatelessRandomUniform(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.StatelessRandomUniform(TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs deterministic pseudorandom random values from a uniform distribution.
  remarks: "The generated values follow a uniform distribution in the range <code>[0, 1)</code>. The\n              lower bound 0 is included in the range, while the upper bound 1 is excluded.\n              \n              The outputs are a deterministic function of <code>shape</code> and <code>seed</code>."
  syntax:
    content: public TensorFlow.TFOutput StatelessRandomUniform (TensorFlow.TFOutput shape, TensorFlow.TFOutput seed, Nullable<TensorFlow.TFDataType> dtype = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFOutput
      description: The shape of the output tensor.
    - id: seed
      type: TensorFlow.TFOutput
      description: 2 seeds (shape [2]).
    - id: dtype
      type: System.Nullable{TensorFlow.TFDataType}
      description: >-
        Optional argument
                      The type of the output.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessRandomUniform'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Random values with specified shape.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StatelessRandomUniform*
  exceptions: []
- uid: TensorFlow.TFGraph.StatelessTruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: StatelessTruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StatelessTruncatedNormal(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.StatelessTruncatedNormal(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.StatelessTruncatedNormal(TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs deterministic pseudorandom values from a truncated normal distribution.
  remarks: "The generated values follow a normal distribution with mean 0 and standard\n              deviation 1, except that values whose magnitude is more than 2 standard\n              deviations from the mean are dropped and re-picked.\n              \n              The outputs are a deterministic function of <code>shape</code> and <code>seed</code>."
  syntax:
    content: public TensorFlow.TFOutput StatelessTruncatedNormal (TensorFlow.TFOutput shape, TensorFlow.TFOutput seed, Nullable<TensorFlow.TFDataType> dtype = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFOutput
      description: The shape of the output tensor.
    - id: seed
      type: TensorFlow.TFOutput
      description: 2 seeds (shape [2]).
    - id: dtype
      type: System.Nullable{TensorFlow.TFDataType}
      description: >-
        Optional argument
                      The type of the output.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StatelessTruncatedNormal'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Random values with specified shape.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StatelessTruncatedNormal*
  exceptions: []
- uid: TensorFlow.TFGraph.StaticRegexFullMatch(TensorFlow.TFOutput,System.String,System.String)
  id: StaticRegexFullMatch(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StaticRegexFullMatch(TFOutput, String, String)
  nameWithType: TFGraph.StaticRegexFullMatch(TFOutput, String, String)
  fullName: TFGraph.StaticRegexFullMatch(TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Check if the input matches the regex pattern.
  remarks: "The input is a string tensor of any shape. The pattern is the\n              regular expression to be matched with every element of the input tensor.\n              The boolean values (True or False) of the output tensor indicate\n              if the input matches the regex pattern provided.\n              \n              The pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)"
  syntax:
    content: public TensorFlow.TFOutput StaticRegexFullMatch (TensorFlow.TFOutput input, string pattern, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A string tensor of the text to be processed.
    - id: pattern
      type: System.String
      description: The regular expression to match the input.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StaticRegexFullMatch'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A bool tensor with the same shape as <code>input</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StaticRegexFullMatch*
  exceptions: []
- uid: TensorFlow.TFGraph.StaticRegexReplace(TensorFlow.TFOutput,System.String,System.String,System.Nullable{System.Boolean},System.String)
  id: StaticRegexReplace(TensorFlow.TFOutput,System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StaticRegexReplace(TFOutput, String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.StaticRegexReplace(TFOutput, String, String, Nullable<Boolean>, String)
  fullName: TFGraph.StaticRegexReplace(TFOutput, String, String, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Replaces the match of pattern in input with rewrite.
  remarks: It follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)
  syntax:
    content: public TensorFlow.TFOutput StaticRegexReplace (TensorFlow.TFOutput input, string pattern, string rewrite, Nullable<bool> replace_global = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The text to be processed.
    - id: pattern
      type: System.String
      description: The regular expression to match the input.
    - id: rewrite
      type: System.String
      description: The rewrite to be applied to the matched expresion.
    - id: replace_global
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If True, the replacement is global, otherwise the replacement
                      is done only on the first match.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StaticRegexReplace'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The text after applying pattern and rewrite.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StaticRegexReplace*
  exceptions: []
- uid: TensorFlow.TFGraph.StopGradient(TensorFlow.TFOutput,System.String)
  id: StopGradient(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StopGradient(TFOutput, String)
  nameWithType: TFGraph.StopGradient(TFOutput, String)
  fullName: TFGraph.StopGradient(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Stops gradient computation.
  remarks: "When executed in a graph, this op outputs its input tensor as-is.\n              \n              When building ops to compute gradients, this op prevents the contribution of\n              its inputs to be taken into account.  Normally, the gradient generator adds ops\n              to a graph to compute the derivatives of a specified 'loss' by recursively\n              finding out inputs that contributed to its computation.  If you insert this op\n              in the graph it inputs are masked from the gradient generator.  They are not\n              taken into account for computing gradients.\n              \n              This is useful any time you want to compute a value with TensorFlow but need\n              to pretend that the value was a constant. Some examples include:\n              \n              *  The *EM* algorithm where the *M-step* should not involve backpropagation\n              through the output of the *E-step*.\n              *  Contrastive divergence training of Boltzmann machines where, when\n              differentiating the energy function, the training must not backpropagate\n              through the graph that generated the samples from the model.\n              *  Adversarial training, where no backprop should happen through the adversarial\n              example generation process."
  syntax:
    content: public TensorFlow.TFOutput StopGradient (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StopGradient'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StopGradient*
  exceptions: []
- uid: TensorFlow.TFGraph.StridedSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: StridedSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StridedSlice(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.StridedSlice(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.StridedSlice(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Return a strided slice from <code>input</code>.
  remarks: "Note, most python users will want to use the Python <code>Tensor.__getitem__</code>\n              or <code>Variable.__getitem__</code> rather than this op directly.\n              \n              The goal of this op is to produce a new tensor with a subset of\n              the elements from the <code>n</code> dimensional <code>input</code> tensor. The subset is chosen using\n              a sequence of <code>m</code> sparse range specifications encoded into the arguments\n              of this function. Note, in some cases\n              <code>m</code> could be equal to <code>n</code>, but this need not be the case. Each\n              range specification entry can be one of the following:\n              \n              - An ellipsis (...). Ellipses are used to imply zero or more\n              dimensions of full-dimension selection and are produced using\n              <code>ellipsis_mask</code>. For example, <code>foo[...]</code> is the identity slice.\n              \n              - A new axis. This is used to insert a new shape=1 dimension and is\n              produced using <code>new_axis_mask</code>. For example, <code>foo[:, ...]</code> where\n              <code>foo</code> is shape <code>(3, 4)</code> produces a <code>(1, 3, 4)</code> tensor.\n              \n              \n              - A range <code>begin:end:stride</code>. This is used to specify how much to choose from\n              a given dimension. <code>stride</code> can be any integer but 0.  <code>begin</code> is an integer\n              which represents the index of the first value to select while <code>end</code> represents\n              the index of the last value to select. The number of values selected in each\n              dimension is <code>end - begin</code> if <code>stride &gt; 0</code> and <code>begin - end</code> if <code>stride &lt; 0</code>.\n              <code>begin</code> and <code>end</code> can be negative where <code>-1</code> is the last element, <code>-2</code> is\n              the second to last. <code>begin_mask</code> controls whether to replace the explicitly\n              given <code>begin</code> with an implicit effective value of <code>0</code> if <code>stride &gt; 0</code> and\n              <code>-1</code> if <code>stride &lt; 0</code>. <code>end_mask</code> is analogous but produces the number\n              required to create the largest open interval. For example, given a shape\n              <code>(3,)</code> tensor <code>foo[:]</code>, the effective <code>begin</code> and <code>end</code> are <code>0</code> and <code>3</code>. Do\n              not assume this is equivalent to <code>foo[0:-1]</code> which has an effective <code>begin</code>\n              and <code>end</code> of <code>0</code> and <code>2</code>. Another example is <code>foo[-2::-1]</code> which reverses the\n              first dimension of a tensor while dropping the last two (in the original\n              order elements). For example <code>foo = [1,2,3,4]; foo[-2::-1]</code> is <code>[4,3]</code>.\n              \n              - A single index. This is used to keep only elements that have a given\n              index. For example (<code>foo[2, :]</code> on a shape <code>(5,6)</code> tensor produces a\n              shape <code>(6,)</code> tensor. This is encoded in <code>begin</code> and <code>end</code> and\n              <code>shrink_axis_mask</code>.\n              \n              Each conceptual range specification is encoded in the op's argument. This\n              encoding is best understand by considering a non-trivial example. In\n              particular,\n              <code>foo[1, 2:4, None, ..., :-3:-1, :]</code> will be encoded as\n              \n               <pre><code>\n              begin = [1, 2, x, x, 0, x] # x denotes don't care (usually 0)\n              end = [2, 4, x, x, -3, x]\n              strides = [1, 1, x, x, -1, 1]\n              begin_mask = 1&lt;&lt;4 | 1 &lt;&lt; 5 = 48\n              end_mask = 1&lt;&lt;5 = 32\n              ellipsis_mask = 1&lt;&lt;3 = 8\n              new_axis_mask = 1&lt;&lt;2 4\n              shrink_axis_mask = 1&lt;&lt;0\n               </code></pre>\n              \n              In this case if <code>foo.shape</code> is (5, 5, 5, 5, 5, 5) the final shape of\n              the slice becomes (2, 1, 5, 5, 2, 5).\n              Let us walk step by step through each argument specification.\n              \n              1.  The first argument in the example slice is turned into <code>begin = 1</code> and\n              <code>end = begin + 1 = 2</code>. To disambiguate from the original spec <code>2:4</code> we\n              also set the appropriate bit in <code>shrink_axis_mask</code>.\n              \n              2. <code>2:4</code> is contributes 2, 4, 1 to begin, end, and stride. All masks have\n              zero bits contributed.\n              \n              3. None is a synonym for <code>tf.newaxis</code>. This means insert a dimension of size 1\n              dimension in the final shape. Dummy values are contributed to begin,\n              end and stride, while the new_axis_mask bit is set.\n              \n              4. <code>...</code> grab the full ranges from as many dimensions as needed to\n              fully specify a slice for every dimension of the input shape.\n              \n              5. <code>:-3:-1</code> shows the use of negative indices. A negative index <code>i</code> associated\n              with a dimension that has shape <code>s</code> is converted to a positive index\n              <code>s + i</code>. So <code>-1</code> becomes <code>s-1</code> (i.e. the last element). This conversion\n              is done internally so begin, end and strides receive x, -3, and -1.\n              The appropriate begin_mask bit is set to indicate the start range is the\n              full range (ignoring the x).\n              \n              6. <code>:</code> indicates that the entire contents of the corresponding dimension\n              is selected. This is equivalent to <code>::</code> or <code>0::1</code>. begin, end, and strides\n              receive 0, 0, and 1, respectively. The appropriate bits in <code>begin_mask</code> and\n              <code>end_mask</code> are also set.\n              \n              *Requirements*:\n              <code>0 != strides[i] for i in [0, m)</code><code>ellipsis_mask must be a power of two (only one ellipsis)</code>"
  syntax:
    content: public TensorFlow.TFOutput StridedSlice (TensorFlow.TFOutput input, TensorFlow.TFOutput begin, TensorFlow.TFOutput end, TensorFlow.TFOutput strides, Nullable<long> begin_mask = null, Nullable<long> end_mask = null, Nullable<long> ellipsis_mask = null, Nullable<long> new_axis_mask = null, Nullable<long> shrink_axis_mask = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: begin
      type: TensorFlow.TFOutput
      description: >-
        <code>begin[k]</code> specifies the offset into the <code>k</code>th range specification.
                      The exact dimension this corresponds to will be determined by context.
                      Out-of-bounds values will be silently clamped. If the <code>k</code>th bit of
                      <code>begin_mask</code> then <code>begin[k]</code> is ignored and the full range of the
                      appropriate dimension is used instead. Negative values causes indexing
                      to start from the highest element e.g. If <code>foo==[1,2,3]</code> then <code>foo[-1]==3</code>.
    - id: end
      type: TensorFlow.TFOutput
      description: >-
        <code>end[i]</code> is like <code>begin</code> with the exception that <code>end_mask</code> is
                      used to determine full ranges.
    - id: strides
      type: TensorFlow.TFOutput
      description: >-
        <code>strides[i]</code> specifies the increment in the <code>i</code>th specification
                      after extracting a given element. Negative indices will reverse
                      the original order. Out or range values are
                      clamped to <code>[0,dim[i]) if slice[i]&gt;0</code> or <code>[-1,dim[i]-1] if slice[i] &lt; 0</code>
    - id: begin_mask
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      a bitmask where a bit i being 1 means to ignore the begin
                      value and instead use the largest interval possible. At runtime
                      begin[i] will be replaced with <code>[0, n-1)</code> if <code>stride[i] &gt; 0</code> or
                      <code>[-1, n-1]</code> if <code>stride[i] &lt; 0</code>
    - id: end_mask
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      analogous to <code>begin_mask</code>
    - id: ellipsis_mask
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      a bitmask where bit <code>i</code> being 1 means the <code>i</code>th
                      position is actually an ellipsis. One bit at most can be 1.
                      If <code>ellipsis_mask == 0</code>, then an implicit ellipsis mask of <code>1 &lt;&lt; (m+1)</code>
                      is provided. This means that <code>foo[3:5] == foo[3:5, ...]</code>. An ellipsis
                      implicitly creates as many range specifications as necessary to fully
                      specify the sliced range for every dimension. For example for a 4-dimensional
                      tensor <code>foo</code> the slice <code>foo[2, ..., 5:8]</code> implies <code>foo[2, :, :, 5:8]</code>.
    - id: new_axis_mask
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      a bitmask where bit <code>i</code> being 1 means the <code>i</code>th
                      specification creates a new shape 1 dimension. For example
                      <code>foo[:4, tf.newaxis, :2]</code> would produce a shape <code>(4, 1, 2)</code> tensor.
    - id: shrink_axis_mask
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      a bitmask where bit <code>i</code> implies that the <code>i</code>th
                      specification should shrink the dimensionality. begin and end
                      must imply a slice of size 1 in the dimension. For example in
                      python one might do <code>foo[:, 3, :]</code> which would result in
                      <code>shrink_axis_mask</code> being 2.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StridedSlice'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StridedSlice*
  exceptions: []
- uid: TensorFlow.TFGraph.StridedSliceAssign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: StridedSliceAssign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.StridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.StridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  syntax:
    content: public TensorFlow.TFOutput StridedSliceAssign (TensorFlow.TFOutput reference, TensorFlow.TFOutput begin, TensorFlow.TFOutput end, TensorFlow.TFOutput strides, TensorFlow.TFOutput value, Nullable<long> begin_mask = null, Nullable<long> end_mask = null, Nullable<long> ellipsis_mask = null, Nullable<long> new_axis_mask = null, Nullable<long> shrink_axis_mask = null, string operName = null);
    parameters:
    - id: reference
      type: TensorFlow.TFOutput
      description: To be added.
    - id: begin
      type: TensorFlow.TFOutput
      description: To be added.
    - id: end
      type: TensorFlow.TFOutput
      description: To be added.
    - id: strides
      type: TensorFlow.TFOutput
      description: To be added.
    - id: value
      type: TensorFlow.TFOutput
      description: To be added.
    - id: begin_mask
      type: System.Nullable{System.Int64}
      description: To be added.
    - id: end_mask
      type: System.Nullable{System.Int64}
      description: To be added.
    - id: ellipsis_mask
      type: System.Nullable{System.Int64}
      description: To be added.
    - id: new_axis_mask
      type: System.Nullable{System.Int64}
      description: To be added.
    - id: shrink_axis_mask
      type: System.Nullable{System.Int64}
      description: To be added.
    - id: operName
      type: System.String
      description: To be added.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.StridedSliceAssign*
  exceptions: []
- uid: TensorFlow.TFGraph.StridedSliceGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: StridedSliceGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StridedSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.StridedSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.StridedSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the gradient of <code>StridedSlice</code>.
  remarks: "Since <code>StridedSlice</code> cuts out pieces of its <code>input</code> which is size\n              <code>shape</code>, its gradient will have the same shape (which is passed here\n              as <code>shape</code>). The gradient will be zero in any element that the slice\n              does not select.\n              \n              Arguments are the same as StridedSliceGrad with the exception that\n              <code>dy</code> is the input gradient to be propagated and <code>shape</code> is the\n              shape of <code>StridedSlice</code>'s <code>input</code>."
  syntax:
    content: public TensorFlow.TFOutput StridedSliceGrad (TensorFlow.TFOutput shape, TensorFlow.TFOutput begin, TensorFlow.TFOutput end, TensorFlow.TFOutput strides, TensorFlow.TFOutput dy, Nullable<long> begin_mask = null, Nullable<long> end_mask = null, Nullable<long> ellipsis_mask = null, Nullable<long> new_axis_mask = null, Nullable<long> shrink_axis_mask = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFOutput
      description: To be added.
    - id: begin
      type: TensorFlow.TFOutput
      description: To be added.
    - id: end
      type: TensorFlow.TFOutput
      description: To be added.
    - id: strides
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dy
      type: TensorFlow.TFOutput
      description: To be added.
    - id: begin_mask
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: end_mask
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: ellipsis_mask
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: new_axis_mask
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: shrink_axis_mask
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StridedSliceGrad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StridedSliceGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.StringFormat(TensorFlow.TFOutput[],System.String,System.String,System.Nullable{System.Int64},System.String)
  id: StringFormat(TensorFlow.TFOutput[],System.String,System.String,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StringFormat(TFOutput[], String, String, Nullable<Int64>, String)
  nameWithType: TFGraph.StringFormat(TFOutput[], String, String, Nullable<Int64>, String)
  fullName: TFGraph.StringFormat(TFOutput[], String, String, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Formats a string template using a list of tensors.
  remarks: Formats a string template using a list of tensors, pretty-printing tensor summaries.
  syntax:
    content: public TensorFlow.TFOutput StringFormat (TensorFlow.TFOutput[] inputs, string template = null, string placeholder = null, Nullable<long> summarize = null, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: The list of tensors to format into the placeholder string.
    - id: template
      type: System.String
      description: >-
        Optional argument
                      A string, the template to format tensor summaries into.
    - id: placeholder
      type: System.String
      description: >-
        Optional argument
                      A string, at each placeholder in the template a subsequent tensor summary will be inserted.
    - id: summarize
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      When formatting the tensor summaries print the first and last summarize entries of each tensor dimension.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StringFormat'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        = The resulting string scalar.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StringFormat*
  exceptions: []
- uid: TensorFlow.TFGraph.StringJoin(TensorFlow.TFOutput[],System.String,System.String)
  id: StringJoin(TensorFlow.TFOutput[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StringJoin(TFOutput[], String, String)
  nameWithType: TFGraph.StringJoin(TFOutput[], String, String)
  fullName: TFGraph.StringJoin(TFOutput[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Joins the strings in the given list of string tensors into one tensor;
  remarks: with the given separator (default is an empty separator).
  syntax:
    content: public TensorFlow.TFOutput StringJoin (TensorFlow.TFOutput[] inputs, string separator = null, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: >-
        A list of string tensors.  The tensors must all have the same shape,
                      or be scalars.  Scalars may be mixed in; these will be broadcast to the shape
                      of non-scalar inputs.
    - id: separator
      type: System.String
      description: >-
        Optional argument
                      string, an optional join separator.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StringJoin'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StringJoin*
  exceptions: []
- uid: TensorFlow.TFGraph.StringLength(TensorFlow.TFOutput,System.String,System.String)
  id: StringLength(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StringLength(TFOutput, String, String)
  nameWithType: TFGraph.StringLength(TFOutput, String, String)
  fullName: TFGraph.StringLength(TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: String lengths of <code>input</code>.
  remarks: Computes the length of each string given in the input tensor.
  syntax:
    content: public TensorFlow.TFOutput StringLength (TensorFlow.TFOutput input, string unit = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The string for which to compute the length.
    - id: unit
      type: System.String
      description: >-
        Optional argument
                      The unit that is counted to compute string length.  One of: <code>"BYTE"</code> (for
                      the number of bytes in each string) or <code>"UTF8_CHAR"</code> (for the number of UTF-8
                      encoded Unicode code points in each string).  Results are undefined
                      if <code>unit=UTF8_CHAR</code> and the <code>input</code> strings do not contain structurally
                      valid UTF-8.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StringLength'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Integer tensor that has the same shape as <code>input</code>. The output contains the
                      element-wise string lengths of <code>input</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StringLength*
  exceptions: []
- uid: TensorFlow.TFGraph.StringSplit(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: StringSplit(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StringSplit(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.StringSplit(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.StringSplit(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Split elements of <code>input</code> based on <code>delimiter</code> into a <code>SparseTensor</code>.
  remarks: "Let N be the size of source (typically N will be the batch size). Split each\n              element of <code>input</code> based on <code>delimiter</code> and return a <code>SparseTensor</code>\n              containing the splitted tokens. Empty tokens are ignored.\n              \n              <code>delimiter</code> can be empty, or a string of split characters. If <code>delimiter</code> is an\n              empty string, each element of <code>input</code> is split into individual single-byte\n              character strings, including splitting of UTF-8 multibyte sequences. Otherwise\n              every character of <code>delimiter</code> is a potential split point.\n              \n              For example:\n              N = 2, input[0] is 'hello world' and input[1] is 'a b c', then the output\n              will be\n              \n              indices = [0, 0;\n              0, 1;\n              1, 0;\n              1, 1;\n              1, 2]\n              shape = [2, 3]\n              values = ['hello', 'world', 'a', 'b', 'c']"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> StringSplit (TensorFlow.TFOutput input, TensorFlow.TFOutput delimiter, Nullable<bool> skip_empty = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 1-D. Strings to split.
    - id: delimiter
      type: TensorFlow.TFOutput
      description: 0-D. Delimiter characters (bytes), or empty string.
    - id: skip_empty
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      A <code>bool</code>. If <code>True</code>, skip the empty strings from the result.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StringSplit'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      indices: A dense matrix of int64 representing the indices of the sparse tensor.
                      values: A vector of strings corresponding to the splited values.
                      shape: a length-2 vector of int64 representing the shape of the sparse
                      tensor, where the first value is N and the second value is the maximum number
                      of tokens in a single input entry.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.StringSplit*
  exceptions: []
- uid: TensorFlow.TFGraph.StringSplitV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  id: StringSplitV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StringSplitV2(TFOutput, TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.StringSplitV2(TFOutput, TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.StringSplitV2(TFOutput, TFOutput, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Split elements of <code>source</code> based on <code>sep</code> into a <code>SparseTensor</code>.
  remarks: "Let N be the size of source (typically N will be the batch size). Split each\n              element of <code>source</code> based on <code>sep</code> and return a <code>SparseTensor</code>\n              containing the split tokens. Empty tokens are ignored.\n              \n              For example, N = 2, source[0] is 'hello world' and source[1] is 'a b c',\n              then the output will be\n               <pre><code>\n              st.indices = [0, 0;\n              0, 1;\n              1, 0;\n              1, 1;\n              1, 2]\n              st.shape = [2, 3]\n              st.values = ['hello', 'world', 'a', 'b', 'c']\n               </code></pre>\n              \n              If <code>sep</code> is given, consecutive delimiters are not grouped together and are\n              deemed to delimit empty strings. For example, source of <code>\"1&lt;&gt;2&lt;&gt;&lt;&gt;3\"</code> and\n              sep of <code>\"&lt;&gt;\"</code> returns <code>[\"1\", \"2\", \"\", \"3\"]</code>. If <code>sep</code> is None or an empty\n              string, consecutive whitespace are regarded as a single separator, and the\n              result will contain no empty strings at the startor end if the string has\n              leading or trailing whitespace.\n              \n              Note that the above mentioned behavior matches python's str.split."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> StringSplitV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput sep, Nullable<long> maxsplit = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: <code>1-D</code> string <code>Tensor</code>, the strings to split.
    - id: sep
      type: TensorFlow.TFOutput
      description: <code>0-D</code> string <code>Tensor</code>, the delimiter character.
    - id: maxsplit
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      An <code>int</code>. If <code>maxsplit &gt; 0</code>, limit of the split of the result.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StringSplitV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      indices:
                      values:
                      shape:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.StringSplitV2*
  exceptions: []
- uid: TensorFlow.TFGraph.StringStrip(TensorFlow.TFOutput,System.String)
  id: StringStrip(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StringStrip(TFOutput, String)
  nameWithType: TFGraph.StringStrip(TFOutput, String)
  fullName: TFGraph.StringStrip(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Strip leading and trailing whitespaces from the Tensor.
  syntax:
    content: public TensorFlow.TFOutput StringStrip (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A string <code>Tensor</code> of any shape.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StringStrip'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A string <code>Tensor</code> of the same shape as the input.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StringStrip*
  exceptions: []
- uid: TensorFlow.TFGraph.StringToHashBucket(TensorFlow.TFOutput,System.Int64,System.String)
  id: StringToHashBucket(TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StringToHashBucket(TFOutput, Int64, String)
  nameWithType: TFGraph.StringToHashBucket(TFOutput, Int64, String)
  fullName: TFGraph.StringToHashBucket(TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts each string in the input Tensor to its hash mod by a number of buckets.
  remarks: "The hash function is deterministic on the content of the string within the\n              process.\n              \n              Note that the hash function may change from time to time.\n              This functionality will be deprecated and it's recommended to use\n              <code>tf.string_to_hash_bucket_fast()</code> or <code>tf.string_to_hash_bucket_strong()</code>."
  syntax:
    content: public TensorFlow.TFOutput StringToHashBucket (TensorFlow.TFOutput string_tensor, long num_buckets, string operName = null);
    parameters:
    - id: string_tensor
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_buckets
      type: System.Int64
      description: The number of buckets.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToHashBucket'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A Tensor of the same shape as the input <code>string_tensor</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StringToHashBucket*
  exceptions: []
- uid: TensorFlow.TFGraph.StringToHashBucketFast(TensorFlow.TFOutput,System.Int64,System.String)
  id: StringToHashBucketFast(TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StringToHashBucketFast(TFOutput, Int64, String)
  nameWithType: TFGraph.StringToHashBucketFast(TFOutput, Int64, String)
  fullName: TFGraph.StringToHashBucketFast(TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts each string in the input Tensor to its hash mod by a number of buckets.
  remarks: >-
    The hash function is deterministic on the content of the string within the
                  process and will never change. However, it is not suitable for cryptography.
                  This function may be used when CPU time is scarce and inputs are trusted or
                  unimportant. There is a risk of adversaries constructing inputs that all hash
                  to the same bucket. To prevent this problem, use a strong hash function with
                  <code>tf.string_to_hash_bucket_strong</code>.
  syntax:
    content: public TensorFlow.TFOutput StringToHashBucketFast (TensorFlow.TFOutput input, long num_buckets, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The strings to assign a hash bucket.
    - id: num_buckets
      type: System.Int64
      description: The number of buckets.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToHashBucketFast'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A Tensor of the same shape as the input <code>string_tensor</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StringToHashBucketFast*
  exceptions: []
- uid: TensorFlow.TFGraph.StringToHashBucketStrong(TensorFlow.TFOutput,System.Int64,System.Int64[],System.String)
  id: StringToHashBucketStrong(TensorFlow.TFOutput,System.Int64,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StringToHashBucketStrong(TFOutput, Int64, Int64[], String)
  nameWithType: TFGraph.StringToHashBucketStrong(TFOutput, Int64, Int64[], String)
  fullName: TFGraph.StringToHashBucketStrong(TFOutput, Int64, Int64[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts each string in the input Tensor to its hash mod by a number of buckets.
  remarks: "The hash function is deterministic on the content of the string within the\n              process. The hash function is a keyed hash function, where attribute <code>key</code>\n              defines the key of the hash function. <code>key</code> is an array of 2 elements.\n              \n              A strong hash is important when inputs may be malicious, e.g. URLs with\n              additional components. Adversaries could try to make their inputs hash to the\n              same bucket for a denial-of-service attack or to skew the results. A strong\n              hash prevents this by making it difficult, if not infeasible, to compute inputs\n              that hash to the same bucket. This comes at a cost of roughly 4x higher compute\n              time than <code>tf.string_to_hash_bucket_fast</code>."
  syntax:
    content: public TensorFlow.TFOutput StringToHashBucketStrong (TensorFlow.TFOutput input, long num_buckets, long[] key, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The strings to assign a hash bucket.
    - id: num_buckets
      type: System.Int64
      description: The number of buckets.
    - id: key
      type: System.Int64[]
      description: >-
        The key for the keyed hash function passed as a list of two uint64
                      elements.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToHashBucketStrong'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A Tensor of the same shape as the input <code>string_tensor</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StringToHashBucketStrong*
  exceptions: []
- uid: TensorFlow.TFGraph.StringToNumber(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: StringToNumber(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: StringToNumber(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.StringToNumber(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.StringToNumber(TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts each string in the input Tensor to the specified numeric type.
  remarks: >-
    (Note that int32 overflow results in an error while float overflow
                  results in a rounded value.)
  syntax:
    content: public TensorFlow.TFOutput StringToNumber (TensorFlow.TFOutput string_tensor, Nullable<TensorFlow.TFDataType> out_type = null, string operName = null);
    parameters:
    - id: string_tensor
      type: TensorFlow.TFOutput
      description: To be added.
    - id: out_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: >-
        Optional argument
                      The numeric type to interpret each string in <code>string_tensor</code> as.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'StringToNumber'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A Tensor of the same shape as the input <code>string_tensor</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.StringToNumber*
  exceptions: []
- uid: TensorFlow.TFGraph.Sub(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Sub(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Sub(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Sub(TFOutput, TFOutput, String)
  fullName: TFGraph.Sub(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns x - y element-wise.
  remarks: >-
    *NOTE*: <code>Subtract</code> supports broadcasting. More about broadcasting
                  [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
  syntax:
    content: public TensorFlow.TFOutput Sub (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Sub'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Sub*
  exceptions: []
- uid: TensorFlow.TFGraph.Sum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: Sum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Sum(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Sum(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Sum(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the sum of elements across dimensions of a tensor.
  remarks: >-
    Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
                  <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
                  <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
                  retained with length 1.
  syntax:
    content: public TensorFlow.TFOutput Sum (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable<bool> keep_dims = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: The tensor to reduce.
    - id: reduction_indices
      type: TensorFlow.TFOutput
      description: >-
        The dimensions to reduce. Must be in the range
                      <code>[-rank(input), rank(input))</code>.
    - id: keep_dims
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, retain reduced dimensions with length 1.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Sum'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The reduced tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Sum*
  exceptions: []
- uid: TensorFlow.TFGraph.Svd(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  id: Svd(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Svd(TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.Svd(TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.Svd(TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the singular value decompositions of one or more matrices.
  remarks: >-
    Computes the SVD of each inner matrix in <code>input</code> such that
                  <code>input[..., :, :] = u[..., :, :] * diag(s[..., :, :]) * transpose(v[..., :, :])</code><pre><code>
                  # a is a tensor containing a batch of matrices.
                  # s is a tensor of singular values for each matrix.
                  # u is the tensor containing of left singular vectors for each matrix.
                  # v is the tensor containing of right singular vectors for each matrix.
                  s, u, v = svd(a)
                  s, _, _ = svd(a, compute_uv=False)
                   </code></pre>
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> Svd (TensorFlow.TFOutput input, Nullable<bool> compute_uv = null, Nullable<bool> full_matrices = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: >-
        A tensor of shape <code>[..., M, N]</code> whose inner-most 2 dimensions
                      form matrices of size <code>[M, N]</code>. Let <code>P</code> be the minimum of <code>M</code> and <code>N</code>.
    - id: compute_uv
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, left and right singular vectors will be
                      computed and returned in <code>u</code> and <code>v</code>, respectively.
                      If false, <code>u</code> and <code>v</code> are not set and should never referenced.
    - id: full_matrices
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true, compute full-sized <code>u</code> and <code>v</code>. If false
                      (the default), compute only the leading <code>P</code> singular vectors.
                      Ignored if <code>compute_uv</code> is <code>False</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Svd'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      s: Singular values. Shape is <code>[..., P]</code>.
                      u: Left singular vectors. If <code>full_matrices</code> is <code>False</code> then shape is
                      <code>[..., M, P]</code>; if <code>full_matrices</code> is <code>True</code> then shape is
                      <code>[..., M, M]</code>. Undefined if <code>compute_uv</code> is <code>False</code>.
                      v: Left singular vectors. If <code>full_matrices</code> is <code>False</code> then shape is
                      <code>[..., N, P]</code>. If <code>full_matrices</code> is <code>True</code> then shape is <code>[..., N, N]</code>.
                      Undefined if <code>compute_uv</code> is false.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.Svd*
  exceptions: []
- uid: TensorFlow.TFGraph.Switch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Switch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Switch(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Switch(TFOutput, TFOutput, String)
  fullName: TFGraph.Switch(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Forwards <code>data</code> to the output port determined by <code>pred</code>.
  remarks: "If <code>pred</code> is true, the <code>data</code> input is forwarded to <code>output_true</code>. Otherwise,\n              the data goes to <code>output_false</code>.\n              \n              See also <code>RefSwitch</code> and <code>Merge</code>."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> Switch (TensorFlow.TFOutput data, TensorFlow.TFOutput pred, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: The tensor to be forwarded to the appropriate output.
    - id: pred
      type: TensorFlow.TFOutput
      description: A scalar that specifies which output port will receive data.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Switch'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_false: If <code>pred</code> is false, data will be forwarded to this output.
                      output_true: If <code>pred</code> is true, data will be forwarded to this output.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.Switch*
  exceptions: []
- uid: TensorFlow.TFGraph.TakeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: TakeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TakeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.TakeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.TakeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that contains <code>count</code> elements from the <code>input_dataset</code>.
  syntax:
    content: public TensorFlow.TFOutput TakeDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput count, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: count
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing the number of elements from the <code>input_dataset</code>
                      that should be taken. A value of <code>-1</code> indicates that all of <code>input_dataset</code>
                      is taken.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TakeDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TakeDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.TakeManySparseFromTensorsMap(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.String)
  id: TakeManySparseFromTensorsMap(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TakeManySparseFromTensorsMap(TFOutput, TFDataType, String, String, String)
  nameWithType: TFGraph.TakeManySparseFromTensorsMap(TFOutput, TFDataType, String, String, String)
  fullName: TFGraph.TakeManySparseFromTensorsMap(TFOutput, TFDataType, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Read <code>SparseTensors</code> from a <code>SparseTensorsMap</code> and concatenate them.
  remarks: "The input <code>sparse_handles</code> must be an <code>int64</code> matrix of shape <code>[N, 1]</code> where\n              <code>N</code> is the minibatch size and the rows correspond to the output handles of\n              <code>AddSparseToTensorsMap</code> or <code>AddManySparseToTensorsMap</code>.  The ranks of the\n              original <code>SparseTensor</code> objects that went into the given input ops must all\n              match.  When the final <code>SparseTensor</code> is created, it has rank one\n              higher than the ranks of the incoming <code>SparseTensor</code> objects\n              (they have been concatenated along a new row dimension on the left).\n              \n              The output <code>SparseTensor</code> object's shape values for all dimensions but the\n              first are the max across the input <code>SparseTensor</code> objects' shape values\n              for the corresponding dimensions.  Its first shape value is <code>N</code>, the minibatch\n              size.\n              \n              The input <code>SparseTensor</code> objects' indices are assumed ordered in\n              standard lexicographic order.  If this is not the case, after this\n              step run <code>SparseReorder</code> to restore index ordering.\n              \n              For example, if the handles represent an input, which is a <code>[2, 3]</code> matrix\n              representing two original <code>SparseTensor</code> objects:\n              \n               <pre><code>\n              index = [ 0]\n              [10]\n              [20]\n              values = [1, 2, 3]\n              shape = [50]\n               </code></pre>\n              \n              and\n              \n               <pre><code>\n              index = [ 2]\n              [10]\n              values = [4, 5]\n              shape = [30]\n               </code></pre>\n              \n              then the final <code>SparseTensor</code> will be:\n              \n               <pre><code>\n              index = [0  0]\n              [0 10]\n              [0 20]\n              [1  2]\n              [1 10]\n              values = [1, 2, 3, 4, 5]\n              shape = [2 50]\n               </code></pre>"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> TakeManySparseFromTensorsMap (TensorFlow.TFOutput sparse_handles, TensorFlow.TFDataType dtype, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: sparse_handles
      type: TensorFlow.TFOutput
      description: >-
        1-D, The <code>N</code> serialized <code>SparseTensor</code> objects.
                      Shape: <code>[N]</code>.
    - id: dtype
      type: TensorFlow.TFDataType
      description: >-
        The <code>dtype</code> of the <code>SparseTensor</code> objects stored in the
                      <code>SparseTensorsMap</code>.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      The container name for the <code>SparseTensorsMap</code> read by this op.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      The shared name for the <code>SparseTensorsMap</code> read by this op.
                      It should not be blank; rather the <code>shared_name</code> or unique Operation name
                      of the Op that created the original <code>SparseTensorsMap</code> should be used.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TakeManySparseFromTensorsMap'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sparse_indices: 2-D.  The <code>indices</code> of the minibatch <code>SparseTensor</code>.
                      sparse_values: 1-D.  The <code>values</code> of the minibatch <code>SparseTensor</code>.
                      sparse_shape: 1-D.  The <code>shape</code> of the minibatch <code>SparseTensor</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.TakeManySparseFromTensorsMap*
  exceptions: []
- uid: TensorFlow.TFGraph.Tan(TensorFlow.TFOutput,System.String)
  id: Tan(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Tan(TFOutput, String)
  nameWithType: TFGraph.Tan(TFOutput, String)
  fullName: TFGraph.Tan(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes tan of x element-wise.
  syntax:
    content: public TensorFlow.TFOutput Tan (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Tan'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Tan*
  exceptions: []
- uid: TensorFlow.TFGraph.Tanh(TensorFlow.TFOutput,System.String)
  id: Tanh(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Tanh(TFOutput, String)
  nameWithType: TFGraph.Tanh(TFOutput, String)
  fullName: TFGraph.Tanh(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes hyperbolic tangent of <code>x</code> element-wise.
  syntax:
    content: public TensorFlow.TFOutput Tanh (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Tanh'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Tanh*
  exceptions: []
- uid: TensorFlow.TFGraph.TanhGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TanhGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TanhGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TanhGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.TanhGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the gradient for the tanh of <code>x</code> wrt its input.
  remarks: >-
    Specifically, <code>grad = dy * (1 - y*y)</code>, where <code>y = tanh(x)</code>, and <code>dy</code>
                  is the corresponding input gradient.
  syntax:
    content: public TensorFlow.TFOutput TanhGrad (TensorFlow.TFOutput y, TensorFlow.TFOutput dy, string operName = null);
    parameters:
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dy
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TanhGrad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TanhGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.TemporaryVariable(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String)
  id: TemporaryVariable(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TemporaryVariable(TFShape, TFDataType, String, String)
  nameWithType: TFGraph.TemporaryVariable(TFShape, TFDataType, String, String)
  fullName: TFGraph.TemporaryVariable(TFShape, TFDataType, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns a tensor that may be mutated, but only persists within a single step.
  remarks: "This is an experimental op for internal use only and it is possible to use this\n              op in unsafe ways.  DO NOT USE unless you fully understand the risks.\n              \n              It is the caller's responsibility to ensure that 'ref' is eventually passed to a\n              matching 'DestroyTemporaryVariable' op after all other uses have completed.\n              \n              Outputs a ref to the tensor state so it may be read or modified.\n              \n              E.g.\n              var = state_ops._temporary_variable([1, 2], types.float_)\n              var_name = var.op.name\n              var = state_ops.assign(var, [[4.0, 5.0]])\n              var = state_ops.assign_add(var, [[6.0, 7.0]])\n              final = state_ops._destroy_temporary_variable(var, var_name=var_name)"
  syntax:
    content: public TensorFlow.TFOutput TemporaryVariable (TensorFlow.TFShape shape, TensorFlow.TFDataType dtype, string var_name = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFShape
      description: The shape of the variable tensor.
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of elements in the variable tensor.
    - id: var_name
      type: System.String
      description: >-
        Optional argument
                      Overrides the name used for the temporary variable resource. Default
                      value is the name of the 'TemporaryVariable' op (which is guaranteed unique).
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TemporaryVariable'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A reference to the variable tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TemporaryVariable*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayCloseV2(TensorFlow.TFOutput,System.String)
  id: TensorArrayCloseV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayCloseV2(TFOutput, String)
  nameWithType: TFGraph.TensorArrayCloseV2(TFOutput, String)
  fullName: TFGraph.TensorArrayCloseV2(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated. Use TensorArrayCloseV3
  syntax:
    content: public TensorFlow.TFOperation TensorArrayCloseV2 (TensorFlow.TFOutput handle, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayCloseV2'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.TensorArrayCloseV2*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayCloseV3(TensorFlow.TFOutput,System.String)
  id: TensorArrayCloseV3(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayCloseV3(TFOutput, String)
  nameWithType: TFGraph.TensorArrayCloseV3(TFOutput, String)
  fullName: TFGraph.TensorArrayCloseV3(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Delete the TensorArray from its resource container.
  remarks: >-
    This enables the user to close and release the resource in the middle
                  of a step/run.
  syntax:
    content: public TensorFlow.TFOperation TensorArrayCloseV3 (TensorFlow.TFOutput handle, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a TensorArray (output of TensorArray or TensorArrayGrad).
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayCloseV3'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.TensorArrayCloseV3*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayConcatV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  id: TensorArrayConcatV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayConcatV2(TFOutput, TFOutput, TFDataType, TFShape, String)
  nameWithType: TFGraph.TensorArrayConcatV2(TFOutput, TFOutput, TFDataType, TFShape, String)
  fullName: TFGraph.TensorArrayConcatV2(TFOutput, TFOutput, TFDataType, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated. Use TensorArrayConcatV3
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> TensorArrayConcatV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, TensorFlow.TFDataType dtype, TensorFlow.TFShape element_shape_except0 = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: element_shape_except0
      type: TensorFlow.TFShape
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayConcatV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      value:
                      lengths:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.TensorArrayConcatV2*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayConcatV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  id: TensorArrayConcatV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayConcatV3(TFOutput, TFOutput, TFDataType, TFShape, String)
  nameWithType: TFGraph.TensorArrayConcatV3(TFOutput, TFOutput, TFDataType, TFShape, String)
  fullName: TFGraph.TensorArrayConcatV3(TFOutput, TFOutput, TFDataType, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Concat the elements from the TensorArray into value <code>value</code>.
  remarks: "Takes <code>T</code> elements of shapes\n              \n               <pre><code>\n              (n0 x d0 x d1 x ...), (n1 x d0 x d1 x ...), ..., (n(T-1) x d0 x d1 x ...)\n               </code></pre>\n              \n              and concatenates them into a Tensor of shape:\n              \n               <pre><code>\n               (n0 + n1 + ... + n(T-1) x d0 x d1 x ...)\n               </code></pre>\n              \n              All elements must have the same shape (excepting the first dimension)."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> TensorArrayConcatV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, TensorFlow.TFDataType dtype, TensorFlow.TFShape element_shape_except0 = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a TensorArray.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: A float scalar that enforces proper chaining of operations.
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of the elem that is returned.
    - id: element_shape_except0
      type: TensorFlow.TFShape
      description: >-
        Optional argument
                      The expected shape of an element, if known,
                      excluding the first dimension. Used to validate the shapes of
                      TensorArray elements. If this shape is not fully specified, concatenating
                      zero-size TensorArrays is an error.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayConcatV3'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      value: All of the elements in the TensorArray, concatenated along the first
                      axis.
                      lengths: A vector of the row sizes of the original T elements in the
                      value output.  In the example above, this would be the values:
                      <code>(n1, n2, ..., n(T-1))</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.TensorArrayConcatV3*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayGatherV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  id: TensorArrayGatherV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayGatherV2(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)
  nameWithType: TFGraph.TensorArrayGatherV2(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)
  fullName: TFGraph.TensorArrayGatherV2(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated. Use TensorArrayGatherV3
  syntax:
    content: public TensorFlow.TFOutput TensorArrayGatherV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput indices, TensorFlow.TFOutput flow_in, TensorFlow.TFDataType dtype, TensorFlow.TFShape element_shape = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: element_shape
      type: TensorFlow.TFShape
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGatherV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorArrayGatherV2*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayGatherV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  id: TensorArrayGatherV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayGatherV3(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)
  nameWithType: TFGraph.TensorArrayGatherV3(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)
  fullName: TFGraph.TensorArrayGatherV3(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gather specific elements from the TensorArray into output <code>value</code>.
  remarks: All elements selected by <code>indices</code> must have the same shape.
  syntax:
    content: public TensorFlow.TFOutput TensorArrayGatherV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput indices, TensorFlow.TFOutput flow_in, TensorFlow.TFDataType dtype, TensorFlow.TFShape element_shape = null, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a TensorArray.
    - id: indices
      type: TensorFlow.TFOutput
      description: The locations in the TensorArray from which to read tensor elements.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: A float scalar that enforces proper chaining of operations.
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of the elem that is returned.
    - id: element_shape
      type: TensorFlow.TFShape
      description: >-
        Optional argument
                      The expected shape of an element, if known. Used to
                      validate the shapes of TensorArray elements. If this shape is not
                      fully specified, gathering zero-size TensorArrays is an error.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGatherV3'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        All of the elements in the TensorArray, concatenated along a new
                      axis (the new dimension 0).
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorArrayGatherV3*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  id: TensorArrayGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayGradV2(TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.TensorArrayGradV2(TFOutput, TFOutput, String, String)
  fullName: TFGraph.TensorArrayGradV2(TFOutput, TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated. Use TensorArrayGradV3
  syntax:
    content: public TensorFlow.TFOutput TensorArrayGradV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, string source, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: To be added.
    - id: source
      type: System.String
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGradV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorArrayGradV2*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayGradV3(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  id: TensorArrayGradV3(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayGradV3(TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.TensorArrayGradV3(TFOutput, TFOutput, String, String)
  fullName: TFGraph.TensorArrayGradV3(TFOutput, TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a TensorArray for storing the gradients of values in the given handle.
  remarks: "If the given TensorArray gradient already exists, returns a reference to it.\n              \n              Locks the size of the original TensorArray by disabling its dynamic size flag.\n              \n              **A note about the input flow_in:**\n              \n              The handle flow_in forces the execution of the gradient lookup to occur\n              only after certain other operations have occurred.  For example, when\n              the forward TensorArray is dynamically sized, writes to this TensorArray\n              may resize the object.  The gradient TensorArray is statically sized based\n              on the size of the forward TensorArray when this operation executes.\n              Furthermore, the size of the forward TensorArray is frozen by this call.\n              As a result, the flow is used to ensure that the call to generate the gradient\n              TensorArray only happens after all writes are executed.\n              \n              In the case of dynamically sized TensorArrays, gradient computation should\n              only be performed on read operations that have themselves been chained via\n              flow to occur only after all writes have executed. That way the final size\n              of the forward TensorArray is known when this operation is called.\n              \n              **A note about the source attribute:**\n              \n              TensorArray gradient calls use an accumulator TensorArray object.  If\n              multiple gradients are calculated and run in the same session, the multiple\n              gradient nodes may accidentally flow through the same accumulator TensorArray.\n              This double counts and generally breaks the TensorArray gradient flow.\n              \n              The solution is to identify which gradient call this particular\n              TensorArray gradient is being called in.  This is performed by identifying\n              a unique string (e.g. \"gradients\", \"gradients_1\", ...) from the input\n              gradient Tensor's name.  This string is used as a suffix when creating\n              the TensorArray gradient object here (the attribute <code>source</code>).\n              \n              The attribute <code>source</code> is added as a suffix to the forward TensorArray's\n              name when performing the creation / lookup, so that each separate gradient\n              calculation gets its own TensorArray accumulator."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> TensorArrayGradV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, string source, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to the forward TensorArray.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: A float scalar that enforces proper chaining of operations.
    - id: source
      type: System.String
      description: >-
        The gradient source string, used to decide which gradient TensorArray
                      to return.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGradV3'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      grad_handle:
                      flow_out:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.TensorArrayGradV3*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayGradWithShape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  id: TensorArrayGradWithShape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayGradWithShape(TFOutput, TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.TensorArrayGradWithShape(TFOutput, TFOutput, TFOutput, String, String)
  fullName: TFGraph.TensorArrayGradWithShape(TFOutput, TFOutput, TFOutput, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a TensorArray for storing multiple gradients of values in the given handle.
  remarks: >-
    Similar to TensorArrayGradV3. However it creates an accumulator with an
                  expanded shape compared to the input TensorArray whose gradient is being
                  computed. This enables multiple gradients for the same TensorArray to be
                  calculated using the same accumulator.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> TensorArrayGradWithShape (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, TensorFlow.TFOutput shape_to_prepend, string source, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to the forward TensorArray.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: A float scalar that enforces proper chaining of operations.
    - id: shape_to_prepend
      type: TensorFlow.TFOutput
      description: >-
        An int32 vector representing a shape. Elements in the gradient accumulator will
                      have shape which is this shape_to_prepend value concatenated with shape of the
                      elements in the TensorArray corresponding to the input handle.
    - id: source
      type: System.String
      description: >-
        The gradient source string, used to decide which gradient TensorArray
                      to return.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayGradWithShape'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      grad_handle:
                      flow_out:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.TensorArrayGradWithShape*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayReadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: TensorArrayReadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayReadV2(TFOutput, TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorArrayReadV2(TFOutput, TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.TensorArrayReadV2(TFOutput, TFOutput, TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated. Use TensorArrayReadV3
  syntax:
    content: public TensorFlow.TFOutput TensorArrayReadV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput index, TensorFlow.TFOutput flow_in, TensorFlow.TFDataType dtype, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: index
      type: TensorFlow.TFOutput
      description: To be added.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayReadV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorArrayReadV2*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayReadV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: TensorArrayReadV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayReadV3(TFOutput, TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorArrayReadV3(TFOutput, TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.TensorArrayReadV3(TFOutput, TFOutput, TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Read an element from the TensorArray into output <code>value</code>.
  syntax:
    content: public TensorFlow.TFOutput TensorArrayReadV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput index, TensorFlow.TFOutput flow_in, TensorFlow.TFDataType dtype, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a TensorArray.
    - id: index
      type: TensorFlow.TFOutput
      description: To be added.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: A float scalar that enforces proper chaining of operations.
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of the elem that is returned.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayReadV3'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The tensor that is read from the TensorArray.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorArrayReadV3*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayScatterV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TensorArrayScatterV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayScatterV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArrayScatterV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArrayScatterV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated. Use TensorArrayScatterV3
  syntax:
    content: public TensorFlow.TFOutput TensorArrayScatterV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput indices, TensorFlow.TFOutput value, TensorFlow.TFOutput flow_in, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: value
      type: TensorFlow.TFOutput
      description: To be added.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayScatterV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorArrayScatterV2*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayScatterV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TensorArrayScatterV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayScatterV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArrayScatterV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArrayScatterV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Scatter the data from the input value into specific TensorArray elements.
  remarks: <code>indices</code> must be a vector, its length must match the first dim of <code>value</code>.
  syntax:
    content: public TensorFlow.TFOutput TensorArrayScatterV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput indices, TensorFlow.TFOutput value, TensorFlow.TFOutput flow_in, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a TensorArray.
    - id: indices
      type: TensorFlow.TFOutput
      description: The locations at which to write the tensor elements.
    - id: value
      type: TensorFlow.TFOutput
      description: The concatenated tensor to write to the TensorArray.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: A float scalar that enforces proper chaining of operations.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayScatterV3'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A float scalar that enforces proper chaining of operations.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorArrayScatterV3*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArraySizeV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TensorArraySizeV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArraySizeV2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArraySizeV2(TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArraySizeV2(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated. Use TensorArraySizeV3
  syntax:
    content: public TensorFlow.TFOutput TensorArraySizeV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySizeV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorArraySizeV2*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArraySizeV3(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TensorArraySizeV3(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArraySizeV3(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArraySizeV3(TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArraySizeV3(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Get the current size of the TensorArray.
  syntax:
    content: public TensorFlow.TFOutput TensorArraySizeV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a TensorArray (output of TensorArray or TensorArrayGrad).
    - id: flow_in
      type: TensorFlow.TFOutput
      description: A float scalar that enforces proper chaining of operations.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySizeV3'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The current size of the TensorArray.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorArraySizeV3*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArraySplitV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TensorArraySplitV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArraySplitV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArraySplitV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArraySplitV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated. Use TensorArraySplitV3
  syntax:
    content: public TensorFlow.TFOutput TensorArraySplitV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput value, TensorFlow.TFOutput lengths, TensorFlow.TFOutput flow_in, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: value
      type: TensorFlow.TFOutput
      description: To be added.
    - id: lengths
      type: TensorFlow.TFOutput
      description: To be added.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArraySplitV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorArraySplitV2*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArraySplitV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TensorArraySplitV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArraySplitV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArraySplitV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArraySplitV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  syntax:
    content: public TensorFlow.TFOutput TensorArraySplitV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput value, TensorFlow.TFOutput lengths, TensorFlow.TFOutput flow_in, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: value
      type: TensorFlow.TFOutput
      description: To be added.
    - id: lengths
      type: TensorFlow.TFOutput
      description: To be added.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: To be added.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.TensorArraySplitV3*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayV2(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)
  id: TensorArrayV2(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayV2(TFOutput, TFDataType, TFShape, Nullable<Boolean>, Nullable<Boolean>, String, String)
  nameWithType: TFGraph.TensorArrayV2(TFOutput, TFDataType, TFShape, Nullable<Boolean>, Nullable<Boolean>, String, String)
  fullName: TFGraph.TensorArrayV2(TFOutput, TFDataType, TFShape, Nullable<Boolean>, Nullable<Boolean>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated. Use TensorArrayV3
  syntax:
    content: public TensorFlow.TFOutput TensorArrayV2 (TensorFlow.TFOutput size, TensorFlow.TFDataType dtype, TensorFlow.TFShape element_shape = null, Nullable<bool> dynamic_size = null, Nullable<bool> clear_after_read = null, string tensor_array_name = null, string operName = null);
    parameters:
    - id: size
      type: TensorFlow.TFOutput
      description: To be added.
    - id: dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: element_shape
      type: TensorFlow.TFShape
      description: Optional argument
    - id: dynamic_size
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: clear_after_read
      type: System.Nullable{System.Boolean}
      description: Optional argument
    - id: tensor_array_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorArrayV2*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayV3(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)
  id: TensorArrayV3(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayV3(TFOutput, TFDataType, TFShape, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String, String)
  nameWithType: TFGraph.TensorArrayV3(TFOutput, TFDataType, TFShape, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String, String)
  fullName: TFGraph.TensorArrayV3(TFOutput, TFDataType, TFShape, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An array of Tensors of given size.
  remarks: Write data via Write and read via Read or Pack.
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> TensorArrayV3 (TensorFlow.TFOutput size, TensorFlow.TFDataType dtype, TensorFlow.TFShape element_shape = null, Nullable<bool> dynamic_size = null, Nullable<bool> clear_after_read = null, Nullable<bool> identical_element_shapes = null, string tensor_array_name = null, string operName = null);
    parameters:
    - id: size
      type: TensorFlow.TFOutput
      description: The size of the array.
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of the elements on the tensor_array.
    - id: element_shape
      type: TensorFlow.TFShape
      description: >-
        Optional argument
                      The expected shape of an element, if known. Used to
                      validate the shapes of TensorArray elements. If this shape is not
                      fully specified, gathering zero-size TensorArrays is an error.
    - id: dynamic_size
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      A boolean that determines whether writes to the TensorArray
                      are allowed to grow the size.  By default, this is not allowed.
    - id: clear_after_read
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true (default), Tensors in the TensorArray are cleared
                      after being read.  This disables multiple read semantics but allows early
                      release of memory.
    - id: identical_element_shapes
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true (default is false), then all
                      elements in the TensorArray will be expected to have have identical shapes.
                      This allows certain behaviors, like dynamically checking for
                      consistent shapes on write, and being able to fill in properly
                      shaped zero tensors on stack -- even if the element_shape attribute
                      is not fully defined.
    - id: tensor_array_name
      type: System.String
      description: >-
        Optional argument
                      Overrides the name used for the temporary tensor_array
                      resource. Default value is the name of the 'TensorArray' op (which
                      is guaranteed unique).
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayV3'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      handle: The handle to the TensorArray.
                      flow: A scalar used to control gradient flow.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.TensorArrayV3*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayWriteV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TensorArrayWriteV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayWriteV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArrayWriteV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArrayWriteV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Deprecated. Use TensorArrayGradV3
  syntax:
    content: public TensorFlow.TFOutput TensorArrayWriteV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput index, TensorFlow.TFOutput value, TensorFlow.TFOutput flow_in, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: index
      type: TensorFlow.TFOutput
      description: To be added.
    - id: value
      type: TensorFlow.TFOutput
      description: To be added.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayWriteV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorArrayWriteV2*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorArrayWriteV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TensorArrayWriteV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorArrayWriteV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArrayWriteV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArrayWriteV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Push an element onto the tensor_array.
  syntax:
    content: public TensorFlow.TFOutput TensorArrayWriteV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput index, TensorFlow.TFOutput value, TensorFlow.TFOutput flow_in, string operName = null);
    parameters:
    - id: handle
      type: TensorFlow.TFOutput
      description: The handle to a TensorArray.
    - id: index
      type: TensorFlow.TFOutput
      description: The position to write to inside the TensorArray.
    - id: value
      type: TensorFlow.TFOutput
      description: The tensor to write to the TensorArray.
    - id: flow_in
      type: TensorFlow.TFOutput
      description: A float scalar that enforces proper chaining of operations.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorArrayWriteV3'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A float scalar that enforces proper chaining of operations.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorArrayWriteV3*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorDataset(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)
  id: TensorDataset(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorDataset(TFOutput[], TFShape[], String)
  nameWithType: TFGraph.TensorDataset(TFOutput[], TFShape[], String)
  fullName: TFGraph.TensorDataset(TFOutput[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that emits <code>components</code> as a tuple of tensors once.
  syntax:
    content: public TensorFlow.TFOutput TensorDataset (TensorFlow.TFOutput[] components, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: components
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorListElementShape(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: TensorListElementShape(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorListElementShape(TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorListElementShape(TFOutput, TFDataType, String)
  fullName: TFGraph.TensorListElementShape(TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: The shape of the elements of the given list, as a tensor.
  remarks: >-
    input_handle: the list
                  element_shape: the shape of elements of the list
  syntax:
    content: public TensorFlow.TFOutput TensorListElementShape (TensorFlow.TFOutput input_handle, TensorFlow.TFDataType shape_type, string operName = null);
    parameters:
    - id: input_handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: shape_type
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListElementShape'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorListElementShape*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorListFromTensor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TensorListFromTensor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorListFromTensor(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorListFromTensor(TFOutput, TFOutput, String)
  fullName: TFGraph.TensorListFromTensor(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a TensorList which, when stacked, has the value of <code>tensor</code>.
  remarks: "Each tensor in the result list corresponds to one row of the input tensor.\n              \n              tensor: The input tensor.\n              output_handle: The list."
  syntax:
    content: public TensorFlow.TFOutput TensorListFromTensor (TensorFlow.TFOutput tensor, TensorFlow.TFOutput element_shape, string operName = null);
    parameters:
    - id: tensor
      type: TensorFlow.TFOutput
      description: To be added.
    - id: element_shape
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListFromTensor'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorListFromTensor*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorListGather(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: TensorListGather(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorListGather(TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorListGather(TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.TensorListGather(TFOutput, TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a Tensor by indexing into the TensorList.
  remarks: "Each row in the produced Tensor corresponds to the element in the TensorList\n              specified by the given index (see <code>tf.gather</code>).\n              \n              input_handle: The input tensor list.\n              indices: The indices used to index into the list.\n              values: The tensor."
  syntax:
    content: public TensorFlow.TFOutput TensorListGather (TensorFlow.TFOutput input_handle, TensorFlow.TFOutput indices, TensorFlow.TFDataType element_dtype, string operName = null);
    parameters:
    - id: input_handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: element_dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListGather'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorListGather*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorListGetItem(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: TensorListGetItem(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorListGetItem(TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorListGetItem(TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.TensorListGetItem(TFOutput, TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the item in the list with the given index.
  remarks: >-
    input_handle: the list
                  index: the position in the list from which an element will be retrieved
                  item: the element at that position
  syntax:
    content: public TensorFlow.TFOutput TensorListGetItem (TensorFlow.TFOutput input_handle, TensorFlow.TFOutput index, TensorFlow.TFDataType element_dtype, string operName = null);
    parameters:
    - id: input_handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: index
      type: TensorFlow.TFOutput
      description: To be added.
    - id: element_dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListGetItem'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorListGetItem*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorListLength(TensorFlow.TFOutput,System.String)
  id: TensorListLength(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorListLength(TFOutput, String)
  nameWithType: TFGraph.TensorListLength(TFOutput, String)
  fullName: TFGraph.TensorListLength(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the number of tensors in the input tensor list.
  remarks: >-
    input_handle: the input list
                  length: the number of tensors in the list
  syntax:
    content: public TensorFlow.TFOutput TensorListLength (TensorFlow.TFOutput input_handle, string operName = null);
    parameters:
    - id: input_handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListLength'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorListLength*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorListPopBack(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: TensorListPopBack(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorListPopBack(TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorListPopBack(TFOutput, TFDataType, String)
  fullName: TFGraph.TensorListPopBack(TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the last element of the input list as well as a list with all but that element.
  remarks: "Fails if the list is empty.\n              \n              input_handle: the input list\n              tensor: the withdrawn last element of the list\n              element_dtype: the type of elements in the list\n              element_shape: the shape of the output tensor"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> TensorListPopBack (TensorFlow.TFOutput input_handle, TensorFlow.TFDataType element_dtype, string operName = null);
    parameters:
    - id: input_handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: element_dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListPopBack'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      output_handle:
                      tensor:
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.TensorListPopBack*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorListPushBack(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TensorListPushBack(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorListPushBack(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorListPushBack(TFOutput, TFOutput, String)
  fullName: TFGraph.TensorListPushBack(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns a list list which has the passed-in <code>Tensor</code> as last element and the other elements of the given list in <code>input_handle</code>.
  remarks: >-
    tensor: The tensor to put on the list.
                  input_handle: The old list.
                  output_handle: A list with the elements of the old list followed by tensor.
                  element_dtype: the type of elements in the list.
                  element_shape: a shape compatible with that of elements in the list.
  syntax:
    content: public TensorFlow.TFOutput TensorListPushBack (TensorFlow.TFOutput input_handle, TensorFlow.TFOutput tensor, string operName = null);
    parameters:
    - id: input_handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: tensor
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListPushBack'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorListPushBack*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorListReserve(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  id: TensorListReserve(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorListReserve(TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorListReserve(TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.TensorListReserve(TFOutput, TFOutput, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: List of the given size with empty elements.
  remarks: >-
    element_shape: the shape of the future elements of the list
                  num_elements: the number of elements to reserve
                  handle: the output list
                  element_dtype: the desired type of elements in the list.
  syntax:
    content: public TensorFlow.TFOutput TensorListReserve (TensorFlow.TFOutput element_shape, TensorFlow.TFOutput num_elements, TensorFlow.TFDataType element_dtype, string operName = null);
    parameters:
    - id: element_shape
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_elements
      type: TensorFlow.TFOutput
      description: To be added.
    - id: element_dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListReserve'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorListReserve*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorListScatter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TensorListScatter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorListScatter(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorListScatter(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorListScatter(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a TensorList by indexing into a Tensor.
  remarks: "Each member of the TensorList corresponds to one row of the input tensor,\n              specified by the given index (see <code>tf.gather</code>).\n              \n              tensor: The input tensor.\n              indices: The indices used to index into the list.\n              element_shape: The shape of the elements in the list (can be less specified than\n              the shape of the tensor).\n              output_handle: The TensorList."
  syntax:
    content: public TensorFlow.TFOutput TensorListScatter (TensorFlow.TFOutput tensor, TensorFlow.TFOutput indices, TensorFlow.TFOutput element_shape, string operName = null);
    parameters:
    - id: tensor
      type: TensorFlow.TFOutput
      description: To be added.
    - id: indices
      type: TensorFlow.TFOutput
      description: To be added.
    - id: element_shape
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListScatter'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorListScatter*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorListSetItem(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TensorListSetItem(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorListSetItem(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorListSetItem(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorListSetItem(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Sets the index-th position of the list to contain the given tensor.
  remarks: >-
    input_handle: the list
                  index: the position in the list to which the tensor will be assigned
                  item: the element to be assigned to that position
                  output_handle: the new list, with the element in the proper position
  syntax:
    content: public TensorFlow.TFOutput TensorListSetItem (TensorFlow.TFOutput input_handle, TensorFlow.TFOutput index, TensorFlow.TFOutput item, string operName = null);
    parameters:
    - id: input_handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: index
      type: TensorFlow.TFOutput
      description: To be added.
    - id: item
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListSetItem'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorListSetItem*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorListStack(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)
  id: TensorListStack(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorListStack(TFOutput, TFDataType, Nullable<Int64>, String)
  nameWithType: TFGraph.TensorListStack(TFOutput, TFDataType, Nullable<Int64>, String)
  fullName: TFGraph.TensorListStack(TFOutput, TFDataType, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Stacks all tensors in the list.
  remarks: "Requires that all tensors have the same shape.\n              \n              input_handle: the input list\n              tensor: the gathered result\n              num_elements: optional. If not -1, the number of elements in the list."
  syntax:
    content: public TensorFlow.TFOutput TensorListStack (TensorFlow.TFOutput input_handle, TensorFlow.TFDataType element_dtype, Nullable<long> num_elements = null, string operName = null);
    parameters:
    - id: input_handle
      type: TensorFlow.TFOutput
      description: To be added.
    - id: element_dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: num_elements
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorListStack'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorListStack*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorSliceDataset(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)
  id: TensorSliceDataset(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorSliceDataset(TFOutput[], TFShape[], String)
  nameWithType: TFGraph.TensorSliceDataset(TFOutput[], TFShape[], String)
  fullName: TFGraph.TensorSliceDataset(TFOutput[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that emits each dim-0 slice of <code>components</code> once.
  syntax:
    content: public TensorFlow.TFOutput TensorSliceDataset (TensorFlow.TFOutput[] components, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: components
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorSliceDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorSliceDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorSummary(TensorFlow.TFOutput,System.String,System.String[],System.String,System.String)
  id: TensorSummary(TensorFlow.TFOutput,System.String,System.String[],System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorSummary(TFOutput, String, String[], String, String)
  nameWithType: TFGraph.TensorSummary(TFOutput, String, String[], String, String)
  fullName: TFGraph.TensorSummary(TFOutput, String, String[], String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs a <code>Summary</code> protocol buffer with a tensor.
  remarks: >-
    This op is being phased out in favor of TensorSummaryV2, which lets callers pass
                  a tag as well as a serialized SummaryMetadata proto string that contains
                  plugin-specific data. We will keep this op to maintain backwards compatibility.
  syntax:
    content: public TensorFlow.TFOutput TensorSummary (TensorFlow.TFOutput tensor, string description = null, string[] labels = null, string display_name = null, string operName = null);
    parameters:
    - id: tensor
      type: TensorFlow.TFOutput
      description: A tensor to serialize.
    - id: description
      type: System.String
      description: >-
        Optional argument
                      A json-encoded SummaryDescription proto.
    - id: labels
      type: System.String[]
      description: >-
        Optional argument
                      An unused list of strings.
    - id: display_name
      type: System.String
      description: >-
        Optional argument
                      An unused string.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorSummary'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorSummary*
  exceptions: []
- uid: TensorFlow.TFGraph.TensorSummaryV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TensorSummaryV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TensorSummaryV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorSummaryV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorSummaryV2(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs a <code>Summary</code> protocol buffer with a tensor and per-plugin data.
  syntax:
    content: public TensorFlow.TFOutput TensorSummaryV2 (TensorFlow.TFOutput tag, TensorFlow.TFOutput tensor, TensorFlow.TFOutput serialized_summary_metadata, string operName = null);
    parameters:
    - id: tag
      type: TensorFlow.TFOutput
      description: A string attached to this summary. Used for organization in TensorBoard.
    - id: tensor
      type: TensorFlow.TFOutput
      description: A tensor to serialize.
    - id: serialized_summary_metadata
      type: TensorFlow.TFOutput
      description: >-
        A serialized SummaryMetadata proto. Contains plugin
                      data.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TensorSummaryV2'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TensorSummaryV2*
  exceptions: []
- uid: TensorFlow.TFGraph.TextLineDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TextLineDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TextLineDataset(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TextLineDataset(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TextLineDataset(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that emits the lines of one or more text files.
  syntax:
    content: public TensorFlow.TFOutput TextLineDataset (TensorFlow.TFOutput filenames, TensorFlow.TFOutput compression_type, TensorFlow.TFOutput buffer_size, string operName = null);
    parameters:
    - id: filenames
      type: TensorFlow.TFOutput
      description: >-
        A scalar or a vector containing the name(s) of the file(s) to be
                      read.
    - id: compression_type
      type: TensorFlow.TFOutput
      description: >-
        A scalar containing either (i) the empty string (no
                      compression), (ii) "ZLIB", or (iii) "GZIP".
    - id: buffer_size
      type: TensorFlow.TFOutput
      description: A scalar containing the number of bytes to buffer.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TextLineDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TextLineDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.TextLineReader(System.Nullable{System.Int64},System.String,System.String,System.String)
  id: TextLineReader(System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TextLineReader(Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.TextLineReader(Nullable<Int64>, String, String, String)
  fullName: TFGraph.TextLineReader(Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A Reader that outputs the lines of a file delimited by '\n'.
  syntax:
    content: public TensorFlow.TFOutput TextLineReader (Nullable<long> skip_header_lines = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: skip_header_lines
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of lines to skip from the beginning of every file.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TextLineReader'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to reference the Reader.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TextLineReader*
  exceptions: []
- uid: TensorFlow.TFGraph.TextLineReaderV2(System.Nullable{System.Int64},System.String,System.String,System.String)
  id: TextLineReaderV2(System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TextLineReaderV2(Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.TextLineReaderV2(Nullable<Int64>, String, String, String)
  fullName: TFGraph.TextLineReaderV2(Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A Reader that outputs the lines of a file delimited by '\n'.
  syntax:
    content: public TensorFlow.TFOutput TextLineReaderV2 (Nullable<long> skip_header_lines = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: skip_header_lines
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Number of lines to skip from the beginning of every file.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TextLineReaderV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to reference the Reader.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TextLineReaderV2*
  exceptions: []
- uid: TensorFlow.TFGraph.TFRecordDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TFRecordDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TFRecordDataset(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TFRecordDataset(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TFRecordDataset(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that emits the records from one or more TFRecord files.
  syntax:
    content: public TensorFlow.TFOutput TFRecordDataset (TensorFlow.TFOutput filenames, TensorFlow.TFOutput compression_type, TensorFlow.TFOutput buffer_size, string operName = null);
    parameters:
    - id: filenames
      type: TensorFlow.TFOutput
      description: >-
        A scalar or vector containing the name(s) of the file(s) to be
                      read.
    - id: compression_type
      type: TensorFlow.TFOutput
      description: >-
        A scalar containing either (i) the empty string (no
                      compression), (ii) "ZLIB", or (iii) "GZIP".
    - id: buffer_size
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing the number of bytes to buffer. A value of
                      0 means no buffering will be performed.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TFRecordDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TFRecordDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.TFRecordReader(System.String,System.String,System.String,System.String)
  id: TFRecordReader(System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TFRecordReader(String, String, String, String)
  nameWithType: TFGraph.TFRecordReader(String, String, String, String)
  fullName: TFGraph.TFRecordReader(String, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A Reader that outputs the records from a TensorFlow Records file.
  syntax:
    content: public TensorFlow.TFOutput TFRecordReader (string container = null, string shared_name = null, string compression_type = null, string operName = null);
    parameters:
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: compression_type
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TFRecordReader'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to reference the Reader.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TFRecordReader*
  exceptions: []
- uid: TensorFlow.TFGraph.TFRecordReaderV2(System.String,System.String,System.String,System.String)
  id: TFRecordReaderV2(System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TFRecordReaderV2(String, String, String, String)
  nameWithType: TFGraph.TFRecordReaderV2(String, String, String, String)
  fullName: TFGraph.TFRecordReaderV2(String, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A Reader that outputs the records from a TensorFlow Records file.
  syntax:
    content: public TensorFlow.TFOutput TFRecordReaderV2 (string container = null, string shared_name = null, string compression_type = null, string operName = null);
    parameters:
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: compression_type
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TFRecordReaderV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to reference the Reader.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TFRecordReaderV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ThreadUnsafeUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: ThreadUnsafeUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ThreadUnsafeUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.ThreadUnsafeUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.ThreadUnsafeUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generates labels for candidate sampling with a learned unigram distribution.
  remarks: "See explanations of candidate sampling and the data formats at\n              go/candidate-sampling.\n              \n              For each batch, this op picks a single set of sampled candidate labels.\n              \n              The advantages of sampling candidates per-batch are simplicity and the\n              possibility of efficient dense matrix multiplication. The disadvantage is that\n              the sampled candidates must be chosen independently of the context and of the\n              true labels."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> ThreadUnsafeUnigramCandidateSampler (TensorFlow.TFOutput true_classes, long num_true, long num_sampled, bool unique, long range_max, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: true_classes
      type: TensorFlow.TFOutput
      description: >-
        A batch_size * num_true matrix, in which each row contains the
                      IDs of the num_true target_classes in the corresponding original label.
    - id: num_true
      type: System.Int64
      description: Number of true labels per context.
    - id: num_sampled
      type: System.Int64
      description: Number of candidates to randomly sample.
    - id: unique
      type: System.Boolean
      description: >-
        If unique is true, we sample with rejection, so that all sampled
                      candidates in a batch are unique. This requires some approximation to
                      estimate the post-rejection sampling probabilities.
    - id: range_max
      type: System.Int64
      description: The sampler will sample integers from the interval [0, range_max).
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either seed or seed2 are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      An second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ThreadUnsafeUnigramCandidateSampler'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sampled_candidates: A vector of length num_sampled, in which each element is
                      the ID of a sampled candidate.
                      true_expected_count: A batch_size * num_true matrix, representing
                      the number of times each candidate is expected to occur in a batch
                      of sampled candidates. If unique=true, then this is a probability.
                      sampled_expected_count: A vector of length num_sampled, for each sampled
                      candidate representing the number of times the candidate is expected
                      to occur in a batch of sampled candidates.  If unique=true, then this is a
                      probability.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.ThreadUnsafeUnigramCandidateSampler*
  exceptions: []
- uid: TensorFlow.TFGraph.Tile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Tile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Tile(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Tile(TFOutput, TFOutput, String)
  fullName: TFGraph.Tile(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Constructs a tensor by tiling a given tensor.
  remarks: >-
    This operation creates a new tensor by replicating <code>input</code><code>multiples</code> times.
                  The output tensor's i'th dimension has <code>input.dims(i) * multiples[i]</code> elements,
                  and the values of <code>input</code> are replicated <code>multiples[i]</code> times along the 'i'th
                  dimension. For example, tiling <code>[a b c d]</code> by <code>[2]</code> produces
                  <code>[a b c d a b c d]</code>.
  syntax:
    content: public TensorFlow.TFOutput Tile (TensorFlow.TFOutput input, TensorFlow.TFOutput multiples, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 1-D or higher.
    - id: multiples
      type: TensorFlow.TFOutput
      description: 1-D. Length must be the same as the number of dimensions in <code>input</code>
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Tile'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Tile*
  exceptions: []
- uid: TensorFlow.TFGraph.TileGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TileGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TileGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TileGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.TileGrad(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the gradient of <code>Tile</code>.
  remarks: >-
    Since <code>Tile</code> takes an input and repeats the input <code>multiples</code> times
                  along each dimension, <code>TileGrad</code> takes in <code>multiples</code> and aggregates
                  each repeated tile of <code>input</code> into <code>output</code>.
  syntax:
    content: public TensorFlow.TFOutput TileGrad (TensorFlow.TFOutput input, TensorFlow.TFOutput multiples, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: multiples
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TileGrad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TileGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.Timestamp(System.String)
  id: Timestamp(System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Timestamp(String)
  nameWithType: TFGraph.Timestamp(String)
  fullName: TFGraph.Timestamp(String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Provides the time since epoch in seconds.
  remarks: "Returns the timestamp as a <code>float64</code> for seconds since the Unix epoch.\n              \n              Note: the timestamp is computed when the op is executed, not when it is added\n              to the graph."
  syntax:
    content: public TensorFlow.TFOutput Timestamp (string operName = null);
    parameters:
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Timestamp'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Timestamp*
  exceptions: []
- uid: TensorFlow.TFGraph.ToFunction(System.String,System.String,TensorFlow.TFOperation[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String[],System.Boolean,TensorFlow.TFStatus)
  id: ToFunction(System.String,System.String,TensorFlow.TFOperation[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String[],System.Boolean,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ToFunction(String, String, TFOperation[], TFOutput[], TFOutput[], String[], Boolean, TFStatus)
  nameWithType: TFGraph.ToFunction(String, String, TFOperation[], TFOutput[], TFOutput[], String[], Boolean, TFStatus)
  fullName: TFGraph.ToFunction(String, String, TFOperation[], TFOutput[], TFOutput[], String[], Boolean, TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a TFFunction from a TFGraph
  remarks: >-
    <p>
                  This method converts the graph whose operations (or a subset of its operations) will be converted
                  into a TFFunction.
                </p>
        <p>
                  Note that when the same TF_Output is listed as both an input and an output,
                  the corresponding function's output will equal to this input,
                  instead of the original node's output.
                </p>
        <p>
                Callers must also satisfy the following constraints:
                </p>
        <p>
          <code>inputs</code> cannot refer to TFOutputs within a control flow context. For
                  example, one cannot use the output of "switch" node as input.
                </p>
        <p>
          <code>inputs</code> and <code>outputs</code> cannot have reference types. Reference types are
                  not exposed through C API and are being replaced with Resources. We support
                  reference types inside function's body to support legacy code. Do not
                  use them in new code.
                </p>
        <p>
                  Every node in the function's body must have all of its inputs (including
                  control inputs). In other words, for every node in the body, each input
                  must be either listed in <code>inputs</code> or must come from another node in
                  the body. In particular, it is an error to have a control edge going from
                  a node outside of the body into a node in the body. This applies to control
                  edges going from nodes referenced in <code>inputs</code> to nodes in the body when
                  the former nodes are not in the body (automatically skipped or not
                  included in explicitly specified body).
                </p>
  syntax:
    content: public TensorFlow.TFFunction ToFunction (string functionName, string description, TensorFlow.TFOperation[] operations, TensorFlow.TFOutput[] inputs, TensorFlow.TFOutput[] outputs, string[] outputNames, bool appendHashToFunctionName = false, TensorFlow.TFStatus status = null);
    parameters:
    - id: functionName
      type: System.String
      description: Name of the new function.  Should match the operation name (OpDef.name) regexp [A-Z][A-Za-z0-9_.\\-/]*.  If appendHashToFunctioName is false, the name must be unique (at least those registered in graphs where this function will be used).
    - id: description
      type: System.String
      description: Optional, human readable description of this function.
    - id: operations
      type: TensorFlow.TFOperation[]
      description: "Array of operations to become the body of the function or null.  \n                If no array is given , all the\n                operations in function body will become part of the function\n                except operations referenced in inputs. These operations\n                must have a single output (these operations are typically\n                placeholders created for the sole purpose of representing\n                an input).\n            \n                If an array is given, all operations\n                in it will become part of the function. In particular, no\n                automatic skipping of dummy input operations is performed."
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: >-
        Array that specify the inputs to the function, or null.  The names used for function inputs are normalized
                        names of the operations (usually placeholders) pointed to by
                        inputs.  These operation names should start with a letter.
                        Normalization will convert all letters to lowercase and
                        non-alphanumeric characters to '_' to make resulting names match
                        the "[a-z][a-z0-9_]*" pattern for operation argument names.
                        `inputs` cannot contain the same tensor twice.
    - id: outputs
      type: TensorFlow.TFOutput[]
      description: rray that specify the inputs to the function, or null.   This can contain the same tensor twice.
    - id: outputNames
      type: System.String[]
      description: The names of the function's outputs.   The array either has the same elements of outputs, or be null.   Names must match "[a-z][a-z0-9_]*" regexp, if null is passed, the names are generated automatically.
    - id: appendHashToFunctionName
      type: System.Boolean
      description: If set to <code>true</code> appends hash to functionName, otherwise it will use the specified name in functionName.
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
    return:
      type: TensorFlow.TFFunction
      description: The function.
  overload: TensorFlow.TFGraph.ToFunction*
  exceptions: []
- uid: TensorFlow.TFGraph.ToGraphDef(TensorFlow.TFBuffer,TensorFlow.TFStatus)
  id: ToGraphDef(TensorFlow.TFBuffer,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ToGraphDef(TFBuffer, TFStatus)
  nameWithType: TFGraph.ToGraphDef(TFBuffer, TFStatus)
  fullName: TFGraph.ToGraphDef(TFBuffer, TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Write out a serialized representation of the graph (as a GraphDef protocol buffer message) into <code>outputGraphDef</code>.
  syntax:
    content: public void ToGraphDef (TensorFlow.TFBuffer outputGraphDef, TensorFlow.TFStatus status = null);
    parameters:
    - id: outputGraphDef
      type: TensorFlow.TFBuffer
      description: Target buffer where the graphs is serialized into.
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
  overload: TensorFlow.TFGraph.ToGraphDef*
  exceptions: []
- uid: TensorFlow.TFGraph.TopK(TensorFlow.TFOutput,System.Int64,System.Nullable{System.Boolean},System.String)
  id: TopK(TensorFlow.TFOutput,System.Int64,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TopK(TFOutput, Int64, Nullable<Boolean>, String)
  nameWithType: TFGraph.TopK(TFOutput, Int64, Nullable<Boolean>, String)
  fullName: TFGraph.TopK(TFOutput, Int64, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Finds values and indices of the <code>k</code> largest elements for the last dimension.
  remarks: "If the input is a vector (rank-1), finds the <code>k</code> largest entries in the vector\n              and outputs their values and indices as vectors.  Thus <code>values[j]</code> is the\n              <code>j</code>-th largest entry in <code>input</code>, and its index is <code>indices[j]</code>.\n              \n              For matrices (resp. higher rank input), computes the top <code>k</code> entries in each\n              row (resp. vector along the last dimension).  Thus,\n              \n              values.shape = indices.shape = input.shape[:-1] + [k]\n              \n              If two elements are equal, the lower-index element appears first.\n              \n              If <code>k</code> varies dynamically, use <code>TopKV2</code> below."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> TopK (TensorFlow.TFOutput input, long k, Nullable<bool> sorted = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 1-D or higher with last dimension at least <code>k</code>.
    - id: k
      type: System.Int64
      description: >-
        Number of top elements to look for along the last dimension (along each
                      row for matrices).
    - id: sorted
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true the resulting <code>k</code> elements will be sorted by the values in
                      descending order.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TopK'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      values: The <code>k</code> largest elements along each last dimensional slice.
                      indices: The indices of <code>values</code> within the last dimension of <code>input</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.TopK*
  exceptions: []
- uid: TensorFlow.TFGraph.TopKV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  id: TopKV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TopKV2(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.TopKV2(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.TopKV2(TFOutput, TFOutput, Nullable<Boolean>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Finds values and indices of the <code>k</code> largest elements for the last dimension.
  remarks: "If the input is a vector (rank-1), finds the <code>k</code> largest entries in the vector\n              and outputs their values and indices as vectors.  Thus <code>values[j]</code> is the\n              <code>j</code>-th largest entry in <code>input</code>, and its index is <code>indices[j]</code>.\n              \n              For matrices (resp. higher rank input), computes the top <code>k</code> entries in each\n              row (resp. vector along the last dimension).  Thus,\n              \n              values.shape = indices.shape = input.shape[:-1] + [k]\n              \n              If two elements are equal, the lower-index element appears first."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> TopKV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput k, Nullable<bool> sorted = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: 1-D or higher with last dimension at least <code>k</code>.
    - id: k
      type: TensorFlow.TFOutput
      description: >-
        0-D.  Number of top elements to look for along the last dimension (along each
                      row for matrices).
    - id: sorted
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      If true the resulting <code>k</code> elements will be sorted by the values in
                      descending order.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TopKV2'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      values: The <code>k</code> largest elements along each last dimensional slice.
                      indices: The indices of <code>values</code> within the last dimension of <code>input</code>.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.TopKV2*
  exceptions: []
- uid: TensorFlow.TFGraph.ToString
  id: ToString
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ToString()
  nameWithType: TFGraph.ToString()
  fullName: TFGraph.ToString()
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: To be added.
  overload: TensorFlow.TFGraph.ToString*
  exceptions: []
- uid: TensorFlow.TFGraph.TPUEmbeddingActivations(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.String)
  id: TPUEmbeddingActivations(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TPUEmbeddingActivations(TFOutput, TFOutput, Int64, Int64, String)
  nameWithType: TFGraph.TPUEmbeddingActivations(TFOutput, TFOutput, Int64, Int64, String)
  fullName: TFGraph.TPUEmbeddingActivations(TFOutput, TFOutput, Int64, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: An op enabling differentiation of TPU Embeddings.
  remarks: >-
    This op simply returns its first input, which is assumed to have been sliced
                  from the Tensors returned by TPUEmbeddingDequeueActivations. The presence of this
                  op, and its first argument being a trainable Variable, enables automatic
                  differentiation of graphs containing embeddings via the TPU Embedding Python
                  libraries.
  syntax:
    content: public TensorFlow.TFOutput TPUEmbeddingActivations (TensorFlow.TFOutput embedding_variable, TensorFlow.TFOutput sliced_activations, long table_id, long lookup_id, string operName = null);
    parameters:
    - id: embedding_variable
      type: TensorFlow.TFOutput
      description: A trainable variable, enabling optimizers to find this op.
    - id: sliced_activations
      type: TensorFlow.TFOutput
      description: The embedding activations Tensor to return.
    - id: table_id
      type: System.Int64
      description: >-
        The id of the table in the embedding layer configuration from which
                      these activations were computed.
    - id: lookup_id
      type: System.Int64
      description: >-
        Identifier of the set of embedding indices which produced these
                      activations.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUEmbeddingActivations'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TPUEmbeddingActivations*
  exceptions: []
- uid: TensorFlow.TFGraph.TPUReplicatedInput(TensorFlow.TFOutput[],System.String)
  id: TPUReplicatedInput(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TPUReplicatedInput(TFOutput[], String)
  nameWithType: TFGraph.TPUReplicatedInput(TFOutput[], String)
  fullName: TFGraph.TPUReplicatedInput(TFOutput[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Operator that connects N unreplicated inputs to an N-way replicated TPU computation.
  syntax:
    content: public TensorFlow.TFOutput TPUReplicatedInput (TensorFlow.TFOutput[] inputs, string operName = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUReplicatedInput'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TPUReplicatedInput*
  exceptions: []
- uid: TensorFlow.TFGraph.TPUReplicatedOutput(TensorFlow.TFOutput,System.Int64,System.String)
  id: TPUReplicatedOutput(TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TPUReplicatedOutput(TFOutput, Int64, String)
  nameWithType: TFGraph.TPUReplicatedOutput(TFOutput, Int64, String)
  fullName: TFGraph.TPUReplicatedOutput(TFOutput, Int64, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Operator that connects the output of an N-way replicated TPU computation to N separate outputs.
  syntax:
    content: public TensorFlow.TFOutput[] TPUReplicatedOutput (TensorFlow.TFOutput input, long num_replicas, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: num_replicas
      type: System.Int64
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TPUReplicatedOutput'.
    return:
      type: TensorFlow.TFOutput[]
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TPUReplicatedOutput*
  exceptions: []
- uid: TensorFlow.TFGraph.Transpose(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Transpose(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Transpose(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Transpose(TFOutput, TFOutput, String)
  fullName: TFGraph.Transpose(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Shuffle dimensions of x according to a permutation.
  remarks: >-
    The output <code>y</code> has the same rank as <code>x</code>. The shapes of <code>x</code> and <code>y</code> satisfy:
                  <code>y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]</code>
  syntax:
    content: public TensorFlow.TFOutput Transpose (TensorFlow.TFOutput x, TensorFlow.TFOutput perm, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: perm
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Transpose'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Transpose*
  exceptions: []
- uid: TensorFlow.TFGraph.Transpose(TensorFlow.TFOutput,System.String)
  id: Transpose(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Transpose(TFOutput, String)
  nameWithType: TFGraph.Transpose(TFOutput, String)
  fullName: TFGraph.Transpose(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Shuffle dimensions of x according to a permutation.
  remarks: >-
    The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:
                    `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`
  syntax:
    content: public TensorFlow.TFOutput Transpose (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Transpose'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Transpose*
  exceptions: []
- uid: TensorFlow.TFGraph.TruncateDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TruncateDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TruncateDiv(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TruncateDiv(TFOutput, TFOutput, String)
  fullName: TFGraph.TruncateDiv(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns x / y element-wise for integer types.
  remarks: "Truncation designates that negative numbers will round fractional quantities\n              toward zero. I.e. -7 / 5 = -1. This matches C semantics but it is different\n              than Python semantics. See <code>FloorDiv</code> for a division function that matches\n              Python Semantics.\n              \n              *NOTE*: <code>TruncateDiv</code> supports broadcasting. More about broadcasting\n              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)"
  syntax:
    content: public TensorFlow.TFOutput TruncateDiv (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TruncateDiv'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TruncateDiv*
  exceptions: []
- uid: TensorFlow.TFGraph.TruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: TruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TruncatedNormal(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.TruncatedNormal(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.TruncatedNormal(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs random values from a truncated normal distribution.
  remarks: >-
    The generated values follow a normal distribution with mean 0 and standard
                  deviation 1, except that values whose magnitude is more than 2 standard
                  deviations from the mean are dropped and re-picked.
  syntax:
    content: public TensorFlow.TFOutput TruncatedNormal (TensorFlow.TFOutput shape, TensorFlow.TFDataType dtype, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFOutput
      description: The shape of the output tensor.
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of the output.
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      A second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TruncatedNormal'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A tensor of the specified shape filled with random truncated normal
                      values.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TruncatedNormal*
  exceptions: []
- uid: TensorFlow.TFGraph.TruncateMod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: TruncateMod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TruncateMod(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TruncateMod(TFOutput, TFOutput, String)
  fullName: TFGraph.TruncateMod(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns element-wise remainder of division. This emulates C semantics in that
  remarks: "the result here is consistent with a truncating divide. E.g. <code>truncate(x / y) *\n              y + truncate_mod(x, y) = x</code>.\n              \n              *NOTE*: <code>TruncateMod</code> supports broadcasting. More about broadcasting\n              [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)"
  syntax:
    content: public TensorFlow.TFOutput TruncateMod (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TruncateMod'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.TruncateMod*
  exceptions: []
- uid: TensorFlow.TFGraph.TryEvaluateConstant(TensorFlow.TFOutput,TensorFlow.TFTensor@)
  id: TryEvaluateConstant(TensorFlow.TFOutput,TensorFlow.TFTensor@)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TryEvaluateConstant(TFOutput, TFTensor)
  nameWithType: TFGraph.TryEvaluateConstant(TFOutput, TFTensor)
  fullName: TFGraph.TryEvaluateConstant(TFOutput, TFTensor)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: >-
    Attempts to evaluate the <code>output</code>.   This is only possible if <code>output</code> does not
                depend on any graph inputs - the function is safe to call if this is not the case though.
  syntax:
    content: public bool TryEvaluateConstant (TensorFlow.TFOutput output, ref TensorFlow.TFTensor tensor);
    parameters:
    - id: output
      type: TensorFlow.TFOutput
      description: Output.
    - id: tensor
      type: TensorFlow.TFTensor
      description: Tensor.
    return:
      type: System.Boolean
      description: <code>true</code>, if the evaluation is successful, in which case the result is returned in <code>tensor</code>, <code>false</code> otherwise.
  overload: TensorFlow.TFGraph.TryEvaluateConstant*
  exceptions: []
- uid: TensorFlow.TFGraph.TryRpc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  id: TryRpc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: TryRpc(TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  nameWithType: TFGraph.TryRpc(TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  fullName: TFGraph.TryRpc(TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Perform batches of RPC requests.
  remarks: "This op asynchronously performs either a single RPC request, or a batch\n              of requests.  RPC requests are defined by three main parameters:\n              \n              - <code>address</code> (the host+port or BNS address of the request)\n              - <code>method</code> (the method name for the request)\n              - <code>request</code> (the serialized proto string, or vector of strings,\n              of the RPC request argument).\n              \n              For example, if you have an RPC service running on port localhost:2345,\n              and its interface is configured with the following proto declaration:\n              \n               <pre><code>\n              service MyService {\n              rpc MyMethod(MyRequestProto) returns (MyResponseProto) {\n              }\n              };\n               </code></pre>\n              \n              then call this op with arguments:\n              \n               <pre><code>\n              address = \"localhost:2345\"\n              method = \"MyService/MyMethod\"\n               </code></pre>\n              \n              The <code>request</code> tensor is a string tensor representing serialized <code>MyRequestProto</code>\n              strings; and the output string tensor <code>response</code> will have the same shape\n              and contain (upon successful completion) corresponding serialized\n              <code>MyResponseProto</code> strings.\n              \n              For example, to send a single, empty, <code>MyRequestProto</code>, call\n              this op with <code>request = \"\"</code>.  To send 5 **parallel** empty requests,\n              call this op with <code>request = [\"\", \"\", \"\", \"\", \"\"]</code>.\n              \n              More generally, one can create a batch of <code>MyRequestProto</code> serialized protos\n              from regular batched tensors using the <code>encode_proto</code> op, and convert\n              the response <code>MyResponseProto</code> serialized protos to batched tensors\n              using the <code>decode_proto</code> op.\n              \n              **NOTE** Working with serialized proto strings is faster than instantiating\n              actual proto objects in memory, so no performance degradation is expected\n              compared to writing custom kernels for this workflow.\n              \n              Unlike the standard <code>Rpc</code> op, if the connection fails or the remote worker\n              returns an error status, this op does **not** reraise the exception.\n              Instead, the <code>status_code</code> and <code>status_message</code> entry for the corresponding RPC\n              call is set with the error returned from the RPC call.  The <code>response</code> tensor\n              will contain valid response values for those minibatch entries whose RPCs did\n              not fail; the rest of the entries will have empty strings."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> TryRpc (TensorFlow.TFOutput address, TensorFlow.TFOutput method, TensorFlow.TFOutput request, string protocol = null, Nullable<bool> fail_fast = null, Nullable<long> timeout_in_ms = null, string operName = null);
    parameters:
    - id: address
      type: TensorFlow.TFOutput
      description: >-
        <code>0-D</code> or <code>1-D</code>.  The address (i.e. host_name:port) of the RPC server.
                      If this tensor has more than 1 element, then multiple parallel rpc requests
                      are sent.  This argument broadcasts with <code>method</code> and <code>request</code>.
    - id: method
      type: TensorFlow.TFOutput
      description: >-
        <code>0-D</code> or <code>1-D</code>.  The method address on the RPC server.
                      If this tensor has more than 1 element, then multiple parallel rpc requests
                      are sent.  This argument broadcasts with <code>address</code> and <code>request</code>.
    - id: request
      type: TensorFlow.TFOutput
      description: >-
        <code>0-D</code> or <code>1-D</code>.  Serialized proto strings: the rpc request argument.
                      If this tensor has more than 1 element, then multiple parallel rpc requests
                      are sent.  This argument broadcasts with <code>address</code> and <code>method</code>.
    - id: protocol
      type: System.String
      description: >-
        Optional argument
                      RPC protocol to use.  Empty string means use the default protocol.
                      Options include 'grpc'.
    - id: fail_fast
      type: System.Nullable{System.Boolean}
      description: >-
        Optional argument
                      <code>boolean</code>. If <code>true</code> (default), then failures to connect
                      (i.e., the server does not immediately respond) cause an RPC failure.
    - id: timeout_in_ms
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      <code>int</code>. If <code>0</code> (default), then the kernel will run the RPC
                      request and only time out if the RPC deadline passes or the session times out.
                      If this value is greater than <code>0</code>, then the op will raise an exception if
                      the RPC takes longer than <code>timeout_in_ms</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'TryRpc'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      response: Same shape as <code>request</code>. Serialized proto strings: the rpc responses.
                      status_code: Same shape as <code>request</code>.  Values correspond to tensorflow Status enum codes.
                      status_message: Same shape as <code>request</code>.  Values correspond to Status messages
                      returned from the RPC calls.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.TryRpc*
  exceptions: []
- uid: TensorFlow.TFGraph.Unbatch(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String,System.String,System.String)
  id: Unbatch(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Unbatch(TFOutput, TFOutput, TFOutput, Int64, String, String, String)
  nameWithType: TFGraph.Unbatch(TFOutput, TFOutput, TFOutput, Int64, String, String, String)
  fullName: TFGraph.Unbatch(TFOutput, TFOutput, TFOutput, Int64, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Reverses the operation of Batch for a single output Tensor.
  remarks: "An instance of Unbatch either receives an empty batched_tensor, in which case it\n              asynchronously waits until the values become available from a concurrently\n              running instance of Unbatch with the same container and shared_name, or receives\n              a non-empty batched_tensor in which case it finalizes all other concurrently\n              running instances and outputs its own element from the batch.\n              \n              batched_tensor: The possibly transformed output of Batch. The size of the first\n              dimension should remain unchanged by the transformations for the operation to\n              work.\n              batch_index: The matching batch_index obtained from Batch.\n              id: The id scalar emitted by Batch.\n              unbatched_tensor: The Tensor corresponding to this execution.\n              timeout_micros: Maximum amount of time (in microseconds) to wait to receive the\n              batched input tensor associated with a given invocation of the op.\n              container: Container to control resource sharing.\n              shared_name: Instances of Unbatch with the same container and shared_name are\n              assumed to possibly belong to the same batch. If left empty, the op name will\n              be used as the shared name."
  syntax:
    content: public TensorFlow.TFOutput Unbatch (TensorFlow.TFOutput batched_tensor, TensorFlow.TFOutput batch_index, TensorFlow.TFOutput id, long timeout_micros, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: batched_tensor
      type: TensorFlow.TFOutput
      description: To be added.
    - id: batch_index
      type: TensorFlow.TFOutput
      description: To be added.
    - id: id
      type: TensorFlow.TFOutput
      description: To be added.
    - id: timeout_micros
      type: System.Int64
      description: To be added.
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Unbatch'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Unbatch*
  exceptions: []
- uid: TensorFlow.TFGraph.UnbatchGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  id: UnbatchGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: UnbatchGrad(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  nameWithType: TFGraph.UnbatchGrad(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  fullName: TFGraph.UnbatchGrad(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Gradient of Unbatch.
  remarks: "Acts like Batch but using the given batch_index index of batching things as they\n              become available. This ensures that the gradients are propagated back in the\n              same session which did the forward pass.\n              \n              original_input: The input to the Unbatch operation this is the gradient of.\n              batch_index: The batch_index given to the Unbatch operation this is the gradient\n              of.\n              grad: The downstream gradient.\n              id: The id scalar emitted by Batch.\n              batched_grad: The return value, either an empty tensor or the batched gradient.\n              container: Container to control resource sharing.\n              shared_name: Instances of UnbatchGrad with the same container and shared_name\n              are assumed to possibly belong to the same batch. If left empty, the op name\n              will be used as the shared name."
  syntax:
    content: public TensorFlow.TFOutput UnbatchGrad (TensorFlow.TFOutput original_input, TensorFlow.TFOutput batch_index, TensorFlow.TFOutput grad, TensorFlow.TFOutput id, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: original_input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: batch_index
      type: TensorFlow.TFOutput
      description: To be added.
    - id: grad
      type: TensorFlow.TFOutput
      description: To be added.
    - id: id
      type: TensorFlow.TFOutput
      description: To be added.
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'UnbatchGrad'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.UnbatchGrad*
  exceptions: []
- uid: TensorFlow.TFGraph.UnicodeScript(TensorFlow.TFOutput,System.String)
  id: UnicodeScript(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: UnicodeScript(TFOutput, String)
  nameWithType: TFGraph.UnicodeScript(TFOutput, String)
  fullName: TFGraph.UnicodeScript(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Determine the script codes of a given tensor of Unicode integer code points.
  remarks: >-
    This operation converts Unicode code points to script codes corresponding to
                  each code point. Script codes correspond to International Components for
                  Unicode (ICU) UScriptCode values. See http://icu-project.org/apiref/icu4c/uscript_8h.html.
                  Returns -1 (USCRIPT_INVALID_CODE) for invalid codepoints. Output shape will
                  match input shape.
  syntax:
    content: public TensorFlow.TFOutput UnicodeScript (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: A Tensor of int32 Unicode code points.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'UnicodeScript'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A Tensor of int32 script codes corresponding to each input code point.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.UnicodeScript*
  exceptions: []
- uid: TensorFlow.TFGraph.UniformCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  id: UniformCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: UniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.UniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.UniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Generates labels for candidate sampling with a uniform distribution.
  remarks: "See explanations of candidate sampling and the data formats at\n              go/candidate-sampling.\n              \n              For each batch, this op picks a single set of sampled candidate labels.\n              \n              The advantages of sampling candidates per-batch are simplicity and the\n              possibility of efficient dense matrix multiplication. The disadvantage is that\n              the sampled candidates must be chosen independently of the context and of the\n              true labels."
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> UniformCandidateSampler (TensorFlow.TFOutput true_classes, long num_true, long num_sampled, bool unique, long range_max, Nullable<long> seed = null, Nullable<long> seed2 = null, string operName = null);
    parameters:
    - id: true_classes
      type: TensorFlow.TFOutput
      description: >-
        A batch_size * num_true matrix, in which each row contains the
                      IDs of the num_true target_classes in the corresponding original label.
    - id: num_true
      type: System.Int64
      description: Number of true labels per context.
    - id: num_sampled
      type: System.Int64
      description: Number of candidates to randomly sample.
    - id: unique
      type: System.Boolean
      description: >-
        If unique is true, we sample with rejection, so that all sampled
                      candidates in a batch are unique. This requires some approximation to
                      estimate the post-rejection sampling probabilities.
    - id: range_max
      type: System.Int64
      description: The sampler will sample integers from the interval [0, range_max).
    - id: seed
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      If either seed or seed2 are set to be non-zero, the random number
                      generator is seeded by the given seed.  Otherwise, it is seeded by a
                      random seed.
    - id: seed2
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      An second seed to avoid seed collision.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'UniformCandidateSampler'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      sampled_candidates: A vector of length num_sampled, in which each element is
                      the ID of a sampled candidate.
                      true_expected_count: A batch_size * num_true matrix, representing
                      the number of times each candidate is expected to occur in a batch
                      of sampled candidates. If unique=true, then this is a probability.
                      sampled_expected_count: A vector of length num_sampled, for each sampled
                      candidate representing the number of times the candidate is expected
                      to occur in a batch of sampled candidates.  If unique=true, then this is a
                      probability.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.UniformCandidateSampler*
  exceptions: []
- uid: TensorFlow.TFGraph.Unique(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: Unique(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Unique(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Unique(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Unique(TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Finds unique elements in a 1-D tensor.
  remarks: "This operation returns a tensor <code>y</code> containing all of the unique elements of <code>x</code>\n              sorted in the same order that they occur in <code>x</code>. This operation also returns a\n              tensor <code>idx</code> the same size as <code>x</code> that contains the index of each value of <code>x</code>\n              in the unique output <code>y</code>. In other words:\n              \n              <code>y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]</code>\n              \n              For example:\n              \n               <pre><code>\n              # tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\n              y, idx = unique(x)\n              y ==&gt; [1, 2, 4, 7, 8]\n              idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]\n               </code></pre>"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> Unique (TensorFlow.TFOutput x, Nullable<TensorFlow.TFDataType> out_idx = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: 1-D.
    - id: out_idx
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Unique'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      y: 1-D.
                      idx: 1-D.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.Unique*
  exceptions: []
- uid: TensorFlow.TFGraph.UniqueV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: UniqueV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: UniqueV2(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.UniqueV2(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.UniqueV2(TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput> UniqueV2 (TensorFlow.TFOutput x, TensorFlow.TFOutput axis, Nullable<TensorFlow.TFDataType> out_idx = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: axis
      type: TensorFlow.TFOutput
      description: To be added.
    - id: out_idx
      type: System.Nullable{TensorFlow.TFDataType}
      description: To be added.
    - id: operName
      type: System.String
      description: To be added.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: To be added.
  overload: TensorFlow.TFGraph.UniqueV2*
  exceptions: []
- uid: TensorFlow.TFGraph.UniqueWithCounts(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: UniqueWithCounts(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: UniqueWithCounts(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.UniqueWithCounts(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.UniqueWithCounts(TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Finds unique elements in a 1-D tensor.
  remarks: "This operation returns a tensor <code>y</code> containing all of the unique elements of <code>x</code>\n              sorted in the same order that they occur in <code>x</code>. This operation also returns a\n              tensor <code>idx</code> the same size as <code>x</code> that contains the index of each value of <code>x</code>\n              in the unique output <code>y</code>. Finally, it returns a third tensor <code>count</code> that\n              contains the count of each element of <code>y</code> in <code>x</code>. In other words:\n              \n              <code>y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]</code>\n              \n              For example:\n              \n               <pre><code>\n              # tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\n              y, idx, count = unique_with_counts(x)\n              y ==&gt; [1, 2, 4, 7, 8]\n              idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]\n              count ==&gt; [2, 1, 3, 1, 2]\n               </code></pre>"
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> UniqueWithCounts (TensorFlow.TFOutput x, Nullable<TensorFlow.TFDataType> out_idx = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: 1-D.
    - id: out_idx
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'UniqueWithCounts'.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: >-
        Returns a tuple with multiple values, as follows:
                      y: 1-D.
                      idx: 1-D.
                      count: 1-D.
                      The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
  overload: TensorFlow.TFGraph.UniqueWithCounts*
  exceptions: []
- uid: TensorFlow.TFGraph.UniqueWithCountsV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: UniqueWithCountsV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: UniqueWithCountsV2(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.UniqueWithCountsV2(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.UniqueWithCountsV2(TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  syntax:
    content: public ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput> UniqueWithCountsV2 (TensorFlow.TFOutput x, TensorFlow.TFOutput axis, Nullable<TensorFlow.TFDataType> out_idx = null, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: axis
      type: TensorFlow.TFOutput
      description: To be added.
    - id: out_idx
      type: System.Nullable{TensorFlow.TFDataType}
      description: To be added.
    - id: operName
      type: System.String
      description: To be added.
    return:
      type: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
      description: To be added.
  overload: TensorFlow.TFGraph.UniqueWithCountsV2*
  exceptions: []
- uid: TensorFlow.TFGraph.Unpack(TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.String)
  id: Unpack(TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Unpack(TFOutput, Int64, Nullable<Int64>, String)
  nameWithType: TFGraph.Unpack(TFOutput, Int64, Nullable<Int64>, String)
  fullName: TFGraph.Unpack(TFOutput, Int64, Nullable<Int64>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Unpacks a given dimension of a rank-<code>R</code> tensor into <code>num</code> rank-<code>(R-1)</code> tensors.
  remarks: "Unpacks <code>num</code> tensors from <code>value</code> by chipping it along the <code>axis</code> dimension.\n              For example, given a tensor of shape <code>(A, B, C, D)</code>;\n              \n              If <code>axis == 0</code> then the i'th tensor in <code>output</code> is the slice <code>value[i, :, :, :]</code>\n              and each tensor in <code>output</code> will have shape <code>(B, C, D)</code>. (Note that the\n              dimension unpacked along is gone, unlike <code>split</code>).\n              \n              If <code>axis == 1</code> then the i'th tensor in <code>output</code> is the slice <code>value[:, i, :, :]</code>\n              and each tensor in <code>output</code> will have shape <code>(A, C, D)</code>.\n              Etc.\n              \n              This is the opposite of <code>pack</code>."
  syntax:
    content: public TensorFlow.TFOutput[] Unpack (TensorFlow.TFOutput value, long num, Nullable<long> axis = null, string operName = null);
    parameters:
    - id: value
      type: TensorFlow.TFOutput
      description: 1-D or higher, with <code>axis</code> dimension size equal to <code>num</code>.
    - id: num
      type: System.Int64
      description: To be added.
    - id: axis
      type: System.Nullable{System.Int64}
      description: >-
        Optional argument
                      Dimension along which to unpack.  Negative values wrap around, so the
                      valid range is <code>[-R, R)</code>.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Unpack'.
    return:
      type: TensorFlow.TFOutput[]
      description: >-
        The list of tensors unpacked from <code>value</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Unpack*
  exceptions: []
- uid: TensorFlow.TFGraph.UnravelIndex(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: UnravelIndex(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: UnravelIndex(TFOutput, TFOutput, String)
  nameWithType: TFGraph.UnravelIndex(TFOutput, TFOutput, String)
  fullName: TFGraph.UnravelIndex(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Converts a flat index or array of flat indices into a tuple of
  remarks: "coordinate arrays.\n              \n              @compatibility(numpy)\n              Equivalent to np.unravel_index\n              @end_compatibility"
  syntax:
    content: public TensorFlow.TFOutput UnravelIndex (TensorFlow.TFOutput indices, TensorFlow.TFOutput dims, string operName = null);
    parameters:
    - id: indices
      type: TensorFlow.TFOutput
      description: >-
        An 0-D or 1-D <code>int</code> Tensor whose elements are indices into the
                      flattened version of an array of dimensions dims.
    - id: dims
      type: TensorFlow.TFOutput
      description: >-
        An 1-D <code>int</code> Tensor. The shape of the array to use for unraveling
                      indices.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'UnravelIndex'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        An 2-D (or 1-D if indices is 0-D) tensor where each row has the
                      same shape as the indices array.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.UnravelIndex*
  exceptions: []
- uid: TensorFlow.TFGraph.UnsortedSegmentMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: UnsortedSegmentMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: UnsortedSegmentMax(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.UnsortedSegmentMax(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.UnsortedSegmentMax(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the maximum along segments of a tensor.
  remarks: "Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\n              for an explanation of segments.\n              \n              This operator is similar to the unsorted segment sum operator found\n              [(here)](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).\n              Instead of computing the sum over segments, it computes the maximum such that:\n              \n              \\\\(output_i = \\max_{j...} data[j...]\\\\) where max is over tuples <code>j...</code> such\n              that <code>segment_ids[j...] == i</code>.\n              \n              If the maximum is empty for a given segment ID <code>i</code>, it outputs the smallest\n              possible value for the specific numeric type,\n              <code>output[i] = numeric_limits&lt;T&gt;::lowest()</code>.\n              \n              If the given segment ID <code>i</code> is negative, then the corresponding value is\n              dropped, and will not be included in the result.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/UnsortedSegmentMax.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput UnsortedSegmentMax (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: >-
        A tensor whose shape is a prefix of <code>data.shape</code>.END
                      }
                      out_arg {
                      name: "output"
                      description: &lt;&lt;END
                      Has same shape as data, except for the first <code>segment_ids.rank</code>
                      dimensions, which are replaced with a single dimension which has size
                      <code>num_segments</code>.
    - id: num_segments
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentMax'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.UnsortedSegmentMax*
  exceptions: []
- uid: TensorFlow.TFGraph.UnsortedSegmentMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: UnsortedSegmentMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: UnsortedSegmentMin(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.UnsortedSegmentMin(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.UnsortedSegmentMin(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the minimum along segments of a tensor.
  remarks: "Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#segmentation)\n              for an explanation of segments.\n              \n              This operator is similar to the unsorted segment sum operator found\n              [(here)](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).\n              Instead of computing the sum over segments, it computes the minimum such that:\n              \n              \\\\(output_i = \\min_{j...} data_[j...]\\\\) where min is over tuples <code>j...</code> such\n              that <code>segment_ids[j...] == i</code>.\n              \n              If the minimum is empty for a given segment ID <code>i</code>, it outputs the largest\n              possible value for the specific numeric type,\n              <code>output[i] = numeric_limits&lt;T&gt;::max()</code>.\n              \n              If the given segment ID <code>i</code> is negative, then the corresponding value is\n              dropped, and will not be included in the result."
  syntax:
    content: public TensorFlow.TFOutput UnsortedSegmentMin (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: A tensor whose shape is a prefix of <code>data.shape</code>.
    - id: num_segments
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentMin'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for the first <code>segment_ids.rank</code>
                      dimensions, which are replaced with a single dimension which has size
                      <code>num_segments</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.UnsortedSegmentMin*
  exceptions: []
- uid: TensorFlow.TFGraph.UnsortedSegmentProd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: UnsortedSegmentProd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: UnsortedSegmentProd(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.UnsortedSegmentProd(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.UnsortedSegmentProd(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the product along segments of a tensor.
  remarks: "Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#segmentation)\n              for an explanation of segments.\n              \n              This operator is similar to the unsorted segment sum operator found\n              [(here)](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).\n              Instead of computing the sum over segments, it computes the product of all\n              entries belonging to a segment such that:\n              \n              \\\\(output_i = \\prod_{j...} data[j...]\\\\) where the product is over tuples\n              <code>j...</code> such that <code>segment_ids[j...] == i</code>.\n              \n              If there is no entry for a given segment ID <code>i</code>, it outputs 1.\n              \n              If the given segment ID <code>i</code> is negative, then the corresponding value is\n              dropped, and will not be included in the result."
  syntax:
    content: public TensorFlow.TFOutput UnsortedSegmentProd (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: A tensor whose shape is a prefix of <code>data.shape</code>.
    - id: num_segments
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentProd'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for the first <code>segment_ids.rank</code>
                      dimensions, which are replaced with a single dimension which has size
                      <code>num_segments</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.UnsortedSegmentProd*
  exceptions: []
- uid: TensorFlow.TFGraph.UnsortedSegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: UnsortedSegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: UnsortedSegmentSum(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.UnsortedSegmentSum(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.UnsortedSegmentSum(TFOutput, TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Computes the sum along segments of a tensor.
  remarks: "Read\n              [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\n              for an explanation of segments.\n              \n              Computes a tensor such that\n              \\\\(output[i] = \\sum_{j...} data[j...]\\\\) where the sum is over tuples <code>j...</code> such\n              that <code>segment_ids[j...] == i</code>.  Unlike <code>SegmentSum</code>, <code>segment_ids</code>\n              need not be sorted and need not cover all values in the full\n              range of valid values.\n              \n              If the sum is empty for a given segment ID <code>i</code>, <code>output[i] = 0</code>.\n              If the given segment ID <code>i</code> is negative, the value is dropped and will not be\n              added to the sum of the segment.\n              \n              <code>num_segments</code> should equal the number of distinct segment IDs.\n              \n              &lt;div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\"&gt;\n              &lt;img style=\"width:100%\" src=\"https://www.tensorflow.org/images/UnsortedSegmentSum.png\" alt&gt;\n              &lt;/div&gt;"
  syntax:
    content: public TensorFlow.TFOutput UnsortedSegmentSum (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);
    parameters:
    - id: data
      type: TensorFlow.TFOutput
      description: To be added.
    - id: segment_ids
      type: TensorFlow.TFOutput
      description: A tensor whose shape is a prefix of <code>data.shape</code>.
    - id: num_segments
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'UnsortedSegmentSum'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        Has same shape as data, except for the first <code>segment_ids.rank</code>
                      dimensions, which are replaced with a single dimension which has size
                      <code>num_segments</code>.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.UnsortedSegmentSum*
  exceptions: []
- uid: TensorFlow.TFGraph.Unstage(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  id: Unstage(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Unstage(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.Unstage(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.Unstage(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Op is similar to a lightweight Dequeue.
  remarks: >-
    The basic functionality is similar to dequeue with many fewer
                  capabilities and options.  This Op is optimized for performance.
  syntax:
    content: public TensorFlow.TFOutput[] Unstage (TensorFlow.TFDataType[] dtypes, Nullable<long> capacity = null, Nullable<long> memory_limit = null, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: dtypes
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: capacity
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: memory_limit
      type: System.Nullable{System.Int64}
      description: Optional argument
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Unstage'.
    return:
      type: TensorFlow.TFOutput[]
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Unstage*
  exceptions: []
- uid: TensorFlow.TFGraph.UpperBound(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: UpperBound(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: UpperBound(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.UpperBound(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.UpperBound(TFOutput, TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Applies upper_bound(sorted_search_values, values) along each row.
  remarks: "Each set of rows with the same index in (sorted_inputs, values) is treated\n              independently.  The resulting row is the equivalent of calling\n              <code>np.searchsorted(sorted_inputs, values, side='right')</code>.\n              \n              The result is not a global index to the entire\n              <code>Tensor</code>, but rather just the index in the last dimension.\n              \n              A 2-D example:\n              sorted_sequence = [[0, 3, 9, 9, 10],\n              [1, 2, 3, 4, 5]]\n              values = [[2, 4, 9],\n              [0, 2, 6]]\n              \n              result = UpperBound(sorted_sequence, values)\n              \n              result == [[1, 2, 4],\n              [0, 2, 5]]"
  syntax:
    content: public TensorFlow.TFOutput UpperBound (TensorFlow.TFOutput sorted_inputs, TensorFlow.TFOutput values, Nullable<TensorFlow.TFDataType> out_type = null, string operName = null);
    parameters:
    - id: sorted_inputs
      type: TensorFlow.TFOutput
      description: 2-D Tensor where each row is ordered.
    - id: values
      type: TensorFlow.TFOutput
      description: >-
        2-D Tensor with the same numbers of rows as <code>sorted_search_values</code>. Contains
                      the values that will be searched for in <code>sorted_search_values</code>.
    - id: out_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'UpperBound'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A <code>Tensor</code> with the same shape as <code>values</code>.  It contains the last scalar index
                      into the last dimension where values can be inserted without changing the
                      ordered property.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.UpperBound*
  exceptions: []
- uid: TensorFlow.TFGraph.VarHandleOp(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String)
  id: VarHandleOp(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: VarHandleOp(TFDataType, TFShape, String, String, String)
  nameWithType: TFGraph.VarHandleOp(TFDataType, TFShape, String, String, String)
  fullName: TFGraph.VarHandleOp(TFDataType, TFShape, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a handle to a Variable resource.
  syntax:
    content: public TensorFlow.TFOutput VarHandleOp (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: dtype
      type: TensorFlow.TFDataType
      description: >-
        the type of this variable. Must agree with the dtypes
                      of all ops using this variable.
    - id: shape
      type: TensorFlow.TFShape
      description: The (possibly partially specified) shape of this variable.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      the container this variable is placed in.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      the name by which this variable is referred to.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'VarHandleOp'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.VarHandleOp*
  exceptions: []
- uid: TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,System.Boolean,System.String)
  id: Variable(TensorFlow.TFOutput,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Variable(TFOutput, Boolean, String)
  nameWithType: TFGraph.Variable(TFOutput, Boolean, String)
  fullName: TFGraph.Variable(TFOutput, Boolean, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Variable node, with a starting initial value.  Convenience that registers the init variable to a global queue.
  remarks: "Variables need to be initialized before the main execution so you will typically want to\n            run the session on the variable.\n            \n            The init sequence for the variable is stored in the graph, you must manually initialize \n            those by running the session on the global variables."
  syntax:
    content: public TensorFlow.Variable Variable (TensorFlow.TFOutput initialValue, bool trainable = true, string operName = null);
    parameters:
    - id: initialValue
      type: TensorFlow.TFOutput
      description: Initial value.
    - id: trainable
      type: System.Boolean
      description: If true, this add the variable to the graph's TrainableVariables, this collection is intended to be used by the Optimizer classes.
    - id: operName
      type: System.String
      description: Operation name, optional.
    return:
      type: TensorFlow.Variable
      description: The returning Variable contains the variable, with three nodes with the operations making up the variable assignment.
  overload: TensorFlow.TFGraph.Variable*
  exceptions: []
- uid: TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,TensorFlow.TFOutput@,System.Boolean,System.String)
  id: Variable(TensorFlow.TFOutput,TensorFlow.TFOutput@,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Variable(TFOutput, TFOutput, Boolean, String)
  nameWithType: TFGraph.Variable(TFOutput, TFOutput, Boolean, String)
  fullName: TFGraph.Variable(TFOutput, TFOutput, Boolean, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Variable node, with a starting initial value.  Convenience that registers the init variable to a global queue.
  remarks: "Variables need to be initialized before the main execution so you will typically want to\n            run the session on the variable.\n            \n            The init sequence for the variable is stored in the graph, you must manually initialize \n            those by running the session on the global variables."
  syntax:
    content: public TensorFlow.Variable Variable (TensorFlow.TFOutput initialValue, out TensorFlow.TFOutput value, bool trainable = true, string operName = null);
    parameters:
    - id: initialValue
      type: TensorFlow.TFOutput
      description: Initial value.
    - id: value
      type: TensorFlow.TFOutput
      description: Returns the value of the variable.
    - id: trainable
      type: System.Boolean
      description: If true, this add the variable to the graph's TrainableVariables, this collection is intended to be used by the Optimizer classes.
    - id: operName
      type: System.String
      description: Operation name, optional.
    return:
      type: TensorFlow.Variable
      description: The returning Variable contains the variable, with three nodes with the operations making up the variable assignment.
  overload: TensorFlow.TFGraph.Variable*
  exceptions: []
- uid: TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,TensorFlow.TFOperation@,TensorFlow.TFOutput@,System.Boolean,System.String)
  id: Variable(TensorFlow.TFOutput,TensorFlow.TFOperation@,TensorFlow.TFOutput@,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Variable(TFOutput, TFOperation, TFOutput, Boolean, String)
  nameWithType: TFGraph.Variable(TFOutput, TFOperation, TFOutput, Boolean, String)
  fullName: TFGraph.Variable(TFOutput, TFOperation, TFOutput, Boolean, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Variable node, with a starting initial value.
  remarks: >-
    Variables need to be initialized before the main execution so you will typically want to
                run the session on the variable
  syntax:
    content: public TensorFlow.Variable Variable (TensorFlow.TFOutput initialValue, out TensorFlow.TFOperation init, out TensorFlow.TFOutput value, bool trainable = true, string operName = null);
    parameters:
    - id: initialValue
      type: TensorFlow.TFOutput
      description: Initial value.
    - id: init
      type: TensorFlow.TFOperation
      description: Returns the operation that initializes the value of the variable.
    - id: value
      type: TensorFlow.TFOutput
      description: Returns the value of the variable.
    - id: trainable
      type: System.Boolean
      description: If true, this add the variable to the graph's TrainableVariables, this collection is intended to be used by the Optimizer classes.
    - id: operName
      type: System.String
      description: Operation name, optional.
    return:
      type: TensorFlow.Variable
      description: The returning Variable contains the variable, with three nodes with the operations making up the variable assignment.
  overload: TensorFlow.TFGraph.Variable*
  exceptions: []
- uid: TensorFlow.TFGraph.Variable(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String,System.String)
  id: Variable(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Variable(TFShape, TFDataType, String, String, String)
  nameWithType: TFGraph.Variable(TFShape, TFDataType, String, String, String)
  fullName: TFGraph.Variable(TFShape, TFDataType, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Use VariableV2 instead.
  syntax:
    content: public TensorFlow.TFOutput Variable (TensorFlow.TFShape shape, TensorFlow.TFDataType dtype, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFShape
      description: To be added.
    - id: dtype
      type: TensorFlow.TFDataType
      description: To be added.
    - id: container
      type: System.String
      description: Optional argument
    - id: shared_name
      type: System.String
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Variable'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Variable*
  exceptions: []
- uid: TensorFlow.TFGraph.VariableShape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  id: VariableShape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: VariableShape(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.VariableShape(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.VariableShape(TFOutput, Nullable<TFDataType>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the shape of the variable pointed to by <code>resource</code>.
  remarks: "This operation returns a 1-D integer tensor representing the shape of <code>input</code>.\n              \n              For example:\n              \n               <pre><code>\n              # 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\n              shape(t) ==&gt; [2, 2, 3]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput VariableShape (TensorFlow.TFOutput input, Nullable<TensorFlow.TFDataType> out_type = null, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: out_type
      type: System.Nullable{TensorFlow.TFDataType}
      description: Optional argument
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'VariableShape'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.VariableShape*
  exceptions: []
- uid: TensorFlow.TFGraph.VariableV2(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String,System.String)
  id: VariableV2(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: VariableV2(TFShape, TFDataType, String, String, String)
  nameWithType: TFGraph.VariableV2(TFShape, TFDataType, String, String, String)
  fullName: TFGraph.VariableV2(TFShape, TFDataType, String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Holds state in the form of a tensor that persists across steps.
  remarks: >-
    Outputs a ref to the tensor state so it may be read or modified.
                  TODO(zhifengc/mrry): Adds a pointer to a more detail document
                  about sharing states in tensorflow.
  syntax:
    content: public TensorFlow.TFOutput VariableV2 (TensorFlow.TFShape shape, TensorFlow.TFDataType dtype, string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFShape
      description: The shape of the variable tensor.
    - id: dtype
      type: TensorFlow.TFDataType
      description: The type of elements in the variable tensor.
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this variable is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this variable is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'VariableV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A reference to the variable tensor.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.VariableV2*
  exceptions: []
- uid: TensorFlow.TFGraph.VarIsInitializedOp(TensorFlow.TFOutput,System.String)
  id: VarIsInitializedOp(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: VarIsInitializedOp(TFOutput, String)
  nameWithType: TFGraph.VarIsInitializedOp(TFOutput, String)
  fullName: TFGraph.VarIsInitializedOp(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Checks whether a resource handle-based variable has been initialized.
  syntax:
    content: public TensorFlow.TFOutput VarIsInitializedOp (TensorFlow.TFOutput resource, string operName = null);
    parameters:
    - id: resource
      type: TensorFlow.TFOutput
      description: the input resource handle.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'VarIsInitializedOp'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        a scalar boolean which is true if the variable has been
                      initialized.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.VarIsInitializedOp*
  exceptions: []
- uid: TensorFlow.TFGraph.Versions(TensorFlow.TFBuffer,TensorFlow.TFStatus)
  id: Versions(TensorFlow.TFBuffer,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Versions(TFBuffer, TFStatus)
  nameWithType: TFGraph.Versions(TFBuffer, TFStatus)
  fullName: TFGraph.Versions(TFBuffer, TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns the serialized VersionDef proto for this graph.
  syntax:
    content: public void Versions (TensorFlow.TFBuffer outputVersionDef, TensorFlow.TFStatus status = null);
    parameters:
    - id: outputVersionDef
      type: TensorFlow.TFBuffer
      description: The buffer where the serialized protocol buffer will be stored.
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
  overload: TensorFlow.TFGraph.Versions*
  exceptions: []
- uid: TensorFlow.TFGraph.Where(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFOutput},System.String)
  id: Where(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFOutput},System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Where(TFOutput, Nullable<TFOutput>, Nullable<TFOutput>, String)
  nameWithType: TFGraph.Where(TFOutput, Nullable<TFOutput>, Nullable<TFOutput>, String)
  fullName: TFGraph.Where(TFOutput, Nullable<TFOutput>, Nullable<TFOutput>, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Return elements from x or y depending on condition.
  syntax:
    content: public TensorFlow.TFOutput Where (TensorFlow.TFOutput condition, Nullable<TensorFlow.TFOutput> x, Nullable<TensorFlow.TFOutput> y, string name = null);
    parameters:
    - id: condition
      type: TensorFlow.TFOutput
      description: LabeledTensor of type `bool`.
    - id: x
      type: System.Nullable{TensorFlow.TFOutput}
      description: LabeledTensor for values where condition is true.
    - id: y
      type: System.Nullable{TensorFlow.TFOutput}
      description: LabeledTensor for values where condition is false.
    - id: name
      type: System.String
      description: Optional op name.
    return:
      type: TensorFlow.TFOutput
      description: The labeled tensor with values according to condition.
  overload: TensorFlow.TFGraph.Where*
  exceptions: []
- uid: TensorFlow.TFGraph.Where(TensorFlow.TFOutput,System.String)
  id: Where(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Where(TFOutput, String)
  nameWithType: TFGraph.Where(TFOutput, String)
  fullName: TFGraph.Where(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns locations of nonzero / true values in a tensor.
  remarks: "This operation returns the coordinates of true elements in <code>condition</code>. The\n              coordinates are returned in a 2-D tensor where the first dimension (rows)\n              represents the number of true elements, and the second dimension (columns)\n              represents the coordinates of the true elements. Keep in mind, the shape of\n              the output tensor can vary depending on how many true values there are in\n              <code>condition</code>. Indices are output in row-major order.\n              \n              For example:\n              \n               <pre><code>\n              # 'input' tensor is [[True, False]\n              #                    [True, False]]\n              # 'input' has two true values, so output has two coordinates.\n              # 'input' has rank of 2, so coordinates have two indices.\n              where(input) ==&gt; [[0, 0],\n              [1, 0]]\n              \n              # <code>condition</code> tensor is [[[True, False]\n              #                     [True, False]]\n              #                    [[False, True]\n              #                     [False, True]]\n              #                    [[False, False]\n              #                     [False, True]]]\n              # 'input' has 5 true values, so output has 5 coordinates.\n              # 'input' has rank of 3, so coordinates have three indices.\n              where(input) ==&gt; [[0, 0, 0],\n              [0, 1, 0],\n              [1, 0, 1],\n              [1, 1, 1],\n              [2, 1, 1]]\n              \n              # <code>condition</code> tensor is [[[1.5,  0.0]\n              #                     [-0.5, 0.0]]\n              #                    [[0.0,  0.25]\n              #                     [0.0,  0.75]]\n              #                    [[0.0,  0.0]\n              #                     [0.0,  0.01]]]\n              # 'input' has 5 nonzero values, so output has 5 coordinates.\n              # 'input' has rank of 3, so coordinates have three indices.\n              where(input) ==&gt; [[0, 0, 0],\n              [0, 1, 0],\n              [1, 0, 1],\n              [1, 1, 1],\n              [2, 1, 1]]\n              \n              # <code>condition</code> tensor is [[[1.5 + 0.0j, 0.0  + 0.0j]\n              #                     [0.0 + 0.5j, 0.0  + 0.0j]]\n              #                    [[0.0 + 0.0j, 0.25 + 1.5j]\n              #                     [0.0 + 0.0j, 0.75 + 0.0j]]\n              #                    [[0.0 + 0.0j, 0.0  + 0.0j]\n              #                     [0.0 + 0.0j, 0.01 + 0.0j]]]\n              # 'input' has 5 nonzero magnitude values, so output has 5 coordinates.\n              # 'input' has rank of 3, so coordinates have three indices.\n              where(input) ==&gt; [[0, 0, 0],\n              [0, 1, 0],\n              [1, 0, 1],\n              [1, 1, 1],\n              [2, 1, 1]]\n               </code></pre>"
  syntax:
    content: public TensorFlow.TFOutput Where (TensorFlow.TFOutput input, string operName = null);
    parameters:
    - id: input
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Where'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Where*
  exceptions: []
- uid: TensorFlow.TFGraph.While(TensorFlow.TFOutput[],TensorFlow.TFGraph.WhileConstructor,TensorFlow.TFStatus)
  id: While(TensorFlow.TFOutput[],TensorFlow.TFGraph.WhileConstructor,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: While(TFOutput[], TFGraph+WhileConstructor, TFStatus)
  nameWithType: TFGraph.While(TFOutput[], TFGraph+WhileConstructor, TFStatus)
  fullName: TFGraph.While(TFOutput[], TFGraph+WhileConstructor, TFStatus)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Constructs a while loop with the specified inputs and a callback that composes the while loop
  syntax:
    content: public TensorFlow.TFOutput[] While (TensorFlow.TFOutput[] inputs, TensorFlow.TFGraph.WhileConstructor constructor, TensorFlow.TFStatus status = null);
    parameters:
    - id: inputs
      type: TensorFlow.TFOutput[]
      description: Inputs.
    - id: constructor
      type: TensorFlow.TFGraph+WhileConstructor
      description: Callback method that fills out the various while loop parameters.
    - id: status
      type: TensorFlow.TFStatus
      description: Status buffer, if specified a status code will be left here, if not specified, a <xref href="TensorFlow.TFException"></xref> exception is raised if there is an error.
    return:
      type: TensorFlow.TFOutput[]
      description: "An array of TFOutputs from creating the While loop, or null if there is an error creating the \n            while loop, or if the constructor raised an exception when it was invoked."
  overload: TensorFlow.TFGraph.While*
  exceptions: []
- uid: TensorFlow.TFGraph.WholeFileReader(System.String,System.String,System.String)
  id: WholeFileReader(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: WholeFileReader(String, String, String)
  nameWithType: TFGraph.WholeFileReader(String, String, String)
  fullName: TFGraph.WholeFileReader(String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A Reader that outputs the entire contents of a file as a value.
  remarks: >-
    To use, enqueue filenames in a Queue.  The output of ReaderRead will
                  be a filename (key) and the contents of that file (value).
  syntax:
    content: public TensorFlow.TFOutput WholeFileReader (string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'WholeFileReader'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to reference the Reader.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.WholeFileReader*
  exceptions: []
- uid: TensorFlow.TFGraph.WholeFileReaderV2(System.String,System.String,System.String)
  id: WholeFileReaderV2(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: WholeFileReaderV2(String, String, String)
  nameWithType: TFGraph.WholeFileReaderV2(String, String, String)
  fullName: TFGraph.WholeFileReaderV2(String, String, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A Reader that outputs the entire contents of a file as a value.
  remarks: >-
    To use, enqueue filenames in a Queue.  The output of ReaderRead will
                  be a filename (key) and the contents of that file (value).
  syntax:
    content: public TensorFlow.TFOutput WholeFileReaderV2 (string container = null, string shared_name = null, string operName = null);
    parameters:
    - id: container
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is placed in the given container.
                      Otherwise, a default container is used.
    - id: shared_name
      type: System.String
      description: >-
        Optional argument
                      If non-empty, this reader is named in the given bucket
                      with this shared_name. Otherwise, the node name is used instead.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'WholeFileReaderV2'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        The handle to reference the Reader.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.WholeFileReaderV2*
  exceptions: []
- uid: TensorFlow.TFGraph.WindowDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: WindowDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: WindowDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.WindowDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.WindowDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: A dataset that creates window datasets from the input dataset.
  syntax:
    content: public TensorFlow.TFOutput WindowDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput size, TensorFlow.TFOutput shift, TensorFlow.TFOutput stride, TensorFlow.TFOutput drop_remainder, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_dataset
      type: TensorFlow.TFOutput
      description: To be added.
    - id: size
      type: TensorFlow.TFOutput
      description: A scalar representing the number of elements to accumulate in a window.
    - id: shift
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing the steps moving the sliding window forward in one
                      iteration. It must be positive.
    - id: stride
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing the stride of the input elements of the sliding window.
                      It must be positive.
    - id: drop_remainder
      type: TensorFlow.TFOutput
      description: >-
        A scalar representing whether a window should be dropped in case its size is
                      smaller than desired.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'WindowDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.WindowDataset*
  exceptions: []
- uid: TensorFlow.TFGraph.WithDependencies(TensorFlow.TFOperation[])
  id: WithDependencies(TensorFlow.TFOperation[])
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: WithDependencies(TFOperation[])
  nameWithType: TFGraph.WithDependencies(TFOperation[])
  fullName: TFGraph.WithDependencies(TFOperation[])
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Adds new dependencies for new tensors and operations created while the context is active.
  syntax:
    content: public TensorFlow.TFDependencies WithDependencies (TensorFlow.TFOperation[] dependencies);
    parameters:
    - id: dependencies
      type: TensorFlow.TFOperation[]
      description: To be added.
    return:
      type: TensorFlow.TFDependencies
      description: To be added.
  overload: TensorFlow.TFGraph.WithDependencies*
  exceptions: []
- uid: TensorFlow.TFGraph.WithScope(System.String)
  id: WithScope(System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: WithScope(String)
  nameWithType: TFGraph.WithScope(String)
  fullName: TFGraph.WithScope(String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a new namescope by setting the scope to the description provided.
  remarks: >-
    <p>
                To more easily name your operations and group then, you can use the
                WithScope method to set a current name scope that alter the complete name
                of an operation added to the graph.
                </p>
        <p>
                The graph starts with a scope set to the empty string, you can introduce new
                scopes by calling WithScope, and can be conveniently used with the C# using
                statement, like this:
                </p>
        <pre><code>
                Assert (graph.CurrentNamescope, "");
                using (var nested = graph.WithScope ("nested")){
                   Assert (graph.CurrentNameScope, "nested");
                   using (var inner = graph.WithScope ("inner")){
                       Assert (graph.CurrentNameScope, "nested/inner");
                   }
                }
                </code></pre>
  syntax:
    content: public TensorFlow.TFScope WithScope (string nameScopeDesc);
    parameters:
    - id: nameScopeDesc
      type: System.String
      description: >-
        The namescope description, if the value is null, this
                    will reset the toplevel namescope to be the empty value.
    return:
      type: TensorFlow.TFScope
      description: A new scope that will remain in use until the return TFScope is disposed.
  overload: TensorFlow.TFGraph.WithScope*
  exceptions: []
- uid: TensorFlow.TFGraph.WorkerHeartbeat(TensorFlow.TFOutput,System.String)
  id: WorkerHeartbeat(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: WorkerHeartbeat(TFOutput, String)
  nameWithType: TFGraph.WorkerHeartbeat(TFOutput, String)
  fullName: TFGraph.WorkerHeartbeat(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Worker heartbeat op.
  remarks: >-
    Heartbeats may be sent periodically to indicate the coordinator is still active,
                  to retrieve the current worker status and to expedite shutdown when necessary.
  syntax:
    content: public TensorFlow.TFOutput WorkerHeartbeat (TensorFlow.TFOutput request, string operName = null);
    parameters:
    - id: request
      type: TensorFlow.TFOutput
      description: A string tensor containing a serialized WorkerHeartbeatRequest
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'WorkerHeartbeat'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        A string tensor containing a serialized WorkerHeartbeatResponse
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.WorkerHeartbeat*
  exceptions: []
- uid: TensorFlow.TFGraph.WriteFile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: WriteFile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: WriteFile(TFOutput, TFOutput, String)
  nameWithType: TFGraph.WriteFile(TFOutput, TFOutput, String)
  fullName: TFGraph.WriteFile(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Writes contents to the file at input filename. Creates file and recursively
  remarks: creates directory if not existing.
  syntax:
    content: public TensorFlow.TFOperation WriteFile (TensorFlow.TFOutput filename, TensorFlow.TFOutput contents, string operName = null);
    parameters:
    - id: filename
      type: TensorFlow.TFOutput
      description: scalar. The name of the file to which we write the contents.
    - id: contents
      type: TensorFlow.TFOutput
      description: scalar. The content to be written to the output file.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'WriteFile'.
    return:
      type: TensorFlow.TFOperation
      description: Returns the description of the operation
  overload: TensorFlow.TFGraph.WriteFile*
  exceptions: []
- uid: TensorFlow.TFGraph.Xdivy(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Xdivy(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Xdivy(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Xdivy(TFOutput, TFOutput, String)
  fullName: TFGraph.Xdivy(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns 0 if x == 0, and x / y otherwise, elementwise.
  syntax:
    content: public TensorFlow.TFOutput Xdivy (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Xdivy'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Xdivy*
  exceptions: []
- uid: TensorFlow.TFGraph.Xlogy(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Xlogy(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Xlogy(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Xlogy(TFOutput, TFOutput, String)
  fullName: TFGraph.Xlogy(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns 0 if x == 0, and x * log(y) otherwise, elementwise.
  syntax:
    content: public TensorFlow.TFOutput Xlogy (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: y
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Xlogy'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Xlogy*
  exceptions: []
- uid: TensorFlow.TFGraph.Zeros(TensorFlow.TFShape,TensorFlow.TFDataType,System.String)
  id: Zeros(TensorFlow.TFShape,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Zeros(TFShape, TFDataType, String)
  nameWithType: TFGraph.Zeros(TFShape, TFDataType, String)
  fullName: TFGraph.Zeros(TFShape, TFDataType, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Outputs Zero values based on shape of tensor
  syntax:
    content: public TensorFlow.TFOutput Zeros (TensorFlow.TFShape shape, TensorFlow.TFDataType dtype = TensorFlow.TFDataType.Double, string operName = null);
    parameters:
    - id: shape
      type: TensorFlow.TFShape
      description: Shape of the output tensor
    - id: dtype
      type: TensorFlow.TFDataType
      description: 'Optional Type of the Zero value. Default: Double'
    - id: operName
      type: System.String
      description: Operation name, optional.
    return:
      type: TensorFlow.TFOutput
      description: To be added.
  overload: TensorFlow.TFGraph.Zeros*
  exceptions: []
- uid: TensorFlow.TFGraph.ZerosLike(TensorFlow.TFOutput,System.String)
  id: ZerosLike(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ZerosLike(TFOutput, String)
  nameWithType: TFGraph.ZerosLike(TFOutput, String)
  fullName: TFGraph.ZerosLike(TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Returns a tensor of zeros with the same shape and type as x.
  syntax:
    content: public TensorFlow.TFOutput ZerosLike (TensorFlow.TFOutput x, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: a tensor of type T.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ZerosLike'.
    return:
      type: TensorFlow.TFOutput
      description: >-
        a tensor of the same shape and type as x but filled with zeros.
                      The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ZerosLike*
  exceptions: []
- uid: TensorFlow.TFGraph.Zeta(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  id: Zeta(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: Zeta(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Zeta(TFOutput, TFOutput, String)
  fullName: TFGraph.Zeta(TFOutput, TFOutput, String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Compute the Hurwitz zeta function \\(\zeta(x, q)\\).
  remarks: "The Hurwitz zeta function is defined as:\n              \n              \n              \\\\(\\zeta(x, q) = \\sum_{n=0}^{\\infty} (q + n)^{-x}\\\\)"
  syntax:
    content: public TensorFlow.TFOutput Zeta (TensorFlow.TFOutput x, TensorFlow.TFOutput q, string operName = null);
    parameters:
    - id: x
      type: TensorFlow.TFOutput
      description: To be added.
    - id: q
      type: TensorFlow.TFOutput
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'Zeta'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.Zeta*
  exceptions: []
- uid: TensorFlow.TFGraph.ZipDataset(TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  id: ZipDataset(TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  langs:
  - csharp
  name: ZipDataset(TFOutput[], TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ZipDataset(TFOutput[], TFDataType[], TFShape[], String)
  fullName: TFGraph.ZipDataset(TFOutput[], TFDataType[], TFShape[], String)
  type: Method
  assemblies:
  - TensorFlowSharp
  namespace: TensorFlow
  summary: Creates a dataset that zips together <code>input_datasets</code>.
  syntax:
    content: public TensorFlow.TFOutput ZipDataset (TensorFlow.TFOutput[] input_datasets, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);
    parameters:
    - id: input_datasets
      type: TensorFlow.TFOutput[]
      description: To be added.
    - id: output_types
      type: TensorFlow.TFDataType[]
      description: To be added.
    - id: output_shapes
      type: TensorFlow.TFShape[]
      description: To be added.
    - id: operName
      type: System.String
      description: If specified, the created operation in the graph will be this one, otherwise it will be named 'ZipDataset'.
    return:
      type: TensorFlow.TFOutput
      description: The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
  overload: TensorFlow.TFGraph.ZipDataset*
  exceptions: []
references:
- uid: TensorFlow.TFDisposableThreadSafe
  parent: TensorFlow
  isExternal: false
  name: TFDisposableThreadSafe
  nameWithType: TFDisposableThreadSafe
  fullName: TensorFlow.TFDisposableThreadSafe
- uid: TensorFlow.TFGraph.#ctor
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TFGraph()
  nameWithType: TFGraph.TFGraph()
  fullName: TFGraph.TFGraph()
- uid: TensorFlow.TFGraph.Abort(System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Abort(String, Nullable<Boolean>, String)
  nameWithType: TFGraph.Abort(String, Nullable<Boolean>, String)
  fullName: TFGraph.Abort(String, Nullable<Boolean>, String)
- uid: TensorFlow.TFOperation
  parent: TensorFlow
  isExternal: false
  name: TFOperation
  nameWithType: TFOperation
  fullName: TensorFlow.TFOperation
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Nullable`1
  name: Nullable
  nameWithType: Nullable
  fullName: System.Nullable
- uid: System.Boolean
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Nullable{System.Boolean}
  parent: System
  isExternal: true
  name: Nullable<Boolean>
  nameWithType: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.Abs(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Abs(TFOutput, String)
  nameWithType: TFGraph.Abs(TFOutput, String)
  fullName: TFGraph.Abs(TFOutput, String)
- uid: TensorFlow.TFOutput
  parent: TensorFlow
  isExternal: false
  name: TFOutput
  nameWithType: TFOutput
  fullName: TensorFlow.TFOutput
- uid: TensorFlow.TFGraph.AccumulateNV2(TensorFlow.TFOutput[],TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AccumulateNV2(TFOutput[], TFShape, String)
  nameWithType: TFGraph.AccumulateNV2(TFOutput[], TFShape, String)
  fullName: TFGraph.AccumulateNV2(TFOutput[], TFShape, String)
- uid: TensorFlow.TFOutput[]
  parent: TensorFlow
  isExternal: false
  name: TFOutput[]
  nameWithType: TFOutput[]
  fullName: TensorFlow.TFOutput[]
  spec.csharp:
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: TensorFlow.TFShape
  parent: TensorFlow
  isExternal: false
  name: TFShape
  nameWithType: TFShape
  fullName: TensorFlow.TFShape
- uid: TensorFlow.TFGraph.AccumulatorApplyGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.AccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.AccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.AccumulatorNumAccumulated(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AccumulatorNumAccumulated(TFOutput, String)
  nameWithType: TFGraph.AccumulatorNumAccumulated(TFOutput, String)
  fullName: TFGraph.AccumulatorNumAccumulated(TFOutput, String)
- uid: TensorFlow.TFGraph.AccumulatorSetGlobalStep(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AccumulatorSetGlobalStep(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AccumulatorSetGlobalStep(TFOutput, TFOutput, String)
  fullName: TFGraph.AccumulatorSetGlobalStep(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.AccumulatorTakeGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.AccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.AccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)
- uid: TensorFlow.TFDataType
  parent: TensorFlow
  isExternal: false
  name: TFDataType
  nameWithType: TFDataType
  fullName: TensorFlow.TFDataType
- uid: TensorFlow.TFGraph.Acos(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Acos(TFOutput, String)
  nameWithType: TFGraph.Acos(TFOutput, String)
  fullName: TFGraph.Acos(TFOutput, String)
- uid: TensorFlow.TFGraph.Acosh(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Acosh(TFOutput, String)
  nameWithType: TFGraph.Acosh(TFOutput, String)
  fullName: TFGraph.Acosh(TFOutput, String)
- uid: TensorFlow.TFGraph.Add(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Add(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Add(TFOutput, TFOutput, String)
  fullName: TFGraph.Add(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.AddGradients(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AddGradients(TFOutput[], TFOutput[], TFOutput[], TFStatus)
  nameWithType: TFGraph.AddGradients(TFOutput[], TFOutput[], TFOutput[], TFStatus)
  fullName: TFGraph.AddGradients(TFOutput[], TFOutput[], TFOutput[], TFStatus)
- uid: TensorFlow.TFStatus
  parent: TensorFlow
  isExternal: false
  name: TFStatus
  nameWithType: TFStatus
  fullName: TensorFlow.TFStatus
- uid: TensorFlow.TFGraph.AddGradients(System.String,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AddGradients(String, TFOutput[], TFOutput[], TFOutput[], TFStatus)
  nameWithType: TFGraph.AddGradients(String, TFOutput[], TFOutput[], TFOutput[], TFStatus)
  fullName: TFGraph.AddGradients(String, TFOutput[], TFOutput[], TFOutput[], TFStatus)
- uid: TensorFlow.TFGraph.AddInitVariable(TensorFlow.TFOperation)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AddInitVariable(TFOperation)
  nameWithType: TFGraph.AddInitVariable(TFOperation)
  fullName: TFGraph.AddInitVariable(TFOperation)
- uid: TensorFlow.TFGraph.AddManySparseToTensorsMap(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AddManySparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)
  nameWithType: TFGraph.AddManySparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)
  fullName: TFGraph.AddManySparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)
- uid: TensorFlow.TFGraph.AddN(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AddN(TFOutput[], String)
  nameWithType: TFGraph.AddN(TFOutput[], String)
  fullName: TFGraph.AddN(TFOutput[], String)
- uid: TensorFlow.TFGraph.AddSparseToTensorsMap(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AddSparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)
  nameWithType: TFGraph.AddSparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)
  fullName: TFGraph.AddSparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)
- uid: TensorFlow.TFGraph.AddV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AddV2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AddV2(TFOutput, TFOutput, String)
  fullName: TFGraph.AddV2(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.AdjustContrast(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AdjustContrast(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.AdjustContrast(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.AdjustContrast(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.AdjustContrastv2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AdjustContrastv2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AdjustContrastv2(TFOutput, TFOutput, String)
  fullName: TFGraph.AdjustContrastv2(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.AdjustHue(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AdjustHue(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AdjustHue(TFOutput, TFOutput, String)
  fullName: TFGraph.AdjustHue(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.AdjustSaturation(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AdjustSaturation(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AdjustSaturation(TFOutput, TFOutput, String)
  fullName: TFGraph.AdjustSaturation(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.All(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: All(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.All(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.All(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.AllCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AllCandidateSampler(TFOutput, Int64, Int64, Boolean, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.AllCandidateSampler(TFOutput, Int64, Int64, Boolean, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.AllCandidateSampler(TFOutput, Int64, Int64, Boolean, Nullable<Int64>, Nullable<Int64>, String)
- uid: System.ValueTuple`3
  name: ValueTuple
  nameWithType: ValueTuple
  fullName: System.ValueTuple
- uid: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput,TFOutput,TFOutput>
  nameWithType: ValueTuple<TFOutput,TFOutput,TFOutput>
  fullName: System.ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput>
  spec.csharp:
  - uid: System.ValueTuple`3
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Nullable{System.Int64}
  parent: System
  isExternal: true
  name: Nullable<Int64>
  nameWithType: Nullable<Int64>
  fullName: System.Nullable<System.Int64>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.AllToAll(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AllToAll(TFOutput, TFOutput, Int64, Int64, Int64, String)
  nameWithType: TFGraph.AllToAll(TFOutput, TFOutput, Int64, Int64, Int64, String)
  fullName: TFGraph.AllToAll(TFOutput, TFOutput, Int64, Int64, Int64, String)
- uid: TensorFlow.TFGraph.Angle(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Angle(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Angle(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Angle(TFOutput, Nullable<TFDataType>, String)
- uid: System.Nullable{TensorFlow.TFDataType}
  parent: System
  isExternal: true
  name: Nullable<TFDataType>
  nameWithType: Nullable<TFDataType>
  fullName: System.Nullable<TensorFlow.TFDataType>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFDataType
    name: TFDataType
    nameWithType: TFDataType
    fullName: TensorFlow.TFDataType
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.AnonymousIterator(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AnonymousIterator(TFDataType[], TFShape[], String)
  nameWithType: TFGraph.AnonymousIterator(TFDataType[], TFShape[], String)
  fullName: TFGraph.AnonymousIterator(TFDataType[], TFShape[], String)
- uid: TensorFlow.TFDataType[]
  parent: TensorFlow
  isExternal: false
  name: TFDataType[]
  nameWithType: TFDataType[]
  fullName: TensorFlow.TFDataType[]
  spec.csharp:
  - uid: TensorFlow.TFDataType
    name: TFDataType
    nameWithType: TFDataType
    fullName: TensorFlow.TFDataType
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: TensorFlow.TFShape[]
  parent: TensorFlow
  isExternal: false
  name: TFShape[]
  nameWithType: TFShape[]
  fullName: TensorFlow.TFShape[]
  spec.csharp:
  - uid: TensorFlow.TFShape
    name: TFShape
    nameWithType: TFShape
    fullName: TensorFlow.TFShape
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: TensorFlow.TFGraph.Any(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Any(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Any(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Any(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyAdam(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyAdaMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyAddSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyPowerSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ApproximateEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApproximateEqual(TFOutput, TFOutput, Nullable<Single>, String)
  nameWithType: TFGraph.ApproximateEqual(TFOutput, TFOutput, Nullable<Single>, String)
  fullName: TFGraph.ApproximateEqual(TFOutput, TFOutput, Nullable<Single>, String)
- uid: System.Single
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Nullable{System.Single}
  parent: System
  isExternal: true
  name: Nullable<Single>
  nameWithType: Nullable<Single>
  fullName: System.Nullable<System.Single>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Single
    name: Single
    nameWithType: Single
    fullName: System.Single
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.ArgMax(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ArgMax(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.ArgMax(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.ArgMax(TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.ArgMin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ArgMin(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.ArgMin(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.ArgMin(TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.Asin(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Asin(TFOutput, String)
  nameWithType: TFGraph.Asin(TFOutput, String)
  fullName: TFGraph.Asin(TFOutput, String)
- uid: TensorFlow.TFGraph.Asinh(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Asinh(TFOutput, String)
  nameWithType: TFGraph.Asinh(TFOutput, String)
  fullName: TFGraph.Asinh(TFOutput, String)
- uid: TensorFlow.TFGraph.Assert(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Assert(TFOutput, TFOutput[], Nullable<Int64>, String)
  nameWithType: TFGraph.Assert(TFOutput, TFOutput[], Nullable<Int64>, String)
  fullName: TFGraph.Assert(TFOutput, TFOutput[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.Assign(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Assign(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.Assign(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.Assign(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.AssignAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AssignAdd(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.AssignAdd(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.AssignAdd(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.AssignAddVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AssignAddVariableOp(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AssignAddVariableOp(TFOutput, TFOutput, String)
  fullName: TFGraph.AssignAddVariableOp(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.AssignSub(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AssignSub(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.AssignSub(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.AssignSub(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.AssignSubVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AssignSubVariableOp(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AssignSubVariableOp(TFOutput, TFOutput, String)
  fullName: TFGraph.AssignSubVariableOp(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.AssignVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AssignVariableOp(TFOutput, TFOutput, String)
  nameWithType: TFGraph.AssignVariableOp(TFOutput, TFOutput, String)
  fullName: TFGraph.AssignVariableOp(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.AsString(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AsString(TFOutput, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, String, String)
  nameWithType: TFGraph.AsString(TFOutput, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, String, String)
  fullName: TFGraph.AsString(TFOutput, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.Atan(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Atan(TFOutput, String)
  nameWithType: TFGraph.Atan(TFOutput, String)
  fullName: TFGraph.Atan(TFOutput, String)
- uid: TensorFlow.TFGraph.Atan2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Atan2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Atan2(TFOutput, TFOutput, String)
  fullName: TFGraph.Atan2(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Atanh(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Atanh(TFOutput, String)
  nameWithType: TFGraph.Atanh(TFOutput, String)
  fullName: TFGraph.Atanh(TFOutput, String)
- uid: TensorFlow.TFGraph.AudioSpectrogram(TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AudioSpectrogram(TFOutput, Int64, Int64, Nullable<Boolean>, String)
  nameWithType: TFGraph.AudioSpectrogram(TFOutput, Int64, Int64, Nullable<Boolean>, String)
  fullName: TFGraph.AudioSpectrogram(TFOutput, Int64, Int64, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.AudioSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AudioSummary(TFOutput, TFOutput, Single, Nullable<Int64>, String)
  nameWithType: TFGraph.AudioSummary(TFOutput, TFOutput, Single, Nullable<Int64>, String)
  fullName: TFGraph.AudioSummary(TFOutput, TFOutput, Single, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.AudioSummaryV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AudioSummaryV2(TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.AudioSummaryV2(TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.AudioSummaryV2(TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.AvgPool(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AvgPool(TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.AvgPool(TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.AvgPool(TFOutput, Int64[], Int64[], String, String, String)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64[]
  nameWithType: Int64[]
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: TensorFlow.TFGraph.AvgPool3D(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AvgPool3D(TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.AvgPool3D(TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.AvgPool3D(TFOutput, Int64[], Int64[], String, String, String)
- uid: TensorFlow.TFGraph.AvgPool3DGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AvgPool3DGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.AvgPool3DGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.AvgPool3DGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)
- uid: TensorFlow.TFGraph.AvgPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AvgPoolGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.AvgPoolGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.AvgPoolGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)
- uid: TensorFlow.TFGraph.Barrier(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Barrier(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.Barrier(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.Barrier(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.BarrierClose(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BarrierClose(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.BarrierClose(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.BarrierClose(TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.BarrierIncompleteSize(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BarrierIncompleteSize(TFOutput, String)
  nameWithType: TFGraph.BarrierIncompleteSize(TFOutput, String)
  fullName: TFGraph.BarrierIncompleteSize(TFOutput, String)
- uid: TensorFlow.TFGraph.BarrierInsertMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BarrierInsertMany(TFOutput, TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.BarrierInsertMany(TFOutput, TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.BarrierInsertMany(TFOutput, TFOutput, TFOutput, Int64, String)
- uid: TensorFlow.TFGraph.BarrierReadySize(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BarrierReadySize(TFOutput, String)
  nameWithType: TFGraph.BarrierReadySize(TFOutput, String)
  fullName: TFGraph.BarrierReadySize(TFOutput, String)
- uid: TensorFlow.TFGraph.BarrierTakeMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BarrierTakeMany(TFOutput, TFOutput, TFDataType[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, String)
  nameWithType: TFGraph.BarrierTakeMany(TFOutput, TFOutput, TFDataType[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, String)
  fullName: TFGraph.BarrierTakeMany(TFOutput, TFOutput, TFDataType[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, String)
- uid: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[]}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput,TFOutput,TFOutput[]>
  nameWithType: ValueTuple<TFOutput,TFOutput,TFOutput[]>
  fullName: System.ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[]>
  spec.csharp:
  - uid: System.ValueTuple`3
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.Batch(TensorFlow.TFOutput[],System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{System.Int64},System.Int64[],System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Batch(TFOutput[], Int64, Int64, Int64, Int64, Nullable<Int64>, Int64[], String, String, String, String)
  nameWithType: TFGraph.Batch(TFOutput[], Int64, Int64, Int64, Int64, Nullable<Int64>, Int64[], String, String, String, String)
  fullName: TFGraph.Batch(TFOutput[], Int64, Int64, Int64, Int64, Nullable<Int64>, Int64[], String, String, String, String)
- uid: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput[],TFOutput,TFOutput>
  nameWithType: ValueTuple<TFOutput[],TFOutput,TFOutput>
  fullName: System.ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput>
  spec.csharp:
  - uid: System.ValueTuple`3
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.BatchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.BatchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.BatchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.BatchDatasetV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchDatasetV2(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.BatchDatasetV2(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.BatchDatasetV2(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.BatchMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchMatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.BatchMatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.BatchMatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.BatchNormWithGlobalNormalization(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)
  nameWithType: TFGraph.BatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)
  fullName: TFGraph.BatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)
- uid: TensorFlow.TFGraph.BatchNormWithGlobalNormalizationGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchNormWithGlobalNormalizationGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)
  nameWithType: TFGraph.BatchNormWithGlobalNormalizationGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)
  fullName: TFGraph.BatchNormWithGlobalNormalizationGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)
- uid: System.ValueTuple`5
  name: ValueTuple
  nameWithType: ValueTuple
  fullName: System.ValueTuple
- uid: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput,TFOutput,TFOutput,TFOutput,TFOutput>
  nameWithType: ValueTuple<TFOutput,TFOutput,TFOutput,TFOutput,TFOutput>
  fullName: System.ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput>
  spec.csharp:
  - uid: System.ValueTuple`5
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.BatchToSpace(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchToSpace(TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.BatchToSpace(TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.BatchToSpace(TFOutput, TFOutput, Int64, String)
- uid: TensorFlow.TFGraph.BatchToSpaceND(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchToSpaceND(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.BatchToSpaceND(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.BatchToSpaceND(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.BesselI0e(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BesselI0e(TFOutput, String)
  nameWithType: TFGraph.BesselI0e(TFOutput, String)
  fullName: TFGraph.BesselI0e(TFOutput, String)
- uid: TensorFlow.TFGraph.BesselI1e(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BesselI1e(TFOutput, String)
  nameWithType: TFGraph.BesselI1e(TFOutput, String)
  fullName: TFGraph.BesselI1e(TFOutput, String)
- uid: TensorFlow.TFGraph.Betainc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Betainc(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.Betainc(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.Betainc(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.BiasAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BiasAdd(TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.BiasAdd(TFOutput, TFOutput, String, String)
  fullName: TFGraph.BiasAdd(TFOutput, TFOutput, String, String)
- uid: TensorFlow.TFGraph.BiasAddGrad(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BiasAddGrad(TFOutput, String, String)
  nameWithType: TFGraph.BiasAddGrad(TFOutput, String, String)
  fullName: TFGraph.BiasAddGrad(TFOutput, String, String)
- uid: TensorFlow.TFGraph.BiasAddV1(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BiasAddV1(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BiasAddV1(TFOutput, TFOutput, String)
  fullName: TFGraph.BiasAddV1(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.BigQueryReader(System.String,System.String,System.String,System.String[],System.Int64,System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BigQueryReader(String, String, String, String[], Int64, String, String, String, String)
  nameWithType: TFGraph.BigQueryReader(String, String, String, String[], Int64, String, String, String, String)
  fullName: TFGraph.BigQueryReader(String, String, String, String[], Int64, String, String, String, String)
- uid: System.String[]
  parent: System
  isExternal: true
  name: String[]
  nameWithType: String[]
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: TensorFlow.TFGraph.Bincount(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Bincount(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.Bincount(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.Bincount(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Bitcast(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Bitcast(TFOutput, TFDataType, String)
  nameWithType: TFGraph.Bitcast(TFOutput, TFDataType, String)
  fullName: TFGraph.Bitcast(TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.BitwiseAnd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BitwiseAnd(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BitwiseAnd(TFOutput, TFOutput, String)
  fullName: TFGraph.BitwiseAnd(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.BitwiseOr(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BitwiseOr(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BitwiseOr(TFOutput, TFOutput, String)
  fullName: TFGraph.BitwiseOr(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.BitwiseXor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BitwiseXor(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BitwiseXor(TFOutput, TFOutput, String)
  fullName: TFGraph.BitwiseXor(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.BoostedTreesBucketize(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesBucketize(TFOutput[], TFOutput[], String)
  nameWithType: TFGraph.BoostedTreesBucketize(TFOutput[], TFOutput[], String)
  fullName: TFGraph.BoostedTreesBucketize(TFOutput[], TFOutput[], String)
- uid: TensorFlow.TFGraph.BoostedTreesCalculateBestGainsPerFeature(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesCalculateBestGainsPerFeature(TFOutput, TFOutput[], TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.BoostedTreesCalculateBestGainsPerFeature(TFOutput, TFOutput[], TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.BoostedTreesCalculateBestGainsPerFeature(TFOutput, TFOutput[], TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)
- uid: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[]>
  nameWithType: ValueTuple<TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[]>
  fullName: System.ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]>
  spec.csharp:
  - uid: System.ValueTuple`5
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.BoostedTreesCenterBias(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesCenterBias(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.BoostedTreesCenterBias(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.BoostedTreesCenterBias(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.BoostedTreesCreateEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesCreateEnsemble(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.BoostedTreesCreateEnsemble(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.BoostedTreesCreateEnsemble(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.BoostedTreesCreateQuantileStreamResource(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesCreateQuantileStreamResource(TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.BoostedTreesCreateQuantileStreamResource(TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.BoostedTreesCreateQuantileStreamResource(TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.BoostedTreesDeserializeEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesDeserializeEnsemble(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.BoostedTreesDeserializeEnsemble(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.BoostedTreesDeserializeEnsemble(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.BoostedTreesEnsembleResourceHandleOp(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesEnsembleResourceHandleOp(String, String, String)
  nameWithType: TFGraph.BoostedTreesEnsembleResourceHandleOp(String, String, String)
  fullName: TFGraph.BoostedTreesEnsembleResourceHandleOp(String, String, String)
- uid: TensorFlow.TFGraph.BoostedTreesExampleDebugOutputs(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesExampleDebugOutputs(TFOutput, TFOutput[], Int64, String)
  nameWithType: TFGraph.BoostedTreesExampleDebugOutputs(TFOutput, TFOutput[], Int64, String)
  fullName: TFGraph.BoostedTreesExampleDebugOutputs(TFOutput, TFOutput[], Int64, String)
- uid: TensorFlow.TFGraph.BoostedTreesGetEnsembleStates(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesGetEnsembleStates(TFOutput, String)
  nameWithType: TFGraph.BoostedTreesGetEnsembleStates(TFOutput, String)
  fullName: TFGraph.BoostedTreesGetEnsembleStates(TFOutput, String)
- uid: TensorFlow.TFGraph.BoostedTreesMakeQuantileSummaries(TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesMakeQuantileSummaries(TFOutput[], TFOutput, TFOutput, String)
  nameWithType: TFGraph.BoostedTreesMakeQuantileSummaries(TFOutput[], TFOutput, TFOutput, String)
  fullName: TFGraph.BoostedTreesMakeQuantileSummaries(TFOutput[], TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.BoostedTreesMakeStatsSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesMakeStatsSummary(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, Int64, String)
  nameWithType: TFGraph.BoostedTreesMakeStatsSummary(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, Int64, String)
  fullName: TFGraph.BoostedTreesMakeStatsSummary(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, Int64, String)
- uid: TensorFlow.TFGraph.BoostedTreesPredict(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesPredict(TFOutput, TFOutput[], Int64, String)
  nameWithType: TFGraph.BoostedTreesPredict(TFOutput, TFOutput[], Int64, String)
  fullName: TFGraph.BoostedTreesPredict(TFOutput, TFOutput[], Int64, String)
- uid: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceAddSummaries(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesQuantileStreamResourceAddSummaries(TFOutput, TFOutput[], String)
  nameWithType: TFGraph.BoostedTreesQuantileStreamResourceAddSummaries(TFOutput, TFOutput[], String)
  fullName: TFGraph.BoostedTreesQuantileStreamResourceAddSummaries(TFOutput, TFOutput[], String)
- uid: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceFlush(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesQuantileStreamResourceFlush(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.BoostedTreesQuantileStreamResourceFlush(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.BoostedTreesQuantileStreamResourceFlush(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceGetBucketBoundaries(TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesQuantileStreamResourceGetBucketBoundaries(TFOutput, Int64, String)
  nameWithType: TFGraph.BoostedTreesQuantileStreamResourceGetBucketBoundaries(TFOutput, Int64, String)
  fullName: TFGraph.BoostedTreesQuantileStreamResourceGetBucketBoundaries(TFOutput, Int64, String)
- uid: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceHandleOp(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesQuantileStreamResourceHandleOp(String, String, String)
  nameWithType: TFGraph.BoostedTreesQuantileStreamResourceHandleOp(String, String, String)
  fullName: TFGraph.BoostedTreesQuantileStreamResourceHandleOp(String, String, String)
- uid: TensorFlow.TFGraph.BoostedTreesSerializeEnsemble(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesSerializeEnsemble(TFOutput, String)
  nameWithType: TFGraph.BoostedTreesSerializeEnsemble(TFOutput, String)
  fullName: TFGraph.BoostedTreesSerializeEnsemble(TFOutput, String)
- uid: System.ValueTuple`2
  name: ValueTuple
  nameWithType: ValueTuple
  fullName: System.ValueTuple
- uid: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput,TFOutput>
  nameWithType: ValueTuple<TFOutput,TFOutput>
  fullName: System.ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput>
  spec.csharp:
  - uid: System.ValueTuple`2
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.BoostedTreesTrainingPredict(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesTrainingPredict(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, String)
  nameWithType: TFGraph.BoostedTreesTrainingPredict(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, String)
  fullName: TFGraph.BoostedTreesTrainingPredict(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, String)
- uid: TensorFlow.TFGraph.BoostedTreesUpdateEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesUpdateEnsemble(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.BoostedTreesUpdateEnsemble(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.BoostedTreesUpdateEnsemble(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, Int64, String)
- uid: TensorFlow.TFGraph.BroadcastArgs(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BroadcastArgs(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BroadcastArgs(TFOutput, TFOutput, String)
  fullName: TFGraph.BroadcastArgs(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.BroadcastGradientArgs(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BroadcastGradientArgs(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BroadcastGradientArgs(TFOutput, TFOutput, String)
  fullName: TFGraph.BroadcastGradientArgs(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.BroadcastTo(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BroadcastTo(TFOutput, TFOutput, String)
  nameWithType: TFGraph.BroadcastTo(TFOutput, TFOutput, String)
  fullName: TFGraph.BroadcastTo(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Bucketize(TensorFlow.TFOutput,System.Single[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Bucketize(TFOutput, Single[], String)
  nameWithType: TFGraph.Bucketize(TFOutput, Single[], String)
  fullName: TFGraph.Bucketize(TFOutput, Single[], String)
- uid: System.Single[]
  parent: System
  isExternal: true
  name: Single[]
  nameWithType: Single[]
  fullName: System.Single[]
  spec.csharp:
  - uid: System.Single
    name: Single
    nameWithType: Single
    fullName: System.Single
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: TensorFlow.TFGraph.CacheDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CacheDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.CacheDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.CacheDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.Cast(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cast(TFOutput, TFDataType, Nullable<Boolean>, String)
  nameWithType: TFGraph.Cast(TFOutput, TFDataType, Nullable<Boolean>, String)
  fullName: TFGraph.Cast(TFOutput, TFDataType, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Ceil(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Ceil(TFOutput, String)
  nameWithType: TFGraph.Ceil(TFOutput, String)
  fullName: TFGraph.Ceil(TFOutput, String)
- uid: TensorFlow.TFGraph.CheckNumerics(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CheckNumerics(TFOutput, String, String)
  nameWithType: TFGraph.CheckNumerics(TFOutput, String, String)
  fullName: TFGraph.CheckNumerics(TFOutput, String, String)
- uid: TensorFlow.TFGraph.Cholesky(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cholesky(TFOutput, String)
  nameWithType: TFGraph.Cholesky(TFOutput, String)
  fullName: TFGraph.Cholesky(TFOutput, String)
- uid: TensorFlow.TFGraph.CholeskyGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CholeskyGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.CholeskyGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.CholeskyGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ClipByAverageNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ClipByAverageNorm(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ClipByAverageNorm(TFOutput, TFOutput, String)
  fullName: TFGraph.ClipByAverageNorm(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ClipByNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ClipByNorm(TFOutput, TFOutput, Nullable<TFOutput>, String)
  nameWithType: TFGraph.ClipByNorm(TFOutput, TFOutput, Nullable<TFOutput>, String)
  fullName: TFGraph.ClipByNorm(TFOutput, TFOutput, Nullable<TFOutput>, String)
- uid: System.Nullable{TensorFlow.TFOutput}
  parent: System
  isExternal: true
  name: Nullable<TFOutput>
  nameWithType: Nullable<TFOutput>
  fullName: System.Nullable<TensorFlow.TFOutput>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.ClipByValue(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ClipByValue(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ClipByValue(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ClipByValue(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.CollectiveBcastRecv(TensorFlow.TFDataType,System.Int64,System.Int64,System.Int64,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CollectiveBcastRecv(TFDataType, Int64, Int64, Int64, TFShape, String)
  nameWithType: TFGraph.CollectiveBcastRecv(TFDataType, Int64, Int64, Int64, TFShape, String)
  fullName: TFGraph.CollectiveBcastRecv(TFDataType, Int64, Int64, Int64, TFShape, String)
- uid: TensorFlow.TFGraph.CollectiveBcastSend(TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CollectiveBcastSend(TFOutput, Int64, Int64, Int64, TFShape, String)
  nameWithType: TFGraph.CollectiveBcastSend(TFOutput, Int64, Int64, Int64, TFShape, String)
  fullName: TFGraph.CollectiveBcastSend(TFOutput, Int64, Int64, Int64, TFShape, String)
- uid: TensorFlow.TFGraph.CollectivePermute(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CollectivePermute(TFOutput, TFOutput, String)
  nameWithType: TFGraph.CollectivePermute(TFOutput, TFOutput, String)
  fullName: TFGraph.CollectivePermute(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.CollectiveReduce(TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CollectiveReduce(TFOutput, Int64, Int64, Int64, String, String, Int64[], String)
  nameWithType: TFGraph.CollectiveReduce(TFOutput, Int64, Int64, Int64, String, String, Int64[], String)
  fullName: TFGraph.CollectiveReduce(TFOutput, Int64, Int64, Int64, String, String, Int64[], String)
- uid: TensorFlow.TFGraph.CompareAndBitpack(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CompareAndBitpack(TFOutput, TFOutput, String)
  nameWithType: TFGraph.CompareAndBitpack(TFOutput, TFOutput, String)
  fullName: TFGraph.CompareAndBitpack(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Complex(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Complex(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Complex(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Complex(TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.ComplexAbs(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ComplexAbs(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.ComplexAbs(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.ComplexAbs(TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.ComputeAccidentalHits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ComputeAccidentalHits(TFOutput, TFOutput, Int64, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.ComputeAccidentalHits(TFOutput, TFOutput, Int64, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.ComputeAccidentalHits(TFOutput, TFOutput, Int64, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.Concat(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Concat(TFOutput, TFOutput[], String)
  nameWithType: TFGraph.Concat(TFOutput, TFOutput[], String)
  fullName: TFGraph.Concat(TFOutput, TFOutput[], String)
- uid: TensorFlow.TFGraph.ConcatenateDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConcatenateDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ConcatenateDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.ConcatenateDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.ConcatOffset(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConcatOffset(TFOutput, TFOutput[], String)
  nameWithType: TFGraph.ConcatOffset(TFOutput, TFOutput[], String)
  fullName: TFGraph.ConcatOffset(TFOutput, TFOutput[], String)
- uid: TensorFlow.TFGraph.ConcatV2(TensorFlow.TFOutput[],TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConcatV2(TFOutput[], TFOutput, String)
  nameWithType: TFGraph.ConcatV2(TFOutput[], TFOutput, String)
  fullName: TFGraph.ConcatV2(TFOutput[], TFOutput, String)
- uid: TensorFlow.TFGraph.Cond(TensorFlow.TFOutput,System.Func{TensorFlow.TFOutput},System.Func{TensorFlow.TFOutput},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cond(TFOutput, Func<TFOutput>, Func<TFOutput>, String)
  nameWithType: TFGraph.Cond(TFOutput, Func<TFOutput>, Func<TFOutput>, String)
  fullName: TFGraph.Cond(TFOutput, Func<TFOutput>, Func<TFOutput>, String)
- uid: System.Func`1
  name: Func
  nameWithType: Func
  fullName: System.Func
- uid: System.Func{TensorFlow.TFOutput}
  parent: System
  isExternal: true
  name: Func<TFOutput>
  nameWithType: Func<TFOutput>
  fullName: System.Func<TensorFlow.TFOutput>
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.ConditionalAccumulator(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConditionalAccumulator(TFDataType, TFShape, String, String, String, String)
  nameWithType: TFGraph.ConditionalAccumulator(TFDataType, TFShape, String, String, String, String)
  fullName: TFGraph.ConditionalAccumulator(TFDataType, TFShape, String, String, String, String)
- uid: TensorFlow.TFGraph.ConfigureDistributedTPU(System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConfigureDistributedTPU(String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.ConfigureDistributedTPU(String, String, Nullable<Boolean>, String)
  fullName: TFGraph.ConfigureDistributedTPU(String, String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Conj(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conj(TFOutput, String)
  nameWithType: TFGraph.Conj(TFOutput, String)
  fullName: TFGraph.Conj(TFOutput, String)
- uid: TensorFlow.TFGraph.ConjugateTranspose(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConjugateTranspose(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ConjugateTranspose(TFOutput, TFOutput, String)
  fullName: TFGraph.ConjugateTranspose(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Const(TensorFlow.TFTensor,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Const(TFTensor, String)
  nameWithType: TFGraph.Const(TFTensor, String)
  fullName: TFGraph.Const(TFTensor, String)
- uid: TensorFlow.TFTensor
  parent: TensorFlow
  isExternal: false
  name: TFTensor
  nameWithType: TFTensor
  fullName: TensorFlow.TFTensor
- uid: TensorFlow.TFGraph.Const(TensorFlow.TFTensor,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Const(TFTensor, TFDataType, String)
  nameWithType: TFGraph.Const(TFTensor, TFDataType, String)
  fullName: TFGraph.Const(TFTensor, TFDataType, String)
- uid: TensorFlow.TFGraph.Constant(System.Object,TensorFlow.TFShape,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Constant(Object, TFShape, TFDataType, String)
  nameWithType: TFGraph.Constant(Object, TFShape, TFDataType, String)
  fullName: TFGraph.Constant(Object, TFShape, TFDataType, String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: TensorFlow.TFGraph.ConsumeMutexLock(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConsumeMutexLock(TFOutput, String)
  nameWithType: TFGraph.ConsumeMutexLock(TFOutput, String)
  fullName: TFGraph.ConsumeMutexLock(TFOutput, String)
- uid: TensorFlow.TFGraph.ControlTrigger(System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ControlTrigger(String)
  nameWithType: TFGraph.ControlTrigger(String)
  fullName: TFGraph.ControlTrigger(String)
- uid: TensorFlow.TFGraph.Conv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv2D(TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  nameWithType: TFGraph.Conv2D(TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  fullName: TFGraph.Conv2D(TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
- uid: TensorFlow.TFGraph.Conv2DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  nameWithType: TFGraph.Conv2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  fullName: TFGraph.Conv2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
- uid: TensorFlow.TFGraph.Conv2DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  nameWithType: TFGraph.Conv2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
  fullName: TFGraph.Conv2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<Boolean>, String, Int64[], String)
- uid: TensorFlow.TFGraph.Conv3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv3D(TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  nameWithType: TFGraph.Conv3D(TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  fullName: TFGraph.Conv3D(TFOutput, TFOutput, Int64[], String, String, Int64[], String)
- uid: TensorFlow.TFGraph.Conv3DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv3DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)
  nameWithType: TFGraph.Conv3DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)
  fullName: TFGraph.Conv3DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)
- uid: TensorFlow.TFGraph.Conv3DBackpropFilterV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv3DBackpropFilterV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  nameWithType: TFGraph.Conv3DBackpropFilterV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  fullName: TFGraph.Conv3DBackpropFilterV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
- uid: TensorFlow.TFGraph.Conv3DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv3DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)
  nameWithType: TFGraph.Conv3DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)
  fullName: TFGraph.Conv3DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)
- uid: TensorFlow.TFGraph.Conv3DBackpropInputV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv3DBackpropInputV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  nameWithType: TFGraph.Conv3DBackpropInputV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  fullName: TFGraph.Conv3DBackpropInputV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
- uid: TensorFlow.TFGraph.Copy(TensorFlow.TFOutput,System.String,System.String[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Copy(TFOutput, String, String[], String)
  nameWithType: TFGraph.Copy(TFOutput, String, String[], String)
  fullName: TFGraph.Copy(TFOutput, String, String[], String)
- uid: TensorFlow.TFGraph.CopyHost(TensorFlow.TFOutput,System.String,System.String[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CopyHost(TFOutput, String, String[], String)
  nameWithType: TFGraph.CopyHost(TFOutput, String, String[], String)
  fullName: TFGraph.CopyHost(TFOutput, String, String[], String)
- uid: TensorFlow.TFGraph.Cos(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cos(TFOutput, String)
  nameWithType: TFGraph.Cos(TFOutput, String)
  fullName: TFGraph.Cos(TFOutput, String)
- uid: TensorFlow.TFGraph.Cosh(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cosh(TFOutput, String)
  nameWithType: TFGraph.Cosh(TFOutput, String)
  fullName: TFGraph.Cosh(TFOutput, String)
- uid: TensorFlow.TFGraph.CountUpTo(TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CountUpTo(TFOutput, Int64, String)
  nameWithType: TFGraph.CountUpTo(TFOutput, Int64, String)
  fullName: TFGraph.CountUpTo(TFOutput, Int64, String)
- uid: TensorFlow.TFGraph.CropAndResize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CropAndResize(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Single>, String)
  nameWithType: TFGraph.CropAndResize(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Single>, String)
  fullName: TFGraph.CropAndResize(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Single>, String)
- uid: TensorFlow.TFGraph.CropAndResizeGradBoxes(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CropAndResizeGradBoxes(TFOutput, TFOutput, TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.CropAndResizeGradBoxes(TFOutput, TFOutput, TFOutput, TFOutput, String, String)
  fullName: TFGraph.CropAndResizeGradBoxes(TFOutput, TFOutput, TFOutput, TFOutput, String, String)
- uid: TensorFlow.TFGraph.CropAndResizeGradImage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CropAndResizeGradImage(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String, String)
  nameWithType: TFGraph.CropAndResizeGradImage(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String, String)
  fullName: TFGraph.CropAndResizeGradImage(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String, String)
- uid: TensorFlow.TFGraph.Cross(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cross(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Cross(TFOutput, TFOutput, String)
  fullName: TFGraph.Cross(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.CrossReplicaSum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CrossReplicaSum(TFOutput, TFOutput, String)
  nameWithType: TFGraph.CrossReplicaSum(TFOutput, TFOutput, String)
  fullName: TFGraph.CrossReplicaSum(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.CTCBeamSearchDecoder(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CTCBeamSearchDecoder(TFOutput, TFOutput, Int64, Int64, Nullable<Boolean>, String)
  nameWithType: TFGraph.CTCBeamSearchDecoder(TFOutput, TFOutput, Int64, Int64, Nullable<Boolean>, String)
  fullName: TFGraph.CTCBeamSearchDecoder(TFOutput, TFOutput, Int64, Int64, Nullable<Boolean>, String)
- uid: System.ValueTuple`4
  name: ValueTuple
  nameWithType: ValueTuple
  fullName: System.ValueTuple
- uid: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput[],TFOutput[],TFOutput[],TFOutput>
  nameWithType: ValueTuple<TFOutput[],TFOutput[],TFOutput[],TFOutput>
  fullName: System.ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput>
  spec.csharp:
  - uid: System.ValueTuple`4
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.CTCGreedyDecoder(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CTCGreedyDecoder(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.CTCGreedyDecoder(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.CTCGreedyDecoder(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput,TFOutput,TFOutput,TFOutput>
  nameWithType: ValueTuple<TFOutput,TFOutput,TFOutput,TFOutput>
  fullName: System.ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput>
  spec.csharp:
  - uid: System.ValueTuple`4
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.CTCLoss(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CTCLoss(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.CTCLoss(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.CTCLoss(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.CudnnRNN(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNN(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.CudnnRNN(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.CudnnRNN(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.CudnnRNNBackprop(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNNBackprop(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.CudnnRNNBackprop(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.CudnnRNNBackprop(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.CudnnRNNBackpropV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNNBackpropV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.CudnnRNNBackpropV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.CudnnRNNBackpropV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.CudnnRNNCanonicalToParams(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNNCanonicalToParams(TFOutput, TFOutput, TFOutput, TFOutput[], TFOutput[], String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.CudnnRNNCanonicalToParams(TFOutput, TFOutput, TFOutput, TFOutput[], TFOutput[], String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.CudnnRNNCanonicalToParams(TFOutput, TFOutput, TFOutput, TFOutput[], TFOutput[], String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.CudnnRNNParamsSize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNNParamsSize(TFOutput, TFOutput, TFOutput, TFDataType, TFDataType, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.CudnnRNNParamsSize(TFOutput, TFOutput, TFOutput, TFDataType, TFDataType, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.CudnnRNNParamsSize(TFOutput, TFOutput, TFOutput, TFDataType, TFDataType, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.CudnnRNNParamsToCanonical(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNNParamsToCanonical(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.CudnnRNNParamsToCanonical(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.CudnnRNNParamsToCanonical(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
- uid: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[]}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput[],TFOutput[]>
  nameWithType: ValueTuple<TFOutput[],TFOutput[]>
  fullName: System.ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[]>
  spec.csharp:
  - uid: System.ValueTuple`2
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.CudnnRNNV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNNV2(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.CudnnRNNV2(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.CudnnRNNV2(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Cumprod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cumprod(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.Cumprod(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.Cumprod(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Cumsum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cumsum(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.Cumsum(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.Cumsum(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.CurrentDependencies
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CurrentDependencies
  nameWithType: TFGraph.CurrentDependencies
  fullName: TFGraph.CurrentDependencies
- uid: TensorFlow.TFOperation[]
  parent: TensorFlow
  isExternal: false
  name: TFOperation[]
  nameWithType: TFOperation[]
  fullName: TensorFlow.TFOperation[]
  spec.csharp:
  - uid: TensorFlow.TFOperation
    name: TFOperation
    nameWithType: TFOperation
    fullName: TensorFlow.TFOperation
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: TensorFlow.TFGraph.CurrentNameScope
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CurrentNameScope
  nameWithType: TFGraph.CurrentNameScope
  fullName: TFGraph.CurrentNameScope
- uid: TensorFlow.TFGraph.DataFormatDimMap(TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DataFormatDimMap(TFOutput, String, String, String)
  nameWithType: TFGraph.DataFormatDimMap(TFOutput, String, String, String)
  fullName: TFGraph.DataFormatDimMap(TFOutput, String, String, String)
- uid: TensorFlow.TFGraph.DataFormatVecPermute(TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DataFormatVecPermute(TFOutput, String, String, String)
  nameWithType: TFGraph.DataFormatVecPermute(TFOutput, String, String, String)
  fullName: TFGraph.DataFormatVecPermute(TFOutput, String, String, String)
- uid: TensorFlow.TFGraph.DatasetToGraph(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DatasetToGraph(TFOutput, String)
  nameWithType: TFGraph.DatasetToGraph(TFOutput, String)
  fullName: TFGraph.DatasetToGraph(TFOutput, String)
- uid: TensorFlow.TFGraph.DatasetToSingleElement(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DatasetToSingleElement(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.DatasetToSingleElement(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.DatasetToSingleElement(TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.DebugGradientIdentity(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DebugGradientIdentity(TFOutput, String)
  nameWithType: TFGraph.DebugGradientIdentity(TFOutput, String)
  fullName: TFGraph.DebugGradientIdentity(TFOutput, String)
- uid: TensorFlow.TFGraph.DebugGradientRefIdentity(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DebugGradientRefIdentity(TFOutput, String)
  nameWithType: TFGraph.DebugGradientRefIdentity(TFOutput, String)
  fullName: TFGraph.DebugGradientRefIdentity(TFOutput, String)
- uid: TensorFlow.TFGraph.DebugIdentity(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DebugIdentity(TFOutput, String, String, String[], Nullable<Boolean>, String)
  nameWithType: TFGraph.DebugIdentity(TFOutput, String, String, String[], Nullable<Boolean>, String)
  fullName: TFGraph.DebugIdentity(TFOutput, String, String, String[], Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.DebugNanCount(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DebugNanCount(TFOutput, String, String, String[], Nullable<Boolean>, String)
  nameWithType: TFGraph.DebugNanCount(TFOutput, String, String, String[], Nullable<Boolean>, String)
  fullName: TFGraph.DebugNanCount(TFOutput, String, String, String[], Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.DebugNumericSummary(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DebugNumericSummary(TFOutput, String, String, String[], Nullable<Single>, Nullable<Single>, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.DebugNumericSummary(TFOutput, String, String, String[], Nullable<Single>, Nullable<Single>, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.DebugNumericSummary(TFOutput, String, String, String[], Nullable<Single>, Nullable<Single>, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.DecodeAndCropJpeg(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Single},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeAndCropJpeg(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Single>, String, String)
  nameWithType: TFGraph.DecodeAndCropJpeg(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Single>, String, String)
  fullName: TFGraph.DecodeAndCropJpeg(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Single>, String, String)
- uid: TensorFlow.TFGraph.DecodeBase64(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeBase64(TFOutput, String)
  nameWithType: TFGraph.DecodeBase64(TFOutput, String)
  fullName: TFGraph.DecodeBase64(TFOutput, String)
- uid: TensorFlow.TFGraph.DecodeBmp(TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeBmp(TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.DecodeBmp(TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.DecodeBmp(TFOutput, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.DecodeCompressed(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeCompressed(TFOutput, String, String)
  nameWithType: TFGraph.DecodeCompressed(TFOutput, String, String)
  fullName: TFGraph.DecodeCompressed(TFOutput, String, String)
- uid: TensorFlow.TFGraph.DecodeCSV(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeCSV(TFOutput, TFOutput[], String, Nullable<Boolean>, String, Int64[], String)
  nameWithType: TFGraph.DecodeCSV(TFOutput, TFOutput[], String, Nullable<Boolean>, String, Int64[], String)
  fullName: TFGraph.DecodeCSV(TFOutput, TFOutput[], String, Nullable<Boolean>, String, Int64[], String)
- uid: TensorFlow.TFGraph.DecodeGif(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeGif(TFOutput, String)
  nameWithType: TFGraph.DecodeGif(TFOutput, String)
  fullName: TFGraph.DecodeGif(TFOutput, String)
- uid: TensorFlow.TFGraph.DecodeJpeg(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Single},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeJpeg(TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Single>, String, String)
  nameWithType: TFGraph.DecodeJpeg(TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Single>, String, String)
  fullName: TFGraph.DecodeJpeg(TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Single>, String, String)
- uid: TensorFlow.TFGraph.DecodeJSONExample(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeJSONExample(TFOutput, String)
  nameWithType: TFGraph.DecodeJSONExample(TFOutput, String)
  fullName: TFGraph.DecodeJSONExample(TFOutput, String)
- uid: TensorFlow.TFGraph.DecodePng(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodePng(TFOutput, Nullable<Int64>, Nullable<TFDataType>, String)
  nameWithType: TFGraph.DecodePng(TFOutput, Nullable<Int64>, Nullable<TFDataType>, String)
  fullName: TFGraph.DecodePng(TFOutput, Nullable<Int64>, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.DecodeProtoV2(TensorFlow.TFOutput,System.String,System.String[],TensorFlow.TFDataType[],System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeProtoV2(TFOutput, String, String[], TFDataType[], String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.DecodeProtoV2(TFOutput, String, String[], TFDataType[], String, String, Nullable<Boolean>, String)
  fullName: TFGraph.DecodeProtoV2(TFOutput, String, String[], TFDataType[], String, String, Nullable<Boolean>, String)
- uid: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput[]}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput,TFOutput[]>
  nameWithType: ValueTuple<TFOutput,TFOutput[]>
  fullName: System.ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput[]>
  spec.csharp:
  - uid: System.ValueTuple`2
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.DecodeRaw(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeRaw(TFOutput, TFDataType, Nullable<Boolean>, String)
  nameWithType: TFGraph.DecodeRaw(TFOutput, TFDataType, Nullable<Boolean>, String)
  fullName: TFGraph.DecodeRaw(TFOutput, TFDataType, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.DecodeWav(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeWav(TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.DecodeWav(TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.DecodeWav(TFOutput, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.DeepCopy(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DeepCopy(TFOutput, String)
  nameWithType: TFGraph.DeepCopy(TFOutput, String)
  fullName: TFGraph.DeepCopy(TFOutput, String)
- uid: TensorFlow.TFGraph.DeleteSessionTensor(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DeleteSessionTensor(TFOutput, String)
  nameWithType: TFGraph.DeleteSessionTensor(TFOutput, String)
  fullName: TFGraph.DeleteSessionTensor(TFOutput, String)
- uid: TensorFlow.TFGraph.DenseToDenseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DenseToDenseSetOperation(TFOutput, TFOutput, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.DenseToDenseSetOperation(TFOutput, TFOutput, String, Nullable<Boolean>, String)
  fullName: TFGraph.DenseToDenseSetOperation(TFOutput, TFOutput, String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.DenseToSparseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DenseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.DenseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, String)
  fullName: TFGraph.DenseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.DepthToSpace(TensorFlow.TFOutput,System.Int64,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DepthToSpace(TFOutput, Int64, String, String)
  nameWithType: TFGraph.DepthToSpace(TFOutput, Int64, String, String)
  fullName: TFGraph.DepthToSpace(TFOutput, Int64, String, String)
- uid: TensorFlow.TFGraph.DepthwiseConv2dNative(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DepthwiseConv2dNative(TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  nameWithType: TFGraph.DepthwiseConv2dNative(TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  fullName: TFGraph.DepthwiseConv2dNative(TFOutput, TFOutput, Int64[], String, String, Int64[], String)
- uid: TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DepthwiseConv2dNativeBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  nameWithType: TFGraph.DepthwiseConv2dNativeBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  fullName: TFGraph.DepthwiseConv2dNativeBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
- uid: TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DepthwiseConv2dNativeBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  nameWithType: TFGraph.DepthwiseConv2dNativeBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
  fullName: TFGraph.DepthwiseConv2dNativeBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)
- uid: TensorFlow.TFGraph.Dequantize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Dequantize(TFOutput, TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.Dequantize(TFOutput, TFOutput, TFOutput, String, String)
  fullName: TFGraph.Dequantize(TFOutput, TFOutput, TFOutput, String, String)
- uid: TensorFlow.TFGraph.DeserializeIterator(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DeserializeIterator(TFOutput, TFOutput, String)
  nameWithType: TFGraph.DeserializeIterator(TFOutput, TFOutput, String)
  fullName: TFGraph.DeserializeIterator(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.DeserializeManySparse(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DeserializeManySparse(TFOutput, TFDataType, String)
  nameWithType: TFGraph.DeserializeManySparse(TFOutput, TFDataType, String)
  fullName: TFGraph.DeserializeManySparse(TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.DeserializeSparse(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DeserializeSparse(TFOutput, TFDataType, String)
  nameWithType: TFGraph.DeserializeSparse(TFOutput, TFDataType, String)
  fullName: TFGraph.DeserializeSparse(TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.DestroyResourceOp(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DestroyResourceOp(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.DestroyResourceOp(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.DestroyResourceOp(TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.DestroyTemporaryVariable(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DestroyTemporaryVariable(TFOutput, String, String)
  nameWithType: TFGraph.DestroyTemporaryVariable(TFOutput, String, String)
  fullName: TFGraph.DestroyTemporaryVariable(TFOutput, String, String)
- uid: TensorFlow.TFGraph.Diag(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Diag(TFOutput, String)
  nameWithType: TFGraph.Diag(TFOutput, String)
  fullName: TFGraph.Diag(TFOutput, String)
- uid: TensorFlow.TFGraph.DiagPart(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DiagPart(TFOutput, String)
  nameWithType: TFGraph.DiagPart(TFOutput, String)
  fullName: TFGraph.DiagPart(TFOutput, String)
- uid: TensorFlow.TFGraph.Digamma(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Digamma(TFOutput, String)
  nameWithType: TFGraph.Digamma(TFOutput, String)
  fullName: TFGraph.Digamma(TFOutput, String)
- uid: TensorFlow.TFGraph.Dilation2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Dilation2D(TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.Dilation2D(TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.Dilation2D(TFOutput, TFOutput, Int64[], Int64[], String, String)
- uid: TensorFlow.TFGraph.Dilation2DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Dilation2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.Dilation2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.Dilation2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
- uid: TensorFlow.TFGraph.Dilation2DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Dilation2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.Dilation2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.Dilation2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
- uid: TensorFlow.TFGraph.Div(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Div(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Div(TFOutput, TFOutput, String)
  fullName: TFGraph.Div(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.DivNoNan(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DivNoNan(TFOutput, TFOutput, String)
  nameWithType: TFGraph.DivNoNan(TFOutput, TFOutput, String)
  fullName: TFGraph.DivNoNan(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.DrawBoundingBoxes(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DrawBoundingBoxes(TFOutput, TFOutput, String)
  nameWithType: TFGraph.DrawBoundingBoxes(TFOutput, TFOutput, String)
  fullName: TFGraph.DrawBoundingBoxes(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Dropout(TensorFlow.TFOutput,System.Double,TensorFlow.TFShape,System.Nullable{System.Int32},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Dropout(TFOutput, Double, TFShape, Nullable<Int32>, String)
  nameWithType: TFGraph.Dropout(TFOutput, Double, TFShape, Nullable<Int32>, String)
  fullName: TFGraph.Dropout(TFOutput, Double, TFShape, Nullable<Int32>, String)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Int32
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Nullable{System.Int32}
  parent: System
  isExternal: true
  name: Nullable<Int32>
  nameWithType: Nullable<Int32>
  fullName: System.Nullable<System.Int32>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: System.Nullable
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: System.Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.Dropout(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFShape,System.Nullable{System.Int32},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Dropout(TFOutput, TFOutput, TFShape, Nullable<Int32>, String)
  nameWithType: TFGraph.Dropout(TFOutput, TFOutput, TFShape, Nullable<Int32>, String)
  fullName: TFGraph.Dropout(TFOutput, TFOutput, TFShape, Nullable<Int32>, String)
- uid: TensorFlow.TFGraph.DynamicPartition(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DynamicPartition(TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.DynamicPartition(TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.DynamicPartition(TFOutput, TFOutput, Int64, String)
- uid: TensorFlow.TFGraph.DynamicStitch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DynamicStitch(TFOutput[], TFOutput[], String)
  nameWithType: TFGraph.DynamicStitch(TFOutput[], TFOutput[], String)
  fullName: TFGraph.DynamicStitch(TFOutput[], TFOutput[], String)
- uid: TensorFlow.TFGraph.EditDistance(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EditDistance(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.EditDistance(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.EditDistance(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Elu(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Elu(TFOutput, String)
  nameWithType: TFGraph.Elu(TFOutput, String)
  fullName: TFGraph.Elu(TFOutput, String)
- uid: TensorFlow.TFGraph.EluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EluGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.EluGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.EluGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Empty(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Empty(TFOutput, TFDataType, Nullable<Boolean>, String)
  nameWithType: TFGraph.Empty(TFOutput, TFDataType, Nullable<Boolean>, String)
  fullName: TFGraph.Empty(TFOutput, TFDataType, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.EmptyTensorList(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EmptyTensorList(TFOutput, TFDataType, String)
  nameWithType: TFGraph.EmptyTensorList(TFOutput, TFDataType, String)
  fullName: TFGraph.EmptyTensorList(TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.EncodeBase64(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EncodeBase64(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.EncodeBase64(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.EncodeBase64(TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.EncodeJpeg(TensorFlow.TFOutput,System.String,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EncodeJpeg(TFOutput, String, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String, Nullable<Int64>, Nullable<Int64>, String, String)
  nameWithType: TFGraph.EncodeJpeg(TFOutput, String, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String, Nullable<Int64>, Nullable<Int64>, String, String)
  fullName: TFGraph.EncodeJpeg(TFOutput, String, Nullable<Int64>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String, Nullable<Int64>, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.EncodePng(TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EncodePng(TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.EncodePng(TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.EncodePng(TFOutput, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.EncodeProto(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EncodeProto(TFOutput, TFOutput[], String[], String, String, String)
  nameWithType: TFGraph.EncodeProto(TFOutput, TFOutput[], String[], String, String, String)
  fullName: TFGraph.EncodeProto(TFOutput, TFOutput[], String[], String, String, String)
- uid: TensorFlow.TFGraph.EncodeWav(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EncodeWav(TFOutput, TFOutput, String)
  nameWithType: TFGraph.EncodeWav(TFOutput, TFOutput, String)
  fullName: TFGraph.EncodeWav(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.EnqueueTPUEmbeddingIntegerBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EnqueueTPUEmbeddingIntegerBatch(TFOutput[], TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.EnqueueTPUEmbeddingIntegerBatch(TFOutput[], TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.EnqueueTPUEmbeddingIntegerBatch(TFOutput[], TFOutput, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Nullable{System.Int64},System.String[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EnqueueTPUEmbeddingSparseBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Nullable<Int64>, String[], String)
  nameWithType: TFGraph.EnqueueTPUEmbeddingSparseBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Nullable<Int64>, String[], String)
  fullName: TFGraph.EnqueueTPUEmbeddingSparseBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Nullable<Int64>, String[], String)
- uid: TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseTensorBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Int64[],System.Nullable{System.Int64},System.String[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EnqueueTPUEmbeddingSparseTensorBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Int64[], Nullable<Int64>, String[], String)
  nameWithType: TFGraph.EnqueueTPUEmbeddingSparseTensorBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Int64[], Nullable<Int64>, String[], String)
  fullName: TFGraph.EnqueueTPUEmbeddingSparseTensorBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Int64[], Nullable<Int64>, String[], String)
- uid: TensorFlow.TFGraph.EnsureShape(TensorFlow.TFOutput,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EnsureShape(TFOutput, TFShape, String)
  nameWithType: TFGraph.EnsureShape(TFOutput, TFShape, String)
  fullName: TFGraph.EnsureShape(TFOutput, TFShape, String)
- uid: TensorFlow.TFGraph.Enter(TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Enter(TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  nameWithType: TFGraph.Enter(TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  fullName: TFGraph.Enter(TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.Equal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Equal(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Equal(TFOutput, TFOutput, String)
  fullName: TFGraph.Equal(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Erf(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Erf(TFOutput, String)
  nameWithType: TFGraph.Erf(TFOutput, String)
  fullName: TFGraph.Erf(TFOutput, String)
- uid: TensorFlow.TFGraph.Erfc(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Erfc(TFOutput, String)
  nameWithType: TFGraph.Erfc(TFOutput, String)
  fullName: TFGraph.Erfc(TFOutput, String)
- uid: TensorFlow.TFGraph.Exit(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Exit(TFOutput, String)
  nameWithType: TFGraph.Exit(TFOutput, String)
  fullName: TFGraph.Exit(TFOutput, String)
- uid: TensorFlow.TFGraph.Exp(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Exp(TFOutput, String)
  nameWithType: TFGraph.Exp(TFOutput, String)
  fullName: TFGraph.Exp(TFOutput, String)
- uid: TensorFlow.TFGraph.ExpandDims(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExpandDims(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ExpandDims(TFOutput, TFOutput, String)
  fullName: TFGraph.ExpandDims(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ExperimentalDirectedInterleaveDataset(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExperimentalDirectedInterleaveDataset(TFOutput, TFOutput[], TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ExperimentalDirectedInterleaveDataset(TFOutput, TFOutput[], TFDataType[], TFShape[], String)
  fullName: TFGraph.ExperimentalDirectedInterleaveDataset(TFOutput, TFOutput[], TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.ExperimentalIgnoreErrorsDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExperimentalIgnoreErrorsDataset(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ExperimentalIgnoreErrorsDataset(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.ExperimentalIgnoreErrorsDataset(TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.ExperimentalIteratorGetDevice(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExperimentalIteratorGetDevice(TFOutput, String)
  nameWithType: TFGraph.ExperimentalIteratorGetDevice(TFOutput, String)
  fullName: TFGraph.ExperimentalIteratorGetDevice(TFOutput, String)
- uid: TensorFlow.TFGraph.ExperimentalThreadPoolDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExperimentalThreadPoolDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ExperimentalThreadPoolDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.ExperimentalThreadPoolDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.ExperimentalThreadPoolHandle(System.Int64,System.String,System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExperimentalThreadPoolHandle(Int64, String, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.ExperimentalThreadPoolHandle(Int64, String, Nullable<Int64>, String, String, String)
  fullName: TFGraph.ExperimentalThreadPoolHandle(Int64, String, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.ExperimentalUniqueDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExperimentalUniqueDataset(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ExperimentalUniqueDataset(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.ExperimentalUniqueDataset(TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.Expm1(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Expm1(TFOutput, String)
  nameWithType: TFGraph.Expm1(TFOutput, String)
  fullName: TFGraph.Expm1(TFOutput, String)
- uid: TensorFlow.TFGraph.ExtractGlimpse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExtractGlimpse(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ExtractGlimpse(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ExtractGlimpse(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ExtractImagePatches(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExtractImagePatches(TFOutput, Int64[], Int64[], Int64[], String, String)
  nameWithType: TFGraph.ExtractImagePatches(TFOutput, Int64[], Int64[], Int64[], String, String)
  fullName: TFGraph.ExtractImagePatches(TFOutput, Int64[], Int64[], Int64[], String, String)
- uid: TensorFlow.TFGraph.ExtractJpegShape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExtractJpegShape(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.ExtractJpegShape(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.ExtractJpegShape(TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.ExtractVolumePatches(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExtractVolumePatches(TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.ExtractVolumePatches(TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.ExtractVolumePatches(TFOutput, Int64[], Int64[], String, String)
- uid: TensorFlow.TFGraph.Fact(System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Fact(String)
  nameWithType: TFGraph.Fact(String)
  fullName: TFGraph.Fact(String)
- uid: TensorFlow.TFGraph.FakeParam(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeParam(TFDataType, TFShape, String)
  nameWithType: TFGraph.FakeParam(TFDataType, TFShape, String)
  fullName: TFGraph.FakeParam(TFDataType, TFShape, String)
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxArgs(TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQuantWithMinMaxArgs(TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.FakeQuantWithMinMaxArgs(TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.FakeQuantWithMinMaxArgs(TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxArgsGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQuantWithMinMaxArgsGradient(TFOutput, TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.FakeQuantWithMinMaxArgsGradient(TFOutput, TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.FakeQuantWithMinMaxArgsGradient(TFOutput, TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxVars(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQuantWithMinMaxVars(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.FakeQuantWithMinMaxVars(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.FakeQuantWithMinMaxVars(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxVarsGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQuantWithMinMaxVarsGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.FakeQuantWithMinMaxVarsGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.FakeQuantWithMinMaxVarsGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannel(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQuantWithMinMaxVarsPerChannel(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.FakeQuantWithMinMaxVarsPerChannel(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.FakeQuantWithMinMaxVarsPerChannel(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQuantWithMinMaxVarsPerChannelGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.FakeQueue(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQueue(TFOutput, String)
  nameWithType: TFGraph.FakeQueue(TFOutput, String)
  fullName: TFGraph.FakeQueue(TFOutput, String)
- uid: TensorFlow.TFGraph.FFT(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FFT(TFOutput, String)
  nameWithType: TFGraph.FFT(TFOutput, String)
  fullName: TFGraph.FFT(TFOutput, String)
- uid: TensorFlow.TFGraph.FFT2D(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FFT2D(TFOutput, String)
  nameWithType: TFGraph.FFT2D(TFOutput, String)
  fullName: TFGraph.FFT2D(TFOutput, String)
- uid: TensorFlow.TFGraph.FFT3D(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FFT3D(TFOutput, String)
  nameWithType: TFGraph.FFT3D(TFOutput, String)
  fullName: TFGraph.FFT3D(TFOutput, String)
- uid: TensorFlow.TFGraph.FIFOQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FIFOQueue(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.FIFOQueue(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.FIFOQueue(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.FIFOQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FIFOQueueV2(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.FIFOQueueV2(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.FIFOQueueV2(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.Fill(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Fill(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Fill(TFOutput, TFOutput, String)
  fullName: TFGraph.Fill(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.FilterByLastComponentDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FilterByLastComponentDataset(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.FilterByLastComponentDataset(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.FilterByLastComponentDataset(TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.FixedLengthRecordDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FixedLengthRecordDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.FixedLengthRecordDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.FixedLengthRecordDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.FixedLengthRecordReader(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FixedLengthRecordReader(Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.FixedLengthRecordReader(Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.FixedLengthRecordReader(Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.FixedLengthRecordReaderV2(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FixedLengthRecordReaderV2(Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String, String)
  nameWithType: TFGraph.FixedLengthRecordReaderV2(Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String, String)
  fullName: TFGraph.FixedLengthRecordReaderV2(Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String, String)
- uid: TensorFlow.TFGraph.FixedUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Single[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FixedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Single[], Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.FixedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Single[], Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.FixedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, String, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Single[], Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.Floor(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Floor(TFOutput, String)
  nameWithType: TFGraph.Floor(TFOutput, String)
  fullName: TFGraph.Floor(TFOutput, String)
- uid: TensorFlow.TFGraph.FloorDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FloorDiv(TFOutput, TFOutput, String)
  nameWithType: TFGraph.FloorDiv(TFOutput, TFOutput, String)
  fullName: TFGraph.FloorDiv(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.FloorMod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FloorMod(TFOutput, TFOutput, String)
  nameWithType: TFGraph.FloorMod(TFOutput, TFOutput, String)
  fullName: TFGraph.FloorMod(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.FractionalAvgPool(TensorFlow.TFOutput,System.Single[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FractionalAvgPool(TFOutput, Single[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.FractionalAvgPool(TFOutput, Single[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.FractionalAvgPool(TFOutput, Single[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.FractionalAvgPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FractionalAvgPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.FractionalAvgPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.FractionalAvgPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.FractionalMaxPool(TensorFlow.TFOutput,System.Single[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FractionalMaxPool(TFOutput, Single[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.FractionalMaxPool(TFOutput, Single[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.FractionalMaxPool(TFOutput, Single[], Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.FractionalMaxPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FractionalMaxPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.FractionalMaxPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.FractionalMaxPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Functions
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Functions
  nameWithType: TFGraph.Functions
  fullName: TFGraph.Functions
- uid: TensorFlow.TFFunction
  name: TFFunction
  nameWithType: TFFunction
  fullName: TensorFlow.TFFunction
- uid: TensorFlow.TFFunction[]
  parent: TensorFlow
  isExternal: false
  name: TFFunction[]
  nameWithType: TFFunction[]
  fullName: TensorFlow.TFFunction[]
  spec.csharp:
  - uid: TensorFlow.TFFunction
    name: TFFunction
    nameWithType: TFFunction
    fullName: TensorFlow.TFFunction
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: TensorFlow.TFGraph.FusedBatchNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FusedBatchNorm(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.FusedBatchNorm(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  fullName: TFGraph.FusedBatchNorm(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.FusedBatchNormGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FusedBatchNormGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.FusedBatchNormGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  fullName: TFGraph.FusedBatchNormGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.FusedBatchNormGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FusedBatchNormGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.FusedBatchNormGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  fullName: TFGraph.FusedBatchNormGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.FusedBatchNormV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FusedBatchNormV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.FusedBatchNormV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
  fullName: TFGraph.FusedBatchNormV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Single>, String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.FusedPadConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FusedPadConv2D(TFOutput, TFOutput, TFOutput, String, Int64[], String, String)
  nameWithType: TFGraph.FusedPadConv2D(TFOutput, TFOutput, TFOutput, String, Int64[], String, String)
  fullName: TFGraph.FusedPadConv2D(TFOutput, TFOutput, TFOutput, String, Int64[], String, String)
- uid: TensorFlow.TFGraph.FusedResizeAndPadConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Int64[],System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FusedResizeAndPadConv2D(TFOutput, TFOutput, TFOutput, TFOutput, String, Int64[], String, Nullable<Boolean>, String)
  nameWithType: TFGraph.FusedResizeAndPadConv2D(TFOutput, TFOutput, TFOutput, TFOutput, String, Int64[], String, Nullable<Boolean>, String)
  fullName: TFGraph.FusedResizeAndPadConv2D(TFOutput, TFOutput, TFOutput, TFOutput, String, Int64[], String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Gather(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Gather(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Gather(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Gather(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.GatherNd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GatherNd(TFOutput, TFOutput, String)
  nameWithType: TFGraph.GatherNd(TFOutput, TFOutput, String)
  fullName: TFGraph.GatherNd(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.GatherV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GatherV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.GatherV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.GatherV2(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.GcsConfigureBlockCache(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GcsConfigureBlockCache(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.GcsConfigureBlockCache(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.GcsConfigureBlockCache(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.GcsConfigureCredentials(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GcsConfigureCredentials(TFOutput, String)
  nameWithType: TFGraph.GcsConfigureCredentials(TFOutput, String)
  fullName: TFGraph.GcsConfigureCredentials(TFOutput, String)
- uid: TensorFlow.TFGraph.GenerateBigQueryReaderPartitions(System.String,System.String,System.String,System.String[],System.Int64,System.Int64,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GenerateBigQueryReaderPartitions(String, String, String, String[], Int64, Int64, String, String)
  nameWithType: TFGraph.GenerateBigQueryReaderPartitions(String, String, String, String[], Int64, Int64, String, String)
  fullName: TFGraph.GenerateBigQueryReaderPartitions(String, String, String, String[], Int64, Int64, String, String)
- uid: TensorFlow.TFGraph.GenerateVocabRemapping(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GenerateVocabRemapping(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String)
  nameWithType: TFGraph.GenerateVocabRemapping(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String)
  fullName: TFGraph.GenerateVocabRemapping(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.GetEnumerator
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetEnumerator()
  nameWithType: TFGraph.GetEnumerator()
  fullName: TFGraph.GetEnumerator()
- uid: System.Collections.Generic.IEnumerable`1
  name: IEnumerable
  nameWithType: IEnumerable
  fullName: System.Collections.Generic.IEnumerable
- uid: System.Collections.Generic.IEnumerable{TensorFlow.TFOperation}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<TFOperation>
  nameWithType: IEnumerable<TFOperation>
  fullName: System.Collections.Generic.IEnumerable<TensorFlow.TFOperation>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOperation
    name: TFOperation
    nameWithType: TFOperation
    fullName: TensorFlow.TFOperation
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.GetGlobalVariablesInitializer
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetGlobalVariablesInitializer()
  nameWithType: TFGraph.GetGlobalVariablesInitializer()
  fullName: TFGraph.GetGlobalVariablesInitializer()
- uid: TensorFlow.TFGraph.GetRandomSeeds(System.Nullable{System.Int32},System.Int32@,System.Int32@)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetRandomSeeds(Nullable<Int32>, Int32, Int32)
  nameWithType: TFGraph.GetRandomSeeds(Nullable<Int32>, Int32, Int32)
  fullName: TFGraph.GetRandomSeeds(Nullable<Int32>, Int32, Int32)
- uid: TensorFlow.TFGraph.GetSessionHandle(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetSessionHandle(TFOutput, String)
  nameWithType: TFGraph.GetSessionHandle(TFOutput, String)
  fullName: TFGraph.GetSessionHandle(TFOutput, String)
- uid: TensorFlow.TFGraph.GetSessionHandleV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetSessionHandleV2(TFOutput, String)
  nameWithType: TFGraph.GetSessionHandleV2(TFOutput, String)
  fullName: TFGraph.GetSessionHandleV2(TFOutput, String)
- uid: TensorFlow.TFGraph.GetSessionTensor(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetSessionTensor(TFOutput, TFDataType, String)
  nameWithType: TFGraph.GetSessionTensor(TFOutput, TFDataType, String)
  fullName: TFGraph.GetSessionTensor(TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.GetShape(TensorFlow.TFOutput,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetShape(TFOutput, TFStatus)
  nameWithType: TFGraph.GetShape(TFOutput, TFStatus)
  fullName: TFGraph.GetShape(TFOutput, TFStatus)
- uid: TensorFlow.TFGraph.GetTensorNumDims(TensorFlow.TFOutput,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetTensorNumDims(TFOutput, TFStatus)
  nameWithType: TFGraph.GetTensorNumDims(TFOutput, TFStatus)
  fullName: TFGraph.GetTensorNumDims(TFOutput, TFStatus)
- uid: TensorFlow.TFGraph.GetTensorShape(TensorFlow.TFOutput,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetTensorShape(TFOutput, TFStatus)
  nameWithType: TFGraph.GetTensorShape(TFOutput, TFStatus)
  fullName: TFGraph.GetTensorShape(TFOutput, TFStatus)
- uid: TensorFlow.TFGraph.GlobalNorm(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GlobalNorm(TFOutput[], String)
  nameWithType: TFGraph.GlobalNorm(TFOutput[], String)
  fullName: TFGraph.GlobalNorm(TFOutput[], String)
- uid: TensorFlow.TFGraph.Greater(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Greater(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Greater(TFOutput, TFOutput, String)
  fullName: TFGraph.Greater(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.GreaterEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GreaterEqual(TFOutput, TFOutput, String)
  nameWithType: TFGraph.GreaterEqual(TFOutput, TFOutput, String)
  fullName: TFGraph.GreaterEqual(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.GuaranteeConst(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GuaranteeConst(TFOutput, String)
  nameWithType: TFGraph.GuaranteeConst(TFOutput, String)
  fullName: TFGraph.GuaranteeConst(TFOutput, String)
- uid: TensorFlow.TFGraph.HashTable(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: HashTable(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.HashTable(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  fullName: TFGraph.HashTable(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.HashTableV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: HashTableV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.HashTableV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  fullName: TFGraph.HashTableV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.HistogramFixedWidth(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: HistogramFixedWidth(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.HistogramFixedWidth(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.HistogramFixedWidth(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.HistogramSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: HistogramSummary(TFOutput, TFOutput, String)
  nameWithType: TFGraph.HistogramSummary(TFOutput, TFOutput, String)
  fullName: TFGraph.HistogramSummary(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.HostConst(TensorFlow.TFTensor,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: HostConst(TFTensor, TFDataType, String)
  nameWithType: TFGraph.HostConst(TFTensor, TFDataType, String)
  fullName: TFGraph.HostConst(TFTensor, TFDataType, String)
- uid: TensorFlow.TFGraph.HSVToRGB(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: HSVToRGB(TFOutput, String)
  nameWithType: TFGraph.HSVToRGB(TFOutput, String)
  fullName: TFGraph.HSVToRGB(TFOutput, String)
- uid: TensorFlow.TFGraph.Identity(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Identity(TFOutput, String)
  nameWithType: TFGraph.Identity(TFOutput, String)
  fullName: TFGraph.Identity(TFOutput, String)
- uid: TensorFlow.TFGraph.IdentityN(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IdentityN(TFOutput[], String)
  nameWithType: TFGraph.IdentityN(TFOutput[], String)
  fullName: TFGraph.IdentityN(TFOutput[], String)
- uid: TensorFlow.TFGraph.IdentityReader(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IdentityReader(String, String, String)
  nameWithType: TFGraph.IdentityReader(String, String, String)
  fullName: TFGraph.IdentityReader(String, String, String)
- uid: TensorFlow.TFGraph.IdentityReaderV2(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IdentityReaderV2(String, String, String)
  nameWithType: TFGraph.IdentityReaderV2(String, String, String)
  fullName: TFGraph.IdentityReaderV2(String, String, String)
- uid: TensorFlow.TFGraph.IFFT(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IFFT(TFOutput, String)
  nameWithType: TFGraph.IFFT(TFOutput, String)
  fullName: TFGraph.IFFT(TFOutput, String)
- uid: TensorFlow.TFGraph.IFFT2D(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IFFT2D(TFOutput, String)
  nameWithType: TFGraph.IFFT2D(TFOutput, String)
  fullName: TFGraph.IFFT2D(TFOutput, String)
- uid: TensorFlow.TFGraph.IFFT3D(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IFFT3D(TFOutput, String)
  nameWithType: TFGraph.IFFT3D(TFOutput, String)
  fullName: TFGraph.IFFT3D(TFOutput, String)
- uid: TensorFlow.TFGraph.Igamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Igamma(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Igamma(TFOutput, TFOutput, String)
  fullName: TFGraph.Igamma(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Igammac(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Igammac(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Igammac(TFOutput, TFOutput, String)
  fullName: TFGraph.Igammac(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.IgammaGradA(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IgammaGradA(TFOutput, TFOutput, String)
  nameWithType: TFGraph.IgammaGradA(TFOutput, TFOutput, String)
  fullName: TFGraph.IgammaGradA(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Imag(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Imag(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Imag(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Imag(TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.ImageSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},TensorFlow.TFTensor,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ImageSummary(TFOutput, TFOutput, Nullable<Int64>, TFTensor, String)
  nameWithType: TFGraph.ImageSummary(TFOutput, TFOutput, Nullable<Int64>, TFTensor, String)
  fullName: TFGraph.ImageSummary(TFOutput, TFOutput, Nullable<Int64>, TFTensor, String)
- uid: TensorFlow.TFGraph.ImmutableConst(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ImmutableConst(TFDataType, TFShape, String, String)
  nameWithType: TFGraph.ImmutableConst(TFDataType, TFShape, String, String)
  fullName: TFGraph.ImmutableConst(TFDataType, TFShape, String, String)
- uid: TensorFlow.TFGraph.Import(System.Byte[],System.String,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Import(Byte[], String, TFStatus)
  nameWithType: TFGraph.Import(Byte[], String, TFStatus)
  fullName: TFGraph.Import(Byte[], String, TFStatus)
- uid: System.Byte
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte[]
  nameWithType: Byte[]
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: System.Byte
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: TensorFlow.TFGraph.Import(System.Byte[],TensorFlow.TFImportGraphDefOptions,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Import(Byte[], TFImportGraphDefOptions, TFStatus)
  nameWithType: TFGraph.Import(Byte[], TFImportGraphDefOptions, TFStatus)
  fullName: TFGraph.Import(Byte[], TFImportGraphDefOptions, TFStatus)
- uid: TensorFlow.TFImportGraphDefOptions
  parent: TensorFlow
  isExternal: false
  name: TFImportGraphDefOptions
  nameWithType: TFImportGraphDefOptions
  fullName: TensorFlow.TFImportGraphDefOptions
- uid: TensorFlow.TFGraph.Import(TensorFlow.TFBuffer,System.String,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Import(TFBuffer, String, TFStatus)
  nameWithType: TFGraph.Import(TFBuffer, String, TFStatus)
  fullName: TFGraph.Import(TFBuffer, String, TFStatus)
- uid: TensorFlow.TFBuffer
  parent: TensorFlow
  isExternal: false
  name: TFBuffer
  nameWithType: TFBuffer
  fullName: TensorFlow.TFBuffer
- uid: TensorFlow.TFGraph.Import(TensorFlow.TFBuffer,TensorFlow.TFImportGraphDefOptions,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Import(TFBuffer, TFImportGraphDefOptions, TFStatus)
  nameWithType: TFGraph.Import(TFBuffer, TFImportGraphDefOptions, TFStatus)
  fullName: TFGraph.Import(TFBuffer, TFImportGraphDefOptions, TFStatus)
- uid: TensorFlow.TFGraph.ImportGraphDef(TensorFlow.TFBuffer,TensorFlow.TFImportGraphDefOptions,TensorFlow.TFOutput[],TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ImportGraphDef(TFBuffer, TFImportGraphDefOptions, TFOutput[], TFStatus)
  nameWithType: TFGraph.ImportGraphDef(TFBuffer, TFImportGraphDefOptions, TFOutput[], TFStatus)
  fullName: TFGraph.ImportGraphDef(TFBuffer, TFImportGraphDefOptions, TFOutput[], TFStatus)
- uid: TensorFlow.TFGraph.InfeedDequeue(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InfeedDequeue(TFDataType, TFShape, String)
  nameWithType: TFGraph.InfeedDequeue(TFDataType, TFShape, String)
  fullName: TFGraph.InfeedDequeue(TFDataType, TFShape, String)
- uid: TensorFlow.TFGraph.InfeedDequeueTuple(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InfeedDequeueTuple(TFDataType[], TFShape[], String)
  nameWithType: TFGraph.InfeedDequeueTuple(TFDataType[], TFShape[], String)
  fullName: TFGraph.InfeedDequeueTuple(TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.InfeedEnqueue(TensorFlow.TFOutput,TensorFlow.TFShape,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InfeedEnqueue(TFOutput, TFShape, Nullable<Int64>, String)
  nameWithType: TFGraph.InfeedEnqueue(TFOutput, TFShape, Nullable<Int64>, String)
  fullName: TFGraph.InfeedEnqueue(TFOutput, TFShape, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.InfeedEnqueueTuple(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InfeedEnqueueTuple(TFOutput[], TFShape[], Nullable<Int64>, String)
  nameWithType: TFGraph.InfeedEnqueueTuple(TFOutput[], TFShape[], Nullable<Int64>, String)
  fullName: TFGraph.InfeedEnqueueTuple(TFOutput[], TFShape[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.InitializeTable(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InitializeTable(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.InitializeTable(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.InitializeTable(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.InitializeTableFromTextFile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InitializeTableFromTextFile(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.InitializeTableFromTextFile(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.InitializeTableFromTextFile(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.InitializeTableFromTextFileV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InitializeTableFromTextFileV2(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.InitializeTableFromTextFileV2(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.InitializeTableFromTextFileV2(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.InitializeTableV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InitializeTableV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.InitializeTableV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.InitializeTableV2(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.InplaceAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InplaceAdd(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.InplaceAdd(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.InplaceAdd(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.InplaceSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InplaceSub(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.InplaceSub(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.InplaceSub(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.InplaceUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InplaceUpdate(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.InplaceUpdate(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.InplaceUpdate(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.InTopK(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InTopK(TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.InTopK(TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.InTopK(TFOutput, TFOutput, Int64, String)
- uid: TensorFlow.TFGraph.InTopKV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InTopKV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.InTopKV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.InTopKV2(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Inv(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Inv(TFOutput, String)
  nameWithType: TFGraph.Inv(TFOutput, String)
  fullName: TFGraph.Inv(TFOutput, String)
- uid: TensorFlow.TFGraph.Invert(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Invert(TFOutput, String)
  nameWithType: TFGraph.Invert(TFOutput, String)
  fullName: TFGraph.Invert(TFOutput, String)
- uid: TensorFlow.TFGraph.InvertPermutation(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InvertPermutation(TFOutput, String)
  nameWithType: TFGraph.InvertPermutation(TFOutput, String)
  fullName: TFGraph.InvertPermutation(TFOutput, String)
- uid: TensorFlow.TFGraph.InvGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InvGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.InvGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.InvGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.IRFFT(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IRFFT(TFOutput, TFOutput, String)
  nameWithType: TFGraph.IRFFT(TFOutput, TFOutput, String)
  fullName: TFGraph.IRFFT(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.IRFFT2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IRFFT2D(TFOutput, TFOutput, String)
  nameWithType: TFGraph.IRFFT2D(TFOutput, TFOutput, String)
  fullName: TFGraph.IRFFT2D(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.IRFFT3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IRFFT3D(TFOutput, TFOutput, String)
  nameWithType: TFGraph.IRFFT3D(TFOutput, TFOutput, String)
  fullName: TFGraph.IRFFT3D(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.IsBoostedTreesEnsembleInitialized(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IsBoostedTreesEnsembleInitialized(TFOutput, String)
  nameWithType: TFGraph.IsBoostedTreesEnsembleInitialized(TFOutput, String)
  fullName: TFGraph.IsBoostedTreesEnsembleInitialized(TFOutput, String)
- uid: TensorFlow.TFGraph.IsBoostedTreesQuantileStreamResourceInitialized(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IsBoostedTreesQuantileStreamResourceInitialized(TFOutput, String)
  nameWithType: TFGraph.IsBoostedTreesQuantileStreamResourceInitialized(TFOutput, String)
  fullName: TFGraph.IsBoostedTreesQuantileStreamResourceInitialized(TFOutput, String)
- uid: TensorFlow.TFGraph.IsFinite(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IsFinite(TFOutput, String)
  nameWithType: TFGraph.IsFinite(TFOutput, String)
  fullName: TFGraph.IsFinite(TFOutput, String)
- uid: TensorFlow.TFGraph.IsInf(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IsInf(TFOutput, String)
  nameWithType: TFGraph.IsInf(TFOutput, String)
  fullName: TFGraph.IsInf(TFOutput, String)
- uid: TensorFlow.TFGraph.IsNan(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IsNan(TFOutput, String)
  nameWithType: TFGraph.IsNan(TFOutput, String)
  fullName: TFGraph.IsNan(TFOutput, String)
- uid: TensorFlow.TFGraph.IsVariableInitialized(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IsVariableInitialized(TFOutput, String)
  nameWithType: TFGraph.IsVariableInitialized(TFOutput, String)
  fullName: TFGraph.IsVariableInitialized(TFOutput, String)
- uid: TensorFlow.TFGraph.Item(System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Item(String)
  nameWithType: TFGraph.Item(String)
  fullName: TFGraph.Item(String)
- uid: TensorFlow.TFGraph.Iterator(System.String,System.String,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Iterator(String, String, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.Iterator(String, String, TFDataType[], TFShape[], String)
  fullName: TFGraph.Iterator(String, String, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.IteratorFromStringHandle(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.IteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.IteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.IteratorGetNext(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IteratorGetNext(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.IteratorGetNext(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.IteratorGetNext(TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.IteratorGetNextAsOptional(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IteratorGetNextAsOptional(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.IteratorGetNextAsOptional(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.IteratorGetNextAsOptional(TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.IteratorGetNextSync(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IteratorGetNextSync(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.IteratorGetNextSync(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.IteratorGetNextSync(TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.IteratorToStringHandle(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IteratorToStringHandle(TFOutput, String)
  nameWithType: TFGraph.IteratorToStringHandle(TFOutput, String)
  fullName: TFGraph.IteratorToStringHandle(TFOutput, String)
- uid: TensorFlow.TFGraph.L2Loss(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: L2Loss(TFOutput, String)
  nameWithType: TFGraph.L2Loss(TFOutput, String)
  fullName: TFGraph.L2Loss(TFOutput, String)
- uid: TensorFlow.TFGraph.LearnedUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LearnedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.LearnedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.LearnedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.LeftShift(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LeftShift(TFOutput, TFOutput, String)
  nameWithType: TFGraph.LeftShift(TFOutput, TFOutput, String)
  fullName: TFGraph.LeftShift(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Less(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Less(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Less(TFOutput, TFOutput, String)
  fullName: TFGraph.Less(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.LessEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LessEqual(TFOutput, TFOutput, String)
  nameWithType: TFGraph.LessEqual(TFOutput, TFOutput, String)
  fullName: TFGraph.LessEqual(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Lgamma(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Lgamma(TFOutput, String)
  nameWithType: TFGraph.Lgamma(TFOutput, String)
  fullName: TFGraph.Lgamma(TFOutput, String)
- uid: TensorFlow.TFGraph.LinSpace(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LinSpace(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LinSpace(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LinSpace(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ListDiff(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ListDiff(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.ListDiff(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.ListDiff(TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.LMDBReader(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LMDBReader(String, String, String)
  nameWithType: TFGraph.LMDBReader(String, String, String)
  fullName: TFGraph.LMDBReader(String, String, String)
- uid: TensorFlow.TFGraph.LoadAndRemapMatrix(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadAndRemapMatrix(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String)
  nameWithType: TFGraph.LoadAndRemapMatrix(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String)
  fullName: TFGraph.LoadAndRemapMatrix(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingAdadeltaParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingAdadeltaParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingAdadeltaParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingAdadeltaParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingADAMParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingADAMParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingADAMParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingADAMParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingADAMParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingADAMParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingADAMParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingADAMParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingCenteredRMSPropParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingCenteredRMSPropParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingCenteredRMSPropParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingCenteredRMSPropParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingFTRLParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingFTRLParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingFTRLParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingFTRLParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingFTRLParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingFTRLParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingMDLAdagradLightParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingMDLAdagradLightParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingMDLAdagradLightParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingMDLAdagradLightParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingMomentumParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingMomentumParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingMomentumParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingMomentumParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingMomentumParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingMomentumParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingProximalAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingProximalAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingProximalAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingRMSPropParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingRMSPropParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingRMSPropParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingRMSPropParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingRMSPropParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingRMSPropParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingStochasticGradientDescentParameters(TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingStochasticGradientDescentParameters(TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.LoadTPUEmbeddingStochasticGradientDescentParameters(TFOutput, Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.LoadTPUEmbeddingStochasticGradientDescentParameters(TFOutput, Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.Log(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Log(TFOutput, String)
  nameWithType: TFGraph.Log(TFOutput, String)
  fullName: TFGraph.Log(TFOutput, String)
- uid: TensorFlow.TFGraph.Log1p(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Log1p(TFOutput, String)
  nameWithType: TFGraph.Log1p(TFOutput, String)
  fullName: TFGraph.Log1p(TFOutput, String)
- uid: TensorFlow.TFGraph.LogicalAnd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LogicalAnd(TFOutput, TFOutput, String)
  nameWithType: TFGraph.LogicalAnd(TFOutput, TFOutput, String)
  fullName: TFGraph.LogicalAnd(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.LogicalNot(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LogicalNot(TFOutput, String)
  nameWithType: TFGraph.LogicalNot(TFOutput, String)
  fullName: TFGraph.LogicalNot(TFOutput, String)
- uid: TensorFlow.TFGraph.LogicalOr(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LogicalOr(TFOutput, TFOutput, String)
  nameWithType: TFGraph.LogicalOr(TFOutput, TFOutput, String)
  fullName: TFGraph.LogicalOr(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.LogMatrixDeterminant(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LogMatrixDeterminant(TFOutput, String)
  nameWithType: TFGraph.LogMatrixDeterminant(TFOutput, String)
  fullName: TFGraph.LogMatrixDeterminant(TFOutput, String)
- uid: TensorFlow.TFGraph.LogSoftmax(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LogSoftmax(TFOutput, String)
  nameWithType: TFGraph.LogSoftmax(TFOutput, String)
  fullName: TFGraph.LogSoftmax(TFOutput, String)
- uid: TensorFlow.TFGraph.LogUniformCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LogUniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.LogUniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.LogUniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.LookupTableExport(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableExport(TFOutput, TFDataType, TFDataType, String)
  nameWithType: TFGraph.LookupTableExport(TFOutput, TFDataType, TFDataType, String)
  fullName: TFGraph.LookupTableExport(TFOutput, TFDataType, TFDataType, String)
- uid: TensorFlow.TFGraph.LookupTableExportV2(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableExportV2(TFOutput, TFDataType, TFDataType, String)
  nameWithType: TFGraph.LookupTableExportV2(TFOutput, TFDataType, TFDataType, String)
  fullName: TFGraph.LookupTableExportV2(TFOutput, TFDataType, TFDataType, String)
- uid: TensorFlow.TFGraph.LookupTableFind(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableFind(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LookupTableFind(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LookupTableFind(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.LookupTableFindV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableFindV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LookupTableFindV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LookupTableFindV2(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.LookupTableImport(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableImport(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LookupTableImport(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LookupTableImport(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.LookupTableImportV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableImportV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LookupTableImportV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LookupTableImportV2(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.LookupTableInsert(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableInsert(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LookupTableInsert(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LookupTableInsert(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.LookupTableInsertV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableInsertV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.LookupTableInsertV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.LookupTableInsertV2(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.LookupTableSize(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableSize(TFOutput, String)
  nameWithType: TFGraph.LookupTableSize(TFOutput, String)
  fullName: TFGraph.LookupTableSize(TFOutput, String)
- uid: TensorFlow.TFGraph.LookupTableSizeV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableSizeV2(TFOutput, String)
  nameWithType: TFGraph.LookupTableSizeV2(TFOutput, String)
  fullName: TFGraph.LookupTableSizeV2(TFOutput, String)
- uid: TensorFlow.TFGraph.LoopCond(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoopCond(TFOutput, String)
  nameWithType: TFGraph.LoopCond(TFOutput, String)
  fullName: TFGraph.LoopCond(TFOutput, String)
- uid: TensorFlow.TFGraph.LowerBound(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LowerBound(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.LowerBound(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.LowerBound(TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.LRN(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LRN(TFOutput, Nullable<Int64>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  nameWithType: TFGraph.LRN(TFOutput, Nullable<Int64>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  fullName: TFGraph.LRN(TFOutput, Nullable<Int64>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
- uid: TensorFlow.TFGraph.LRNGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LRNGrad(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  nameWithType: TFGraph.LRNGrad(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  fullName: TFGraph.LRNGrad(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
- uid: TensorFlow.TFGraph.MakeIterator(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MakeIterator(TFOutput, TFOutput, String)
  nameWithType: TFGraph.MakeIterator(TFOutput, TFOutput, String)
  fullName: TFGraph.MakeIterator(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.MapClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.MapIncompleteSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapIncompleteSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapIncompleteSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapIncompleteSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.MapPeek(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapPeek(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapPeek(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapPeek(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.MapSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.MapStage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.MapUnstage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapUnstage(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapUnstage(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapUnstage(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.MapUnstageNoKey(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapUnstageNoKey(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.MapUnstageNoKey(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.MapUnstageNoKey(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.MatchingFiles(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatchingFiles(TFOutput, String)
  nameWithType: TFGraph.MatchingFiles(TFOutput, String)
  fullName: TFGraph.MatchingFiles(TFOutput, String)
- uid: TensorFlow.TFGraph.MatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.MatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.MatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.MatrixBandPart(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixBandPart(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.MatrixBandPart(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.MatrixBandPart(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.MatrixDeterminant(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixDeterminant(TFOutput, String)
  nameWithType: TFGraph.MatrixDeterminant(TFOutput, String)
  fullName: TFGraph.MatrixDeterminant(TFOutput, String)
- uid: TensorFlow.TFGraph.MatrixDiag(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixDiag(TFOutput, String)
  nameWithType: TFGraph.MatrixDiag(TFOutput, String)
  fullName: TFGraph.MatrixDiag(TFOutput, String)
- uid: TensorFlow.TFGraph.MatrixDiagPart(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixDiagPart(TFOutput, String)
  nameWithType: TFGraph.MatrixDiagPart(TFOutput, String)
  fullName: TFGraph.MatrixDiagPart(TFOutput, String)
- uid: TensorFlow.TFGraph.MatrixExponential(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixExponential(TFOutput, String)
  nameWithType: TFGraph.MatrixExponential(TFOutput, String)
  fullName: TFGraph.MatrixExponential(TFOutput, String)
- uid: TensorFlow.TFGraph.MatrixInverse(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixInverse(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.MatrixInverse(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.MatrixInverse(TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.MatrixLogarithm(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixLogarithm(TFOutput, String)
  nameWithType: TFGraph.MatrixLogarithm(TFOutput, String)
  fullName: TFGraph.MatrixLogarithm(TFOutput, String)
- uid: TensorFlow.TFGraph.MatrixSetDiag(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixSetDiag(TFOutput, TFOutput, String)
  nameWithType: TFGraph.MatrixSetDiag(TFOutput, TFOutput, String)
  fullName: TFGraph.MatrixSetDiag(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.MatrixSolve(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixSolve(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.MatrixSolve(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.MatrixSolve(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.MatrixSolveLs(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixSolveLs(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.MatrixSolveLs(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.MatrixSolveLs(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.MatrixTriangularSolve(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixTriangularSolve(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.MatrixTriangularSolve(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.MatrixTriangularSolve(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Max(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Max(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Max(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Max(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Maximum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Maximum(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Maximum(TFOutput, TFOutput, String)
  fullName: TFGraph.Maximum(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.MaxPool(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPool(TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.MaxPool(TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.MaxPool(TFOutput, Int64[], Int64[], String, String, String)
- uid: TensorFlow.TFGraph.MaxPool3D(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPool3D(TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.MaxPool3D(TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.MaxPool3D(TFOutput, Int64[], Int64[], String, String, String)
- uid: TensorFlow.TFGraph.MaxPool3DGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPool3DGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.MaxPool3DGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.MaxPool3DGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
- uid: TensorFlow.TFGraph.MaxPool3DGradGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPool3DGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.MaxPool3DGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.MaxPool3DGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
- uid: TensorFlow.TFGraph.MaxPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.MaxPoolGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.MaxPoolGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
- uid: TensorFlow.TFGraph.MaxPoolGradGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  nameWithType: TFGraph.MaxPoolGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
  fullName: TFGraph.MaxPoolGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)
- uid: TensorFlow.TFGraph.MaxPoolGradGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolGradGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  nameWithType: TFGraph.MaxPoolGradGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  fullName: TFGraph.MaxPoolGradGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
- uid: TensorFlow.TFGraph.MaxPoolGradGradWithArgmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolGradGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.MaxPoolGradGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.MaxPoolGradGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
- uid: TensorFlow.TFGraph.MaxPoolGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  nameWithType: TFGraph.MaxPoolGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  fullName: TFGraph.MaxPoolGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
- uid: TensorFlow.TFGraph.MaxPoolGradWithArgmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.MaxPoolGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.MaxPoolGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
- uid: TensorFlow.TFGraph.MaxPoolV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolV2(TFOutput, TFOutput, TFOutput, String, String, String)
  nameWithType: TFGraph.MaxPoolV2(TFOutput, TFOutput, TFOutput, String, String, String)
  fullName: TFGraph.MaxPoolV2(TFOutput, TFOutput, TFOutput, String, String, String)
- uid: TensorFlow.TFGraph.MaxPoolWithArgmax(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolWithArgmax(TFOutput, Int64[], Int64[], String, Nullable<TFDataType>, String)
  nameWithType: TFGraph.MaxPoolWithArgmax(TFOutput, Int64[], Int64[], String, Nullable<TFDataType>, String)
  fullName: TFGraph.MaxPoolWithArgmax(TFOutput, Int64[], Int64[], String, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.Mean(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Mean(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Mean(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Mean(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Merge(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Merge(TFOutput[], String)
  nameWithType: TFGraph.Merge(TFOutput[], String)
  fullName: TFGraph.Merge(TFOutput[], String)
- uid: TensorFlow.TFGraph.MergeSummary(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MergeSummary(TFOutput[], String)
  nameWithType: TFGraph.MergeSummary(TFOutput[], String)
  fullName: TFGraph.MergeSummary(TFOutput[], String)
- uid: TensorFlow.TFGraph.MergeV2Checkpoints(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MergeV2Checkpoints(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.MergeV2Checkpoints(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.MergeV2Checkpoints(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Mfcc(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Mfcc(TFOutput, TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.Mfcc(TFOutput, TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.Mfcc(TFOutput, TFOutput, Nullable<Single>, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.Min(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Min(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Min(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Min(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Minimum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Minimum(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Minimum(TFOutput, TFOutput, String)
  fullName: TFGraph.Minimum(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.MirrorPad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MirrorPad(TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.MirrorPad(TFOutput, TFOutput, String, String)
  fullName: TFGraph.MirrorPad(TFOutput, TFOutput, String, String)
- uid: TensorFlow.TFGraph.MirrorPadGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MirrorPadGrad(TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.MirrorPadGrad(TFOutput, TFOutput, String, String)
  fullName: TFGraph.MirrorPadGrad(TFOutput, TFOutput, String, String)
- uid: TensorFlow.TFGraph.Mod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Mod(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Mod(TFOutput, TFOutput, String)
  fullName: TFGraph.Mod(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ModelDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ModelDataset(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ModelDataset(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.ModelDataset(TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.Mul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Mul(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Mul(TFOutput, TFOutput, String)
  fullName: TFGraph.Mul(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.MultiDeviceIterator(System.String[],System.String,System.String,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MultiDeviceIterator(String[], String, String, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.MultiDeviceIterator(String[], String, String, TFDataType[], TFShape[], String)
  fullName: TFGraph.MultiDeviceIterator(String[], String, String, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.MultiDeviceIteratorFromStringHandle(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MultiDeviceIteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.MultiDeviceIteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.MultiDeviceIteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.MultiDeviceIteratorGetNextFromShard(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MultiDeviceIteratorGetNextFromShard(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.MultiDeviceIteratorGetNextFromShard(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.MultiDeviceIteratorGetNextFromShard(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.MultiDeviceIteratorInit(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MultiDeviceIteratorInit(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.MultiDeviceIteratorInit(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.MultiDeviceIteratorInit(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.MultiDeviceIteratorToStringHandle(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MultiDeviceIteratorToStringHandle(TFOutput, String)
  nameWithType: TFGraph.MultiDeviceIteratorToStringHandle(TFOutput, String)
  fullName: TFGraph.MultiDeviceIteratorToStringHandle(TFOutput, String)
- uid: TensorFlow.TFGraph.Multinomial(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Multinomial(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Multinomial(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<TFDataType>, String)
  fullName: TFGraph.Multinomial(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.MutableDenseHashTable(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.Nullable{System.Int64},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutableDenseHashTable(TFOutput, TFDataType, String, String, Nullable<Boolean>, TFShape, Nullable<Int64>, Nullable<Single>, String)
  nameWithType: TFGraph.MutableDenseHashTable(TFOutput, TFDataType, String, String, Nullable<Boolean>, TFShape, Nullable<Int64>, Nullable<Single>, String)
  fullName: TFGraph.MutableDenseHashTable(TFOutput, TFDataType, String, String, Nullable<Boolean>, TFShape, Nullable<Int64>, Nullable<Single>, String)
- uid: TensorFlow.TFGraph.MutableDenseHashTableV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.Nullable{System.Int64},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutableDenseHashTableV2(TFOutput, TFDataType, String, String, Nullable<Boolean>, TFShape, Nullable<Int64>, Nullable<Single>, String)
  nameWithType: TFGraph.MutableDenseHashTableV2(TFOutput, TFDataType, String, String, Nullable<Boolean>, TFShape, Nullable<Int64>, Nullable<Single>, String)
  fullName: TFGraph.MutableDenseHashTableV2(TFOutput, TFDataType, String, String, Nullable<Boolean>, TFShape, Nullable<Int64>, Nullable<Single>, String)
- uid: TensorFlow.TFGraph.MutableHashTable(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutableHashTable(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.MutableHashTable(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  fullName: TFGraph.MutableHashTable(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.MutableHashTableOfTensors(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutableHashTableOfTensors(TFDataType, TFDataType, String, String, Nullable<Boolean>, TFShape, String)
  nameWithType: TFGraph.MutableHashTableOfTensors(TFDataType, TFDataType, String, String, Nullable<Boolean>, TFShape, String)
  fullName: TFGraph.MutableHashTableOfTensors(TFDataType, TFDataType, String, String, Nullable<Boolean>, TFShape, String)
- uid: TensorFlow.TFGraph.MutableHashTableOfTensorsV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutableHashTableOfTensorsV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, TFShape, String)
  nameWithType: TFGraph.MutableHashTableOfTensorsV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, TFShape, String)
  fullName: TFGraph.MutableHashTableOfTensorsV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, TFShape, String)
- uid: TensorFlow.TFGraph.MutableHashTableV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutableHashTableV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.MutableHashTableV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
  fullName: TFGraph.MutableHashTableV2(TFDataType, TFDataType, String, String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.MutexLock(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutexLock(TFOutput, String)
  nameWithType: TFGraph.MutexLock(TFOutput, String)
  fullName: TFGraph.MutexLock(TFOutput, String)
- uid: TensorFlow.TFGraph.MutexV2(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutexV2(String, String, String)
  nameWithType: TFGraph.MutexV2(String, String, String)
  fullName: TFGraph.MutexV2(String, String, String)
- uid: TensorFlow.TFGraph.Neg(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Neg(TFOutput, String)
  nameWithType: TFGraph.Neg(TFOutput, String)
  fullName: TFGraph.Neg(TFOutput, String)
- uid: TensorFlow.TFGraph.NegTrain(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NegTrain(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], Int64, String)
  nameWithType: TFGraph.NegTrain(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], Int64, String)
  fullName: TFGraph.NegTrain(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], Int64, String)
- uid: TensorFlow.TFGraph.NextIteration(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NextIteration(TFOutput, String)
  nameWithType: TFGraph.NextIteration(TFOutput, String)
  fullName: TFGraph.NextIteration(TFOutput, String)
- uid: TensorFlow.TFGraph.NonMaxSuppression(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NonMaxSuppression(TFOutput, TFOutput, TFOutput, Nullable<Single>, String)
  nameWithType: TFGraph.NonMaxSuppression(TFOutput, TFOutput, TFOutput, Nullable<Single>, String)
  fullName: TFGraph.NonMaxSuppression(TFOutput, TFOutput, TFOutput, Nullable<Single>, String)
- uid: TensorFlow.TFGraph.NonMaxSuppressionV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NonMaxSuppressionV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.NonMaxSuppressionV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.NonMaxSuppressionV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.NonMaxSuppressionV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NonMaxSuppressionV3(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.NonMaxSuppressionV3(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.NonMaxSuppressionV3(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.NonMaxSuppressionV4(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NonMaxSuppressionV4(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.NonMaxSuppressionV4(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.NonMaxSuppressionV4(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.NonMaxSuppressionWithOverlaps(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NonMaxSuppressionWithOverlaps(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.NonMaxSuppressionWithOverlaps(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.NonMaxSuppressionWithOverlaps(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.NoOp(System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NoOp(String)
  nameWithType: TFGraph.NoOp(String)
  fullName: TFGraph.NoOp(String)
- uid: TensorFlow.TFGraph.NotEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NotEqual(TFOutput, TFOutput, String)
  nameWithType: TFGraph.NotEqual(TFOutput, TFOutput, String)
  fullName: TFGraph.NotEqual(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.NthElement(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NthElement(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.NthElement(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.NthElement(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.NumFunctions
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NumFunctions
  nameWithType: TFGraph.NumFunctions
  fullName: TFGraph.NumFunctions
- uid: TensorFlow.TFGraph.OneHot(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OneHot(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.OneHot(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.OneHot(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.Ones(TensorFlow.TFShape,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Ones(TFShape, TFDataType, String)
  nameWithType: TFGraph.Ones(TFShape, TFDataType, String)
  fullName: TFGraph.Ones(TFShape, TFDataType, String)
- uid: TensorFlow.TFGraph.OnesLike(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OnesLike(TFOutput, String)
  nameWithType: TFGraph.OnesLike(TFOutput, String)
  fullName: TFGraph.OnesLike(TFOutput, String)
- uid: TensorFlow.TFGraph.OptimizeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OptimizeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.OptimizeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.OptimizeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.OptionalFromValue(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OptionalFromValue(TFOutput[], String)
  nameWithType: TFGraph.OptionalFromValue(TFOutput[], String)
  fullName: TFGraph.OptionalFromValue(TFOutput[], String)
- uid: TensorFlow.TFGraph.OptionalGetValue(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OptionalGetValue(TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.OptionalGetValue(TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.OptionalGetValue(TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.OptionalHasValue(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OptionalHasValue(TFOutput, String)
  nameWithType: TFGraph.OptionalHasValue(TFOutput, String)
  fullName: TFGraph.OptionalHasValue(TFOutput, String)
- uid: TensorFlow.TFGraph.OptionalNone(System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OptionalNone(String)
  nameWithType: TFGraph.OptionalNone(String)
  fullName: TFGraph.OptionalNone(String)
- uid: TensorFlow.TFGraph.OrderedMapClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.OrderedMapIncompleteSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapIncompleteSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapIncompleteSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapIncompleteSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.OrderedMapPeek(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapPeek(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapPeek(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapPeek(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.OrderedMapSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.OrderedMapStage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.OrderedMapUnstage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapUnstage(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapUnstage(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapUnstage(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.OrderedMapUnstageNoKey(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapUnstageNoKey(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.OrderedMapUnstageNoKey(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.OrderedMapUnstageNoKey(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.OutfeedDequeue(TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OutfeedDequeue(TFDataType, TFShape, Nullable<Int64>, String)
  nameWithType: TFGraph.OutfeedDequeue(TFDataType, TFShape, Nullable<Int64>, String)
  fullName: TFGraph.OutfeedDequeue(TFDataType, TFShape, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.OutfeedDequeueTuple(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OutfeedDequeueTuple(TFDataType[], TFShape[], Nullable<Int64>, String)
  nameWithType: TFGraph.OutfeedDequeueTuple(TFDataType[], TFShape[], Nullable<Int64>, String)
  fullName: TFGraph.OutfeedDequeueTuple(TFDataType[], TFShape[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.OutfeedEnqueue(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OutfeedEnqueue(TFOutput, String)
  nameWithType: TFGraph.OutfeedEnqueue(TFOutput, String)
  fullName: TFGraph.OutfeedEnqueue(TFOutput, String)
- uid: TensorFlow.TFGraph.OutfeedEnqueueTuple(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OutfeedEnqueueTuple(TFOutput[], String)
  nameWithType: TFGraph.OutfeedEnqueueTuple(TFOutput[], String)
  fullName: TFGraph.OutfeedEnqueueTuple(TFOutput[], String)
- uid: TensorFlow.TFGraph.Pack(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Pack(TFOutput[], Nullable<Int64>, String)
  nameWithType: TFGraph.Pack(TFOutput[], Nullable<Int64>, String)
  fullName: TFGraph.Pack(TFOutput[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.Pad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Pad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Pad(TFOutput, TFOutput, String)
  fullName: TFGraph.Pad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.PaddedBatchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PaddedBatchDataset(TFOutput, TFOutput, TFOutput[], TFOutput[], TFShape[], String)
  nameWithType: TFGraph.PaddedBatchDataset(TFOutput, TFOutput, TFOutput[], TFOutput[], TFShape[], String)
  fullName: TFGraph.PaddedBatchDataset(TFOutput, TFOutput, TFOutput[], TFOutput[], TFShape[], String)
- uid: TensorFlow.TFGraph.PaddedBatchDatasetV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PaddedBatchDatasetV2(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput, TFShape[], String)
  nameWithType: TFGraph.PaddedBatchDatasetV2(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput, TFShape[], String)
  fullName: TFGraph.PaddedBatchDatasetV2(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput, TFShape[], String)
- uid: TensorFlow.TFGraph.PaddingFIFOQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PaddingFIFOQueue(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.PaddingFIFOQueue(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.PaddingFIFOQueue(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.PaddingFIFOQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PaddingFIFOQueueV2(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.PaddingFIFOQueueV2(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.PaddingFIFOQueueV2(TFDataType[], TFShape[], Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.PadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PadV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.PadV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.PadV2(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ParallelConcat(TensorFlow.TFOutput[],TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParallelConcat(TFOutput[], TFShape, String)
  nameWithType: TFGraph.ParallelConcat(TFOutput[], TFShape, String)
  fullName: TFGraph.ParallelConcat(TFOutput[], TFShape, String)
- uid: TensorFlow.TFGraph.ParallelDynamicStitch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParallelDynamicStitch(TFOutput[], TFOutput[], String)
  nameWithType: TFGraph.ParallelDynamicStitch(TFOutput[], TFOutput[], String)
  fullName: TFGraph.ParallelDynamicStitch(TFOutput[], TFOutput[], String)
- uid: TensorFlow.TFGraph.ParameterizedTruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParameterizedTruncatedNormal(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.ParameterizedTruncatedNormal(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.ParameterizedTruncatedNormal(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.ParseExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParseExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ParseExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFDataType[], TFShape[], String)
  fullName: TFGraph.ParseExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFDataType[], TFShape[], String)
- uid: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput[],TFOutput[],TFOutput[],TFOutput[]>
  nameWithType: ValueTuple<TFOutput[],TFOutput[],TFOutput[],TFOutput[]>
  fullName: System.ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]>
  spec.csharp:
  - uid: System.ValueTuple`4
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.ParseSequenceExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String[],System.String[],System.String[],System.String[],System.String[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},TensorFlow.TFDataType[],TensorFlow.TFDataType[],TensorFlow.TFShape[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParseSequenceExample(TFOutput, TFOutput, TFOutput[], String[], String[], String[], String[], String[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ParseSequenceExample(TFOutput, TFOutput, TFOutput[], String[], String[], String[], String[], String[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)
  fullName: TFGraph.ParseSequenceExample(TFOutput, TFOutput, TFOutput[], String[], String[], String[], String[], String[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)
- uid: System.ValueTuple`8
  name: ValueTuple
  nameWithType: ValueTuple
  fullName: System.ValueTuple
- uid: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[]}}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[],ValueTuple<TFOutput[],TFOutput[]>>
  nameWithType: ValueTuple<TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[],ValueTuple<TFOutput[],TFOutput[]>>
  fullName: System.ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[]>>
  spec.csharp:
  - uid: System.ValueTuple`8
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: System.ValueTuple`2
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.ParseSingleExample(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String[],System.String[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParseSingleExample(TFOutput, TFOutput[], Int64, String[], String[], TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ParseSingleExample(TFOutput, TFOutput[], Int64, String[], String[], TFDataType[], TFShape[], String)
  fullName: TFGraph.ParseSingleExample(TFOutput, TFOutput[], Int64, String[], String[], TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.ParseSingleSequenceExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFDataType[],TensorFlow.TFShape[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParseSingleSequenceExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ParseSingleSequenceExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)
  fullName: TFGraph.ParseSingleSequenceExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)
- uid: System.ValueTuple`1
  name: ValueTuple
  nameWithType: ValueTuple
  fullName: System.ValueTuple
- uid: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.ValueTuple{TensorFlow.TFOutput[]}}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[],ValueTuple<TFOutput[]>>
  nameWithType: ValueTuple<TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[],TFOutput[],ValueTuple<TFOutput[]>>
  fullName: System.ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.ValueTuple<TensorFlow.TFOutput[]>>
  spec.csharp:
  - uid: System.ValueTuple`8
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: System.ValueTuple`1
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.ParseTensor(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParseTensor(TFOutput, TFDataType, String)
  nameWithType: TFGraph.ParseTensor(TFOutput, TFDataType, String)
  fullName: TFGraph.ParseTensor(TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.Placeholder(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Placeholder(TFDataType, TFShape, String)
  nameWithType: TFGraph.Placeholder(TFDataType, TFShape, String)
  fullName: TFGraph.Placeholder(TFDataType, TFShape, String)
- uid: TensorFlow.TFGraph.PlaceholderV2(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PlaceholderV2(TFDataType, TFShape, String)
  nameWithType: TFGraph.PlaceholderV2(TFDataType, TFShape, String)
  fullName: TFGraph.PlaceholderV2(TFDataType, TFShape, String)
- uid: TensorFlow.TFGraph.PlaceholderWithDefault(TensorFlow.TFOutput,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PlaceholderWithDefault(TFOutput, TFShape, String)
  nameWithType: TFGraph.PlaceholderWithDefault(TFOutput, TFShape, String)
  fullName: TFGraph.PlaceholderWithDefault(TFOutput, TFShape, String)
- uid: TensorFlow.TFGraph.Polygamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Polygamma(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Polygamma(TFOutput, TFOutput, String)
  fullName: TFGraph.Polygamma(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.PopulationCount(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PopulationCount(TFOutput, String)
  nameWithType: TFGraph.PopulationCount(TFOutput, String)
  fullName: TFGraph.PopulationCount(TFOutput, String)
- uid: TensorFlow.TFGraph.Pow(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Pow(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Pow(TFOutput, TFOutput, String)
  fullName: TFGraph.Pow(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.PrefetchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PrefetchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.PrefetchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.PrefetchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.PreventGradient(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PreventGradient(TFOutput, String, String)
  nameWithType: TFGraph.PreventGradient(TFOutput, String, String)
  fullName: TFGraph.PreventGradient(TFOutput, String, String)
- uid: TensorFlow.TFGraph.Print(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Print(TFOutput, TFOutput[], String, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.Print(TFOutput, TFOutput[], String, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.Print(TFOutput, TFOutput[], String, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.PrintV2(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PrintV2(TFOutput, String, String)
  nameWithType: TFGraph.PrintV2(TFOutput, String, String)
  fullName: TFGraph.PrintV2(TFOutput, String, String)
- uid: TensorFlow.TFGraph.PriorityQueue(TensorFlow.TFShape[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PriorityQueue(TFShape[], TFDataType[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.PriorityQueue(TFShape[], TFDataType[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.PriorityQueue(TFShape[], TFDataType[], Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.PriorityQueueV2(TensorFlow.TFShape[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PriorityQueueV2(TFShape[], TFDataType[], Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.PriorityQueueV2(TFShape[], TFDataType[], Nullable<Int64>, String, String, String)
  fullName: TFGraph.PriorityQueueV2(TFShape[], TFDataType[], Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.Prod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Prod(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Prod(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Prod(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Qr(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Qr(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Qr(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Qr(TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.QuantizeAndDequantize(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizeAndDequantize(TFOutput, Nullable<Boolean>, Nullable<Int64>, Nullable<Boolean>, Nullable<Single>, Nullable<Single>, String)
  nameWithType: TFGraph.QuantizeAndDequantize(TFOutput, Nullable<Boolean>, Nullable<Int64>, Nullable<Boolean>, Nullable<Single>, Nullable<Single>, String)
  fullName: TFGraph.QuantizeAndDequantize(TFOutput, Nullable<Boolean>, Nullable<Int64>, Nullable<Boolean>, Nullable<Single>, Nullable<Single>, String)
- uid: TensorFlow.TFGraph.QuantizeAndDequantizeV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizeAndDequantizeV3(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.QuantizeAndDequantizeV3(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.QuantizeAndDequantizeV3(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.QuantizedAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.QuantizedAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.QuantizedAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.QuantizedAvgPool(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedAvgPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.QuantizedAvgPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.QuantizedAvgPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
- uid: TensorFlow.TFGraph.QuantizedBatchNormWithGlobalNormalization(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Single,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedBatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, Single, Boolean, String)
  nameWithType: TFGraph.QuantizedBatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, Single, Boolean, String)
  fullName: TFGraph.QuantizedBatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, Single, Boolean, String)
- uid: TensorFlow.TFGraph.QuantizedBiasAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedBiasAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.QuantizedBiasAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.QuantizedBiasAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.QuantizedConcat(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedConcat(TFOutput, TFOutput[], TFOutput[], TFOutput[], String)
  nameWithType: TFGraph.QuantizedConcat(TFOutput, TFOutput[], TFOutput[], TFOutput[], String)
  fullName: TFGraph.QuantizedConcat(TFOutput, TFOutput[], TFOutput[], TFOutput[], String)
- uid: TensorFlow.TFGraph.QuantizedConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{TensorFlow.TFDataType},System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedConv2D(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<TFDataType>, Int64[], String)
  nameWithType: TFGraph.QuantizedConv2D(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<TFDataType>, Int64[], String)
  fullName: TFGraph.QuantizedConv2D(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], String, Nullable<TFDataType>, Int64[], String)
- uid: TensorFlow.TFGraph.QuantizedInstanceNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedInstanceNorm(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Single>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  nameWithType: TFGraph.QuantizedInstanceNorm(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Single>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
  fullName: TFGraph.QuantizedInstanceNorm(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Single>, Nullable<Single>, Nullable<Single>, Nullable<Single>, String)
- uid: TensorFlow.TFGraph.QuantizedMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedMatMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, Nullable<Boolean>, Nullable<Boolean>, Nullable<TFDataType>, String)
  nameWithType: TFGraph.QuantizedMatMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, Nullable<Boolean>, Nullable<Boolean>, Nullable<TFDataType>, String)
  fullName: TFGraph.QuantizedMatMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, Nullable<Boolean>, Nullable<Boolean>, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.QuantizedMaxPool(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedMaxPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  nameWithType: TFGraph.QuantizedMaxPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
  fullName: TFGraph.QuantizedMaxPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)
- uid: TensorFlow.TFGraph.QuantizedMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.QuantizedMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.QuantizedMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.QuantizeDownAndShrinkRange(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizeDownAndShrinkRange(TFOutput, TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.QuantizeDownAndShrinkRange(TFOutput, TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.QuantizeDownAndShrinkRange(TFOutput, TFOutput, TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.QuantizedRelu(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedRelu(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.QuantizedRelu(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.QuantizedRelu(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.QuantizedRelu6(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedRelu6(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.QuantizedRelu6(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.QuantizedRelu6(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.QuantizedReluX(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedReluX(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.QuantizedReluX(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.QuantizedReluX(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.QuantizedReshape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedReshape(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.QuantizedReshape(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.QuantizedReshape(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.QuantizedResizeBilinear(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedResizeBilinear(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.QuantizedResizeBilinear(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.QuantizedResizeBilinear(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.QuantizeV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizeV2(TFOutput, TFOutput, TFOutput, TFDataType, String, String, String)
  nameWithType: TFGraph.QuantizeV2(TFOutput, TFOutput, TFOutput, TFDataType, String, String, String)
  fullName: TFGraph.QuantizeV2(TFOutput, TFOutput, TFOutput, TFDataType, String, String, String)
- uid: TensorFlow.TFGraph.QueueClose(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueClose(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.QueueClose(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.QueueClose(TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.QueueCloseV2(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueCloseV2(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.QueueCloseV2(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.QueueCloseV2(TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.QueueDequeue(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueDequeue(TFOutput, TFDataType[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueDequeue(TFOutput, TFDataType[], Nullable<Int64>, String)
  fullName: TFGraph.QueueDequeue(TFOutput, TFDataType[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.QueueDequeueMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueDequeueMany(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueDequeueMany(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  fullName: TFGraph.QueueDequeueMany(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.QueueDequeueManyV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueDequeueManyV2(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueDequeueManyV2(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  fullName: TFGraph.QueueDequeueManyV2(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.QueueDequeueUpTo(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueDequeueUpTo(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueDequeueUpTo(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  fullName: TFGraph.QueueDequeueUpTo(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.QueueDequeueUpToV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueDequeueUpToV2(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueDequeueUpToV2(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
  fullName: TFGraph.QueueDequeueUpToV2(TFOutput, TFOutput, TFDataType[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.QueueDequeueV2(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueDequeueV2(TFOutput, TFDataType[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueDequeueV2(TFOutput, TFDataType[], Nullable<Int64>, String)
  fullName: TFGraph.QueueDequeueV2(TFOutput, TFDataType[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.QueueEnqueue(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueEnqueue(TFOutput, TFOutput[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueEnqueue(TFOutput, TFOutput[], Nullable<Int64>, String)
  fullName: TFGraph.QueueEnqueue(TFOutput, TFOutput[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.QueueEnqueueMany(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueEnqueueMany(TFOutput, TFOutput[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueEnqueueMany(TFOutput, TFOutput[], Nullable<Int64>, String)
  fullName: TFGraph.QueueEnqueueMany(TFOutput, TFOutput[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.QueueEnqueueManyV2(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueEnqueueManyV2(TFOutput, TFOutput[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueEnqueueManyV2(TFOutput, TFOutput[], Nullable<Int64>, String)
  fullName: TFGraph.QueueEnqueueManyV2(TFOutput, TFOutput[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.QueueEnqueueV2(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueEnqueueV2(TFOutput, TFOutput[], Nullable<Int64>, String)
  nameWithType: TFGraph.QueueEnqueueV2(TFOutput, TFOutput[], Nullable<Int64>, String)
  fullName: TFGraph.QueueEnqueueV2(TFOutput, TFOutput[], Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.QueueIsClosed(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueIsClosed(TFOutput, String)
  nameWithType: TFGraph.QueueIsClosed(TFOutput, String)
  fullName: TFGraph.QueueIsClosed(TFOutput, String)
- uid: TensorFlow.TFGraph.QueueIsClosedV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueIsClosedV2(TFOutput, String)
  nameWithType: TFGraph.QueueIsClosedV2(TFOutput, String)
  fullName: TFGraph.QueueIsClosedV2(TFOutput, String)
- uid: TensorFlow.TFGraph.QueueSize(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueSize(TFOutput, String)
  nameWithType: TFGraph.QueueSize(TFOutput, String)
  fullName: TFGraph.QueueSize(TFOutput, String)
- uid: TensorFlow.TFGraph.QueueSizeV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueSizeV2(TFOutput, String)
  nameWithType: TFGraph.QueueSizeV2(TFOutput, String)
  fullName: TFGraph.QueueSizeV2(TFOutput, String)
- uid: TensorFlow.TFGraph.RandomCrop(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomCrop(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomCrop(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomCrop(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.RandomGamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomGamma(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomGamma(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomGamma(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.RandomGammaGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomGammaGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RandomGammaGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.RandomGammaGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.RandomNormal(TensorFlow.TFShape,System.Double,System.Double,System.Nullable{System.Int32},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomNormal(TFShape, Double, Double, Nullable<Int32>, String)
  nameWithType: TFGraph.RandomNormal(TFShape, Double, Double, Nullable<Int32>, String)
  fullName: TFGraph.RandomNormal(TFShape, Double, Double, Nullable<Int32>, String)
- uid: TensorFlow.TFGraph.RandomPoisson(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomPoisson(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomPoisson(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomPoisson(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.RandomPoissonV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomPoissonV2(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<TFDataType>, String)
  nameWithType: TFGraph.RandomPoissonV2(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<TFDataType>, String)
  fullName: TFGraph.RandomPoissonV2(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.RandomShuffle(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomShuffle(TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomShuffle(TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomShuffle(TFOutput, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.RandomShuffleQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomShuffleQueue(TFDataType[], TFShape[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.RandomShuffleQueue(TFDataType[], TFShape[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.RandomShuffleQueue(TFDataType[], TFShape[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.RandomShuffleQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomShuffleQueueV2(TFDataType[], TFShape[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.RandomShuffleQueueV2(TFDataType[], TFShape[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.RandomShuffleQueueV2(TFDataType[], TFShape[], Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.RandomStandardNormal(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomStandardNormal(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomStandardNormal(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomStandardNormal(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.RandomUniform(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomUniform(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomUniform(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomUniform(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.RandomUniform(TensorFlow.TFShape,System.Double,System.Double,System.Nullable{System.Int32},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomUniform(TFShape, Double, Double, Nullable<Int32>, String)
  nameWithType: TFGraph.RandomUniform(TFShape, Double, Double, Nullable<Int32>, String)
  fullName: TFGraph.RandomUniform(TFShape, Double, Double, Nullable<Int32>, String)
- uid: TensorFlow.TFGraph.RandomUniformInt(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomUniformInt(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.RandomUniformInt(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.RandomUniformInt(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.Range(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Range(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.Range(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.Range(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Range(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Range(TFOutput, Nullable<TFOutput>, Nullable<TFOutput>, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Range(TFOutput, Nullable<TFOutput>, Nullable<TFOutput>, Nullable<TFDataType>, String)
  fullName: TFGraph.Range(TFOutput, Nullable<TFOutput>, Nullable<TFOutput>, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.RangeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RangeDataset(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.RangeDataset(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.RangeDataset(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.Rank(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Rank(TFOutput, String)
  nameWithType: TFGraph.Rank(TFOutput, String)
  fullName: TFGraph.Rank(TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderNumRecordsProduced(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderNumRecordsProduced(TFOutput, String)
  nameWithType: TFGraph.ReaderNumRecordsProduced(TFOutput, String)
  fullName: TFGraph.ReaderNumRecordsProduced(TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderNumRecordsProducedV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderNumRecordsProducedV2(TFOutput, String)
  nameWithType: TFGraph.ReaderNumRecordsProducedV2(TFOutput, String)
  fullName: TFGraph.ReaderNumRecordsProducedV2(TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderNumWorkUnitsCompleted(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderNumWorkUnitsCompleted(TFOutput, String)
  nameWithType: TFGraph.ReaderNumWorkUnitsCompleted(TFOutput, String)
  fullName: TFGraph.ReaderNumWorkUnitsCompleted(TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderNumWorkUnitsCompletedV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderNumWorkUnitsCompletedV2(TFOutput, String)
  nameWithType: TFGraph.ReaderNumWorkUnitsCompletedV2(TFOutput, String)
  fullName: TFGraph.ReaderNumWorkUnitsCompletedV2(TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderRead(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderRead(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReaderRead(TFOutput, TFOutput, String)
  fullName: TFGraph.ReaderRead(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderReadUpTo(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderReadUpTo(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReaderReadUpTo(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ReaderReadUpTo(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderReadUpToV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderReadUpToV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReaderReadUpToV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ReaderReadUpToV2(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderReadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderReadV2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReaderReadV2(TFOutput, TFOutput, String)
  fullName: TFGraph.ReaderReadV2(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderReset(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderReset(TFOutput, String)
  nameWithType: TFGraph.ReaderReset(TFOutput, String)
  fullName: TFGraph.ReaderReset(TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderResetV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderResetV2(TFOutput, String)
  nameWithType: TFGraph.ReaderResetV2(TFOutput, String)
  fullName: TFGraph.ReaderResetV2(TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderRestoreState(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderRestoreState(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReaderRestoreState(TFOutput, TFOutput, String)
  fullName: TFGraph.ReaderRestoreState(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderRestoreStateV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderRestoreStateV2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReaderRestoreStateV2(TFOutput, TFOutput, String)
  fullName: TFGraph.ReaderRestoreStateV2(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderSerializeState(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderSerializeState(TFOutput, String)
  nameWithType: TFGraph.ReaderSerializeState(TFOutput, String)
  fullName: TFGraph.ReaderSerializeState(TFOutput, String)
- uid: TensorFlow.TFGraph.ReaderSerializeStateV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderSerializeStateV2(TFOutput, String)
  nameWithType: TFGraph.ReaderSerializeStateV2(TFOutput, String)
  fullName: TFGraph.ReaderSerializeStateV2(TFOutput, String)
- uid: TensorFlow.TFGraph.ReadFile(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReadFile(TFOutput, String)
  nameWithType: TFGraph.ReadFile(TFOutput, String)
  fullName: TFGraph.ReadFile(TFOutput, String)
- uid: TensorFlow.TFGraph.ReadVariableOp(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReadVariableOp(TFOutput, TFDataType, String)
  nameWithType: TFGraph.ReadVariableOp(TFOutput, TFDataType, String)
  fullName: TFGraph.ReadVariableOp(TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.Real(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Real(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Real(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Real(TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.RealDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RealDiv(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RealDiv(TFOutput, TFOutput, String)
  fullName: TFGraph.RealDiv(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Reciprocal(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Reciprocal(TFOutput, String)
  nameWithType: TFGraph.Reciprocal(TFOutput, String)
  fullName: TFGraph.Reciprocal(TFOutput, String)
- uid: TensorFlow.TFGraph.ReciprocalGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReciprocalGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReciprocalGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.ReciprocalGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.RecordInput(System.String,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RecordInput(String, Nullable<Int64>, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RecordInput(String, Nullable<Int64>, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String)
  fullName: TFGraph.RecordInput(String, Nullable<Int64>, Nullable<Single>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RecvTPUEmbeddingActivations(System.Int64,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RecvTPUEmbeddingActivations(Int64, String, String)
  nameWithType: TFGraph.RecvTPUEmbeddingActivations(Int64, String, String)
  fullName: TFGraph.RecvTPUEmbeddingActivations(Int64, String, String)
- uid: TensorFlow.TFGraph.ReduceJoin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReduceJoin(TFOutput, TFOutput, Nullable<Boolean>, String, String)
  nameWithType: TFGraph.ReduceJoin(TFOutput, TFOutput, Nullable<Boolean>, String, String)
  fullName: TFGraph.ReduceJoin(TFOutput, TFOutput, Nullable<Boolean>, String, String)
- uid: TensorFlow.TFGraph.ReduceMean(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReduceMean(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ReduceMean(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  fullName: TFGraph.ReduceMean(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ReduceProd(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReduceProd(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ReduceProd(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  fullName: TFGraph.ReduceProd(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ReduceSum(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReduceSum(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ReduceSum(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
  fullName: TFGraph.ReduceSum(TFOutput, Nullable<TFOutput>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.RefEnter(TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefEnter(TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  nameWithType: TFGraph.RefEnter(TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  fullName: TFGraph.RefEnter(TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.RefExit(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefExit(TFOutput, String)
  nameWithType: TFGraph.RefExit(TFOutput, String)
  fullName: TFGraph.RefExit(TFOutput, String)
- uid: TensorFlow.TFGraph.RefIdentity(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefIdentity(TFOutput, String)
  nameWithType: TFGraph.RefIdentity(TFOutput, String)
  fullName: TFGraph.RefIdentity(TFOutput, String)
- uid: TensorFlow.TFGraph.RefMerge(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefMerge(TFOutput[], String)
  nameWithType: TFGraph.RefMerge(TFOutput[], String)
  fullName: TFGraph.RefMerge(TFOutput[], String)
- uid: TensorFlow.TFGraph.RefNextIteration(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefNextIteration(TFOutput, String)
  nameWithType: TFGraph.RefNextIteration(TFOutput, String)
  fullName: TFGraph.RefNextIteration(TFOutput, String)
- uid: TensorFlow.TFGraph.RefSelect(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefSelect(TFOutput, TFOutput[], String)
  nameWithType: TFGraph.RefSelect(TFOutput, TFOutput[], String)
  fullName: TFGraph.RefSelect(TFOutput, TFOutput[], String)
- uid: TensorFlow.TFGraph.RefSwitch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefSwitch(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RefSwitch(TFOutput, TFOutput, String)
  fullName: TFGraph.RefSwitch(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.RegexFullMatch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RegexFullMatch(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RegexFullMatch(TFOutput, TFOutput, String)
  fullName: TFGraph.RegexFullMatch(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.RegexReplace(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RegexReplace(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.RegexReplace(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.RegexReplace(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Relu(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Relu(TFOutput, String)
  nameWithType: TFGraph.Relu(TFOutput, String)
  fullName: TFGraph.Relu(TFOutput, String)
- uid: TensorFlow.TFGraph.Relu6(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Relu6(TFOutput, String)
  nameWithType: TFGraph.Relu6(TFOutput, String)
  fullName: TFGraph.Relu6(TFOutput, String)
- uid: TensorFlow.TFGraph.Relu6Grad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Relu6Grad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Relu6Grad(TFOutput, TFOutput, String)
  fullName: TFGraph.Relu6Grad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ReluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReluGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReluGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.ReluGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.RemoteFusedGraphExecute(TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RemoteFusedGraphExecute(TFOutput[], TFDataType[], String, String)
  nameWithType: TFGraph.RemoteFusedGraphExecute(TFOutput[], TFDataType[], String, String)
  fullName: TFGraph.RemoteFusedGraphExecute(TFOutput[], TFDataType[], String, String)
- uid: TensorFlow.TFGraph.RepeatDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RepeatDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.RepeatDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.RepeatDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.RequantizationRange(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RequantizationRange(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.RequantizationRange(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.RequantizationRange(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Requantize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Requantize(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.Requantize(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.Requantize(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.Reshape(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Reshape(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Reshape(TFOutput, TFOutput, String)
  fullName: TFGraph.Reshape(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ResizeArea(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeArea(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeArea(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeArea(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResizeBicubic(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeBicubic(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeBicubic(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeBicubic(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResizeBicubicGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeBicubicGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeBicubicGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeBicubicGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResizeBilinear(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeBilinear(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeBilinear(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeBilinear(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResizeBilinearGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeBilinearGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeBilinearGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeBilinearGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResizeNearestNeighbor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeNearestNeighbor(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeNearestNeighbor(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeNearestNeighbor(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResizeNearestNeighborGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeNearestNeighborGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResizeNearestNeighborGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResizeNearestNeighborGrad(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyAdam(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyAdaMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyAddSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyPowerSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceCountUpTo(TensorFlow.TFOutput,System.Int64,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceCountUpTo(TFOutput, Int64, TFDataType, String)
  nameWithType: TFGraph.ResourceCountUpTo(TFOutput, Int64, TFDataType, String)
  fullName: TFGraph.ResourceCountUpTo(TFOutput, Int64, TFDataType, String)
- uid: TensorFlow.TFGraph.ResourceGather(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceGather(TFOutput, TFOutput, TFDataType, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceGather(TFOutput, TFOutput, TFDataType, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceGather(TFOutput, TFOutput, TFDataType, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceScatterAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterAdd(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterAdd(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterAdd(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ResourceScatterDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterDiv(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterDiv(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterDiv(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ResourceScatterMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterMax(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterMax(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterMax(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ResourceScatterMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterMin(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterMin(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterMin(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ResourceScatterMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterMul(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterMul(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterMul(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ResourceScatterNdAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceScatterNdUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceScatterSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterSub(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterSub(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterSub(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ResourceScatterUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterUpdate(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ResourceScatterUpdate(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ResourceScatterUpdate(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ResourceSparseApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceSparseApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceSparseApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceSparseApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceSparseApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceSparseApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceSparseApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceSparseApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceSparseApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceSparseApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ResourceSparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ResourceSparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ResourceStridedSliceAssign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceStridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.ResourceStridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.ResourceStridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.Restore(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Restore(TFOutput, TFOutput, TFDataType, Nullable<Int64>, String)
  nameWithType: TFGraph.Restore(TFOutput, TFOutput, TFDataType, Nullable<Int64>, String)
  fullName: TFGraph.Restore(TFOutput, TFOutput, TFDataType, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.RestoreSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RestoreSlice(TFOutput, TFOutput, TFOutput, TFDataType, Nullable<Int64>, String)
  nameWithType: TFGraph.RestoreSlice(TFOutput, TFOutput, TFOutput, TFDataType, Nullable<Int64>, String)
  fullName: TFGraph.RestoreSlice(TFOutput, TFOutput, TFOutput, TFDataType, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.RestoreV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RestoreV2(TFOutput, TFOutput, TFOutput, TFDataType[], String)
  nameWithType: TFGraph.RestoreV2(TFOutput, TFOutput, TFOutput, TFDataType[], String)
  fullName: TFGraph.RestoreV2(TFOutput, TFOutput, TFOutput, TFDataType[], String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingAdadeltaParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingAdadeltaParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingAdadeltaParameters(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingAdagradParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingAdagradParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingAdagradParameters(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingAdagradParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingADAMParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingADAMParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingADAMParameters(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingADAMParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingADAMParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingADAMParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingCenteredRMSPropParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingCenteredRMSPropParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingCenteredRMSPropParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingCenteredRMSPropParameters(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingFTRLParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingFTRLParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingFTRLParameters(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingFTRLParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingMDLAdagradLightParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingMDLAdagradLightParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingMDLAdagradLightParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingMDLAdagradLightParameters(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingMomentumParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingMomentumParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingMomentumParameters(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingMomentumParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingProximalAdagradParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingProximalAdagradParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingProximalAdagradParameters(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingRMSPropParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingRMSPropParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingRMSPropParameters(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingStochasticGradientDescentParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingStochasticGradientDescentParameters(Int64, Int64, Nullable<Int64>, String, String)
  nameWithType: TFGraph.RetrieveTPUEmbeddingStochasticGradientDescentParameters(Int64, Int64, Nullable<Int64>, String, String)
  fullName: TFGraph.RetrieveTPUEmbeddingStochasticGradientDescentParameters(Int64, Int64, Nullable<Int64>, String, String)
- uid: TensorFlow.TFGraph.Reverse(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Reverse(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Reverse(TFOutput, TFOutput, String)
  fullName: TFGraph.Reverse(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ReverseSequence(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReverseSequence(TFOutput, TFOutput, Int64, Nullable<Int64>, String)
  nameWithType: TFGraph.ReverseSequence(TFOutput, TFOutput, Int64, Nullable<Int64>, String)
  fullName: TFGraph.ReverseSequence(TFOutput, TFOutput, Int64, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.ReverseV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReverseV2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ReverseV2(TFOutput, TFOutput, String)
  fullName: TFGraph.ReverseV2(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.RFFT(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RFFT(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RFFT(TFOutput, TFOutput, String)
  fullName: TFGraph.RFFT(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.RFFT2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RFFT2D(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RFFT2D(TFOutput, TFOutput, String)
  fullName: TFGraph.RFFT2D(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.RFFT3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RFFT3D(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RFFT3D(TFOutput, TFOutput, String)
  fullName: TFGraph.RFFT3D(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.RGBToHSV(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RGBToHSV(TFOutput, String)
  nameWithType: TFGraph.RGBToHSV(TFOutput, String)
  fullName: TFGraph.RGBToHSV(TFOutput, String)
- uid: TensorFlow.TFGraph.RightShift(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RightShift(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RightShift(TFOutput, TFOutput, String)
  fullName: TFGraph.RightShift(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Rint(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Rint(TFOutput, String)
  nameWithType: TFGraph.Rint(TFOutput, String)
  fullName: TFGraph.Rint(TFOutput, String)
- uid: TensorFlow.TFGraph.Roll(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Roll(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.Roll(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.Roll(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Round(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Round(TFOutput, String)
  nameWithType: TFGraph.Round(TFOutput, String)
  fullName: TFGraph.Round(TFOutput, String)
- uid: TensorFlow.TFGraph.Rpc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Rpc(TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  nameWithType: TFGraph.Rpc(TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  fullName: TFGraph.Rpc(TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.Rsqrt(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Rsqrt(TFOutput, String)
  nameWithType: TFGraph.Rsqrt(TFOutput, String)
  fullName: TFGraph.Rsqrt(TFOutput, String)
- uid: TensorFlow.TFGraph.RsqrtGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RsqrtGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.RsqrtGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.RsqrtGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SampleDistortedBoundingBox(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Single},System.Single[],System.Single[],System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SampleDistortedBoundingBox(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Single>, Single[], Single[], Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.SampleDistortedBoundingBox(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Single>, Single[], Single[], Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.SampleDistortedBoundingBox(TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Single>, Single[], Single[], Nullable<Int64>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SampleDistortedBoundingBoxV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Single[],System.Single[],System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SampleDistortedBoundingBoxV2(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Single[], Single[], Nullable<Int64>, Nullable<Boolean>, String)
  nameWithType: TFGraph.SampleDistortedBoundingBoxV2(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Single[], Single[], Nullable<Int64>, Nullable<Boolean>, String)
  fullName: TFGraph.SampleDistortedBoundingBoxV2(TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Single[], Single[], Nullable<Int64>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Save(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Save(TFOutput, TFOutput, TFOutput[], String)
  nameWithType: TFGraph.Save(TFOutput, TFOutput, TFOutput[], String)
  fullName: TFGraph.Save(TFOutput, TFOutput, TFOutput[], String)
- uid: TensorFlow.TFGraph.SaveSlices(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SaveSlices(TFOutput, TFOutput, TFOutput, TFOutput[], String)
  nameWithType: TFGraph.SaveSlices(TFOutput, TFOutput, TFOutput, TFOutput[], String)
  fullName: TFGraph.SaveSlices(TFOutput, TFOutput, TFOutput, TFOutput[], String)
- uid: TensorFlow.TFGraph.SaveV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SaveV2(TFOutput, TFOutput, TFOutput, TFOutput[], String)
  nameWithType: TFGraph.SaveV2(TFOutput, TFOutput, TFOutput, TFOutput[], String)
  fullName: TFGraph.SaveV2(TFOutput, TFOutput, TFOutput, TFOutput[], String)
- uid: TensorFlow.TFGraph.ScalarSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScalarSummary(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ScalarSummary(TFOutput, TFOutput, String)
  fullName: TFGraph.ScalarSummary(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ScatterAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ScatterDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterDiv(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterDiv(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterDiv(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ScatterMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterMax(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterMax(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterMax(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ScatterMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterMin(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterMin(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterMin(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ScatterMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterMul(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterMul(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterMul(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ScatterNd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterNd(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ScatterNd(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ScatterNd(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ScatterNdAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ScatterNdNonAliasingAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterNdNonAliasingAdd(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ScatterNdNonAliasingAdd(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ScatterNdNonAliasingAdd(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ScatterNdSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterNdSub(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterNdSub(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterNdSub(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ScatterNdUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ScatterSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterSub(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterSub(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterSub(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ScatterUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.ScatterUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.ScatterUpdate(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SdcaFprint(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SdcaFprint(TFOutput, String)
  nameWithType: TFGraph.SdcaFprint(TFOutput, String)
  fullName: TFGraph.SdcaFprint(TFOutput, String)
- uid: TensorFlow.TFGraph.SdcaOptimizer(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.String,System.Single,System.Single,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SdcaOptimizer(TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput, String, Single, Single, Int64, Int64, Nullable<Boolean>, String)
  nameWithType: TFGraph.SdcaOptimizer(TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput, String, Single, Single, Int64, Int64, Nullable<Boolean>, String)
  fullName: TFGraph.SdcaOptimizer(TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput, String, Single, Single, Int64, Int64, Nullable<Boolean>, String)
- uid: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[]}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput,TFOutput[],TFOutput[]>
  nameWithType: ValueTuple<TFOutput,TFOutput[],TFOutput[]>
  fullName: System.ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[]>
  spec.csharp:
  - uid: System.ValueTuple`3
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.SdcaShrinkL1(TensorFlow.TFOutput[],System.Single,System.Single,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SdcaShrinkL1(TFOutput[], Single, Single, String)
  nameWithType: TFGraph.SdcaShrinkL1(TFOutput[], Single, Single, String)
  fullName: TFGraph.SdcaShrinkL1(TFOutput[], Single, Single, String)
- uid: TensorFlow.TFGraph.Seed
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Seed
  nameWithType: TFGraph.Seed
  fullName: TFGraph.Seed
- uid: TensorFlow.TFGraph.SegmentMax(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SegmentMax(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SegmentMax(TFOutput, TFOutput, String)
  fullName: TFGraph.SegmentMax(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SegmentMean(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SegmentMean(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SegmentMean(TFOutput, TFOutput, String)
  fullName: TFGraph.SegmentMean(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SegmentMin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SegmentMin(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SegmentMin(TFOutput, TFOutput, String)
  fullName: TFGraph.SegmentMin(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SegmentProd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SegmentProd(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SegmentProd(TFOutput, TFOutput, String)
  fullName: TFGraph.SegmentProd(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SegmentSum(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SegmentSum(TFOutput, TFOutput, String)
  fullName: TFGraph.SegmentSum(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Select(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Select(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.Select(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.Select(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SelfAdjointEig(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SelfAdjointEig(TFOutput, String)
  nameWithType: TFGraph.SelfAdjointEig(TFOutput, String)
  fullName: TFGraph.SelfAdjointEig(TFOutput, String)
- uid: TensorFlow.TFGraph.SelfAdjointEigV2(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SelfAdjointEigV2(TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SelfAdjointEigV2(TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SelfAdjointEigV2(TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Selu(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Selu(TFOutput, String)
  nameWithType: TFGraph.Selu(TFOutput, String)
  fullName: TFGraph.Selu(TFOutput, String)
- uid: TensorFlow.TFGraph.SeluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SeluGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SeluGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.SeluGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SendTPUEmbeddingGradients(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SendTPUEmbeddingGradients(TFOutput[], TFOutput[], String, String)
  nameWithType: TFGraph.SendTPUEmbeddingGradients(TFOutput[], TFOutput[], String, String)
  fullName: TFGraph.SendTPUEmbeddingGradients(TFOutput[], TFOutput[], String, String)
- uid: TensorFlow.TFGraph.SerializeIterator(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SerializeIterator(TFOutput, String)
  nameWithType: TFGraph.SerializeIterator(TFOutput, String)
  fullName: TFGraph.SerializeIterator(TFOutput, String)
- uid: TensorFlow.TFGraph.SerializeManySparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SerializeManySparse(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.SerializeManySparse(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.SerializeManySparse(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.SerializeSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SerializeSparse(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.SerializeSparse(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.SerializeSparse(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.SerializeTensor(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SerializeTensor(TFOutput, String)
  nameWithType: TFGraph.SerializeTensor(TFOutput, String)
  fullName: TFGraph.SerializeTensor(TFOutput, String)
- uid: TensorFlow.TFGraph.SetSize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SetSize(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SetSize(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SetSize(TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SetTensorShape(TensorFlow.TFOutput,System.Int64[],TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SetTensorShape(TFOutput, Int64[], TFStatus)
  nameWithType: TFGraph.SetTensorShape(TFOutput, Int64[], TFStatus)
  fullName: TFGraph.SetTensorShape(TFOutput, Int64[], TFStatus)
- uid: TensorFlow.TFGraph.Shape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Shape(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Shape(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Shape(TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.ShapeN(TensorFlow.TFOutput[],System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ShapeN(TFOutput[], Nullable<TFDataType>, String)
  nameWithType: TFGraph.ShapeN(TFOutput[], Nullable<TFDataType>, String)
  fullName: TFGraph.ShapeN(TFOutput[], Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.ShardedFilename(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ShardedFilename(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.ShardedFilename(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.ShardedFilename(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ShardedFilespec(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ShardedFilespec(TFOutput, TFOutput, String)
  nameWithType: TFGraph.ShardedFilespec(TFOutput, TFOutput, String)
  fullName: TFGraph.ShardedFilespec(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ShuffleAndRepeatDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ShuffleAndRepeatDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ShuffleAndRepeatDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.ShuffleAndRepeatDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.ShuffleDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ShuffleDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], Nullable<Boolean>, String)
  nameWithType: TFGraph.ShuffleDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], Nullable<Boolean>, String)
  fullName: TFGraph.ShuffleDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ShutdownDistributedTPU(System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ShutdownDistributedTPU(String)
  nameWithType: TFGraph.ShutdownDistributedTPU(String)
  fullName: TFGraph.ShutdownDistributedTPU(String)
- uid: TensorFlow.TFGraph.Sigmoid(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sigmoid(TFOutput, String)
  nameWithType: TFGraph.Sigmoid(TFOutput, String)
  fullName: TFGraph.Sigmoid(TFOutput, String)
- uid: TensorFlow.TFGraph.SigmoidCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SigmoidCrossEntropyWithLogits(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SigmoidCrossEntropyWithLogits(TFOutput, TFOutput, String)
  fullName: TFGraph.SigmoidCrossEntropyWithLogits(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SigmoidGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SigmoidGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SigmoidGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.SigmoidGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Sign(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sign(TFOutput, String)
  nameWithType: TFGraph.Sign(TFOutput, String)
  fullName: TFGraph.Sign(TFOutput, String)
- uid: TensorFlow.TFGraph.Sin(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sin(TFOutput, String)
  nameWithType: TFGraph.Sin(TFOutput, String)
  fullName: TFGraph.Sin(TFOutput, String)
- uid: TensorFlow.TFGraph.Sinh(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sinh(TFOutput, String)
  nameWithType: TFGraph.Sinh(TFOutput, String)
  fullName: TFGraph.Sinh(TFOutput, String)
- uid: TensorFlow.TFGraph.Size(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Size(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Size(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Size(TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.SkipDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SkipDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.SkipDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.SkipDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.Skipgram(System.String,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Single},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Skipgram(String, Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Single>, String)
  nameWithType: TFGraph.Skipgram(String, Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Single>, String)
  fullName: TFGraph.Skipgram(String, Int64, Nullable<Int64>, Nullable<Int64>, Nullable<Single>, String)
- uid: System.ValueTuple`7
  name: ValueTuple
  nameWithType: ValueTuple
  fullName: System.ValueTuple
- uid: System.ValueTuple{TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput,TFOutput,TFOutput,TFOutput,TFOutput,TFOutput,TFOutput>
  nameWithType: ValueTuple<TFOutput,TFOutput,TFOutput,TFOutput,TFOutput,TFOutput,TFOutput>
  fullName: System.ValueTuple<TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput>
  spec.csharp:
  - uid: System.ValueTuple`7
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.Slice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Slice(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.Slice(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.Slice(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Snapshot(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Snapshot(TFOutput, String)
  nameWithType: TFGraph.Snapshot(TFOutput, String)
  fullName: TFGraph.Snapshot(TFOutput, String)
- uid: TensorFlow.TFGraph.Softmax(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Softmax(TFOutput, String)
  nameWithType: TFGraph.Softmax(TFOutput, String)
  fullName: TFGraph.Softmax(TFOutput, String)
- uid: TensorFlow.TFGraph.SoftmaxCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)
  fullName: TFGraph.SoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Softplus(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Softplus(TFOutput, String)
  nameWithType: TFGraph.Softplus(TFOutput, String)
  fullName: TFGraph.Softplus(TFOutput, String)
- uid: TensorFlow.TFGraph.SoftplusGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SoftplusGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SoftplusGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.SoftplusGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Softsign(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Softsign(TFOutput, String)
  nameWithType: TFGraph.Softsign(TFOutput, String)
  fullName: TFGraph.Softsign(TFOutput, String)
- uid: TensorFlow.TFGraph.SoftsignGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SoftsignGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SoftsignGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.SoftsignGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SpaceToBatch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SpaceToBatch(TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.SpaceToBatch(TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.SpaceToBatch(TFOutput, TFOutput, Int64, String)
- uid: TensorFlow.TFGraph.SpaceToBatchND(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SpaceToBatchND(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SpaceToBatchND(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SpaceToBatchND(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SpaceToDepth(TensorFlow.TFOutput,System.Int64,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SpaceToDepth(TFOutput, Int64, String, String)
  nameWithType: TFGraph.SpaceToDepth(TFOutput, Int64, String, String)
  fullName: TFGraph.SpaceToDepth(TFOutput, Int64, String, String)
- uid: TensorFlow.TFGraph.SparseAccumulatorApplyGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseAccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Boolean, String)
  nameWithType: TFGraph.SparseAccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Boolean, String)
  fullName: TFGraph.SparseAccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Boolean, String)
- uid: TensorFlow.TFGraph.SparseAccumulatorTakeGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseAccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.SparseAccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.SparseAccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.SparseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseAddGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseAddGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseAddGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseAddGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseConcat(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseConcat(TFOutput[], TFOutput[], TFOutput[], Int64, String)
  nameWithType: TFGraph.SparseConcat(TFOutput[], TFOutput[], TFOutput[], Int64, String)
  fullName: TFGraph.SparseConcat(TFOutput[], TFOutput[], TFOutput[], Int64, String)
- uid: TensorFlow.TFGraph.SparseConditionalAccumulator(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseConditionalAccumulator(TFDataType, TFShape, String, String, String, String)
  nameWithType: TFGraph.SparseConditionalAccumulator(TFDataType, TFShape, String, String, String, String)
  fullName: TFGraph.SparseConditionalAccumulator(TFDataType, TFShape, String, String, String, String)
- uid: TensorFlow.TFGraph.SparseCross(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.Boolean,System.Int64,System.Int64,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseCross(TFOutput[], TFOutput[], TFOutput[], TFOutput[], Boolean, Int64, Int64, TFDataType, TFDataType, String)
  nameWithType: TFGraph.SparseCross(TFOutput[], TFOutput[], TFOutput[], TFOutput[], Boolean, Int64, Int64, TFDataType, TFDataType, String)
  fullName: TFGraph.SparseCross(TFOutput[], TFOutput[], TFOutput[], TFOutput[], Boolean, Int64, Int64, TFDataType, TFDataType, String)
- uid: TensorFlow.TFGraph.SparseDenseCwiseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseDenseCwiseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseDenseCwiseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseDenseCwiseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseDenseCwiseDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseDenseCwiseDiv(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseDenseCwiseDiv(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseDenseCwiseDiv(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseDenseCwiseMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseDenseCwiseMul(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseDenseCwiseMul(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseDenseCwiseMul(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseFillEmptyRows(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseFillEmptyRows(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseFillEmptyRows(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseFillEmptyRows(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseFillEmptyRowsGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseFillEmptyRowsGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseFillEmptyRowsGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.SparseFillEmptyRowsGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseMatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseMatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.SparseMatMul(TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseReduceMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseReduceMax(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseReduceMax(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseReduceMax(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseReduceMaxSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseReduceMaxSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseReduceMaxSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseReduceMaxSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseReduceSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseReduceSum(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseReduceSum(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseReduceSum(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseReduceSumSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseReduceSumSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseReduceSumSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseReduceSumSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseReorder(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseReorder(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseReorder(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseReorder(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseReshape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseReshape(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseReshape(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseReshape(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSegmentMean(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentMean(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentMean(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentMean(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSegmentMeanGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentMeanGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentMeanGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentMeanGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSegmentMeanWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentMeanWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentMeanWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentMeanWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSegmentSqrtN(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentSqrtN(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentSqrtN(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentSqrtN(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSegmentSqrtNGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentSqrtNGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentSqrtNGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentSqrtNGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSegmentSqrtNWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentSqrtNWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentSqrtNWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentSqrtNWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentSum(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentSum(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentSum(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSegmentSumWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentSumWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSegmentSumWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSegmentSumWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSlice(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSlice(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSlice(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSliceGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSoftmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSoftmax(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSoftmax(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSoftmax(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSoftmaxCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSparseMaximum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSparseMaximum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSparseMaximum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSparseMaximum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSparseMinimum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSparseMinimum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseSparseMinimum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseSparseMinimum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseSplit(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSplit(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.SparseSplit(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.SparseSplit(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)
- uid: System.ValueTuple{TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]}
  parent: System
  isExternal: true
  name: ValueTuple<TFOutput[],TFOutput[],TFOutput[]>
  nameWithType: ValueTuple<TFOutput[],TFOutput[],TFOutput[]>
  fullName: System.ValueTuple<TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]>
  spec.csharp:
  - uid: System.ValueTuple`3
    name: ValueTuple
    nameWithType: ValueTuple
    fullName: System.ValueTuple
  - name: <
    nameWithType: <
    fullName: <
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: TensorFlow.TFOutput
    name: TFOutput
    nameWithType: TFOutput
    fullName: TensorFlow.TFOutput
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: TensorFlow.TFGraph.SparseTensorDenseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseTensorDenseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseTensorDenseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseTensorDenseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseTensorDenseMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseTensorDenseMatMul(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseTensorDenseMatMul(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.SparseTensorDenseMatMul(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseTensorSliceDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseTensorSliceDataset(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.SparseTensorSliceDataset(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.SparseTensorSliceDataset(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.SparseToDense(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseToDense(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseToDense(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.SparseToDense(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.SparseToSparseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.SparseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, String)
  fullName: TFGraph.SparseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Split(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Split(TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.Split(TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.Split(TFOutput, TFOutput, Int64, String)
- uid: TensorFlow.TFGraph.SplitV(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SplitV(TFOutput, TFOutput, TFOutput, Int64, String)
  nameWithType: TFGraph.SplitV(TFOutput, TFOutput, TFOutput, Int64, String)
  fullName: TFGraph.SplitV(TFOutput, TFOutput, TFOutput, Int64, String)
- uid: TensorFlow.TFGraph.Sqrt(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sqrt(TFOutput, String)
  nameWithType: TFGraph.Sqrt(TFOutput, String)
  fullName: TFGraph.Sqrt(TFOutput, String)
- uid: TensorFlow.TFGraph.SqrtGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SqrtGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SqrtGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.SqrtGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Square(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Square(TFOutput, String)
  nameWithType: TFGraph.Square(TFOutput, String)
  fullName: TFGraph.Square(TFOutput, String)
- uid: TensorFlow.TFGraph.SquaredDifference(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SquaredDifference(TFOutput, TFOutput, String)
  nameWithType: TFGraph.SquaredDifference(TFOutput, TFOutput, String)
  fullName: TFGraph.SquaredDifference(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Squeeze(TensorFlow.TFOutput,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Squeeze(TFOutput, Int64[], String)
  nameWithType: TFGraph.Squeeze(TFOutput, Int64[], String)
  fullName: TFGraph.Squeeze(TFOutput, Int64[], String)
- uid: TensorFlow.TFGraph.Stack(TensorFlow.TFDataType,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Stack(TFDataType, String, String)
  nameWithType: TFGraph.Stack(TFDataType, String, String)
  fullName: TFGraph.Stack(TFDataType, String, String)
- uid: TensorFlow.TFGraph.Stack(TensorFlow.TFOutput[],System.Nullable{System.Int32},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Stack(TFOutput[], Nullable<Int32>, String)
  nameWithType: TFGraph.Stack(TFOutput[], Nullable<Int32>, String)
  fullName: TFGraph.Stack(TFOutput[], Nullable<Int32>, String)
- uid: TensorFlow.TFGraph.StackClose(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackClose(TFOutput, String)
  nameWithType: TFGraph.StackClose(TFOutput, String)
  fullName: TFGraph.StackClose(TFOutput, String)
- uid: TensorFlow.TFGraph.StackCloseV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackCloseV2(TFOutput, String)
  nameWithType: TFGraph.StackCloseV2(TFOutput, String)
  fullName: TFGraph.StackCloseV2(TFOutput, String)
- uid: TensorFlow.TFGraph.StackPop(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackPop(TFOutput, TFDataType, String)
  nameWithType: TFGraph.StackPop(TFOutput, TFDataType, String)
  fullName: TFGraph.StackPop(TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.StackPopV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackPopV2(TFOutput, TFDataType, String)
  nameWithType: TFGraph.StackPopV2(TFOutput, TFDataType, String)
  fullName: TFGraph.StackPopV2(TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.StackPush(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackPush(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.StackPush(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.StackPush(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.StackPushV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackPushV2(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.StackPushV2(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.StackPushV2(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.StackV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackV2(TFOutput, TFDataType, String, String)
  nameWithType: TFGraph.StackV2(TFOutput, TFDataType, String, String)
  fullName: TFGraph.StackV2(TFOutput, TFDataType, String, String)
- uid: TensorFlow.TFGraph.Stage(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Stage(TFOutput[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.Stage(TFOutput[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.Stage(TFOutput[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.StageClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StageClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.StageClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.StageClear(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.StagePeek(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StagePeek(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.StagePeek(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.StagePeek(TFOutput, TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.StageSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StageSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.StageSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.StageSize(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.StatelessMultinomial(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StatelessMultinomial(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.StatelessMultinomial(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.StatelessMultinomial(TFOutput, TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.StatelessRandomNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StatelessRandomNormal(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.StatelessRandomNormal(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.StatelessRandomNormal(TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.StatelessRandomUniform(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StatelessRandomUniform(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.StatelessRandomUniform(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.StatelessRandomUniform(TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.StatelessTruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StatelessTruncatedNormal(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.StatelessTruncatedNormal(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.StatelessTruncatedNormal(TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.StaticRegexFullMatch(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StaticRegexFullMatch(TFOutput, String, String)
  nameWithType: TFGraph.StaticRegexFullMatch(TFOutput, String, String)
  fullName: TFGraph.StaticRegexFullMatch(TFOutput, String, String)
- uid: TensorFlow.TFGraph.StaticRegexReplace(TensorFlow.TFOutput,System.String,System.String,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StaticRegexReplace(TFOutput, String, String, Nullable<Boolean>, String)
  nameWithType: TFGraph.StaticRegexReplace(TFOutput, String, String, Nullable<Boolean>, String)
  fullName: TFGraph.StaticRegexReplace(TFOutput, String, String, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.StopGradient(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StopGradient(TFOutput, String)
  nameWithType: TFGraph.StopGradient(TFOutput, String)
  fullName: TFGraph.StopGradient(TFOutput, String)
- uid: TensorFlow.TFGraph.StridedSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StridedSlice(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.StridedSlice(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.StridedSlice(TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.StridedSliceAssign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.StridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.StridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.StridedSliceGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StridedSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.StridedSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.StridedSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.StringFormat(TensorFlow.TFOutput[],System.String,System.String,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringFormat(TFOutput[], String, String, Nullable<Int64>, String)
  nameWithType: TFGraph.StringFormat(TFOutput[], String, String, Nullable<Int64>, String)
  fullName: TFGraph.StringFormat(TFOutput[], String, String, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.StringJoin(TensorFlow.TFOutput[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringJoin(TFOutput[], String, String)
  nameWithType: TFGraph.StringJoin(TFOutput[], String, String)
  fullName: TFGraph.StringJoin(TFOutput[], String, String)
- uid: TensorFlow.TFGraph.StringLength(TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringLength(TFOutput, String, String)
  nameWithType: TFGraph.StringLength(TFOutput, String, String)
  fullName: TFGraph.StringLength(TFOutput, String, String)
- uid: TensorFlow.TFGraph.StringSplit(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringSplit(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.StringSplit(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.StringSplit(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.StringSplitV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringSplitV2(TFOutput, TFOutput, Nullable<Int64>, String)
  nameWithType: TFGraph.StringSplitV2(TFOutput, TFOutput, Nullable<Int64>, String)
  fullName: TFGraph.StringSplitV2(TFOutput, TFOutput, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.StringStrip(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringStrip(TFOutput, String)
  nameWithType: TFGraph.StringStrip(TFOutput, String)
  fullName: TFGraph.StringStrip(TFOutput, String)
- uid: TensorFlow.TFGraph.StringToHashBucket(TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringToHashBucket(TFOutput, Int64, String)
  nameWithType: TFGraph.StringToHashBucket(TFOutput, Int64, String)
  fullName: TFGraph.StringToHashBucket(TFOutput, Int64, String)
- uid: TensorFlow.TFGraph.StringToHashBucketFast(TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringToHashBucketFast(TFOutput, Int64, String)
  nameWithType: TFGraph.StringToHashBucketFast(TFOutput, Int64, String)
  fullName: TFGraph.StringToHashBucketFast(TFOutput, Int64, String)
- uid: TensorFlow.TFGraph.StringToHashBucketStrong(TensorFlow.TFOutput,System.Int64,System.Int64[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringToHashBucketStrong(TFOutput, Int64, Int64[], String)
  nameWithType: TFGraph.StringToHashBucketStrong(TFOutput, Int64, Int64[], String)
  fullName: TFGraph.StringToHashBucketStrong(TFOutput, Int64, Int64[], String)
- uid: TensorFlow.TFGraph.StringToNumber(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringToNumber(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.StringToNumber(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.StringToNumber(TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.Sub(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sub(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Sub(TFOutput, TFOutput, String)
  fullName: TFGraph.Sub(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Sum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sum(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.Sum(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.Sum(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Svd(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Svd(TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  nameWithType: TFGraph.Svd(TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
  fullName: TFGraph.Svd(TFOutput, Nullable<Boolean>, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.Switch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Switch(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Switch(TFOutput, TFOutput, String)
  fullName: TFGraph.Switch(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TakeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TakeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.TakeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.TakeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.TakeManySparseFromTensorsMap(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TakeManySparseFromTensorsMap(TFOutput, TFDataType, String, String, String)
  nameWithType: TFGraph.TakeManySparseFromTensorsMap(TFOutput, TFDataType, String, String, String)
  fullName: TFGraph.TakeManySparseFromTensorsMap(TFOutput, TFDataType, String, String, String)
- uid: TensorFlow.TFGraph.Tan(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Tan(TFOutput, String)
  nameWithType: TFGraph.Tan(TFOutput, String)
  fullName: TFGraph.Tan(TFOutput, String)
- uid: TensorFlow.TFGraph.Tanh(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Tanh(TFOutput, String)
  nameWithType: TFGraph.Tanh(TFOutput, String)
  fullName: TFGraph.Tanh(TFOutput, String)
- uid: TensorFlow.TFGraph.TanhGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TanhGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TanhGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.TanhGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TemporaryVariable(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TemporaryVariable(TFShape, TFDataType, String, String)
  nameWithType: TFGraph.TemporaryVariable(TFShape, TFDataType, String, String)
  fullName: TFGraph.TemporaryVariable(TFShape, TFDataType, String, String)
- uid: TensorFlow.TFGraph.TensorArrayCloseV2(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayCloseV2(TFOutput, String)
  nameWithType: TFGraph.TensorArrayCloseV2(TFOutput, String)
  fullName: TFGraph.TensorArrayCloseV2(TFOutput, String)
- uid: TensorFlow.TFGraph.TensorArrayCloseV3(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayCloseV3(TFOutput, String)
  nameWithType: TFGraph.TensorArrayCloseV3(TFOutput, String)
  fullName: TFGraph.TensorArrayCloseV3(TFOutput, String)
- uid: TensorFlow.TFGraph.TensorArrayConcatV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayConcatV2(TFOutput, TFOutput, TFDataType, TFShape, String)
  nameWithType: TFGraph.TensorArrayConcatV2(TFOutput, TFOutput, TFDataType, TFShape, String)
  fullName: TFGraph.TensorArrayConcatV2(TFOutput, TFOutput, TFDataType, TFShape, String)
- uid: TensorFlow.TFGraph.TensorArrayConcatV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayConcatV3(TFOutput, TFOutput, TFDataType, TFShape, String)
  nameWithType: TFGraph.TensorArrayConcatV3(TFOutput, TFOutput, TFDataType, TFShape, String)
  fullName: TFGraph.TensorArrayConcatV3(TFOutput, TFOutput, TFDataType, TFShape, String)
- uid: TensorFlow.TFGraph.TensorArrayGatherV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayGatherV2(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)
  nameWithType: TFGraph.TensorArrayGatherV2(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)
  fullName: TFGraph.TensorArrayGatherV2(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)
- uid: TensorFlow.TFGraph.TensorArrayGatherV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayGatherV3(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)
  nameWithType: TFGraph.TensorArrayGatherV3(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)
  fullName: TFGraph.TensorArrayGatherV3(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)
- uid: TensorFlow.TFGraph.TensorArrayGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayGradV2(TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.TensorArrayGradV2(TFOutput, TFOutput, String, String)
  fullName: TFGraph.TensorArrayGradV2(TFOutput, TFOutput, String, String)
- uid: TensorFlow.TFGraph.TensorArrayGradV3(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayGradV3(TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.TensorArrayGradV3(TFOutput, TFOutput, String, String)
  fullName: TFGraph.TensorArrayGradV3(TFOutput, TFOutput, String, String)
- uid: TensorFlow.TFGraph.TensorArrayGradWithShape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayGradWithShape(TFOutput, TFOutput, TFOutput, String, String)
  nameWithType: TFGraph.TensorArrayGradWithShape(TFOutput, TFOutput, TFOutput, String, String)
  fullName: TFGraph.TensorArrayGradWithShape(TFOutput, TFOutput, TFOutput, String, String)
- uid: TensorFlow.TFGraph.TensorArrayReadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayReadV2(TFOutput, TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorArrayReadV2(TFOutput, TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.TensorArrayReadV2(TFOutput, TFOutput, TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.TensorArrayReadV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayReadV3(TFOutput, TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorArrayReadV3(TFOutput, TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.TensorArrayReadV3(TFOutput, TFOutput, TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.TensorArrayScatterV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayScatterV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArrayScatterV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArrayScatterV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TensorArrayScatterV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayScatterV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArrayScatterV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArrayScatterV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TensorArraySizeV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArraySizeV2(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArraySizeV2(TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArraySizeV2(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TensorArraySizeV3(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArraySizeV3(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArraySizeV3(TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArraySizeV3(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TensorArraySplitV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArraySplitV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArraySplitV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArraySplitV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TensorArraySplitV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArraySplitV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArraySplitV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArraySplitV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TensorArrayV2(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayV2(TFOutput, TFDataType, TFShape, Nullable<Boolean>, Nullable<Boolean>, String, String)
  nameWithType: TFGraph.TensorArrayV2(TFOutput, TFDataType, TFShape, Nullable<Boolean>, Nullable<Boolean>, String, String)
  fullName: TFGraph.TensorArrayV2(TFOutput, TFDataType, TFShape, Nullable<Boolean>, Nullable<Boolean>, String, String)
- uid: TensorFlow.TFGraph.TensorArrayV3(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayV3(TFOutput, TFDataType, TFShape, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String, String)
  nameWithType: TFGraph.TensorArrayV3(TFOutput, TFDataType, TFShape, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String, String)
  fullName: TFGraph.TensorArrayV3(TFOutput, TFDataType, TFShape, Nullable<Boolean>, Nullable<Boolean>, Nullable<Boolean>, String, String)
- uid: TensorFlow.TFGraph.TensorArrayWriteV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayWriteV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArrayWriteV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArrayWriteV2(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TensorArrayWriteV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayWriteV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorArrayWriteV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorArrayWriteV3(TFOutput, TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TensorDataset(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorDataset(TFOutput[], TFShape[], String)
  nameWithType: TFGraph.TensorDataset(TFOutput[], TFShape[], String)
  fullName: TFGraph.TensorDataset(TFOutput[], TFShape[], String)
- uid: TensorFlow.TFGraph.TensorListElementShape(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListElementShape(TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorListElementShape(TFOutput, TFDataType, String)
  fullName: TFGraph.TensorListElementShape(TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.TensorListFromTensor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListFromTensor(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorListFromTensor(TFOutput, TFOutput, String)
  fullName: TFGraph.TensorListFromTensor(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TensorListGather(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListGather(TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorListGather(TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.TensorListGather(TFOutput, TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.TensorListGetItem(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListGetItem(TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorListGetItem(TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.TensorListGetItem(TFOutput, TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.TensorListLength(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListLength(TFOutput, String)
  nameWithType: TFGraph.TensorListLength(TFOutput, String)
  fullName: TFGraph.TensorListLength(TFOutput, String)
- uid: TensorFlow.TFGraph.TensorListPopBack(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListPopBack(TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorListPopBack(TFOutput, TFDataType, String)
  fullName: TFGraph.TensorListPopBack(TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.TensorListPushBack(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListPushBack(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorListPushBack(TFOutput, TFOutput, String)
  fullName: TFGraph.TensorListPushBack(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TensorListReserve(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListReserve(TFOutput, TFOutput, TFDataType, String)
  nameWithType: TFGraph.TensorListReserve(TFOutput, TFOutput, TFDataType, String)
  fullName: TFGraph.TensorListReserve(TFOutput, TFOutput, TFDataType, String)
- uid: TensorFlow.TFGraph.TensorListScatter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListScatter(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorListScatter(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorListScatter(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TensorListSetItem(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListSetItem(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorListSetItem(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorListSetItem(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TensorListStack(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListStack(TFOutput, TFDataType, Nullable<Int64>, String)
  nameWithType: TFGraph.TensorListStack(TFOutput, TFDataType, Nullable<Int64>, String)
  fullName: TFGraph.TensorListStack(TFOutput, TFDataType, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.TensorSliceDataset(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorSliceDataset(TFOutput[], TFShape[], String)
  nameWithType: TFGraph.TensorSliceDataset(TFOutput[], TFShape[], String)
  fullName: TFGraph.TensorSliceDataset(TFOutput[], TFShape[], String)
- uid: TensorFlow.TFGraph.TensorSummary(TensorFlow.TFOutput,System.String,System.String[],System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorSummary(TFOutput, String, String[], String, String)
  nameWithType: TFGraph.TensorSummary(TFOutput, String, String[], String, String)
  fullName: TFGraph.TensorSummary(TFOutput, String, String[], String, String)
- uid: TensorFlow.TFGraph.TensorSummaryV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorSummaryV2(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TensorSummaryV2(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TensorSummaryV2(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TextLineDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TextLineDataset(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TextLineDataset(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TextLineDataset(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TextLineReader(System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TextLineReader(Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.TextLineReader(Nullable<Int64>, String, String, String)
  fullName: TFGraph.TextLineReader(Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.TextLineReaderV2(System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TextLineReaderV2(Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.TextLineReaderV2(Nullable<Int64>, String, String, String)
  fullName: TFGraph.TextLineReaderV2(Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.TFRecordDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TFRecordDataset(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.TFRecordDataset(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.TFRecordDataset(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TFRecordReader(System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TFRecordReader(String, String, String, String)
  nameWithType: TFGraph.TFRecordReader(String, String, String, String)
  fullName: TFGraph.TFRecordReader(String, String, String, String)
- uid: TensorFlow.TFGraph.TFRecordReaderV2(System.String,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TFRecordReaderV2(String, String, String, String)
  nameWithType: TFGraph.TFRecordReaderV2(String, String, String, String)
  fullName: TFGraph.TFRecordReaderV2(String, String, String, String)
- uid: TensorFlow.TFGraph.ThreadUnsafeUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ThreadUnsafeUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.ThreadUnsafeUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.ThreadUnsafeUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.Tile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Tile(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Tile(TFOutput, TFOutput, String)
  fullName: TFGraph.Tile(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TileGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TileGrad(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TileGrad(TFOutput, TFOutput, String)
  fullName: TFGraph.TileGrad(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Timestamp(System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Timestamp(String)
  nameWithType: TFGraph.Timestamp(String)
  fullName: TFGraph.Timestamp(String)
- uid: TensorFlow.TFGraph.ToFunction(System.String,System.String,TensorFlow.TFOperation[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String[],System.Boolean,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ToFunction(String, String, TFOperation[], TFOutput[], TFOutput[], String[], Boolean, TFStatus)
  nameWithType: TFGraph.ToFunction(String, String, TFOperation[], TFOutput[], TFOutput[], String[], Boolean, TFStatus)
  fullName: TFGraph.ToFunction(String, String, TFOperation[], TFOutput[], TFOutput[], String[], Boolean, TFStatus)
- uid: TensorFlow.TFGraph.ToGraphDef(TensorFlow.TFBuffer,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ToGraphDef(TFBuffer, TFStatus)
  nameWithType: TFGraph.ToGraphDef(TFBuffer, TFStatus)
  fullName: TFGraph.ToGraphDef(TFBuffer, TFStatus)
- uid: TensorFlow.TFGraph.TopK(TensorFlow.TFOutput,System.Int64,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TopK(TFOutput, Int64, Nullable<Boolean>, String)
  nameWithType: TFGraph.TopK(TFOutput, Int64, Nullable<Boolean>, String)
  fullName: TFGraph.TopK(TFOutput, Int64, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.TopKV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TopKV2(TFOutput, TFOutput, Nullable<Boolean>, String)
  nameWithType: TFGraph.TopKV2(TFOutput, TFOutput, Nullable<Boolean>, String)
  fullName: TFGraph.TopKV2(TFOutput, TFOutput, Nullable<Boolean>, String)
- uid: TensorFlow.TFGraph.ToString
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ToString()
  nameWithType: TFGraph.ToString()
  fullName: TFGraph.ToString()
- uid: TensorFlow.TFGraph.TPUEmbeddingActivations(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TPUEmbeddingActivations(TFOutput, TFOutput, Int64, Int64, String)
  nameWithType: TFGraph.TPUEmbeddingActivations(TFOutput, TFOutput, Int64, Int64, String)
  fullName: TFGraph.TPUEmbeddingActivations(TFOutput, TFOutput, Int64, Int64, String)
- uid: TensorFlow.TFGraph.TPUReplicatedInput(TensorFlow.TFOutput[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TPUReplicatedInput(TFOutput[], String)
  nameWithType: TFGraph.TPUReplicatedInput(TFOutput[], String)
  fullName: TFGraph.TPUReplicatedInput(TFOutput[], String)
- uid: TensorFlow.TFGraph.TPUReplicatedOutput(TensorFlow.TFOutput,System.Int64,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TPUReplicatedOutput(TFOutput, Int64, String)
  nameWithType: TFGraph.TPUReplicatedOutput(TFOutput, Int64, String)
  fullName: TFGraph.TPUReplicatedOutput(TFOutput, Int64, String)
- uid: TensorFlow.TFGraph.Transpose(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Transpose(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Transpose(TFOutput, TFOutput, String)
  fullName: TFGraph.Transpose(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Transpose(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Transpose(TFOutput, String)
  nameWithType: TFGraph.Transpose(TFOutput, String)
  fullName: TFGraph.Transpose(TFOutput, String)
- uid: TensorFlow.TFGraph.TruncateDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TruncateDiv(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TruncateDiv(TFOutput, TFOutput, String)
  fullName: TFGraph.TruncateDiv(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TruncatedNormal(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.TruncatedNormal(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.TruncatedNormal(TFOutput, TFDataType, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.TruncateMod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TruncateMod(TFOutput, TFOutput, String)
  nameWithType: TFGraph.TruncateMod(TFOutput, TFOutput, String)
  fullName: TFGraph.TruncateMod(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.TryEvaluateConstant(TensorFlow.TFOutput,TensorFlow.TFTensor@)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TryEvaluateConstant(TFOutput, TFTensor)
  nameWithType: TFGraph.TryEvaluateConstant(TFOutput, TFTensor)
  fullName: TFGraph.TryEvaluateConstant(TFOutput, TFTensor)
- uid: TensorFlow.TFGraph.TryRpc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TryRpc(TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  nameWithType: TFGraph.TryRpc(TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
  fullName: TFGraph.TryRpc(TFOutput, TFOutput, TFOutput, String, Nullable<Boolean>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.Unbatch(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Unbatch(TFOutput, TFOutput, TFOutput, Int64, String, String, String)
  nameWithType: TFGraph.Unbatch(TFOutput, TFOutput, TFOutput, Int64, String, String, String)
  fullName: TFGraph.Unbatch(TFOutput, TFOutput, TFOutput, Int64, String, String, String)
- uid: TensorFlow.TFGraph.UnbatchGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnbatchGrad(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  nameWithType: TFGraph.UnbatchGrad(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
  fullName: TFGraph.UnbatchGrad(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)
- uid: TensorFlow.TFGraph.UnicodeScript(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnicodeScript(TFOutput, String)
  nameWithType: TFGraph.UnicodeScript(TFOutput, String)
  fullName: TFGraph.UnicodeScript(TFOutput, String)
- uid: TensorFlow.TFGraph.UniformCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  nameWithType: TFGraph.UniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
  fullName: TFGraph.UniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable<Int64>, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.Unique(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Unique(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.Unique(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.Unique(TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.UniqueV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UniqueV2(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.UniqueV2(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.UniqueV2(TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.UniqueWithCounts(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UniqueWithCounts(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.UniqueWithCounts(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.UniqueWithCounts(TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.UniqueWithCountsV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UniqueWithCountsV2(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.UniqueWithCountsV2(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.UniqueWithCountsV2(TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.Unpack(TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Unpack(TFOutput, Int64, Nullable<Int64>, String)
  nameWithType: TFGraph.Unpack(TFOutput, Int64, Nullable<Int64>, String)
  fullName: TFGraph.Unpack(TFOutput, Int64, Nullable<Int64>, String)
- uid: TensorFlow.TFGraph.UnravelIndex(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnravelIndex(TFOutput, TFOutput, String)
  nameWithType: TFGraph.UnravelIndex(TFOutput, TFOutput, String)
  fullName: TFGraph.UnravelIndex(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.UnsortedSegmentMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnsortedSegmentMax(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.UnsortedSegmentMax(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.UnsortedSegmentMax(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.UnsortedSegmentMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnsortedSegmentMin(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.UnsortedSegmentMin(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.UnsortedSegmentMin(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.UnsortedSegmentProd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnsortedSegmentProd(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.UnsortedSegmentProd(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.UnsortedSegmentProd(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.UnsortedSegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnsortedSegmentSum(TFOutput, TFOutput, TFOutput, String)
  nameWithType: TFGraph.UnsortedSegmentSum(TFOutput, TFOutput, TFOutput, String)
  fullName: TFGraph.UnsortedSegmentSum(TFOutput, TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Unstage(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Unstage(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  nameWithType: TFGraph.Unstage(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
  fullName: TFGraph.Unstage(TFDataType[], Nullable<Int64>, Nullable<Int64>, String, String, String)
- uid: TensorFlow.TFGraph.UpperBound(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UpperBound(TFOutput, TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.UpperBound(TFOutput, TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.UpperBound(TFOutput, TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.VarHandleOp(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: VarHandleOp(TFDataType, TFShape, String, String, String)
  nameWithType: TFGraph.VarHandleOp(TFDataType, TFShape, String, String, String)
  fullName: TFGraph.VarHandleOp(TFDataType, TFShape, String, String, String)
- uid: TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Variable(TFOutput, Boolean, String)
  nameWithType: TFGraph.Variable(TFOutput, Boolean, String)
  fullName: TFGraph.Variable(TFOutput, Boolean, String)
- uid: TensorFlow.Variable
  parent: TensorFlow
  isExternal: false
  name: Variable
  nameWithType: Variable
  fullName: TensorFlow.Variable
- uid: TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,TensorFlow.TFOutput@,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Variable(TFOutput, TFOutput, Boolean, String)
  nameWithType: TFGraph.Variable(TFOutput, TFOutput, Boolean, String)
  fullName: TFGraph.Variable(TFOutput, TFOutput, Boolean, String)
- uid: TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,TensorFlow.TFOperation@,TensorFlow.TFOutput@,System.Boolean,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Variable(TFOutput, TFOperation, TFOutput, Boolean, String)
  nameWithType: TFGraph.Variable(TFOutput, TFOperation, TFOutput, Boolean, String)
  fullName: TFGraph.Variable(TFOutput, TFOperation, TFOutput, Boolean, String)
- uid: TensorFlow.TFGraph.Variable(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Variable(TFShape, TFDataType, String, String, String)
  nameWithType: TFGraph.Variable(TFShape, TFDataType, String, String, String)
  fullName: TFGraph.Variable(TFShape, TFDataType, String, String, String)
- uid: TensorFlow.TFGraph.VariableShape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: VariableShape(TFOutput, Nullable<TFDataType>, String)
  nameWithType: TFGraph.VariableShape(TFOutput, Nullable<TFDataType>, String)
  fullName: TFGraph.VariableShape(TFOutput, Nullable<TFDataType>, String)
- uid: TensorFlow.TFGraph.VariableV2(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: VariableV2(TFShape, TFDataType, String, String, String)
  nameWithType: TFGraph.VariableV2(TFShape, TFDataType, String, String, String)
  fullName: TFGraph.VariableV2(TFShape, TFDataType, String, String, String)
- uid: TensorFlow.TFGraph.VarIsInitializedOp(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: VarIsInitializedOp(TFOutput, String)
  nameWithType: TFGraph.VarIsInitializedOp(TFOutput, String)
  fullName: TFGraph.VarIsInitializedOp(TFOutput, String)
- uid: TensorFlow.TFGraph.Versions(TensorFlow.TFBuffer,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Versions(TFBuffer, TFStatus)
  nameWithType: TFGraph.Versions(TFBuffer, TFStatus)
  fullName: TFGraph.Versions(TFBuffer, TFStatus)
- uid: TensorFlow.TFGraph.Where(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFOutput},System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Where(TFOutput, Nullable<TFOutput>, Nullable<TFOutput>, String)
  nameWithType: TFGraph.Where(TFOutput, Nullable<TFOutput>, Nullable<TFOutput>, String)
  fullName: TFGraph.Where(TFOutput, Nullable<TFOutput>, Nullable<TFOutput>, String)
- uid: TensorFlow.TFGraph.Where(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Where(TFOutput, String)
  nameWithType: TFGraph.Where(TFOutput, String)
  fullName: TFGraph.Where(TFOutput, String)
- uid: TensorFlow.TFGraph.While(TensorFlow.TFOutput[],TensorFlow.TFGraph.WhileConstructor,TensorFlow.TFStatus)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: While(TFOutput[], TFGraph+WhileConstructor, TFStatus)
  nameWithType: TFGraph.While(TFOutput[], TFGraph+WhileConstructor, TFStatus)
  fullName: TFGraph.While(TFOutput[], TFGraph+WhileConstructor, TFStatus)
- uid: TensorFlow.TFGraph
  parent: TensorFlow
  isExternal: false
  name: TFGraph
  nameWithType: TFGraph
  fullName: TensorFlow.TFGraph+WhileConstructor
- uid: TensorFlow.TFGraph.WholeFileReader(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WholeFileReader(String, String, String)
  nameWithType: TFGraph.WholeFileReader(String, String, String)
  fullName: TFGraph.WholeFileReader(String, String, String)
- uid: TensorFlow.TFGraph.WholeFileReaderV2(System.String,System.String,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WholeFileReaderV2(String, String, String)
  nameWithType: TFGraph.WholeFileReaderV2(String, String, String)
  fullName: TFGraph.WholeFileReaderV2(String, String, String)
- uid: TensorFlow.TFGraph.WindowDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WindowDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  nameWithType: TFGraph.WindowDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
  fullName: TFGraph.WindowDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.WithDependencies(TensorFlow.TFOperation[])
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WithDependencies(TFOperation[])
  nameWithType: TFGraph.WithDependencies(TFOperation[])
  fullName: TFGraph.WithDependencies(TFOperation[])
- uid: TensorFlow.TFDependencies
  parent: TensorFlow
  isExternal: false
  name: TFDependencies
  nameWithType: TFDependencies
  fullName: TensorFlow.TFDependencies
- uid: TensorFlow.TFGraph.WithScope(System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WithScope(String)
  nameWithType: TFGraph.WithScope(String)
  fullName: TFGraph.WithScope(String)
- uid: TensorFlow.TFScope
  parent: TensorFlow
  isExternal: false
  name: TFScope
  nameWithType: TFScope
  fullName: TensorFlow.TFScope
- uid: TensorFlow.TFGraph.WorkerHeartbeat(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WorkerHeartbeat(TFOutput, String)
  nameWithType: TFGraph.WorkerHeartbeat(TFOutput, String)
  fullName: TFGraph.WorkerHeartbeat(TFOutput, String)
- uid: TensorFlow.TFGraph.WriteFile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WriteFile(TFOutput, TFOutput, String)
  nameWithType: TFGraph.WriteFile(TFOutput, TFOutput, String)
  fullName: TFGraph.WriteFile(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Xdivy(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Xdivy(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Xdivy(TFOutput, TFOutput, String)
  fullName: TFGraph.Xdivy(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Xlogy(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Xlogy(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Xlogy(TFOutput, TFOutput, String)
  fullName: TFGraph.Xlogy(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.Zeros(TensorFlow.TFShape,TensorFlow.TFDataType,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Zeros(TFShape, TFDataType, String)
  nameWithType: TFGraph.Zeros(TFShape, TFDataType, String)
  fullName: TFGraph.Zeros(TFShape, TFDataType, String)
- uid: TensorFlow.TFGraph.ZerosLike(TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ZerosLike(TFOutput, String)
  nameWithType: TFGraph.ZerosLike(TFOutput, String)
  fullName: TFGraph.ZerosLike(TFOutput, String)
- uid: TensorFlow.TFGraph.Zeta(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Zeta(TFOutput, TFOutput, String)
  nameWithType: TFGraph.Zeta(TFOutput, TFOutput, String)
  fullName: TFGraph.Zeta(TFOutput, TFOutput, String)
- uid: TensorFlow.TFGraph.ZipDataset(TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ZipDataset(TFOutput[], TFDataType[], TFShape[], String)
  nameWithType: TFGraph.ZipDataset(TFOutput[], TFDataType[], TFShape[], String)
  fullName: TFGraph.ZipDataset(TFOutput[], TFDataType[], TFShape[], String)
- uid: TensorFlow.TFGraph.#ctor*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TFGraph
  nameWithType: TFGraph.TFGraph
  fullName: TFGraph.TFGraph
- uid: TensorFlow.TFGraph.Abort*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Abort
  nameWithType: TFGraph.Abort
  fullName: TFGraph.Abort
- uid: TensorFlow.TFGraph.Abs*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Abs
  nameWithType: TFGraph.Abs
  fullName: TFGraph.Abs
- uid: TensorFlow.TFGraph.AccumulateNV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AccumulateNV2
  nameWithType: TFGraph.AccumulateNV2
  fullName: TFGraph.AccumulateNV2
- uid: TensorFlow.TFGraph.AccumulatorApplyGradient*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AccumulatorApplyGradient
  nameWithType: TFGraph.AccumulatorApplyGradient
  fullName: TFGraph.AccumulatorApplyGradient
- uid: TensorFlow.TFGraph.AccumulatorNumAccumulated*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AccumulatorNumAccumulated
  nameWithType: TFGraph.AccumulatorNumAccumulated
  fullName: TFGraph.AccumulatorNumAccumulated
- uid: TensorFlow.TFGraph.AccumulatorSetGlobalStep*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AccumulatorSetGlobalStep
  nameWithType: TFGraph.AccumulatorSetGlobalStep
  fullName: TFGraph.AccumulatorSetGlobalStep
- uid: TensorFlow.TFGraph.AccumulatorTakeGradient*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AccumulatorTakeGradient
  nameWithType: TFGraph.AccumulatorTakeGradient
  fullName: TFGraph.AccumulatorTakeGradient
- uid: TensorFlow.TFGraph.Acos*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Acos
  nameWithType: TFGraph.Acos
  fullName: TFGraph.Acos
- uid: TensorFlow.TFGraph.Acosh*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Acosh
  nameWithType: TFGraph.Acosh
  fullName: TFGraph.Acosh
- uid: TensorFlow.TFGraph.Add*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Add
  nameWithType: TFGraph.Add
  fullName: TFGraph.Add
- uid: TensorFlow.TFGraph.AddGradients*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AddGradients
  nameWithType: TFGraph.AddGradients
  fullName: TFGraph.AddGradients
- uid: TensorFlow.TFGraph.AddInitVariable*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AddInitVariable
  nameWithType: TFGraph.AddInitVariable
  fullName: TFGraph.AddInitVariable
- uid: TensorFlow.TFGraph.AddManySparseToTensorsMap*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AddManySparseToTensorsMap
  nameWithType: TFGraph.AddManySparseToTensorsMap
  fullName: TFGraph.AddManySparseToTensorsMap
- uid: TensorFlow.TFGraph.AddN*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AddN
  nameWithType: TFGraph.AddN
  fullName: TFGraph.AddN
- uid: TensorFlow.TFGraph.AddSparseToTensorsMap*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AddSparseToTensorsMap
  nameWithType: TFGraph.AddSparseToTensorsMap
  fullName: TFGraph.AddSparseToTensorsMap
- uid: TensorFlow.TFGraph.AddV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AddV2
  nameWithType: TFGraph.AddV2
  fullName: TFGraph.AddV2
- uid: TensorFlow.TFGraph.AdjustContrast*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AdjustContrast
  nameWithType: TFGraph.AdjustContrast
  fullName: TFGraph.AdjustContrast
- uid: TensorFlow.TFGraph.AdjustContrastv2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AdjustContrastv2
  nameWithType: TFGraph.AdjustContrastv2
  fullName: TFGraph.AdjustContrastv2
- uid: TensorFlow.TFGraph.AdjustHue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AdjustHue
  nameWithType: TFGraph.AdjustHue
  fullName: TFGraph.AdjustHue
- uid: TensorFlow.TFGraph.AdjustSaturation*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AdjustSaturation
  nameWithType: TFGraph.AdjustSaturation
  fullName: TFGraph.AdjustSaturation
- uid: TensorFlow.TFGraph.All*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: All
  nameWithType: TFGraph.All
  fullName: TFGraph.All
- uid: TensorFlow.TFGraph.AllCandidateSampler*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AllCandidateSampler
  nameWithType: TFGraph.AllCandidateSampler
  fullName: TFGraph.AllCandidateSampler
- uid: TensorFlow.TFGraph.AllToAll*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AllToAll
  nameWithType: TFGraph.AllToAll
  fullName: TFGraph.AllToAll
- uid: TensorFlow.TFGraph.Angle*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Angle
  nameWithType: TFGraph.Angle
  fullName: TFGraph.Angle
- uid: TensorFlow.TFGraph.AnonymousIterator*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AnonymousIterator
  nameWithType: TFGraph.AnonymousIterator
  fullName: TFGraph.AnonymousIterator
- uid: TensorFlow.TFGraph.Any*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Any
  nameWithType: TFGraph.Any
  fullName: TFGraph.Any
- uid: TensorFlow.TFGraph.ApplyAdadelta*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyAdadelta
  nameWithType: TFGraph.ApplyAdadelta
  fullName: TFGraph.ApplyAdadelta
- uid: TensorFlow.TFGraph.ApplyAdagrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyAdagrad
  nameWithType: TFGraph.ApplyAdagrad
  fullName: TFGraph.ApplyAdagrad
- uid: TensorFlow.TFGraph.ApplyAdagradDA*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyAdagradDA
  nameWithType: TFGraph.ApplyAdagradDA
  fullName: TFGraph.ApplyAdagradDA
- uid: TensorFlow.TFGraph.ApplyAdam*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyAdam
  nameWithType: TFGraph.ApplyAdam
  fullName: TFGraph.ApplyAdam
- uid: TensorFlow.TFGraph.ApplyAdaMax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyAdaMax
  nameWithType: TFGraph.ApplyAdaMax
  fullName: TFGraph.ApplyAdaMax
- uid: TensorFlow.TFGraph.ApplyAddSign*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyAddSign
  nameWithType: TFGraph.ApplyAddSign
  fullName: TFGraph.ApplyAddSign
- uid: TensorFlow.TFGraph.ApplyCenteredRMSProp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyCenteredRMSProp
  nameWithType: TFGraph.ApplyCenteredRMSProp
  fullName: TFGraph.ApplyCenteredRMSProp
- uid: TensorFlow.TFGraph.ApplyFtrl*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyFtrl
  nameWithType: TFGraph.ApplyFtrl
  fullName: TFGraph.ApplyFtrl
- uid: TensorFlow.TFGraph.ApplyFtrlV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyFtrlV2
  nameWithType: TFGraph.ApplyFtrlV2
  fullName: TFGraph.ApplyFtrlV2
- uid: TensorFlow.TFGraph.ApplyGradientDescent*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyGradientDescent
  nameWithType: TFGraph.ApplyGradientDescent
  fullName: TFGraph.ApplyGradientDescent
- uid: TensorFlow.TFGraph.ApplyMomentum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyMomentum
  nameWithType: TFGraph.ApplyMomentum
  fullName: TFGraph.ApplyMomentum
- uid: TensorFlow.TFGraph.ApplyPowerSign*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyPowerSign
  nameWithType: TFGraph.ApplyPowerSign
  fullName: TFGraph.ApplyPowerSign
- uid: TensorFlow.TFGraph.ApplyProximalAdagrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyProximalAdagrad
  nameWithType: TFGraph.ApplyProximalAdagrad
  fullName: TFGraph.ApplyProximalAdagrad
- uid: TensorFlow.TFGraph.ApplyProximalGradientDescent*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyProximalGradientDescent
  nameWithType: TFGraph.ApplyProximalGradientDescent
  fullName: TFGraph.ApplyProximalGradientDescent
- uid: TensorFlow.TFGraph.ApplyRMSProp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApplyRMSProp
  nameWithType: TFGraph.ApplyRMSProp
  fullName: TFGraph.ApplyRMSProp
- uid: TensorFlow.TFGraph.ApproximateEqual*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ApproximateEqual
  nameWithType: TFGraph.ApproximateEqual
  fullName: TFGraph.ApproximateEqual
- uid: TensorFlow.TFGraph.ArgMax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ArgMax
  nameWithType: TFGraph.ArgMax
  fullName: TFGraph.ArgMax
- uid: TensorFlow.TFGraph.ArgMin*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ArgMin
  nameWithType: TFGraph.ArgMin
  fullName: TFGraph.ArgMin
- uid: TensorFlow.TFGraph.Asin*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Asin
  nameWithType: TFGraph.Asin
  fullName: TFGraph.Asin
- uid: TensorFlow.TFGraph.Asinh*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Asinh
  nameWithType: TFGraph.Asinh
  fullName: TFGraph.Asinh
- uid: TensorFlow.TFGraph.Assert*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Assert
  nameWithType: TFGraph.Assert
  fullName: TFGraph.Assert
- uid: TensorFlow.TFGraph.Assign*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Assign
  nameWithType: TFGraph.Assign
  fullName: TFGraph.Assign
- uid: TensorFlow.TFGraph.AssignAdd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AssignAdd
  nameWithType: TFGraph.AssignAdd
  fullName: TFGraph.AssignAdd
- uid: TensorFlow.TFGraph.AssignAddVariableOp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AssignAddVariableOp
  nameWithType: TFGraph.AssignAddVariableOp
  fullName: TFGraph.AssignAddVariableOp
- uid: TensorFlow.TFGraph.AssignSub*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AssignSub
  nameWithType: TFGraph.AssignSub
  fullName: TFGraph.AssignSub
- uid: TensorFlow.TFGraph.AssignSubVariableOp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AssignSubVariableOp
  nameWithType: TFGraph.AssignSubVariableOp
  fullName: TFGraph.AssignSubVariableOp
- uid: TensorFlow.TFGraph.AssignVariableOp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AssignVariableOp
  nameWithType: TFGraph.AssignVariableOp
  fullName: TFGraph.AssignVariableOp
- uid: TensorFlow.TFGraph.AsString*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AsString
  nameWithType: TFGraph.AsString
  fullName: TFGraph.AsString
- uid: TensorFlow.TFGraph.Atan*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Atan
  nameWithType: TFGraph.Atan
  fullName: TFGraph.Atan
- uid: TensorFlow.TFGraph.Atan2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Atan2
  nameWithType: TFGraph.Atan2
  fullName: TFGraph.Atan2
- uid: TensorFlow.TFGraph.Atanh*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Atanh
  nameWithType: TFGraph.Atanh
  fullName: TFGraph.Atanh
- uid: TensorFlow.TFGraph.AudioSpectrogram*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AudioSpectrogram
  nameWithType: TFGraph.AudioSpectrogram
  fullName: TFGraph.AudioSpectrogram
- uid: TensorFlow.TFGraph.AudioSummary*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AudioSummary
  nameWithType: TFGraph.AudioSummary
  fullName: TFGraph.AudioSummary
- uid: TensorFlow.TFGraph.AudioSummaryV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AudioSummaryV2
  nameWithType: TFGraph.AudioSummaryV2
  fullName: TFGraph.AudioSummaryV2
- uid: TensorFlow.TFGraph.AvgPool*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AvgPool
  nameWithType: TFGraph.AvgPool
  fullName: TFGraph.AvgPool
- uid: TensorFlow.TFGraph.AvgPool3D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AvgPool3D
  nameWithType: TFGraph.AvgPool3D
  fullName: TFGraph.AvgPool3D
- uid: TensorFlow.TFGraph.AvgPool3DGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AvgPool3DGrad
  nameWithType: TFGraph.AvgPool3DGrad
  fullName: TFGraph.AvgPool3DGrad
- uid: TensorFlow.TFGraph.AvgPoolGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: AvgPoolGrad
  nameWithType: TFGraph.AvgPoolGrad
  fullName: TFGraph.AvgPoolGrad
- uid: TensorFlow.TFGraph.Barrier*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Barrier
  nameWithType: TFGraph.Barrier
  fullName: TFGraph.Barrier
- uid: TensorFlow.TFGraph.BarrierClose*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BarrierClose
  nameWithType: TFGraph.BarrierClose
  fullName: TFGraph.BarrierClose
- uid: TensorFlow.TFGraph.BarrierIncompleteSize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BarrierIncompleteSize
  nameWithType: TFGraph.BarrierIncompleteSize
  fullName: TFGraph.BarrierIncompleteSize
- uid: TensorFlow.TFGraph.BarrierInsertMany*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BarrierInsertMany
  nameWithType: TFGraph.BarrierInsertMany
  fullName: TFGraph.BarrierInsertMany
- uid: TensorFlow.TFGraph.BarrierReadySize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BarrierReadySize
  nameWithType: TFGraph.BarrierReadySize
  fullName: TFGraph.BarrierReadySize
- uid: TensorFlow.TFGraph.BarrierTakeMany*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BarrierTakeMany
  nameWithType: TFGraph.BarrierTakeMany
  fullName: TFGraph.BarrierTakeMany
- uid: TensorFlow.TFGraph.Batch*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Batch
  nameWithType: TFGraph.Batch
  fullName: TFGraph.Batch
- uid: TensorFlow.TFGraph.BatchDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchDataset
  nameWithType: TFGraph.BatchDataset
  fullName: TFGraph.BatchDataset
- uid: TensorFlow.TFGraph.BatchDatasetV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchDatasetV2
  nameWithType: TFGraph.BatchDatasetV2
  fullName: TFGraph.BatchDatasetV2
- uid: TensorFlow.TFGraph.BatchMatMul*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchMatMul
  nameWithType: TFGraph.BatchMatMul
  fullName: TFGraph.BatchMatMul
- uid: TensorFlow.TFGraph.BatchNormWithGlobalNormalization*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchNormWithGlobalNormalization
  nameWithType: TFGraph.BatchNormWithGlobalNormalization
  fullName: TFGraph.BatchNormWithGlobalNormalization
- uid: TensorFlow.TFGraph.BatchNormWithGlobalNormalizationGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchNormWithGlobalNormalizationGrad
  nameWithType: TFGraph.BatchNormWithGlobalNormalizationGrad
  fullName: TFGraph.BatchNormWithGlobalNormalizationGrad
- uid: TensorFlow.TFGraph.BatchToSpace*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchToSpace
  nameWithType: TFGraph.BatchToSpace
  fullName: TFGraph.BatchToSpace
- uid: TensorFlow.TFGraph.BatchToSpaceND*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BatchToSpaceND
  nameWithType: TFGraph.BatchToSpaceND
  fullName: TFGraph.BatchToSpaceND
- uid: TensorFlow.TFGraph.BesselI0e*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BesselI0e
  nameWithType: TFGraph.BesselI0e
  fullName: TFGraph.BesselI0e
- uid: TensorFlow.TFGraph.BesselI1e*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BesselI1e
  nameWithType: TFGraph.BesselI1e
  fullName: TFGraph.BesselI1e
- uid: TensorFlow.TFGraph.Betainc*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Betainc
  nameWithType: TFGraph.Betainc
  fullName: TFGraph.Betainc
- uid: TensorFlow.TFGraph.BiasAdd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BiasAdd
  nameWithType: TFGraph.BiasAdd
  fullName: TFGraph.BiasAdd
- uid: TensorFlow.TFGraph.BiasAddGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BiasAddGrad
  nameWithType: TFGraph.BiasAddGrad
  fullName: TFGraph.BiasAddGrad
- uid: TensorFlow.TFGraph.BiasAddV1*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BiasAddV1
  nameWithType: TFGraph.BiasAddV1
  fullName: TFGraph.BiasAddV1
- uid: TensorFlow.TFGraph.BigQueryReader*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BigQueryReader
  nameWithType: TFGraph.BigQueryReader
  fullName: TFGraph.BigQueryReader
- uid: TensorFlow.TFGraph.Bincount*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Bincount
  nameWithType: TFGraph.Bincount
  fullName: TFGraph.Bincount
- uid: TensorFlow.TFGraph.Bitcast*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Bitcast
  nameWithType: TFGraph.Bitcast
  fullName: TFGraph.Bitcast
- uid: TensorFlow.TFGraph.BitwiseAnd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BitwiseAnd
  nameWithType: TFGraph.BitwiseAnd
  fullName: TFGraph.BitwiseAnd
- uid: TensorFlow.TFGraph.BitwiseOr*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BitwiseOr
  nameWithType: TFGraph.BitwiseOr
  fullName: TFGraph.BitwiseOr
- uid: TensorFlow.TFGraph.BitwiseXor*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BitwiseXor
  nameWithType: TFGraph.BitwiseXor
  fullName: TFGraph.BitwiseXor
- uid: TensorFlow.TFGraph.BoostedTreesBucketize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesBucketize
  nameWithType: TFGraph.BoostedTreesBucketize
  fullName: TFGraph.BoostedTreesBucketize
- uid: TensorFlow.TFGraph.BoostedTreesCalculateBestGainsPerFeature*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesCalculateBestGainsPerFeature
  nameWithType: TFGraph.BoostedTreesCalculateBestGainsPerFeature
  fullName: TFGraph.BoostedTreesCalculateBestGainsPerFeature
- uid: TensorFlow.TFGraph.BoostedTreesCenterBias*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesCenterBias
  nameWithType: TFGraph.BoostedTreesCenterBias
  fullName: TFGraph.BoostedTreesCenterBias
- uid: TensorFlow.TFGraph.BoostedTreesCreateEnsemble*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesCreateEnsemble
  nameWithType: TFGraph.BoostedTreesCreateEnsemble
  fullName: TFGraph.BoostedTreesCreateEnsemble
- uid: TensorFlow.TFGraph.BoostedTreesCreateQuantileStreamResource*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesCreateQuantileStreamResource
  nameWithType: TFGraph.BoostedTreesCreateQuantileStreamResource
  fullName: TFGraph.BoostedTreesCreateQuantileStreamResource
- uid: TensorFlow.TFGraph.BoostedTreesDeserializeEnsemble*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesDeserializeEnsemble
  nameWithType: TFGraph.BoostedTreesDeserializeEnsemble
  fullName: TFGraph.BoostedTreesDeserializeEnsemble
- uid: TensorFlow.TFGraph.BoostedTreesEnsembleResourceHandleOp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesEnsembleResourceHandleOp
  nameWithType: TFGraph.BoostedTreesEnsembleResourceHandleOp
  fullName: TFGraph.BoostedTreesEnsembleResourceHandleOp
- uid: TensorFlow.TFGraph.BoostedTreesExampleDebugOutputs*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesExampleDebugOutputs
  nameWithType: TFGraph.BoostedTreesExampleDebugOutputs
  fullName: TFGraph.BoostedTreesExampleDebugOutputs
- uid: TensorFlow.TFGraph.BoostedTreesGetEnsembleStates*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesGetEnsembleStates
  nameWithType: TFGraph.BoostedTreesGetEnsembleStates
  fullName: TFGraph.BoostedTreesGetEnsembleStates
- uid: TensorFlow.TFGraph.BoostedTreesMakeQuantileSummaries*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesMakeQuantileSummaries
  nameWithType: TFGraph.BoostedTreesMakeQuantileSummaries
  fullName: TFGraph.BoostedTreesMakeQuantileSummaries
- uid: TensorFlow.TFGraph.BoostedTreesMakeStatsSummary*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesMakeStatsSummary
  nameWithType: TFGraph.BoostedTreesMakeStatsSummary
  fullName: TFGraph.BoostedTreesMakeStatsSummary
- uid: TensorFlow.TFGraph.BoostedTreesPredict*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesPredict
  nameWithType: TFGraph.BoostedTreesPredict
  fullName: TFGraph.BoostedTreesPredict
- uid: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceAddSummaries*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesQuantileStreamResourceAddSummaries
  nameWithType: TFGraph.BoostedTreesQuantileStreamResourceAddSummaries
  fullName: TFGraph.BoostedTreesQuantileStreamResourceAddSummaries
- uid: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceFlush*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesQuantileStreamResourceFlush
  nameWithType: TFGraph.BoostedTreesQuantileStreamResourceFlush
  fullName: TFGraph.BoostedTreesQuantileStreamResourceFlush
- uid: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceGetBucketBoundaries*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesQuantileStreamResourceGetBucketBoundaries
  nameWithType: TFGraph.BoostedTreesQuantileStreamResourceGetBucketBoundaries
  fullName: TFGraph.BoostedTreesQuantileStreamResourceGetBucketBoundaries
- uid: TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceHandleOp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesQuantileStreamResourceHandleOp
  nameWithType: TFGraph.BoostedTreesQuantileStreamResourceHandleOp
  fullName: TFGraph.BoostedTreesQuantileStreamResourceHandleOp
- uid: TensorFlow.TFGraph.BoostedTreesSerializeEnsemble*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesSerializeEnsemble
  nameWithType: TFGraph.BoostedTreesSerializeEnsemble
  fullName: TFGraph.BoostedTreesSerializeEnsemble
- uid: TensorFlow.TFGraph.BoostedTreesTrainingPredict*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesTrainingPredict
  nameWithType: TFGraph.BoostedTreesTrainingPredict
  fullName: TFGraph.BoostedTreesTrainingPredict
- uid: TensorFlow.TFGraph.BoostedTreesUpdateEnsemble*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BoostedTreesUpdateEnsemble
  nameWithType: TFGraph.BoostedTreesUpdateEnsemble
  fullName: TFGraph.BoostedTreesUpdateEnsemble
- uid: TensorFlow.TFGraph.BroadcastArgs*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BroadcastArgs
  nameWithType: TFGraph.BroadcastArgs
  fullName: TFGraph.BroadcastArgs
- uid: TensorFlow.TFGraph.BroadcastGradientArgs*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BroadcastGradientArgs
  nameWithType: TFGraph.BroadcastGradientArgs
  fullName: TFGraph.BroadcastGradientArgs
- uid: TensorFlow.TFGraph.BroadcastTo*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: BroadcastTo
  nameWithType: TFGraph.BroadcastTo
  fullName: TFGraph.BroadcastTo
- uid: TensorFlow.TFGraph.Bucketize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Bucketize
  nameWithType: TFGraph.Bucketize
  fullName: TFGraph.Bucketize
- uid: TensorFlow.TFGraph.CacheDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CacheDataset
  nameWithType: TFGraph.CacheDataset
  fullName: TFGraph.CacheDataset
- uid: TensorFlow.TFGraph.Cast*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cast
  nameWithType: TFGraph.Cast
  fullName: TFGraph.Cast
- uid: TensorFlow.TFGraph.Ceil*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Ceil
  nameWithType: TFGraph.Ceil
  fullName: TFGraph.Ceil
- uid: TensorFlow.TFGraph.CheckNumerics*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CheckNumerics
  nameWithType: TFGraph.CheckNumerics
  fullName: TFGraph.CheckNumerics
- uid: TensorFlow.TFGraph.Cholesky*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cholesky
  nameWithType: TFGraph.Cholesky
  fullName: TFGraph.Cholesky
- uid: TensorFlow.TFGraph.CholeskyGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CholeskyGrad
  nameWithType: TFGraph.CholeskyGrad
  fullName: TFGraph.CholeskyGrad
- uid: TensorFlow.TFGraph.ClipByAverageNorm*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ClipByAverageNorm
  nameWithType: TFGraph.ClipByAverageNorm
  fullName: TFGraph.ClipByAverageNorm
- uid: TensorFlow.TFGraph.ClipByNorm*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ClipByNorm
  nameWithType: TFGraph.ClipByNorm
  fullName: TFGraph.ClipByNorm
- uid: TensorFlow.TFGraph.ClipByValue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ClipByValue
  nameWithType: TFGraph.ClipByValue
  fullName: TFGraph.ClipByValue
- uid: TensorFlow.TFGraph.CollectiveBcastRecv*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CollectiveBcastRecv
  nameWithType: TFGraph.CollectiveBcastRecv
  fullName: TFGraph.CollectiveBcastRecv
- uid: TensorFlow.TFGraph.CollectiveBcastSend*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CollectiveBcastSend
  nameWithType: TFGraph.CollectiveBcastSend
  fullName: TFGraph.CollectiveBcastSend
- uid: TensorFlow.TFGraph.CollectivePermute*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CollectivePermute
  nameWithType: TFGraph.CollectivePermute
  fullName: TFGraph.CollectivePermute
- uid: TensorFlow.TFGraph.CollectiveReduce*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CollectiveReduce
  nameWithType: TFGraph.CollectiveReduce
  fullName: TFGraph.CollectiveReduce
- uid: TensorFlow.TFGraph.CompareAndBitpack*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CompareAndBitpack
  nameWithType: TFGraph.CompareAndBitpack
  fullName: TFGraph.CompareAndBitpack
- uid: TensorFlow.TFGraph.Complex*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Complex
  nameWithType: TFGraph.Complex
  fullName: TFGraph.Complex
- uid: TensorFlow.TFGraph.ComplexAbs*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ComplexAbs
  nameWithType: TFGraph.ComplexAbs
  fullName: TFGraph.ComplexAbs
- uid: TensorFlow.TFGraph.ComputeAccidentalHits*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ComputeAccidentalHits
  nameWithType: TFGraph.ComputeAccidentalHits
  fullName: TFGraph.ComputeAccidentalHits
- uid: TensorFlow.TFGraph.Concat*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Concat
  nameWithType: TFGraph.Concat
  fullName: TFGraph.Concat
- uid: TensorFlow.TFGraph.ConcatenateDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConcatenateDataset
  nameWithType: TFGraph.ConcatenateDataset
  fullName: TFGraph.ConcatenateDataset
- uid: TensorFlow.TFGraph.ConcatOffset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConcatOffset
  nameWithType: TFGraph.ConcatOffset
  fullName: TFGraph.ConcatOffset
- uid: TensorFlow.TFGraph.ConcatV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConcatV2
  nameWithType: TFGraph.ConcatV2
  fullName: TFGraph.ConcatV2
- uid: TensorFlow.TFGraph.Cond*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cond
  nameWithType: TFGraph.Cond
  fullName: TFGraph.Cond
- uid: TensorFlow.TFGraph.ConditionalAccumulator*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConditionalAccumulator
  nameWithType: TFGraph.ConditionalAccumulator
  fullName: TFGraph.ConditionalAccumulator
- uid: TensorFlow.TFGraph.ConfigureDistributedTPU*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConfigureDistributedTPU
  nameWithType: TFGraph.ConfigureDistributedTPU
  fullName: TFGraph.ConfigureDistributedTPU
- uid: TensorFlow.TFGraph.Conj*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conj
  nameWithType: TFGraph.Conj
  fullName: TFGraph.Conj
- uid: TensorFlow.TFGraph.ConjugateTranspose*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConjugateTranspose
  nameWithType: TFGraph.ConjugateTranspose
  fullName: TFGraph.ConjugateTranspose
- uid: TensorFlow.TFGraph.Const*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Const
  nameWithType: TFGraph.Const
  fullName: TFGraph.Const
- uid: TensorFlow.TFGraph.Constant*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Constant
  nameWithType: TFGraph.Constant
  fullName: TFGraph.Constant
- uid: TensorFlow.TFGraph.ConsumeMutexLock*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ConsumeMutexLock
  nameWithType: TFGraph.ConsumeMutexLock
  fullName: TFGraph.ConsumeMutexLock
- uid: TensorFlow.TFGraph.ControlTrigger*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ControlTrigger
  nameWithType: TFGraph.ControlTrigger
  fullName: TFGraph.ControlTrigger
- uid: TensorFlow.TFGraph.Conv2D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv2D
  nameWithType: TFGraph.Conv2D
  fullName: TFGraph.Conv2D
- uid: TensorFlow.TFGraph.Conv2DBackpropFilter*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv2DBackpropFilter
  nameWithType: TFGraph.Conv2DBackpropFilter
  fullName: TFGraph.Conv2DBackpropFilter
- uid: TensorFlow.TFGraph.Conv2DBackpropInput*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv2DBackpropInput
  nameWithType: TFGraph.Conv2DBackpropInput
  fullName: TFGraph.Conv2DBackpropInput
- uid: TensorFlow.TFGraph.Conv3D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv3D
  nameWithType: TFGraph.Conv3D
  fullName: TFGraph.Conv3D
- uid: TensorFlow.TFGraph.Conv3DBackpropFilter*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv3DBackpropFilter
  nameWithType: TFGraph.Conv3DBackpropFilter
  fullName: TFGraph.Conv3DBackpropFilter
- uid: TensorFlow.TFGraph.Conv3DBackpropFilterV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv3DBackpropFilterV2
  nameWithType: TFGraph.Conv3DBackpropFilterV2
  fullName: TFGraph.Conv3DBackpropFilterV2
- uid: TensorFlow.TFGraph.Conv3DBackpropInput*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv3DBackpropInput
  nameWithType: TFGraph.Conv3DBackpropInput
  fullName: TFGraph.Conv3DBackpropInput
- uid: TensorFlow.TFGraph.Conv3DBackpropInputV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Conv3DBackpropInputV2
  nameWithType: TFGraph.Conv3DBackpropInputV2
  fullName: TFGraph.Conv3DBackpropInputV2
- uid: TensorFlow.TFGraph.Copy*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Copy
  nameWithType: TFGraph.Copy
  fullName: TFGraph.Copy
- uid: TensorFlow.TFGraph.CopyHost*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CopyHost
  nameWithType: TFGraph.CopyHost
  fullName: TFGraph.CopyHost
- uid: TensorFlow.TFGraph.Cos*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cos
  nameWithType: TFGraph.Cos
  fullName: TFGraph.Cos
- uid: TensorFlow.TFGraph.Cosh*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cosh
  nameWithType: TFGraph.Cosh
  fullName: TFGraph.Cosh
- uid: TensorFlow.TFGraph.CountUpTo*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CountUpTo
  nameWithType: TFGraph.CountUpTo
  fullName: TFGraph.CountUpTo
- uid: TensorFlow.TFGraph.CropAndResize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CropAndResize
  nameWithType: TFGraph.CropAndResize
  fullName: TFGraph.CropAndResize
- uid: TensorFlow.TFGraph.CropAndResizeGradBoxes*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CropAndResizeGradBoxes
  nameWithType: TFGraph.CropAndResizeGradBoxes
  fullName: TFGraph.CropAndResizeGradBoxes
- uid: TensorFlow.TFGraph.CropAndResizeGradImage*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CropAndResizeGradImage
  nameWithType: TFGraph.CropAndResizeGradImage
  fullName: TFGraph.CropAndResizeGradImage
- uid: TensorFlow.TFGraph.Cross*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cross
  nameWithType: TFGraph.Cross
  fullName: TFGraph.Cross
- uid: TensorFlow.TFGraph.CrossReplicaSum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CrossReplicaSum
  nameWithType: TFGraph.CrossReplicaSum
  fullName: TFGraph.CrossReplicaSum
- uid: TensorFlow.TFGraph.CTCBeamSearchDecoder*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CTCBeamSearchDecoder
  nameWithType: TFGraph.CTCBeamSearchDecoder
  fullName: TFGraph.CTCBeamSearchDecoder
- uid: TensorFlow.TFGraph.CTCGreedyDecoder*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CTCGreedyDecoder
  nameWithType: TFGraph.CTCGreedyDecoder
  fullName: TFGraph.CTCGreedyDecoder
- uid: TensorFlow.TFGraph.CTCLoss*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CTCLoss
  nameWithType: TFGraph.CTCLoss
  fullName: TFGraph.CTCLoss
- uid: TensorFlow.TFGraph.CudnnRNN*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNN
  nameWithType: TFGraph.CudnnRNN
  fullName: TFGraph.CudnnRNN
- uid: TensorFlow.TFGraph.CudnnRNNBackprop*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNNBackprop
  nameWithType: TFGraph.CudnnRNNBackprop
  fullName: TFGraph.CudnnRNNBackprop
- uid: TensorFlow.TFGraph.CudnnRNNBackpropV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNNBackpropV2
  nameWithType: TFGraph.CudnnRNNBackpropV2
  fullName: TFGraph.CudnnRNNBackpropV2
- uid: TensorFlow.TFGraph.CudnnRNNCanonicalToParams*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNNCanonicalToParams
  nameWithType: TFGraph.CudnnRNNCanonicalToParams
  fullName: TFGraph.CudnnRNNCanonicalToParams
- uid: TensorFlow.TFGraph.CudnnRNNParamsSize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNNParamsSize
  nameWithType: TFGraph.CudnnRNNParamsSize
  fullName: TFGraph.CudnnRNNParamsSize
- uid: TensorFlow.TFGraph.CudnnRNNParamsToCanonical*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNNParamsToCanonical
  nameWithType: TFGraph.CudnnRNNParamsToCanonical
  fullName: TFGraph.CudnnRNNParamsToCanonical
- uid: TensorFlow.TFGraph.CudnnRNNV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CudnnRNNV2
  nameWithType: TFGraph.CudnnRNNV2
  fullName: TFGraph.CudnnRNNV2
- uid: TensorFlow.TFGraph.Cumprod*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cumprod
  nameWithType: TFGraph.Cumprod
  fullName: TFGraph.Cumprod
- uid: TensorFlow.TFGraph.Cumsum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Cumsum
  nameWithType: TFGraph.Cumsum
  fullName: TFGraph.Cumsum
- uid: TensorFlow.TFGraph.CurrentDependencies*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CurrentDependencies
  nameWithType: TFGraph.CurrentDependencies
  fullName: TFGraph.CurrentDependencies
- uid: TensorFlow.TFGraph.CurrentNameScope*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: CurrentNameScope
  nameWithType: TFGraph.CurrentNameScope
  fullName: TFGraph.CurrentNameScope
- uid: TensorFlow.TFGraph.DataFormatDimMap*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DataFormatDimMap
  nameWithType: TFGraph.DataFormatDimMap
  fullName: TFGraph.DataFormatDimMap
- uid: TensorFlow.TFGraph.DataFormatVecPermute*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DataFormatVecPermute
  nameWithType: TFGraph.DataFormatVecPermute
  fullName: TFGraph.DataFormatVecPermute
- uid: TensorFlow.TFGraph.DatasetToGraph*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DatasetToGraph
  nameWithType: TFGraph.DatasetToGraph
  fullName: TFGraph.DatasetToGraph
- uid: TensorFlow.TFGraph.DatasetToSingleElement*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DatasetToSingleElement
  nameWithType: TFGraph.DatasetToSingleElement
  fullName: TFGraph.DatasetToSingleElement
- uid: TensorFlow.TFGraph.DebugGradientIdentity*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DebugGradientIdentity
  nameWithType: TFGraph.DebugGradientIdentity
  fullName: TFGraph.DebugGradientIdentity
- uid: TensorFlow.TFGraph.DebugGradientRefIdentity*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DebugGradientRefIdentity
  nameWithType: TFGraph.DebugGradientRefIdentity
  fullName: TFGraph.DebugGradientRefIdentity
- uid: TensorFlow.TFGraph.DebugIdentity*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DebugIdentity
  nameWithType: TFGraph.DebugIdentity
  fullName: TFGraph.DebugIdentity
- uid: TensorFlow.TFGraph.DebugNanCount*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DebugNanCount
  nameWithType: TFGraph.DebugNanCount
  fullName: TFGraph.DebugNanCount
- uid: TensorFlow.TFGraph.DebugNumericSummary*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DebugNumericSummary
  nameWithType: TFGraph.DebugNumericSummary
  fullName: TFGraph.DebugNumericSummary
- uid: TensorFlow.TFGraph.DecodeAndCropJpeg*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeAndCropJpeg
  nameWithType: TFGraph.DecodeAndCropJpeg
  fullName: TFGraph.DecodeAndCropJpeg
- uid: TensorFlow.TFGraph.DecodeBase64*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeBase64
  nameWithType: TFGraph.DecodeBase64
  fullName: TFGraph.DecodeBase64
- uid: TensorFlow.TFGraph.DecodeBmp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeBmp
  nameWithType: TFGraph.DecodeBmp
  fullName: TFGraph.DecodeBmp
- uid: TensorFlow.TFGraph.DecodeCompressed*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeCompressed
  nameWithType: TFGraph.DecodeCompressed
  fullName: TFGraph.DecodeCompressed
- uid: TensorFlow.TFGraph.DecodeCSV*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeCSV
  nameWithType: TFGraph.DecodeCSV
  fullName: TFGraph.DecodeCSV
- uid: TensorFlow.TFGraph.DecodeGif*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeGif
  nameWithType: TFGraph.DecodeGif
  fullName: TFGraph.DecodeGif
- uid: TensorFlow.TFGraph.DecodeJpeg*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeJpeg
  nameWithType: TFGraph.DecodeJpeg
  fullName: TFGraph.DecodeJpeg
- uid: TensorFlow.TFGraph.DecodeJSONExample*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeJSONExample
  nameWithType: TFGraph.DecodeJSONExample
  fullName: TFGraph.DecodeJSONExample
- uid: TensorFlow.TFGraph.DecodePng*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodePng
  nameWithType: TFGraph.DecodePng
  fullName: TFGraph.DecodePng
- uid: TensorFlow.TFGraph.DecodeProtoV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeProtoV2
  nameWithType: TFGraph.DecodeProtoV2
  fullName: TFGraph.DecodeProtoV2
- uid: TensorFlow.TFGraph.DecodeRaw*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeRaw
  nameWithType: TFGraph.DecodeRaw
  fullName: TFGraph.DecodeRaw
- uid: TensorFlow.TFGraph.DecodeWav*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DecodeWav
  nameWithType: TFGraph.DecodeWav
  fullName: TFGraph.DecodeWav
- uid: TensorFlow.TFGraph.DeepCopy*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DeepCopy
  nameWithType: TFGraph.DeepCopy
  fullName: TFGraph.DeepCopy
- uid: TensorFlow.TFGraph.DeleteSessionTensor*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DeleteSessionTensor
  nameWithType: TFGraph.DeleteSessionTensor
  fullName: TFGraph.DeleteSessionTensor
- uid: TensorFlow.TFGraph.DenseToDenseSetOperation*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DenseToDenseSetOperation
  nameWithType: TFGraph.DenseToDenseSetOperation
  fullName: TFGraph.DenseToDenseSetOperation
- uid: TensorFlow.TFGraph.DenseToSparseSetOperation*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DenseToSparseSetOperation
  nameWithType: TFGraph.DenseToSparseSetOperation
  fullName: TFGraph.DenseToSparseSetOperation
- uid: TensorFlow.TFGraph.DepthToSpace*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DepthToSpace
  nameWithType: TFGraph.DepthToSpace
  fullName: TFGraph.DepthToSpace
- uid: TensorFlow.TFGraph.DepthwiseConv2dNative*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DepthwiseConv2dNative
  nameWithType: TFGraph.DepthwiseConv2dNative
  fullName: TFGraph.DepthwiseConv2dNative
- uid: TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropFilter*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DepthwiseConv2dNativeBackpropFilter
  nameWithType: TFGraph.DepthwiseConv2dNativeBackpropFilter
  fullName: TFGraph.DepthwiseConv2dNativeBackpropFilter
- uid: TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropInput*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DepthwiseConv2dNativeBackpropInput
  nameWithType: TFGraph.DepthwiseConv2dNativeBackpropInput
  fullName: TFGraph.DepthwiseConv2dNativeBackpropInput
- uid: TensorFlow.TFGraph.Dequantize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Dequantize
  nameWithType: TFGraph.Dequantize
  fullName: TFGraph.Dequantize
- uid: TensorFlow.TFGraph.DeserializeIterator*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DeserializeIterator
  nameWithType: TFGraph.DeserializeIterator
  fullName: TFGraph.DeserializeIterator
- uid: TensorFlow.TFGraph.DeserializeManySparse*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DeserializeManySparse
  nameWithType: TFGraph.DeserializeManySparse
  fullName: TFGraph.DeserializeManySparse
- uid: TensorFlow.TFGraph.DeserializeSparse*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DeserializeSparse
  nameWithType: TFGraph.DeserializeSparse
  fullName: TFGraph.DeserializeSparse
- uid: TensorFlow.TFGraph.DestroyResourceOp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DestroyResourceOp
  nameWithType: TFGraph.DestroyResourceOp
  fullName: TFGraph.DestroyResourceOp
- uid: TensorFlow.TFGraph.DestroyTemporaryVariable*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DestroyTemporaryVariable
  nameWithType: TFGraph.DestroyTemporaryVariable
  fullName: TFGraph.DestroyTemporaryVariable
- uid: TensorFlow.TFGraph.Diag*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Diag
  nameWithType: TFGraph.Diag
  fullName: TFGraph.Diag
- uid: TensorFlow.TFGraph.DiagPart*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DiagPart
  nameWithType: TFGraph.DiagPart
  fullName: TFGraph.DiagPart
- uid: TensorFlow.TFGraph.Digamma*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Digamma
  nameWithType: TFGraph.Digamma
  fullName: TFGraph.Digamma
- uid: TensorFlow.TFGraph.Dilation2D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Dilation2D
  nameWithType: TFGraph.Dilation2D
  fullName: TFGraph.Dilation2D
- uid: TensorFlow.TFGraph.Dilation2DBackpropFilter*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Dilation2DBackpropFilter
  nameWithType: TFGraph.Dilation2DBackpropFilter
  fullName: TFGraph.Dilation2DBackpropFilter
- uid: TensorFlow.TFGraph.Dilation2DBackpropInput*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Dilation2DBackpropInput
  nameWithType: TFGraph.Dilation2DBackpropInput
  fullName: TFGraph.Dilation2DBackpropInput
- uid: TensorFlow.TFGraph.Div*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Div
  nameWithType: TFGraph.Div
  fullName: TFGraph.Div
- uid: TensorFlow.TFGraph.DivNoNan*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DivNoNan
  nameWithType: TFGraph.DivNoNan
  fullName: TFGraph.DivNoNan
- uid: TensorFlow.TFGraph.DrawBoundingBoxes*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DrawBoundingBoxes
  nameWithType: TFGraph.DrawBoundingBoxes
  fullName: TFGraph.DrawBoundingBoxes
- uid: TensorFlow.TFGraph.Dropout*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Dropout
  nameWithType: TFGraph.Dropout
  fullName: TFGraph.Dropout
- uid: TensorFlow.TFGraph.DynamicPartition*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DynamicPartition
  nameWithType: TFGraph.DynamicPartition
  fullName: TFGraph.DynamicPartition
- uid: TensorFlow.TFGraph.DynamicStitch*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: DynamicStitch
  nameWithType: TFGraph.DynamicStitch
  fullName: TFGraph.DynamicStitch
- uid: TensorFlow.TFGraph.EditDistance*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EditDistance
  nameWithType: TFGraph.EditDistance
  fullName: TFGraph.EditDistance
- uid: TensorFlow.TFGraph.Elu*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Elu
  nameWithType: TFGraph.Elu
  fullName: TFGraph.Elu
- uid: TensorFlow.TFGraph.EluGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EluGrad
  nameWithType: TFGraph.EluGrad
  fullName: TFGraph.EluGrad
- uid: TensorFlow.TFGraph.Empty*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Empty
  nameWithType: TFGraph.Empty
  fullName: TFGraph.Empty
- uid: TensorFlow.TFGraph.EmptyTensorList*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EmptyTensorList
  nameWithType: TFGraph.EmptyTensorList
  fullName: TFGraph.EmptyTensorList
- uid: TensorFlow.TFGraph.EncodeBase64*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EncodeBase64
  nameWithType: TFGraph.EncodeBase64
  fullName: TFGraph.EncodeBase64
- uid: TensorFlow.TFGraph.EncodeJpeg*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EncodeJpeg
  nameWithType: TFGraph.EncodeJpeg
  fullName: TFGraph.EncodeJpeg
- uid: TensorFlow.TFGraph.EncodePng*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EncodePng
  nameWithType: TFGraph.EncodePng
  fullName: TFGraph.EncodePng
- uid: TensorFlow.TFGraph.EncodeProto*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EncodeProto
  nameWithType: TFGraph.EncodeProto
  fullName: TFGraph.EncodeProto
- uid: TensorFlow.TFGraph.EncodeWav*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EncodeWav
  nameWithType: TFGraph.EncodeWav
  fullName: TFGraph.EncodeWav
- uid: TensorFlow.TFGraph.EnqueueTPUEmbeddingIntegerBatch*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EnqueueTPUEmbeddingIntegerBatch
  nameWithType: TFGraph.EnqueueTPUEmbeddingIntegerBatch
  fullName: TFGraph.EnqueueTPUEmbeddingIntegerBatch
- uid: TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseBatch*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EnqueueTPUEmbeddingSparseBatch
  nameWithType: TFGraph.EnqueueTPUEmbeddingSparseBatch
  fullName: TFGraph.EnqueueTPUEmbeddingSparseBatch
- uid: TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseTensorBatch*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EnqueueTPUEmbeddingSparseTensorBatch
  nameWithType: TFGraph.EnqueueTPUEmbeddingSparseTensorBatch
  fullName: TFGraph.EnqueueTPUEmbeddingSparseTensorBatch
- uid: TensorFlow.TFGraph.EnsureShape*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: EnsureShape
  nameWithType: TFGraph.EnsureShape
  fullName: TFGraph.EnsureShape
- uid: TensorFlow.TFGraph.Enter*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Enter
  nameWithType: TFGraph.Enter
  fullName: TFGraph.Enter
- uid: TensorFlow.TFGraph.Equal*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Equal
  nameWithType: TFGraph.Equal
  fullName: TFGraph.Equal
- uid: TensorFlow.TFGraph.Erf*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Erf
  nameWithType: TFGraph.Erf
  fullName: TFGraph.Erf
- uid: TensorFlow.TFGraph.Erfc*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Erfc
  nameWithType: TFGraph.Erfc
  fullName: TFGraph.Erfc
- uid: TensorFlow.TFGraph.Exit*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Exit
  nameWithType: TFGraph.Exit
  fullName: TFGraph.Exit
- uid: TensorFlow.TFGraph.Exp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Exp
  nameWithType: TFGraph.Exp
  fullName: TFGraph.Exp
- uid: TensorFlow.TFGraph.ExpandDims*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExpandDims
  nameWithType: TFGraph.ExpandDims
  fullName: TFGraph.ExpandDims
- uid: TensorFlow.TFGraph.ExperimentalDirectedInterleaveDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExperimentalDirectedInterleaveDataset
  nameWithType: TFGraph.ExperimentalDirectedInterleaveDataset
  fullName: TFGraph.ExperimentalDirectedInterleaveDataset
- uid: TensorFlow.TFGraph.ExperimentalIgnoreErrorsDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExperimentalIgnoreErrorsDataset
  nameWithType: TFGraph.ExperimentalIgnoreErrorsDataset
  fullName: TFGraph.ExperimentalIgnoreErrorsDataset
- uid: TensorFlow.TFGraph.ExperimentalIteratorGetDevice*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExperimentalIteratorGetDevice
  nameWithType: TFGraph.ExperimentalIteratorGetDevice
  fullName: TFGraph.ExperimentalIteratorGetDevice
- uid: TensorFlow.TFGraph.ExperimentalThreadPoolDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExperimentalThreadPoolDataset
  nameWithType: TFGraph.ExperimentalThreadPoolDataset
  fullName: TFGraph.ExperimentalThreadPoolDataset
- uid: TensorFlow.TFGraph.ExperimentalThreadPoolHandle*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExperimentalThreadPoolHandle
  nameWithType: TFGraph.ExperimentalThreadPoolHandle
  fullName: TFGraph.ExperimentalThreadPoolHandle
- uid: TensorFlow.TFGraph.ExperimentalUniqueDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExperimentalUniqueDataset
  nameWithType: TFGraph.ExperimentalUniqueDataset
  fullName: TFGraph.ExperimentalUniqueDataset
- uid: TensorFlow.TFGraph.Expm1*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Expm1
  nameWithType: TFGraph.Expm1
  fullName: TFGraph.Expm1
- uid: TensorFlow.TFGraph.ExtractGlimpse*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExtractGlimpse
  nameWithType: TFGraph.ExtractGlimpse
  fullName: TFGraph.ExtractGlimpse
- uid: TensorFlow.TFGraph.ExtractImagePatches*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExtractImagePatches
  nameWithType: TFGraph.ExtractImagePatches
  fullName: TFGraph.ExtractImagePatches
- uid: TensorFlow.TFGraph.ExtractJpegShape*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExtractJpegShape
  nameWithType: TFGraph.ExtractJpegShape
  fullName: TFGraph.ExtractJpegShape
- uid: TensorFlow.TFGraph.ExtractVolumePatches*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ExtractVolumePatches
  nameWithType: TFGraph.ExtractVolumePatches
  fullName: TFGraph.ExtractVolumePatches
- uid: TensorFlow.TFGraph.Fact*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Fact
  nameWithType: TFGraph.Fact
  fullName: TFGraph.Fact
- uid: TensorFlow.TFGraph.FakeParam*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeParam
  nameWithType: TFGraph.FakeParam
  fullName: TFGraph.FakeParam
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxArgs*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQuantWithMinMaxArgs
  nameWithType: TFGraph.FakeQuantWithMinMaxArgs
  fullName: TFGraph.FakeQuantWithMinMaxArgs
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxArgsGradient*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQuantWithMinMaxArgsGradient
  nameWithType: TFGraph.FakeQuantWithMinMaxArgsGradient
  fullName: TFGraph.FakeQuantWithMinMaxArgsGradient
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxVars*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQuantWithMinMaxVars
  nameWithType: TFGraph.FakeQuantWithMinMaxVars
  fullName: TFGraph.FakeQuantWithMinMaxVars
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxVarsGradient*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQuantWithMinMaxVarsGradient
  nameWithType: TFGraph.FakeQuantWithMinMaxVarsGradient
  fullName: TFGraph.FakeQuantWithMinMaxVarsGradient
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannel*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQuantWithMinMaxVarsPerChannel
  nameWithType: TFGraph.FakeQuantWithMinMaxVarsPerChannel
  fullName: TFGraph.FakeQuantWithMinMaxVarsPerChannel
- uid: TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQuantWithMinMaxVarsPerChannelGradient
  nameWithType: TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient
  fullName: TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient
- uid: TensorFlow.TFGraph.FakeQueue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FakeQueue
  nameWithType: TFGraph.FakeQueue
  fullName: TFGraph.FakeQueue
- uid: TensorFlow.TFGraph.FFT*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FFT
  nameWithType: TFGraph.FFT
  fullName: TFGraph.FFT
- uid: TensorFlow.TFGraph.FFT2D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FFT2D
  nameWithType: TFGraph.FFT2D
  fullName: TFGraph.FFT2D
- uid: TensorFlow.TFGraph.FFT3D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FFT3D
  nameWithType: TFGraph.FFT3D
  fullName: TFGraph.FFT3D
- uid: TensorFlow.TFGraph.FIFOQueue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FIFOQueue
  nameWithType: TFGraph.FIFOQueue
  fullName: TFGraph.FIFOQueue
- uid: TensorFlow.TFGraph.FIFOQueueV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FIFOQueueV2
  nameWithType: TFGraph.FIFOQueueV2
  fullName: TFGraph.FIFOQueueV2
- uid: TensorFlow.TFGraph.Fill*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Fill
  nameWithType: TFGraph.Fill
  fullName: TFGraph.Fill
- uid: TensorFlow.TFGraph.FilterByLastComponentDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FilterByLastComponentDataset
  nameWithType: TFGraph.FilterByLastComponentDataset
  fullName: TFGraph.FilterByLastComponentDataset
- uid: TensorFlow.TFGraph.FixedLengthRecordDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FixedLengthRecordDataset
  nameWithType: TFGraph.FixedLengthRecordDataset
  fullName: TFGraph.FixedLengthRecordDataset
- uid: TensorFlow.TFGraph.FixedLengthRecordReader*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FixedLengthRecordReader
  nameWithType: TFGraph.FixedLengthRecordReader
  fullName: TFGraph.FixedLengthRecordReader
- uid: TensorFlow.TFGraph.FixedLengthRecordReaderV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FixedLengthRecordReaderV2
  nameWithType: TFGraph.FixedLengthRecordReaderV2
  fullName: TFGraph.FixedLengthRecordReaderV2
- uid: TensorFlow.TFGraph.FixedUnigramCandidateSampler*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FixedUnigramCandidateSampler
  nameWithType: TFGraph.FixedUnigramCandidateSampler
  fullName: TFGraph.FixedUnigramCandidateSampler
- uid: TensorFlow.TFGraph.Floor*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Floor
  nameWithType: TFGraph.Floor
  fullName: TFGraph.Floor
- uid: TensorFlow.TFGraph.FloorDiv*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FloorDiv
  nameWithType: TFGraph.FloorDiv
  fullName: TFGraph.FloorDiv
- uid: TensorFlow.TFGraph.FloorMod*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FloorMod
  nameWithType: TFGraph.FloorMod
  fullName: TFGraph.FloorMod
- uid: TensorFlow.TFGraph.FractionalAvgPool*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FractionalAvgPool
  nameWithType: TFGraph.FractionalAvgPool
  fullName: TFGraph.FractionalAvgPool
- uid: TensorFlow.TFGraph.FractionalAvgPoolGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FractionalAvgPoolGrad
  nameWithType: TFGraph.FractionalAvgPoolGrad
  fullName: TFGraph.FractionalAvgPoolGrad
- uid: TensorFlow.TFGraph.FractionalMaxPool*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FractionalMaxPool
  nameWithType: TFGraph.FractionalMaxPool
  fullName: TFGraph.FractionalMaxPool
- uid: TensorFlow.TFGraph.FractionalMaxPoolGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FractionalMaxPoolGrad
  nameWithType: TFGraph.FractionalMaxPoolGrad
  fullName: TFGraph.FractionalMaxPoolGrad
- uid: TensorFlow.TFGraph.Functions*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Functions
  nameWithType: TFGraph.Functions
  fullName: TFGraph.Functions
- uid: TensorFlow.TFGraph.FusedBatchNorm*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FusedBatchNorm
  nameWithType: TFGraph.FusedBatchNorm
  fullName: TFGraph.FusedBatchNorm
- uid: TensorFlow.TFGraph.FusedBatchNormGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FusedBatchNormGrad
  nameWithType: TFGraph.FusedBatchNormGrad
  fullName: TFGraph.FusedBatchNormGrad
- uid: TensorFlow.TFGraph.FusedBatchNormGradV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FusedBatchNormGradV2
  nameWithType: TFGraph.FusedBatchNormGradV2
  fullName: TFGraph.FusedBatchNormGradV2
- uid: TensorFlow.TFGraph.FusedBatchNormV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FusedBatchNormV2
  nameWithType: TFGraph.FusedBatchNormV2
  fullName: TFGraph.FusedBatchNormV2
- uid: TensorFlow.TFGraph.FusedPadConv2D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FusedPadConv2D
  nameWithType: TFGraph.FusedPadConv2D
  fullName: TFGraph.FusedPadConv2D
- uid: TensorFlow.TFGraph.FusedResizeAndPadConv2D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: FusedResizeAndPadConv2D
  nameWithType: TFGraph.FusedResizeAndPadConv2D
  fullName: TFGraph.FusedResizeAndPadConv2D
- uid: TensorFlow.TFGraph.Gather*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Gather
  nameWithType: TFGraph.Gather
  fullName: TFGraph.Gather
- uid: TensorFlow.TFGraph.GatherNd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GatherNd
  nameWithType: TFGraph.GatherNd
  fullName: TFGraph.GatherNd
- uid: TensorFlow.TFGraph.GatherV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GatherV2
  nameWithType: TFGraph.GatherV2
  fullName: TFGraph.GatherV2
- uid: TensorFlow.TFGraph.GcsConfigureBlockCache*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GcsConfigureBlockCache
  nameWithType: TFGraph.GcsConfigureBlockCache
  fullName: TFGraph.GcsConfigureBlockCache
- uid: TensorFlow.TFGraph.GcsConfigureCredentials*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GcsConfigureCredentials
  nameWithType: TFGraph.GcsConfigureCredentials
  fullName: TFGraph.GcsConfigureCredentials
- uid: TensorFlow.TFGraph.GenerateBigQueryReaderPartitions*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GenerateBigQueryReaderPartitions
  nameWithType: TFGraph.GenerateBigQueryReaderPartitions
  fullName: TFGraph.GenerateBigQueryReaderPartitions
- uid: TensorFlow.TFGraph.GenerateVocabRemapping*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GenerateVocabRemapping
  nameWithType: TFGraph.GenerateVocabRemapping
  fullName: TFGraph.GenerateVocabRemapping
- uid: TensorFlow.TFGraph.GetEnumerator*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetEnumerator
  nameWithType: TFGraph.GetEnumerator
  fullName: TFGraph.GetEnumerator
- uid: TensorFlow.TFGraph.GetGlobalVariablesInitializer*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetGlobalVariablesInitializer
  nameWithType: TFGraph.GetGlobalVariablesInitializer
  fullName: TFGraph.GetGlobalVariablesInitializer
- uid: TensorFlow.TFGraph.GetRandomSeeds*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetRandomSeeds
  nameWithType: TFGraph.GetRandomSeeds
  fullName: TFGraph.GetRandomSeeds
- uid: TensorFlow.TFGraph.GetSessionHandle*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetSessionHandle
  nameWithType: TFGraph.GetSessionHandle
  fullName: TFGraph.GetSessionHandle
- uid: TensorFlow.TFGraph.GetSessionHandleV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetSessionHandleV2
  nameWithType: TFGraph.GetSessionHandleV2
  fullName: TFGraph.GetSessionHandleV2
- uid: TensorFlow.TFGraph.GetSessionTensor*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetSessionTensor
  nameWithType: TFGraph.GetSessionTensor
  fullName: TFGraph.GetSessionTensor
- uid: TensorFlow.TFGraph.GetShape*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetShape
  nameWithType: TFGraph.GetShape
  fullName: TFGraph.GetShape
- uid: TensorFlow.TFGraph.GetTensorNumDims*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetTensorNumDims
  nameWithType: TFGraph.GetTensorNumDims
  fullName: TFGraph.GetTensorNumDims
- uid: TensorFlow.TFGraph.GetTensorShape*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GetTensorShape
  nameWithType: TFGraph.GetTensorShape
  fullName: TFGraph.GetTensorShape
- uid: TensorFlow.TFGraph.GlobalNorm*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GlobalNorm
  nameWithType: TFGraph.GlobalNorm
  fullName: TFGraph.GlobalNorm
- uid: TensorFlow.TFGraph.Greater*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Greater
  nameWithType: TFGraph.Greater
  fullName: TFGraph.Greater
- uid: TensorFlow.TFGraph.GreaterEqual*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GreaterEqual
  nameWithType: TFGraph.GreaterEqual
  fullName: TFGraph.GreaterEqual
- uid: TensorFlow.TFGraph.GuaranteeConst*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: GuaranteeConst
  nameWithType: TFGraph.GuaranteeConst
  fullName: TFGraph.GuaranteeConst
- uid: TensorFlow.TFGraph.HashTable*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: HashTable
  nameWithType: TFGraph.HashTable
  fullName: TFGraph.HashTable
- uid: TensorFlow.TFGraph.HashTableV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: HashTableV2
  nameWithType: TFGraph.HashTableV2
  fullName: TFGraph.HashTableV2
- uid: TensorFlow.TFGraph.HistogramFixedWidth*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: HistogramFixedWidth
  nameWithType: TFGraph.HistogramFixedWidth
  fullName: TFGraph.HistogramFixedWidth
- uid: TensorFlow.TFGraph.HistogramSummary*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: HistogramSummary
  nameWithType: TFGraph.HistogramSummary
  fullName: TFGraph.HistogramSummary
- uid: TensorFlow.TFGraph.HostConst*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: HostConst
  nameWithType: TFGraph.HostConst
  fullName: TFGraph.HostConst
- uid: TensorFlow.TFGraph.HSVToRGB*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: HSVToRGB
  nameWithType: TFGraph.HSVToRGB
  fullName: TFGraph.HSVToRGB
- uid: TensorFlow.TFGraph.Identity*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Identity
  nameWithType: TFGraph.Identity
  fullName: TFGraph.Identity
- uid: TensorFlow.TFGraph.IdentityN*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IdentityN
  nameWithType: TFGraph.IdentityN
  fullName: TFGraph.IdentityN
- uid: TensorFlow.TFGraph.IdentityReader*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IdentityReader
  nameWithType: TFGraph.IdentityReader
  fullName: TFGraph.IdentityReader
- uid: TensorFlow.TFGraph.IdentityReaderV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IdentityReaderV2
  nameWithType: TFGraph.IdentityReaderV2
  fullName: TFGraph.IdentityReaderV2
- uid: TensorFlow.TFGraph.IFFT*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IFFT
  nameWithType: TFGraph.IFFT
  fullName: TFGraph.IFFT
- uid: TensorFlow.TFGraph.IFFT2D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IFFT2D
  nameWithType: TFGraph.IFFT2D
  fullName: TFGraph.IFFT2D
- uid: TensorFlow.TFGraph.IFFT3D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IFFT3D
  nameWithType: TFGraph.IFFT3D
  fullName: TFGraph.IFFT3D
- uid: TensorFlow.TFGraph.Igamma*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Igamma
  nameWithType: TFGraph.Igamma
  fullName: TFGraph.Igamma
- uid: TensorFlow.TFGraph.Igammac*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Igammac
  nameWithType: TFGraph.Igammac
  fullName: TFGraph.Igammac
- uid: TensorFlow.TFGraph.IgammaGradA*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IgammaGradA
  nameWithType: TFGraph.IgammaGradA
  fullName: TFGraph.IgammaGradA
- uid: TensorFlow.TFGraph.Imag*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Imag
  nameWithType: TFGraph.Imag
  fullName: TFGraph.Imag
- uid: TensorFlow.TFGraph.ImageSummary*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ImageSummary
  nameWithType: TFGraph.ImageSummary
  fullName: TFGraph.ImageSummary
- uid: TensorFlow.TFGraph.ImmutableConst*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ImmutableConst
  nameWithType: TFGraph.ImmutableConst
  fullName: TFGraph.ImmutableConst
- uid: TensorFlow.TFGraph.Import*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Import
  nameWithType: TFGraph.Import
  fullName: TFGraph.Import
- uid: TensorFlow.TFGraph.ImportGraphDef*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ImportGraphDef
  nameWithType: TFGraph.ImportGraphDef
  fullName: TFGraph.ImportGraphDef
- uid: TensorFlow.TFGraph.InfeedDequeue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InfeedDequeue
  nameWithType: TFGraph.InfeedDequeue
  fullName: TFGraph.InfeedDequeue
- uid: TensorFlow.TFGraph.InfeedDequeueTuple*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InfeedDequeueTuple
  nameWithType: TFGraph.InfeedDequeueTuple
  fullName: TFGraph.InfeedDequeueTuple
- uid: TensorFlow.TFGraph.InfeedEnqueue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InfeedEnqueue
  nameWithType: TFGraph.InfeedEnqueue
  fullName: TFGraph.InfeedEnqueue
- uid: TensorFlow.TFGraph.InfeedEnqueueTuple*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InfeedEnqueueTuple
  nameWithType: TFGraph.InfeedEnqueueTuple
  fullName: TFGraph.InfeedEnqueueTuple
- uid: TensorFlow.TFGraph.InitializeTable*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InitializeTable
  nameWithType: TFGraph.InitializeTable
  fullName: TFGraph.InitializeTable
- uid: TensorFlow.TFGraph.InitializeTableFromTextFile*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InitializeTableFromTextFile
  nameWithType: TFGraph.InitializeTableFromTextFile
  fullName: TFGraph.InitializeTableFromTextFile
- uid: TensorFlow.TFGraph.InitializeTableFromTextFileV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InitializeTableFromTextFileV2
  nameWithType: TFGraph.InitializeTableFromTextFileV2
  fullName: TFGraph.InitializeTableFromTextFileV2
- uid: TensorFlow.TFGraph.InitializeTableV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InitializeTableV2
  nameWithType: TFGraph.InitializeTableV2
  fullName: TFGraph.InitializeTableV2
- uid: TensorFlow.TFGraph.InplaceAdd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InplaceAdd
  nameWithType: TFGraph.InplaceAdd
  fullName: TFGraph.InplaceAdd
- uid: TensorFlow.TFGraph.InplaceSub*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InplaceSub
  nameWithType: TFGraph.InplaceSub
  fullName: TFGraph.InplaceSub
- uid: TensorFlow.TFGraph.InplaceUpdate*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InplaceUpdate
  nameWithType: TFGraph.InplaceUpdate
  fullName: TFGraph.InplaceUpdate
- uid: TensorFlow.TFGraph.InTopK*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InTopK
  nameWithType: TFGraph.InTopK
  fullName: TFGraph.InTopK
- uid: TensorFlow.TFGraph.InTopKV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InTopKV2
  nameWithType: TFGraph.InTopKV2
  fullName: TFGraph.InTopKV2
- uid: TensorFlow.TFGraph.Inv*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Inv
  nameWithType: TFGraph.Inv
  fullName: TFGraph.Inv
- uid: TensorFlow.TFGraph.Invert*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Invert
  nameWithType: TFGraph.Invert
  fullName: TFGraph.Invert
- uid: TensorFlow.TFGraph.InvertPermutation*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InvertPermutation
  nameWithType: TFGraph.InvertPermutation
  fullName: TFGraph.InvertPermutation
- uid: TensorFlow.TFGraph.InvGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: InvGrad
  nameWithType: TFGraph.InvGrad
  fullName: TFGraph.InvGrad
- uid: TensorFlow.TFGraph.IRFFT*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IRFFT
  nameWithType: TFGraph.IRFFT
  fullName: TFGraph.IRFFT
- uid: TensorFlow.TFGraph.IRFFT2D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IRFFT2D
  nameWithType: TFGraph.IRFFT2D
  fullName: TFGraph.IRFFT2D
- uid: TensorFlow.TFGraph.IRFFT3D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IRFFT3D
  nameWithType: TFGraph.IRFFT3D
  fullName: TFGraph.IRFFT3D
- uid: TensorFlow.TFGraph.IsBoostedTreesEnsembleInitialized*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IsBoostedTreesEnsembleInitialized
  nameWithType: TFGraph.IsBoostedTreesEnsembleInitialized
  fullName: TFGraph.IsBoostedTreesEnsembleInitialized
- uid: TensorFlow.TFGraph.IsBoostedTreesQuantileStreamResourceInitialized*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IsBoostedTreesQuantileStreamResourceInitialized
  nameWithType: TFGraph.IsBoostedTreesQuantileStreamResourceInitialized
  fullName: TFGraph.IsBoostedTreesQuantileStreamResourceInitialized
- uid: TensorFlow.TFGraph.IsFinite*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IsFinite
  nameWithType: TFGraph.IsFinite
  fullName: TFGraph.IsFinite
- uid: TensorFlow.TFGraph.IsInf*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IsInf
  nameWithType: TFGraph.IsInf
  fullName: TFGraph.IsInf
- uid: TensorFlow.TFGraph.IsNan*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IsNan
  nameWithType: TFGraph.IsNan
  fullName: TFGraph.IsNan
- uid: TensorFlow.TFGraph.IsVariableInitialized*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IsVariableInitialized
  nameWithType: TFGraph.IsVariableInitialized
  fullName: TFGraph.IsVariableInitialized
- uid: TensorFlow.TFGraph.Item*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Item
  nameWithType: TFGraph.Item
  fullName: TFGraph.Item
- uid: TensorFlow.TFGraph.Iterator*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Iterator
  nameWithType: TFGraph.Iterator
  fullName: TFGraph.Iterator
- uid: TensorFlow.TFGraph.IteratorFromStringHandle*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IteratorFromStringHandle
  nameWithType: TFGraph.IteratorFromStringHandle
  fullName: TFGraph.IteratorFromStringHandle
- uid: TensorFlow.TFGraph.IteratorGetNext*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IteratorGetNext
  nameWithType: TFGraph.IteratorGetNext
  fullName: TFGraph.IteratorGetNext
- uid: TensorFlow.TFGraph.IteratorGetNextAsOptional*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IteratorGetNextAsOptional
  nameWithType: TFGraph.IteratorGetNextAsOptional
  fullName: TFGraph.IteratorGetNextAsOptional
- uid: TensorFlow.TFGraph.IteratorGetNextSync*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IteratorGetNextSync
  nameWithType: TFGraph.IteratorGetNextSync
  fullName: TFGraph.IteratorGetNextSync
- uid: TensorFlow.TFGraph.IteratorToStringHandle*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: IteratorToStringHandle
  nameWithType: TFGraph.IteratorToStringHandle
  fullName: TFGraph.IteratorToStringHandle
- uid: TensorFlow.TFGraph.L2Loss*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: L2Loss
  nameWithType: TFGraph.L2Loss
  fullName: TFGraph.L2Loss
- uid: TensorFlow.TFGraph.LearnedUnigramCandidateSampler*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LearnedUnigramCandidateSampler
  nameWithType: TFGraph.LearnedUnigramCandidateSampler
  fullName: TFGraph.LearnedUnigramCandidateSampler
- uid: TensorFlow.TFGraph.LeftShift*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LeftShift
  nameWithType: TFGraph.LeftShift
  fullName: TFGraph.LeftShift
- uid: TensorFlow.TFGraph.Less*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Less
  nameWithType: TFGraph.Less
  fullName: TFGraph.Less
- uid: TensorFlow.TFGraph.LessEqual*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LessEqual
  nameWithType: TFGraph.LessEqual
  fullName: TFGraph.LessEqual
- uid: TensorFlow.TFGraph.Lgamma*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Lgamma
  nameWithType: TFGraph.Lgamma
  fullName: TFGraph.Lgamma
- uid: TensorFlow.TFGraph.LinSpace*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LinSpace
  nameWithType: TFGraph.LinSpace
  fullName: TFGraph.LinSpace
- uid: TensorFlow.TFGraph.ListDiff*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ListDiff
  nameWithType: TFGraph.ListDiff
  fullName: TFGraph.ListDiff
- uid: TensorFlow.TFGraph.LMDBReader*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LMDBReader
  nameWithType: TFGraph.LMDBReader
  fullName: TFGraph.LMDBReader
- uid: TensorFlow.TFGraph.LoadAndRemapMatrix*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadAndRemapMatrix
  nameWithType: TFGraph.LoadAndRemapMatrix
  fullName: TFGraph.LoadAndRemapMatrix
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingAdadeltaParameters
  nameWithType: TFGraph.LoadTPUEmbeddingAdadeltaParameters
  fullName: TFGraph.LoadTPUEmbeddingAdadeltaParameters
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingAdadeltaParametersGradAccumDebug
  nameWithType: TFGraph.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug
  fullName: TFGraph.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingAdagradParameters
  nameWithType: TFGraph.LoadTPUEmbeddingAdagradParameters
  fullName: TFGraph.LoadTPUEmbeddingAdagradParameters
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingAdagradParametersGradAccumDebug
  nameWithType: TFGraph.LoadTPUEmbeddingAdagradParametersGradAccumDebug
  fullName: TFGraph.LoadTPUEmbeddingAdagradParametersGradAccumDebug
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingADAMParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingADAMParameters
  nameWithType: TFGraph.LoadTPUEmbeddingADAMParameters
  fullName: TFGraph.LoadTPUEmbeddingADAMParameters
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingADAMParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingADAMParametersGradAccumDebug
  nameWithType: TFGraph.LoadTPUEmbeddingADAMParametersGradAccumDebug
  fullName: TFGraph.LoadTPUEmbeddingADAMParametersGradAccumDebug
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingCenteredRMSPropParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingCenteredRMSPropParameters
  nameWithType: TFGraph.LoadTPUEmbeddingCenteredRMSPropParameters
  fullName: TFGraph.LoadTPUEmbeddingCenteredRMSPropParameters
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingFTRLParameters
  nameWithType: TFGraph.LoadTPUEmbeddingFTRLParameters
  fullName: TFGraph.LoadTPUEmbeddingFTRLParameters
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingFTRLParametersGradAccumDebug
  nameWithType: TFGraph.LoadTPUEmbeddingFTRLParametersGradAccumDebug
  fullName: TFGraph.LoadTPUEmbeddingFTRLParametersGradAccumDebug
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingMDLAdagradLightParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingMDLAdagradLightParameters
  nameWithType: TFGraph.LoadTPUEmbeddingMDLAdagradLightParameters
  fullName: TFGraph.LoadTPUEmbeddingMDLAdagradLightParameters
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingMomentumParameters
  nameWithType: TFGraph.LoadTPUEmbeddingMomentumParameters
  fullName: TFGraph.LoadTPUEmbeddingMomentumParameters
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingMomentumParametersGradAccumDebug
  nameWithType: TFGraph.LoadTPUEmbeddingMomentumParametersGradAccumDebug
  fullName: TFGraph.LoadTPUEmbeddingMomentumParametersGradAccumDebug
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingProximalAdagradParameters
  nameWithType: TFGraph.LoadTPUEmbeddingProximalAdagradParameters
  fullName: TFGraph.LoadTPUEmbeddingProximalAdagradParameters
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug
  nameWithType: TFGraph.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug
  fullName: TFGraph.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingRMSPropParameters
  nameWithType: TFGraph.LoadTPUEmbeddingRMSPropParameters
  fullName: TFGraph.LoadTPUEmbeddingRMSPropParameters
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingRMSPropParametersGradAccumDebug
  nameWithType: TFGraph.LoadTPUEmbeddingRMSPropParametersGradAccumDebug
  fullName: TFGraph.LoadTPUEmbeddingRMSPropParametersGradAccumDebug
- uid: TensorFlow.TFGraph.LoadTPUEmbeddingStochasticGradientDescentParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoadTPUEmbeddingStochasticGradientDescentParameters
  nameWithType: TFGraph.LoadTPUEmbeddingStochasticGradientDescentParameters
  fullName: TFGraph.LoadTPUEmbeddingStochasticGradientDescentParameters
- uid: TensorFlow.TFGraph.Log*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Log
  nameWithType: TFGraph.Log
  fullName: TFGraph.Log
- uid: TensorFlow.TFGraph.Log1p*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Log1p
  nameWithType: TFGraph.Log1p
  fullName: TFGraph.Log1p
- uid: TensorFlow.TFGraph.LogicalAnd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LogicalAnd
  nameWithType: TFGraph.LogicalAnd
  fullName: TFGraph.LogicalAnd
- uid: TensorFlow.TFGraph.LogicalNot*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LogicalNot
  nameWithType: TFGraph.LogicalNot
  fullName: TFGraph.LogicalNot
- uid: TensorFlow.TFGraph.LogicalOr*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LogicalOr
  nameWithType: TFGraph.LogicalOr
  fullName: TFGraph.LogicalOr
- uid: TensorFlow.TFGraph.LogMatrixDeterminant*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LogMatrixDeterminant
  nameWithType: TFGraph.LogMatrixDeterminant
  fullName: TFGraph.LogMatrixDeterminant
- uid: TensorFlow.TFGraph.LogSoftmax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LogSoftmax
  nameWithType: TFGraph.LogSoftmax
  fullName: TFGraph.LogSoftmax
- uid: TensorFlow.TFGraph.LogUniformCandidateSampler*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LogUniformCandidateSampler
  nameWithType: TFGraph.LogUniformCandidateSampler
  fullName: TFGraph.LogUniformCandidateSampler
- uid: TensorFlow.TFGraph.LookupTableExport*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableExport
  nameWithType: TFGraph.LookupTableExport
  fullName: TFGraph.LookupTableExport
- uid: TensorFlow.TFGraph.LookupTableExportV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableExportV2
  nameWithType: TFGraph.LookupTableExportV2
  fullName: TFGraph.LookupTableExportV2
- uid: TensorFlow.TFGraph.LookupTableFind*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableFind
  nameWithType: TFGraph.LookupTableFind
  fullName: TFGraph.LookupTableFind
- uid: TensorFlow.TFGraph.LookupTableFindV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableFindV2
  nameWithType: TFGraph.LookupTableFindV2
  fullName: TFGraph.LookupTableFindV2
- uid: TensorFlow.TFGraph.LookupTableImport*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableImport
  nameWithType: TFGraph.LookupTableImport
  fullName: TFGraph.LookupTableImport
- uid: TensorFlow.TFGraph.LookupTableImportV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableImportV2
  nameWithType: TFGraph.LookupTableImportV2
  fullName: TFGraph.LookupTableImportV2
- uid: TensorFlow.TFGraph.LookupTableInsert*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableInsert
  nameWithType: TFGraph.LookupTableInsert
  fullName: TFGraph.LookupTableInsert
- uid: TensorFlow.TFGraph.LookupTableInsertV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableInsertV2
  nameWithType: TFGraph.LookupTableInsertV2
  fullName: TFGraph.LookupTableInsertV2
- uid: TensorFlow.TFGraph.LookupTableSize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableSize
  nameWithType: TFGraph.LookupTableSize
  fullName: TFGraph.LookupTableSize
- uid: TensorFlow.TFGraph.LookupTableSizeV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LookupTableSizeV2
  nameWithType: TFGraph.LookupTableSizeV2
  fullName: TFGraph.LookupTableSizeV2
- uid: TensorFlow.TFGraph.LoopCond*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LoopCond
  nameWithType: TFGraph.LoopCond
  fullName: TFGraph.LoopCond
- uid: TensorFlow.TFGraph.LowerBound*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LowerBound
  nameWithType: TFGraph.LowerBound
  fullName: TFGraph.LowerBound
- uid: TensorFlow.TFGraph.LRN*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LRN
  nameWithType: TFGraph.LRN
  fullName: TFGraph.LRN
- uid: TensorFlow.TFGraph.LRNGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: LRNGrad
  nameWithType: TFGraph.LRNGrad
  fullName: TFGraph.LRNGrad
- uid: TensorFlow.TFGraph.MakeIterator*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MakeIterator
  nameWithType: TFGraph.MakeIterator
  fullName: TFGraph.MakeIterator
- uid: TensorFlow.TFGraph.MapClear*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapClear
  nameWithType: TFGraph.MapClear
  fullName: TFGraph.MapClear
- uid: TensorFlow.TFGraph.MapIncompleteSize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapIncompleteSize
  nameWithType: TFGraph.MapIncompleteSize
  fullName: TFGraph.MapIncompleteSize
- uid: TensorFlow.TFGraph.MapPeek*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapPeek
  nameWithType: TFGraph.MapPeek
  fullName: TFGraph.MapPeek
- uid: TensorFlow.TFGraph.MapSize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapSize
  nameWithType: TFGraph.MapSize
  fullName: TFGraph.MapSize
- uid: TensorFlow.TFGraph.MapStage*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapStage
  nameWithType: TFGraph.MapStage
  fullName: TFGraph.MapStage
- uid: TensorFlow.TFGraph.MapUnstage*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapUnstage
  nameWithType: TFGraph.MapUnstage
  fullName: TFGraph.MapUnstage
- uid: TensorFlow.TFGraph.MapUnstageNoKey*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MapUnstageNoKey
  nameWithType: TFGraph.MapUnstageNoKey
  fullName: TFGraph.MapUnstageNoKey
- uid: TensorFlow.TFGraph.MatchingFiles*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatchingFiles
  nameWithType: TFGraph.MatchingFiles
  fullName: TFGraph.MatchingFiles
- uid: TensorFlow.TFGraph.MatMul*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatMul
  nameWithType: TFGraph.MatMul
  fullName: TFGraph.MatMul
- uid: TensorFlow.TFGraph.MatrixBandPart*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixBandPart
  nameWithType: TFGraph.MatrixBandPart
  fullName: TFGraph.MatrixBandPart
- uid: TensorFlow.TFGraph.MatrixDeterminant*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixDeterminant
  nameWithType: TFGraph.MatrixDeterminant
  fullName: TFGraph.MatrixDeterminant
- uid: TensorFlow.TFGraph.MatrixDiag*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixDiag
  nameWithType: TFGraph.MatrixDiag
  fullName: TFGraph.MatrixDiag
- uid: TensorFlow.TFGraph.MatrixDiagPart*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixDiagPart
  nameWithType: TFGraph.MatrixDiagPart
  fullName: TFGraph.MatrixDiagPart
- uid: TensorFlow.TFGraph.MatrixExponential*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixExponential
  nameWithType: TFGraph.MatrixExponential
  fullName: TFGraph.MatrixExponential
- uid: TensorFlow.TFGraph.MatrixInverse*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixInverse
  nameWithType: TFGraph.MatrixInverse
  fullName: TFGraph.MatrixInverse
- uid: TensorFlow.TFGraph.MatrixLogarithm*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixLogarithm
  nameWithType: TFGraph.MatrixLogarithm
  fullName: TFGraph.MatrixLogarithm
- uid: TensorFlow.TFGraph.MatrixSetDiag*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixSetDiag
  nameWithType: TFGraph.MatrixSetDiag
  fullName: TFGraph.MatrixSetDiag
- uid: TensorFlow.TFGraph.MatrixSolve*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixSolve
  nameWithType: TFGraph.MatrixSolve
  fullName: TFGraph.MatrixSolve
- uid: TensorFlow.TFGraph.MatrixSolveLs*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixSolveLs
  nameWithType: TFGraph.MatrixSolveLs
  fullName: TFGraph.MatrixSolveLs
- uid: TensorFlow.TFGraph.MatrixTriangularSolve*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MatrixTriangularSolve
  nameWithType: TFGraph.MatrixTriangularSolve
  fullName: TFGraph.MatrixTriangularSolve
- uid: TensorFlow.TFGraph.Max*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Max
  nameWithType: TFGraph.Max
  fullName: TFGraph.Max
- uid: TensorFlow.TFGraph.Maximum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Maximum
  nameWithType: TFGraph.Maximum
  fullName: TFGraph.Maximum
- uid: TensorFlow.TFGraph.MaxPool*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPool
  nameWithType: TFGraph.MaxPool
  fullName: TFGraph.MaxPool
- uid: TensorFlow.TFGraph.MaxPool3D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPool3D
  nameWithType: TFGraph.MaxPool3D
  fullName: TFGraph.MaxPool3D
- uid: TensorFlow.TFGraph.MaxPool3DGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPool3DGrad
  nameWithType: TFGraph.MaxPool3DGrad
  fullName: TFGraph.MaxPool3DGrad
- uid: TensorFlow.TFGraph.MaxPool3DGradGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPool3DGradGrad
  nameWithType: TFGraph.MaxPool3DGradGrad
  fullName: TFGraph.MaxPool3DGradGrad
- uid: TensorFlow.TFGraph.MaxPoolGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolGrad
  nameWithType: TFGraph.MaxPoolGrad
  fullName: TFGraph.MaxPoolGrad
- uid: TensorFlow.TFGraph.MaxPoolGradGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolGradGrad
  nameWithType: TFGraph.MaxPoolGradGrad
  fullName: TFGraph.MaxPoolGradGrad
- uid: TensorFlow.TFGraph.MaxPoolGradGradV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolGradGradV2
  nameWithType: TFGraph.MaxPoolGradGradV2
  fullName: TFGraph.MaxPoolGradGradV2
- uid: TensorFlow.TFGraph.MaxPoolGradGradWithArgmax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolGradGradWithArgmax
  nameWithType: TFGraph.MaxPoolGradGradWithArgmax
  fullName: TFGraph.MaxPoolGradGradWithArgmax
- uid: TensorFlow.TFGraph.MaxPoolGradV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolGradV2
  nameWithType: TFGraph.MaxPoolGradV2
  fullName: TFGraph.MaxPoolGradV2
- uid: TensorFlow.TFGraph.MaxPoolGradWithArgmax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolGradWithArgmax
  nameWithType: TFGraph.MaxPoolGradWithArgmax
  fullName: TFGraph.MaxPoolGradWithArgmax
- uid: TensorFlow.TFGraph.MaxPoolV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolV2
  nameWithType: TFGraph.MaxPoolV2
  fullName: TFGraph.MaxPoolV2
- uid: TensorFlow.TFGraph.MaxPoolWithArgmax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MaxPoolWithArgmax
  nameWithType: TFGraph.MaxPoolWithArgmax
  fullName: TFGraph.MaxPoolWithArgmax
- uid: TensorFlow.TFGraph.Mean*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Mean
  nameWithType: TFGraph.Mean
  fullName: TFGraph.Mean
- uid: TensorFlow.TFGraph.Merge*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Merge
  nameWithType: TFGraph.Merge
  fullName: TFGraph.Merge
- uid: TensorFlow.TFGraph.MergeSummary*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MergeSummary
  nameWithType: TFGraph.MergeSummary
  fullName: TFGraph.MergeSummary
- uid: TensorFlow.TFGraph.MergeV2Checkpoints*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MergeV2Checkpoints
  nameWithType: TFGraph.MergeV2Checkpoints
  fullName: TFGraph.MergeV2Checkpoints
- uid: TensorFlow.TFGraph.Mfcc*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Mfcc
  nameWithType: TFGraph.Mfcc
  fullName: TFGraph.Mfcc
- uid: TensorFlow.TFGraph.Min*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Min
  nameWithType: TFGraph.Min
  fullName: TFGraph.Min
- uid: TensorFlow.TFGraph.Minimum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Minimum
  nameWithType: TFGraph.Minimum
  fullName: TFGraph.Minimum
- uid: TensorFlow.TFGraph.MirrorPad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MirrorPad
  nameWithType: TFGraph.MirrorPad
  fullName: TFGraph.MirrorPad
- uid: TensorFlow.TFGraph.MirrorPadGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MirrorPadGrad
  nameWithType: TFGraph.MirrorPadGrad
  fullName: TFGraph.MirrorPadGrad
- uid: TensorFlow.TFGraph.Mod*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Mod
  nameWithType: TFGraph.Mod
  fullName: TFGraph.Mod
- uid: TensorFlow.TFGraph.ModelDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ModelDataset
  nameWithType: TFGraph.ModelDataset
  fullName: TFGraph.ModelDataset
- uid: TensorFlow.TFGraph.Mul*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Mul
  nameWithType: TFGraph.Mul
  fullName: TFGraph.Mul
- uid: TensorFlow.TFGraph.MultiDeviceIterator*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MultiDeviceIterator
  nameWithType: TFGraph.MultiDeviceIterator
  fullName: TFGraph.MultiDeviceIterator
- uid: TensorFlow.TFGraph.MultiDeviceIteratorFromStringHandle*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MultiDeviceIteratorFromStringHandle
  nameWithType: TFGraph.MultiDeviceIteratorFromStringHandle
  fullName: TFGraph.MultiDeviceIteratorFromStringHandle
- uid: TensorFlow.TFGraph.MultiDeviceIteratorGetNextFromShard*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MultiDeviceIteratorGetNextFromShard
  nameWithType: TFGraph.MultiDeviceIteratorGetNextFromShard
  fullName: TFGraph.MultiDeviceIteratorGetNextFromShard
- uid: TensorFlow.TFGraph.MultiDeviceIteratorInit*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MultiDeviceIteratorInit
  nameWithType: TFGraph.MultiDeviceIteratorInit
  fullName: TFGraph.MultiDeviceIteratorInit
- uid: TensorFlow.TFGraph.MultiDeviceIteratorToStringHandle*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MultiDeviceIteratorToStringHandle
  nameWithType: TFGraph.MultiDeviceIteratorToStringHandle
  fullName: TFGraph.MultiDeviceIteratorToStringHandle
- uid: TensorFlow.TFGraph.Multinomial*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Multinomial
  nameWithType: TFGraph.Multinomial
  fullName: TFGraph.Multinomial
- uid: TensorFlow.TFGraph.MutableDenseHashTable*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutableDenseHashTable
  nameWithType: TFGraph.MutableDenseHashTable
  fullName: TFGraph.MutableDenseHashTable
- uid: TensorFlow.TFGraph.MutableDenseHashTableV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutableDenseHashTableV2
  nameWithType: TFGraph.MutableDenseHashTableV2
  fullName: TFGraph.MutableDenseHashTableV2
- uid: TensorFlow.TFGraph.MutableHashTable*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutableHashTable
  nameWithType: TFGraph.MutableHashTable
  fullName: TFGraph.MutableHashTable
- uid: TensorFlow.TFGraph.MutableHashTableOfTensors*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutableHashTableOfTensors
  nameWithType: TFGraph.MutableHashTableOfTensors
  fullName: TFGraph.MutableHashTableOfTensors
- uid: TensorFlow.TFGraph.MutableHashTableOfTensorsV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutableHashTableOfTensorsV2
  nameWithType: TFGraph.MutableHashTableOfTensorsV2
  fullName: TFGraph.MutableHashTableOfTensorsV2
- uid: TensorFlow.TFGraph.MutableHashTableV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutableHashTableV2
  nameWithType: TFGraph.MutableHashTableV2
  fullName: TFGraph.MutableHashTableV2
- uid: TensorFlow.TFGraph.MutexLock*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutexLock
  nameWithType: TFGraph.MutexLock
  fullName: TFGraph.MutexLock
- uid: TensorFlow.TFGraph.MutexV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: MutexV2
  nameWithType: TFGraph.MutexV2
  fullName: TFGraph.MutexV2
- uid: TensorFlow.TFGraph.Neg*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Neg
  nameWithType: TFGraph.Neg
  fullName: TFGraph.Neg
- uid: TensorFlow.TFGraph.NegTrain*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NegTrain
  nameWithType: TFGraph.NegTrain
  fullName: TFGraph.NegTrain
- uid: TensorFlow.TFGraph.NextIteration*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NextIteration
  nameWithType: TFGraph.NextIteration
  fullName: TFGraph.NextIteration
- uid: TensorFlow.TFGraph.NonMaxSuppression*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NonMaxSuppression
  nameWithType: TFGraph.NonMaxSuppression
  fullName: TFGraph.NonMaxSuppression
- uid: TensorFlow.TFGraph.NonMaxSuppressionV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NonMaxSuppressionV2
  nameWithType: TFGraph.NonMaxSuppressionV2
  fullName: TFGraph.NonMaxSuppressionV2
- uid: TensorFlow.TFGraph.NonMaxSuppressionV3*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NonMaxSuppressionV3
  nameWithType: TFGraph.NonMaxSuppressionV3
  fullName: TFGraph.NonMaxSuppressionV3
- uid: TensorFlow.TFGraph.NonMaxSuppressionV4*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NonMaxSuppressionV4
  nameWithType: TFGraph.NonMaxSuppressionV4
  fullName: TFGraph.NonMaxSuppressionV4
- uid: TensorFlow.TFGraph.NonMaxSuppressionWithOverlaps*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NonMaxSuppressionWithOverlaps
  nameWithType: TFGraph.NonMaxSuppressionWithOverlaps
  fullName: TFGraph.NonMaxSuppressionWithOverlaps
- uid: TensorFlow.TFGraph.NoOp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NoOp
  nameWithType: TFGraph.NoOp
  fullName: TFGraph.NoOp
- uid: TensorFlow.TFGraph.NotEqual*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NotEqual
  nameWithType: TFGraph.NotEqual
  fullName: TFGraph.NotEqual
- uid: TensorFlow.TFGraph.NthElement*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NthElement
  nameWithType: TFGraph.NthElement
  fullName: TFGraph.NthElement
- uid: TensorFlow.TFGraph.NumFunctions*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: NumFunctions
  nameWithType: TFGraph.NumFunctions
  fullName: TFGraph.NumFunctions
- uid: TensorFlow.TFGraph.OneHot*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OneHot
  nameWithType: TFGraph.OneHot
  fullName: TFGraph.OneHot
- uid: TensorFlow.TFGraph.Ones*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Ones
  nameWithType: TFGraph.Ones
  fullName: TFGraph.Ones
- uid: TensorFlow.TFGraph.OnesLike*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OnesLike
  nameWithType: TFGraph.OnesLike
  fullName: TFGraph.OnesLike
- uid: TensorFlow.TFGraph.OptimizeDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OptimizeDataset
  nameWithType: TFGraph.OptimizeDataset
  fullName: TFGraph.OptimizeDataset
- uid: TensorFlow.TFGraph.OptionalFromValue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OptionalFromValue
  nameWithType: TFGraph.OptionalFromValue
  fullName: TFGraph.OptionalFromValue
- uid: TensorFlow.TFGraph.OptionalGetValue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OptionalGetValue
  nameWithType: TFGraph.OptionalGetValue
  fullName: TFGraph.OptionalGetValue
- uid: TensorFlow.TFGraph.OptionalHasValue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OptionalHasValue
  nameWithType: TFGraph.OptionalHasValue
  fullName: TFGraph.OptionalHasValue
- uid: TensorFlow.TFGraph.OptionalNone*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OptionalNone
  nameWithType: TFGraph.OptionalNone
  fullName: TFGraph.OptionalNone
- uid: TensorFlow.TFGraph.OrderedMapClear*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapClear
  nameWithType: TFGraph.OrderedMapClear
  fullName: TFGraph.OrderedMapClear
- uid: TensorFlow.TFGraph.OrderedMapIncompleteSize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapIncompleteSize
  nameWithType: TFGraph.OrderedMapIncompleteSize
  fullName: TFGraph.OrderedMapIncompleteSize
- uid: TensorFlow.TFGraph.OrderedMapPeek*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapPeek
  nameWithType: TFGraph.OrderedMapPeek
  fullName: TFGraph.OrderedMapPeek
- uid: TensorFlow.TFGraph.OrderedMapSize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapSize
  nameWithType: TFGraph.OrderedMapSize
  fullName: TFGraph.OrderedMapSize
- uid: TensorFlow.TFGraph.OrderedMapStage*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapStage
  nameWithType: TFGraph.OrderedMapStage
  fullName: TFGraph.OrderedMapStage
- uid: TensorFlow.TFGraph.OrderedMapUnstage*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapUnstage
  nameWithType: TFGraph.OrderedMapUnstage
  fullName: TFGraph.OrderedMapUnstage
- uid: TensorFlow.TFGraph.OrderedMapUnstageNoKey*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OrderedMapUnstageNoKey
  nameWithType: TFGraph.OrderedMapUnstageNoKey
  fullName: TFGraph.OrderedMapUnstageNoKey
- uid: TensorFlow.TFGraph.OutfeedDequeue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OutfeedDequeue
  nameWithType: TFGraph.OutfeedDequeue
  fullName: TFGraph.OutfeedDequeue
- uid: TensorFlow.TFGraph.OutfeedDequeueTuple*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OutfeedDequeueTuple
  nameWithType: TFGraph.OutfeedDequeueTuple
  fullName: TFGraph.OutfeedDequeueTuple
- uid: TensorFlow.TFGraph.OutfeedEnqueue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OutfeedEnqueue
  nameWithType: TFGraph.OutfeedEnqueue
  fullName: TFGraph.OutfeedEnqueue
- uid: TensorFlow.TFGraph.OutfeedEnqueueTuple*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: OutfeedEnqueueTuple
  nameWithType: TFGraph.OutfeedEnqueueTuple
  fullName: TFGraph.OutfeedEnqueueTuple
- uid: TensorFlow.TFGraph.Pack*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Pack
  nameWithType: TFGraph.Pack
  fullName: TFGraph.Pack
- uid: TensorFlow.TFGraph.Pad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Pad
  nameWithType: TFGraph.Pad
  fullName: TFGraph.Pad
- uid: TensorFlow.TFGraph.PaddedBatchDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PaddedBatchDataset
  nameWithType: TFGraph.PaddedBatchDataset
  fullName: TFGraph.PaddedBatchDataset
- uid: TensorFlow.TFGraph.PaddedBatchDatasetV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PaddedBatchDatasetV2
  nameWithType: TFGraph.PaddedBatchDatasetV2
  fullName: TFGraph.PaddedBatchDatasetV2
- uid: TensorFlow.TFGraph.PaddingFIFOQueue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PaddingFIFOQueue
  nameWithType: TFGraph.PaddingFIFOQueue
  fullName: TFGraph.PaddingFIFOQueue
- uid: TensorFlow.TFGraph.PaddingFIFOQueueV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PaddingFIFOQueueV2
  nameWithType: TFGraph.PaddingFIFOQueueV2
  fullName: TFGraph.PaddingFIFOQueueV2
- uid: TensorFlow.TFGraph.PadV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PadV2
  nameWithType: TFGraph.PadV2
  fullName: TFGraph.PadV2
- uid: TensorFlow.TFGraph.ParallelConcat*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParallelConcat
  nameWithType: TFGraph.ParallelConcat
  fullName: TFGraph.ParallelConcat
- uid: TensorFlow.TFGraph.ParallelDynamicStitch*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParallelDynamicStitch
  nameWithType: TFGraph.ParallelDynamicStitch
  fullName: TFGraph.ParallelDynamicStitch
- uid: TensorFlow.TFGraph.ParameterizedTruncatedNormal*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParameterizedTruncatedNormal
  nameWithType: TFGraph.ParameterizedTruncatedNormal
  fullName: TFGraph.ParameterizedTruncatedNormal
- uid: TensorFlow.TFGraph.ParseExample*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParseExample
  nameWithType: TFGraph.ParseExample
  fullName: TFGraph.ParseExample
- uid: TensorFlow.TFGraph.ParseSequenceExample*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParseSequenceExample
  nameWithType: TFGraph.ParseSequenceExample
  fullName: TFGraph.ParseSequenceExample
- uid: TensorFlow.TFGraph.ParseSingleExample*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParseSingleExample
  nameWithType: TFGraph.ParseSingleExample
  fullName: TFGraph.ParseSingleExample
- uid: TensorFlow.TFGraph.ParseSingleSequenceExample*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParseSingleSequenceExample
  nameWithType: TFGraph.ParseSingleSequenceExample
  fullName: TFGraph.ParseSingleSequenceExample
- uid: TensorFlow.TFGraph.ParseTensor*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ParseTensor
  nameWithType: TFGraph.ParseTensor
  fullName: TFGraph.ParseTensor
- uid: TensorFlow.TFGraph.Placeholder*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Placeholder
  nameWithType: TFGraph.Placeholder
  fullName: TFGraph.Placeholder
- uid: TensorFlow.TFGraph.PlaceholderV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PlaceholderV2
  nameWithType: TFGraph.PlaceholderV2
  fullName: TFGraph.PlaceholderV2
- uid: TensorFlow.TFGraph.PlaceholderWithDefault*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PlaceholderWithDefault
  nameWithType: TFGraph.PlaceholderWithDefault
  fullName: TFGraph.PlaceholderWithDefault
- uid: TensorFlow.TFGraph.Polygamma*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Polygamma
  nameWithType: TFGraph.Polygamma
  fullName: TFGraph.Polygamma
- uid: TensorFlow.TFGraph.PopulationCount*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PopulationCount
  nameWithType: TFGraph.PopulationCount
  fullName: TFGraph.PopulationCount
- uid: TensorFlow.TFGraph.Pow*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Pow
  nameWithType: TFGraph.Pow
  fullName: TFGraph.Pow
- uid: TensorFlow.TFGraph.PrefetchDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PrefetchDataset
  nameWithType: TFGraph.PrefetchDataset
  fullName: TFGraph.PrefetchDataset
- uid: TensorFlow.TFGraph.PreventGradient*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PreventGradient
  nameWithType: TFGraph.PreventGradient
  fullName: TFGraph.PreventGradient
- uid: TensorFlow.TFGraph.Print*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Print
  nameWithType: TFGraph.Print
  fullName: TFGraph.Print
- uid: TensorFlow.TFGraph.PrintV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PrintV2
  nameWithType: TFGraph.PrintV2
  fullName: TFGraph.PrintV2
- uid: TensorFlow.TFGraph.PriorityQueue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PriorityQueue
  nameWithType: TFGraph.PriorityQueue
  fullName: TFGraph.PriorityQueue
- uid: TensorFlow.TFGraph.PriorityQueueV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: PriorityQueueV2
  nameWithType: TFGraph.PriorityQueueV2
  fullName: TFGraph.PriorityQueueV2
- uid: TensorFlow.TFGraph.Prod*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Prod
  nameWithType: TFGraph.Prod
  fullName: TFGraph.Prod
- uid: TensorFlow.TFGraph.Qr*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Qr
  nameWithType: TFGraph.Qr
  fullName: TFGraph.Qr
- uid: TensorFlow.TFGraph.QuantizeAndDequantize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizeAndDequantize
  nameWithType: TFGraph.QuantizeAndDequantize
  fullName: TFGraph.QuantizeAndDequantize
- uid: TensorFlow.TFGraph.QuantizeAndDequantizeV3*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizeAndDequantizeV3
  nameWithType: TFGraph.QuantizeAndDequantizeV3
  fullName: TFGraph.QuantizeAndDequantizeV3
- uid: TensorFlow.TFGraph.QuantizedAdd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedAdd
  nameWithType: TFGraph.QuantizedAdd
  fullName: TFGraph.QuantizedAdd
- uid: TensorFlow.TFGraph.QuantizedAvgPool*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedAvgPool
  nameWithType: TFGraph.QuantizedAvgPool
  fullName: TFGraph.QuantizedAvgPool
- uid: TensorFlow.TFGraph.QuantizedBatchNormWithGlobalNormalization*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedBatchNormWithGlobalNormalization
  nameWithType: TFGraph.QuantizedBatchNormWithGlobalNormalization
  fullName: TFGraph.QuantizedBatchNormWithGlobalNormalization
- uid: TensorFlow.TFGraph.QuantizedBiasAdd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedBiasAdd
  nameWithType: TFGraph.QuantizedBiasAdd
  fullName: TFGraph.QuantizedBiasAdd
- uid: TensorFlow.TFGraph.QuantizedConcat*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedConcat
  nameWithType: TFGraph.QuantizedConcat
  fullName: TFGraph.QuantizedConcat
- uid: TensorFlow.TFGraph.QuantizedConv2D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedConv2D
  nameWithType: TFGraph.QuantizedConv2D
  fullName: TFGraph.QuantizedConv2D
- uid: TensorFlow.TFGraph.QuantizedInstanceNorm*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedInstanceNorm
  nameWithType: TFGraph.QuantizedInstanceNorm
  fullName: TFGraph.QuantizedInstanceNorm
- uid: TensorFlow.TFGraph.QuantizedMatMul*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedMatMul
  nameWithType: TFGraph.QuantizedMatMul
  fullName: TFGraph.QuantizedMatMul
- uid: TensorFlow.TFGraph.QuantizedMaxPool*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedMaxPool
  nameWithType: TFGraph.QuantizedMaxPool
  fullName: TFGraph.QuantizedMaxPool
- uid: TensorFlow.TFGraph.QuantizedMul*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedMul
  nameWithType: TFGraph.QuantizedMul
  fullName: TFGraph.QuantizedMul
- uid: TensorFlow.TFGraph.QuantizeDownAndShrinkRange*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizeDownAndShrinkRange
  nameWithType: TFGraph.QuantizeDownAndShrinkRange
  fullName: TFGraph.QuantizeDownAndShrinkRange
- uid: TensorFlow.TFGraph.QuantizedRelu*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedRelu
  nameWithType: TFGraph.QuantizedRelu
  fullName: TFGraph.QuantizedRelu
- uid: TensorFlow.TFGraph.QuantizedRelu6*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedRelu6
  nameWithType: TFGraph.QuantizedRelu6
  fullName: TFGraph.QuantizedRelu6
- uid: TensorFlow.TFGraph.QuantizedReluX*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedReluX
  nameWithType: TFGraph.QuantizedReluX
  fullName: TFGraph.QuantizedReluX
- uid: TensorFlow.TFGraph.QuantizedReshape*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedReshape
  nameWithType: TFGraph.QuantizedReshape
  fullName: TFGraph.QuantizedReshape
- uid: TensorFlow.TFGraph.QuantizedResizeBilinear*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizedResizeBilinear
  nameWithType: TFGraph.QuantizedResizeBilinear
  fullName: TFGraph.QuantizedResizeBilinear
- uid: TensorFlow.TFGraph.QuantizeV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QuantizeV2
  nameWithType: TFGraph.QuantizeV2
  fullName: TFGraph.QuantizeV2
- uid: TensorFlow.TFGraph.QueueClose*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueClose
  nameWithType: TFGraph.QueueClose
  fullName: TFGraph.QueueClose
- uid: TensorFlow.TFGraph.QueueCloseV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueCloseV2
  nameWithType: TFGraph.QueueCloseV2
  fullName: TFGraph.QueueCloseV2
- uid: TensorFlow.TFGraph.QueueDequeue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueDequeue
  nameWithType: TFGraph.QueueDequeue
  fullName: TFGraph.QueueDequeue
- uid: TensorFlow.TFGraph.QueueDequeueMany*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueDequeueMany
  nameWithType: TFGraph.QueueDequeueMany
  fullName: TFGraph.QueueDequeueMany
- uid: TensorFlow.TFGraph.QueueDequeueManyV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueDequeueManyV2
  nameWithType: TFGraph.QueueDequeueManyV2
  fullName: TFGraph.QueueDequeueManyV2
- uid: TensorFlow.TFGraph.QueueDequeueUpTo*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueDequeueUpTo
  nameWithType: TFGraph.QueueDequeueUpTo
  fullName: TFGraph.QueueDequeueUpTo
- uid: TensorFlow.TFGraph.QueueDequeueUpToV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueDequeueUpToV2
  nameWithType: TFGraph.QueueDequeueUpToV2
  fullName: TFGraph.QueueDequeueUpToV2
- uid: TensorFlow.TFGraph.QueueDequeueV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueDequeueV2
  nameWithType: TFGraph.QueueDequeueV2
  fullName: TFGraph.QueueDequeueV2
- uid: TensorFlow.TFGraph.QueueEnqueue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueEnqueue
  nameWithType: TFGraph.QueueEnqueue
  fullName: TFGraph.QueueEnqueue
- uid: TensorFlow.TFGraph.QueueEnqueueMany*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueEnqueueMany
  nameWithType: TFGraph.QueueEnqueueMany
  fullName: TFGraph.QueueEnqueueMany
- uid: TensorFlow.TFGraph.QueueEnqueueManyV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueEnqueueManyV2
  nameWithType: TFGraph.QueueEnqueueManyV2
  fullName: TFGraph.QueueEnqueueManyV2
- uid: TensorFlow.TFGraph.QueueEnqueueV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueEnqueueV2
  nameWithType: TFGraph.QueueEnqueueV2
  fullName: TFGraph.QueueEnqueueV2
- uid: TensorFlow.TFGraph.QueueIsClosed*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueIsClosed
  nameWithType: TFGraph.QueueIsClosed
  fullName: TFGraph.QueueIsClosed
- uid: TensorFlow.TFGraph.QueueIsClosedV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueIsClosedV2
  nameWithType: TFGraph.QueueIsClosedV2
  fullName: TFGraph.QueueIsClosedV2
- uid: TensorFlow.TFGraph.QueueSize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueSize
  nameWithType: TFGraph.QueueSize
  fullName: TFGraph.QueueSize
- uid: TensorFlow.TFGraph.QueueSizeV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: QueueSizeV2
  nameWithType: TFGraph.QueueSizeV2
  fullName: TFGraph.QueueSizeV2
- uid: TensorFlow.TFGraph.RandomCrop*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomCrop
  nameWithType: TFGraph.RandomCrop
  fullName: TFGraph.RandomCrop
- uid: TensorFlow.TFGraph.RandomGamma*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomGamma
  nameWithType: TFGraph.RandomGamma
  fullName: TFGraph.RandomGamma
- uid: TensorFlow.TFGraph.RandomGammaGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomGammaGrad
  nameWithType: TFGraph.RandomGammaGrad
  fullName: TFGraph.RandomGammaGrad
- uid: TensorFlow.TFGraph.RandomNormal*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomNormal
  nameWithType: TFGraph.RandomNormal
  fullName: TFGraph.RandomNormal
- uid: TensorFlow.TFGraph.RandomPoisson*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomPoisson
  nameWithType: TFGraph.RandomPoisson
  fullName: TFGraph.RandomPoisson
- uid: TensorFlow.TFGraph.RandomPoissonV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomPoissonV2
  nameWithType: TFGraph.RandomPoissonV2
  fullName: TFGraph.RandomPoissonV2
- uid: TensorFlow.TFGraph.RandomShuffle*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomShuffle
  nameWithType: TFGraph.RandomShuffle
  fullName: TFGraph.RandomShuffle
- uid: TensorFlow.TFGraph.RandomShuffleQueue*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomShuffleQueue
  nameWithType: TFGraph.RandomShuffleQueue
  fullName: TFGraph.RandomShuffleQueue
- uid: TensorFlow.TFGraph.RandomShuffleQueueV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomShuffleQueueV2
  nameWithType: TFGraph.RandomShuffleQueueV2
  fullName: TFGraph.RandomShuffleQueueV2
- uid: TensorFlow.TFGraph.RandomStandardNormal*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomStandardNormal
  nameWithType: TFGraph.RandomStandardNormal
  fullName: TFGraph.RandomStandardNormal
- uid: TensorFlow.TFGraph.RandomUniform*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomUniform
  nameWithType: TFGraph.RandomUniform
  fullName: TFGraph.RandomUniform
- uid: TensorFlow.TFGraph.RandomUniformInt*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RandomUniformInt
  nameWithType: TFGraph.RandomUniformInt
  fullName: TFGraph.RandomUniformInt
- uid: TensorFlow.TFGraph.Range*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Range
  nameWithType: TFGraph.Range
  fullName: TFGraph.Range
- uid: TensorFlow.TFGraph.RangeDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RangeDataset
  nameWithType: TFGraph.RangeDataset
  fullName: TFGraph.RangeDataset
- uid: TensorFlow.TFGraph.Rank*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Rank
  nameWithType: TFGraph.Rank
  fullName: TFGraph.Rank
- uid: TensorFlow.TFGraph.ReaderNumRecordsProduced*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderNumRecordsProduced
  nameWithType: TFGraph.ReaderNumRecordsProduced
  fullName: TFGraph.ReaderNumRecordsProduced
- uid: TensorFlow.TFGraph.ReaderNumRecordsProducedV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderNumRecordsProducedV2
  nameWithType: TFGraph.ReaderNumRecordsProducedV2
  fullName: TFGraph.ReaderNumRecordsProducedV2
- uid: TensorFlow.TFGraph.ReaderNumWorkUnitsCompleted*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderNumWorkUnitsCompleted
  nameWithType: TFGraph.ReaderNumWorkUnitsCompleted
  fullName: TFGraph.ReaderNumWorkUnitsCompleted
- uid: TensorFlow.TFGraph.ReaderNumWorkUnitsCompletedV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderNumWorkUnitsCompletedV2
  nameWithType: TFGraph.ReaderNumWorkUnitsCompletedV2
  fullName: TFGraph.ReaderNumWorkUnitsCompletedV2
- uid: TensorFlow.TFGraph.ReaderRead*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderRead
  nameWithType: TFGraph.ReaderRead
  fullName: TFGraph.ReaderRead
- uid: TensorFlow.TFGraph.ReaderReadUpTo*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderReadUpTo
  nameWithType: TFGraph.ReaderReadUpTo
  fullName: TFGraph.ReaderReadUpTo
- uid: TensorFlow.TFGraph.ReaderReadUpToV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderReadUpToV2
  nameWithType: TFGraph.ReaderReadUpToV2
  fullName: TFGraph.ReaderReadUpToV2
- uid: TensorFlow.TFGraph.ReaderReadV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderReadV2
  nameWithType: TFGraph.ReaderReadV2
  fullName: TFGraph.ReaderReadV2
- uid: TensorFlow.TFGraph.ReaderReset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderReset
  nameWithType: TFGraph.ReaderReset
  fullName: TFGraph.ReaderReset
- uid: TensorFlow.TFGraph.ReaderResetV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderResetV2
  nameWithType: TFGraph.ReaderResetV2
  fullName: TFGraph.ReaderResetV2
- uid: TensorFlow.TFGraph.ReaderRestoreState*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderRestoreState
  nameWithType: TFGraph.ReaderRestoreState
  fullName: TFGraph.ReaderRestoreState
- uid: TensorFlow.TFGraph.ReaderRestoreStateV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderRestoreStateV2
  nameWithType: TFGraph.ReaderRestoreStateV2
  fullName: TFGraph.ReaderRestoreStateV2
- uid: TensorFlow.TFGraph.ReaderSerializeState*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderSerializeState
  nameWithType: TFGraph.ReaderSerializeState
  fullName: TFGraph.ReaderSerializeState
- uid: TensorFlow.TFGraph.ReaderSerializeStateV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReaderSerializeStateV2
  nameWithType: TFGraph.ReaderSerializeStateV2
  fullName: TFGraph.ReaderSerializeStateV2
- uid: TensorFlow.TFGraph.ReadFile*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReadFile
  nameWithType: TFGraph.ReadFile
  fullName: TFGraph.ReadFile
- uid: TensorFlow.TFGraph.ReadVariableOp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReadVariableOp
  nameWithType: TFGraph.ReadVariableOp
  fullName: TFGraph.ReadVariableOp
- uid: TensorFlow.TFGraph.Real*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Real
  nameWithType: TFGraph.Real
  fullName: TFGraph.Real
- uid: TensorFlow.TFGraph.RealDiv*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RealDiv
  nameWithType: TFGraph.RealDiv
  fullName: TFGraph.RealDiv
- uid: TensorFlow.TFGraph.Reciprocal*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Reciprocal
  nameWithType: TFGraph.Reciprocal
  fullName: TFGraph.Reciprocal
- uid: TensorFlow.TFGraph.ReciprocalGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReciprocalGrad
  nameWithType: TFGraph.ReciprocalGrad
  fullName: TFGraph.ReciprocalGrad
- uid: TensorFlow.TFGraph.RecordInput*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RecordInput
  nameWithType: TFGraph.RecordInput
  fullName: TFGraph.RecordInput
- uid: TensorFlow.TFGraph.RecvTPUEmbeddingActivations*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RecvTPUEmbeddingActivations
  nameWithType: TFGraph.RecvTPUEmbeddingActivations
  fullName: TFGraph.RecvTPUEmbeddingActivations
- uid: TensorFlow.TFGraph.ReduceJoin*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReduceJoin
  nameWithType: TFGraph.ReduceJoin
  fullName: TFGraph.ReduceJoin
- uid: TensorFlow.TFGraph.ReduceMean*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReduceMean
  nameWithType: TFGraph.ReduceMean
  fullName: TFGraph.ReduceMean
- uid: TensorFlow.TFGraph.ReduceProd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReduceProd
  nameWithType: TFGraph.ReduceProd
  fullName: TFGraph.ReduceProd
- uid: TensorFlow.TFGraph.ReduceSum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReduceSum
  nameWithType: TFGraph.ReduceSum
  fullName: TFGraph.ReduceSum
- uid: TensorFlow.TFGraph.RefEnter*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefEnter
  nameWithType: TFGraph.RefEnter
  fullName: TFGraph.RefEnter
- uid: TensorFlow.TFGraph.RefExit*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefExit
  nameWithType: TFGraph.RefExit
  fullName: TFGraph.RefExit
- uid: TensorFlow.TFGraph.RefIdentity*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefIdentity
  nameWithType: TFGraph.RefIdentity
  fullName: TFGraph.RefIdentity
- uid: TensorFlow.TFGraph.RefMerge*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefMerge
  nameWithType: TFGraph.RefMerge
  fullName: TFGraph.RefMerge
- uid: TensorFlow.TFGraph.RefNextIteration*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefNextIteration
  nameWithType: TFGraph.RefNextIteration
  fullName: TFGraph.RefNextIteration
- uid: TensorFlow.TFGraph.RefSelect*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefSelect
  nameWithType: TFGraph.RefSelect
  fullName: TFGraph.RefSelect
- uid: TensorFlow.TFGraph.RefSwitch*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RefSwitch
  nameWithType: TFGraph.RefSwitch
  fullName: TFGraph.RefSwitch
- uid: TensorFlow.TFGraph.RegexFullMatch*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RegexFullMatch
  nameWithType: TFGraph.RegexFullMatch
  fullName: TFGraph.RegexFullMatch
- uid: TensorFlow.TFGraph.RegexReplace*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RegexReplace
  nameWithType: TFGraph.RegexReplace
  fullName: TFGraph.RegexReplace
- uid: TensorFlow.TFGraph.Relu*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Relu
  nameWithType: TFGraph.Relu
  fullName: TFGraph.Relu
- uid: TensorFlow.TFGraph.Relu6*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Relu6
  nameWithType: TFGraph.Relu6
  fullName: TFGraph.Relu6
- uid: TensorFlow.TFGraph.Relu6Grad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Relu6Grad
  nameWithType: TFGraph.Relu6Grad
  fullName: TFGraph.Relu6Grad
- uid: TensorFlow.TFGraph.ReluGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReluGrad
  nameWithType: TFGraph.ReluGrad
  fullName: TFGraph.ReluGrad
- uid: TensorFlow.TFGraph.RemoteFusedGraphExecute*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RemoteFusedGraphExecute
  nameWithType: TFGraph.RemoteFusedGraphExecute
  fullName: TFGraph.RemoteFusedGraphExecute
- uid: TensorFlow.TFGraph.RepeatDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RepeatDataset
  nameWithType: TFGraph.RepeatDataset
  fullName: TFGraph.RepeatDataset
- uid: TensorFlow.TFGraph.RequantizationRange*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RequantizationRange
  nameWithType: TFGraph.RequantizationRange
  fullName: TFGraph.RequantizationRange
- uid: TensorFlow.TFGraph.Requantize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Requantize
  nameWithType: TFGraph.Requantize
  fullName: TFGraph.Requantize
- uid: TensorFlow.TFGraph.Reshape*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Reshape
  nameWithType: TFGraph.Reshape
  fullName: TFGraph.Reshape
- uid: TensorFlow.TFGraph.ResizeArea*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeArea
  nameWithType: TFGraph.ResizeArea
  fullName: TFGraph.ResizeArea
- uid: TensorFlow.TFGraph.ResizeBicubic*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeBicubic
  nameWithType: TFGraph.ResizeBicubic
  fullName: TFGraph.ResizeBicubic
- uid: TensorFlow.TFGraph.ResizeBicubicGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeBicubicGrad
  nameWithType: TFGraph.ResizeBicubicGrad
  fullName: TFGraph.ResizeBicubicGrad
- uid: TensorFlow.TFGraph.ResizeBilinear*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeBilinear
  nameWithType: TFGraph.ResizeBilinear
  fullName: TFGraph.ResizeBilinear
- uid: TensorFlow.TFGraph.ResizeBilinearGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeBilinearGrad
  nameWithType: TFGraph.ResizeBilinearGrad
  fullName: TFGraph.ResizeBilinearGrad
- uid: TensorFlow.TFGraph.ResizeNearestNeighbor*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeNearestNeighbor
  nameWithType: TFGraph.ResizeNearestNeighbor
  fullName: TFGraph.ResizeNearestNeighbor
- uid: TensorFlow.TFGraph.ResizeNearestNeighborGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResizeNearestNeighborGrad
  nameWithType: TFGraph.ResizeNearestNeighborGrad
  fullName: TFGraph.ResizeNearestNeighborGrad
- uid: TensorFlow.TFGraph.ResourceApplyAdadelta*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyAdadelta
  nameWithType: TFGraph.ResourceApplyAdadelta
  fullName: TFGraph.ResourceApplyAdadelta
- uid: TensorFlow.TFGraph.ResourceApplyAdagrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyAdagrad
  nameWithType: TFGraph.ResourceApplyAdagrad
  fullName: TFGraph.ResourceApplyAdagrad
- uid: TensorFlow.TFGraph.ResourceApplyAdagradDA*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyAdagradDA
  nameWithType: TFGraph.ResourceApplyAdagradDA
  fullName: TFGraph.ResourceApplyAdagradDA
- uid: TensorFlow.TFGraph.ResourceApplyAdam*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyAdam
  nameWithType: TFGraph.ResourceApplyAdam
  fullName: TFGraph.ResourceApplyAdam
- uid: TensorFlow.TFGraph.ResourceApplyAdaMax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyAdaMax
  nameWithType: TFGraph.ResourceApplyAdaMax
  fullName: TFGraph.ResourceApplyAdaMax
- uid: TensorFlow.TFGraph.ResourceApplyAddSign*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyAddSign
  nameWithType: TFGraph.ResourceApplyAddSign
  fullName: TFGraph.ResourceApplyAddSign
- uid: TensorFlow.TFGraph.ResourceApplyCenteredRMSProp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyCenteredRMSProp
  nameWithType: TFGraph.ResourceApplyCenteredRMSProp
  fullName: TFGraph.ResourceApplyCenteredRMSProp
- uid: TensorFlow.TFGraph.ResourceApplyFtrl*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyFtrl
  nameWithType: TFGraph.ResourceApplyFtrl
  fullName: TFGraph.ResourceApplyFtrl
- uid: TensorFlow.TFGraph.ResourceApplyFtrlV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyFtrlV2
  nameWithType: TFGraph.ResourceApplyFtrlV2
  fullName: TFGraph.ResourceApplyFtrlV2
- uid: TensorFlow.TFGraph.ResourceApplyGradientDescent*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyGradientDescent
  nameWithType: TFGraph.ResourceApplyGradientDescent
  fullName: TFGraph.ResourceApplyGradientDescent
- uid: TensorFlow.TFGraph.ResourceApplyMomentum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyMomentum
  nameWithType: TFGraph.ResourceApplyMomentum
  fullName: TFGraph.ResourceApplyMomentum
- uid: TensorFlow.TFGraph.ResourceApplyPowerSign*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyPowerSign
  nameWithType: TFGraph.ResourceApplyPowerSign
  fullName: TFGraph.ResourceApplyPowerSign
- uid: TensorFlow.TFGraph.ResourceApplyProximalAdagrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyProximalAdagrad
  nameWithType: TFGraph.ResourceApplyProximalAdagrad
  fullName: TFGraph.ResourceApplyProximalAdagrad
- uid: TensorFlow.TFGraph.ResourceApplyProximalGradientDescent*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyProximalGradientDescent
  nameWithType: TFGraph.ResourceApplyProximalGradientDescent
  fullName: TFGraph.ResourceApplyProximalGradientDescent
- uid: TensorFlow.TFGraph.ResourceApplyRMSProp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceApplyRMSProp
  nameWithType: TFGraph.ResourceApplyRMSProp
  fullName: TFGraph.ResourceApplyRMSProp
- uid: TensorFlow.TFGraph.ResourceCountUpTo*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceCountUpTo
  nameWithType: TFGraph.ResourceCountUpTo
  fullName: TFGraph.ResourceCountUpTo
- uid: TensorFlow.TFGraph.ResourceGather*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceGather
  nameWithType: TFGraph.ResourceGather
  fullName: TFGraph.ResourceGather
- uid: TensorFlow.TFGraph.ResourceScatterAdd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterAdd
  nameWithType: TFGraph.ResourceScatterAdd
  fullName: TFGraph.ResourceScatterAdd
- uid: TensorFlow.TFGraph.ResourceScatterDiv*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterDiv
  nameWithType: TFGraph.ResourceScatterDiv
  fullName: TFGraph.ResourceScatterDiv
- uid: TensorFlow.TFGraph.ResourceScatterMax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterMax
  nameWithType: TFGraph.ResourceScatterMax
  fullName: TFGraph.ResourceScatterMax
- uid: TensorFlow.TFGraph.ResourceScatterMin*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterMin
  nameWithType: TFGraph.ResourceScatterMin
  fullName: TFGraph.ResourceScatterMin
- uid: TensorFlow.TFGraph.ResourceScatterMul*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterMul
  nameWithType: TFGraph.ResourceScatterMul
  fullName: TFGraph.ResourceScatterMul
- uid: TensorFlow.TFGraph.ResourceScatterNdAdd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterNdAdd
  nameWithType: TFGraph.ResourceScatterNdAdd
  fullName: TFGraph.ResourceScatterNdAdd
- uid: TensorFlow.TFGraph.ResourceScatterNdUpdate*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterNdUpdate
  nameWithType: TFGraph.ResourceScatterNdUpdate
  fullName: TFGraph.ResourceScatterNdUpdate
- uid: TensorFlow.TFGraph.ResourceScatterSub*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterSub
  nameWithType: TFGraph.ResourceScatterSub
  fullName: TFGraph.ResourceScatterSub
- uid: TensorFlow.TFGraph.ResourceScatterUpdate*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceScatterUpdate
  nameWithType: TFGraph.ResourceScatterUpdate
  fullName: TFGraph.ResourceScatterUpdate
- uid: TensorFlow.TFGraph.ResourceSparseApplyAdadelta*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyAdadelta
  nameWithType: TFGraph.ResourceSparseApplyAdadelta
  fullName: TFGraph.ResourceSparseApplyAdadelta
- uid: TensorFlow.TFGraph.ResourceSparseApplyAdagrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyAdagrad
  nameWithType: TFGraph.ResourceSparseApplyAdagrad
  fullName: TFGraph.ResourceSparseApplyAdagrad
- uid: TensorFlow.TFGraph.ResourceSparseApplyAdagradDA*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyAdagradDA
  nameWithType: TFGraph.ResourceSparseApplyAdagradDA
  fullName: TFGraph.ResourceSparseApplyAdagradDA
- uid: TensorFlow.TFGraph.ResourceSparseApplyCenteredRMSProp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyCenteredRMSProp
  nameWithType: TFGraph.ResourceSparseApplyCenteredRMSProp
  fullName: TFGraph.ResourceSparseApplyCenteredRMSProp
- uid: TensorFlow.TFGraph.ResourceSparseApplyFtrl*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyFtrl
  nameWithType: TFGraph.ResourceSparseApplyFtrl
  fullName: TFGraph.ResourceSparseApplyFtrl
- uid: TensorFlow.TFGraph.ResourceSparseApplyFtrlV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyFtrlV2
  nameWithType: TFGraph.ResourceSparseApplyFtrlV2
  fullName: TFGraph.ResourceSparseApplyFtrlV2
- uid: TensorFlow.TFGraph.ResourceSparseApplyMomentum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyMomentum
  nameWithType: TFGraph.ResourceSparseApplyMomentum
  fullName: TFGraph.ResourceSparseApplyMomentum
- uid: TensorFlow.TFGraph.ResourceSparseApplyProximalAdagrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyProximalAdagrad
  nameWithType: TFGraph.ResourceSparseApplyProximalAdagrad
  fullName: TFGraph.ResourceSparseApplyProximalAdagrad
- uid: TensorFlow.TFGraph.ResourceSparseApplyProximalGradientDescent*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyProximalGradientDescent
  nameWithType: TFGraph.ResourceSparseApplyProximalGradientDescent
  fullName: TFGraph.ResourceSparseApplyProximalGradientDescent
- uid: TensorFlow.TFGraph.ResourceSparseApplyRMSProp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceSparseApplyRMSProp
  nameWithType: TFGraph.ResourceSparseApplyRMSProp
  fullName: TFGraph.ResourceSparseApplyRMSProp
- uid: TensorFlow.TFGraph.ResourceStridedSliceAssign*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ResourceStridedSliceAssign
  nameWithType: TFGraph.ResourceStridedSliceAssign
  fullName: TFGraph.ResourceStridedSliceAssign
- uid: TensorFlow.TFGraph.Restore*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Restore
  nameWithType: TFGraph.Restore
  fullName: TFGraph.Restore
- uid: TensorFlow.TFGraph.RestoreSlice*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RestoreSlice
  nameWithType: TFGraph.RestoreSlice
  fullName: TFGraph.RestoreSlice
- uid: TensorFlow.TFGraph.RestoreV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RestoreV2
  nameWithType: TFGraph.RestoreV2
  fullName: TFGraph.RestoreV2
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingAdadeltaParameters
  nameWithType: TFGraph.RetrieveTPUEmbeddingAdadeltaParameters
  fullName: TFGraph.RetrieveTPUEmbeddingAdadeltaParameters
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug
  nameWithType: TFGraph.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug
  fullName: TFGraph.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingAdagradParameters
  nameWithType: TFGraph.RetrieveTPUEmbeddingAdagradParameters
  fullName: TFGraph.RetrieveTPUEmbeddingAdagradParameters
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingAdagradParametersGradAccumDebug
  nameWithType: TFGraph.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug
  fullName: TFGraph.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingADAMParameters
  nameWithType: TFGraph.RetrieveTPUEmbeddingADAMParameters
  fullName: TFGraph.RetrieveTPUEmbeddingADAMParameters
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingADAMParametersGradAccumDebug
  nameWithType: TFGraph.RetrieveTPUEmbeddingADAMParametersGradAccumDebug
  fullName: TFGraph.RetrieveTPUEmbeddingADAMParametersGradAccumDebug
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingCenteredRMSPropParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingCenteredRMSPropParameters
  nameWithType: TFGraph.RetrieveTPUEmbeddingCenteredRMSPropParameters
  fullName: TFGraph.RetrieveTPUEmbeddingCenteredRMSPropParameters
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingFTRLParameters
  nameWithType: TFGraph.RetrieveTPUEmbeddingFTRLParameters
  fullName: TFGraph.RetrieveTPUEmbeddingFTRLParameters
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingFTRLParametersGradAccumDebug
  nameWithType: TFGraph.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug
  fullName: TFGraph.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingMDLAdagradLightParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingMDLAdagradLightParameters
  nameWithType: TFGraph.RetrieveTPUEmbeddingMDLAdagradLightParameters
  fullName: TFGraph.RetrieveTPUEmbeddingMDLAdagradLightParameters
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingMomentumParameters
  nameWithType: TFGraph.RetrieveTPUEmbeddingMomentumParameters
  fullName: TFGraph.RetrieveTPUEmbeddingMomentumParameters
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingMomentumParametersGradAccumDebug
  nameWithType: TFGraph.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug
  fullName: TFGraph.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingProximalAdagradParameters
  nameWithType: TFGraph.RetrieveTPUEmbeddingProximalAdagradParameters
  fullName: TFGraph.RetrieveTPUEmbeddingProximalAdagradParameters
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug
  nameWithType: TFGraph.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug
  fullName: TFGraph.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingRMSPropParameters
  nameWithType: TFGraph.RetrieveTPUEmbeddingRMSPropParameters
  fullName: TFGraph.RetrieveTPUEmbeddingRMSPropParameters
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug
  nameWithType: TFGraph.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug
  fullName: TFGraph.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug
- uid: TensorFlow.TFGraph.RetrieveTPUEmbeddingStochasticGradientDescentParameters*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RetrieveTPUEmbeddingStochasticGradientDescentParameters
  nameWithType: TFGraph.RetrieveTPUEmbeddingStochasticGradientDescentParameters
  fullName: TFGraph.RetrieveTPUEmbeddingStochasticGradientDescentParameters
- uid: TensorFlow.TFGraph.Reverse*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Reverse
  nameWithType: TFGraph.Reverse
  fullName: TFGraph.Reverse
- uid: TensorFlow.TFGraph.ReverseSequence*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReverseSequence
  nameWithType: TFGraph.ReverseSequence
  fullName: TFGraph.ReverseSequence
- uid: TensorFlow.TFGraph.ReverseV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ReverseV2
  nameWithType: TFGraph.ReverseV2
  fullName: TFGraph.ReverseV2
- uid: TensorFlow.TFGraph.RFFT*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RFFT
  nameWithType: TFGraph.RFFT
  fullName: TFGraph.RFFT
- uid: TensorFlow.TFGraph.RFFT2D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RFFT2D
  nameWithType: TFGraph.RFFT2D
  fullName: TFGraph.RFFT2D
- uid: TensorFlow.TFGraph.RFFT3D*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RFFT3D
  nameWithType: TFGraph.RFFT3D
  fullName: TFGraph.RFFT3D
- uid: TensorFlow.TFGraph.RGBToHSV*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RGBToHSV
  nameWithType: TFGraph.RGBToHSV
  fullName: TFGraph.RGBToHSV
- uid: TensorFlow.TFGraph.RightShift*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RightShift
  nameWithType: TFGraph.RightShift
  fullName: TFGraph.RightShift
- uid: TensorFlow.TFGraph.Rint*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Rint
  nameWithType: TFGraph.Rint
  fullName: TFGraph.Rint
- uid: TensorFlow.TFGraph.Roll*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Roll
  nameWithType: TFGraph.Roll
  fullName: TFGraph.Roll
- uid: TensorFlow.TFGraph.Round*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Round
  nameWithType: TFGraph.Round
  fullName: TFGraph.Round
- uid: TensorFlow.TFGraph.Rpc*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Rpc
  nameWithType: TFGraph.Rpc
  fullName: TFGraph.Rpc
- uid: TensorFlow.TFGraph.Rsqrt*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Rsqrt
  nameWithType: TFGraph.Rsqrt
  fullName: TFGraph.Rsqrt
- uid: TensorFlow.TFGraph.RsqrtGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: RsqrtGrad
  nameWithType: TFGraph.RsqrtGrad
  fullName: TFGraph.RsqrtGrad
- uid: TensorFlow.TFGraph.SampleDistortedBoundingBox*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SampleDistortedBoundingBox
  nameWithType: TFGraph.SampleDistortedBoundingBox
  fullName: TFGraph.SampleDistortedBoundingBox
- uid: TensorFlow.TFGraph.SampleDistortedBoundingBoxV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SampleDistortedBoundingBoxV2
  nameWithType: TFGraph.SampleDistortedBoundingBoxV2
  fullName: TFGraph.SampleDistortedBoundingBoxV2
- uid: TensorFlow.TFGraph.Save*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Save
  nameWithType: TFGraph.Save
  fullName: TFGraph.Save
- uid: TensorFlow.TFGraph.SaveSlices*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SaveSlices
  nameWithType: TFGraph.SaveSlices
  fullName: TFGraph.SaveSlices
- uid: TensorFlow.TFGraph.SaveV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SaveV2
  nameWithType: TFGraph.SaveV2
  fullName: TFGraph.SaveV2
- uid: TensorFlow.TFGraph.ScalarSummary*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScalarSummary
  nameWithType: TFGraph.ScalarSummary
  fullName: TFGraph.ScalarSummary
- uid: TensorFlow.TFGraph.ScatterAdd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterAdd
  nameWithType: TFGraph.ScatterAdd
  fullName: TFGraph.ScatterAdd
- uid: TensorFlow.TFGraph.ScatterDiv*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterDiv
  nameWithType: TFGraph.ScatterDiv
  fullName: TFGraph.ScatterDiv
- uid: TensorFlow.TFGraph.ScatterMax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterMax
  nameWithType: TFGraph.ScatterMax
  fullName: TFGraph.ScatterMax
- uid: TensorFlow.TFGraph.ScatterMin*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterMin
  nameWithType: TFGraph.ScatterMin
  fullName: TFGraph.ScatterMin
- uid: TensorFlow.TFGraph.ScatterMul*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterMul
  nameWithType: TFGraph.ScatterMul
  fullName: TFGraph.ScatterMul
- uid: TensorFlow.TFGraph.ScatterNd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterNd
  nameWithType: TFGraph.ScatterNd
  fullName: TFGraph.ScatterNd
- uid: TensorFlow.TFGraph.ScatterNdAdd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterNdAdd
  nameWithType: TFGraph.ScatterNdAdd
  fullName: TFGraph.ScatterNdAdd
- uid: TensorFlow.TFGraph.ScatterNdNonAliasingAdd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterNdNonAliasingAdd
  nameWithType: TFGraph.ScatterNdNonAliasingAdd
  fullName: TFGraph.ScatterNdNonAliasingAdd
- uid: TensorFlow.TFGraph.ScatterNdSub*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterNdSub
  nameWithType: TFGraph.ScatterNdSub
  fullName: TFGraph.ScatterNdSub
- uid: TensorFlow.TFGraph.ScatterNdUpdate*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterNdUpdate
  nameWithType: TFGraph.ScatterNdUpdate
  fullName: TFGraph.ScatterNdUpdate
- uid: TensorFlow.TFGraph.ScatterSub*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterSub
  nameWithType: TFGraph.ScatterSub
  fullName: TFGraph.ScatterSub
- uid: TensorFlow.TFGraph.ScatterUpdate*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ScatterUpdate
  nameWithType: TFGraph.ScatterUpdate
  fullName: TFGraph.ScatterUpdate
- uid: TensorFlow.TFGraph.SdcaFprint*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SdcaFprint
  nameWithType: TFGraph.SdcaFprint
  fullName: TFGraph.SdcaFprint
- uid: TensorFlow.TFGraph.SdcaOptimizer*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SdcaOptimizer
  nameWithType: TFGraph.SdcaOptimizer
  fullName: TFGraph.SdcaOptimizer
- uid: TensorFlow.TFGraph.SdcaShrinkL1*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SdcaShrinkL1
  nameWithType: TFGraph.SdcaShrinkL1
  fullName: TFGraph.SdcaShrinkL1
- uid: TensorFlow.TFGraph.Seed*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Seed
  nameWithType: TFGraph.Seed
  fullName: TFGraph.Seed
- uid: TensorFlow.TFGraph.SegmentMax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SegmentMax
  nameWithType: TFGraph.SegmentMax
  fullName: TFGraph.SegmentMax
- uid: TensorFlow.TFGraph.SegmentMean*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SegmentMean
  nameWithType: TFGraph.SegmentMean
  fullName: TFGraph.SegmentMean
- uid: TensorFlow.TFGraph.SegmentMin*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SegmentMin
  nameWithType: TFGraph.SegmentMin
  fullName: TFGraph.SegmentMin
- uid: TensorFlow.TFGraph.SegmentProd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SegmentProd
  nameWithType: TFGraph.SegmentProd
  fullName: TFGraph.SegmentProd
- uid: TensorFlow.TFGraph.SegmentSum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SegmentSum
  nameWithType: TFGraph.SegmentSum
  fullName: TFGraph.SegmentSum
- uid: TensorFlow.TFGraph.Select*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Select
  nameWithType: TFGraph.Select
  fullName: TFGraph.Select
- uid: TensorFlow.TFGraph.SelfAdjointEig*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SelfAdjointEig
  nameWithType: TFGraph.SelfAdjointEig
  fullName: TFGraph.SelfAdjointEig
- uid: TensorFlow.TFGraph.SelfAdjointEigV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SelfAdjointEigV2
  nameWithType: TFGraph.SelfAdjointEigV2
  fullName: TFGraph.SelfAdjointEigV2
- uid: TensorFlow.TFGraph.Selu*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Selu
  nameWithType: TFGraph.Selu
  fullName: TFGraph.Selu
- uid: TensorFlow.TFGraph.SeluGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SeluGrad
  nameWithType: TFGraph.SeluGrad
  fullName: TFGraph.SeluGrad
- uid: TensorFlow.TFGraph.SendTPUEmbeddingGradients*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SendTPUEmbeddingGradients
  nameWithType: TFGraph.SendTPUEmbeddingGradients
  fullName: TFGraph.SendTPUEmbeddingGradients
- uid: TensorFlow.TFGraph.SerializeIterator*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SerializeIterator
  nameWithType: TFGraph.SerializeIterator
  fullName: TFGraph.SerializeIterator
- uid: TensorFlow.TFGraph.SerializeManySparse*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SerializeManySparse
  nameWithType: TFGraph.SerializeManySparse
  fullName: TFGraph.SerializeManySparse
- uid: TensorFlow.TFGraph.SerializeSparse*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SerializeSparse
  nameWithType: TFGraph.SerializeSparse
  fullName: TFGraph.SerializeSparse
- uid: TensorFlow.TFGraph.SerializeTensor*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SerializeTensor
  nameWithType: TFGraph.SerializeTensor
  fullName: TFGraph.SerializeTensor
- uid: TensorFlow.TFGraph.SetSize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SetSize
  nameWithType: TFGraph.SetSize
  fullName: TFGraph.SetSize
- uid: TensorFlow.TFGraph.SetTensorShape*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SetTensorShape
  nameWithType: TFGraph.SetTensorShape
  fullName: TFGraph.SetTensorShape
- uid: TensorFlow.TFGraph.Shape*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Shape
  nameWithType: TFGraph.Shape
  fullName: TFGraph.Shape
- uid: TensorFlow.TFGraph.ShapeN*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ShapeN
  nameWithType: TFGraph.ShapeN
  fullName: TFGraph.ShapeN
- uid: TensorFlow.TFGraph.ShardedFilename*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ShardedFilename
  nameWithType: TFGraph.ShardedFilename
  fullName: TFGraph.ShardedFilename
- uid: TensorFlow.TFGraph.ShardedFilespec*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ShardedFilespec
  nameWithType: TFGraph.ShardedFilespec
  fullName: TFGraph.ShardedFilespec
- uid: TensorFlow.TFGraph.ShuffleAndRepeatDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ShuffleAndRepeatDataset
  nameWithType: TFGraph.ShuffleAndRepeatDataset
  fullName: TFGraph.ShuffleAndRepeatDataset
- uid: TensorFlow.TFGraph.ShuffleDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ShuffleDataset
  nameWithType: TFGraph.ShuffleDataset
  fullName: TFGraph.ShuffleDataset
- uid: TensorFlow.TFGraph.ShutdownDistributedTPU*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ShutdownDistributedTPU
  nameWithType: TFGraph.ShutdownDistributedTPU
  fullName: TFGraph.ShutdownDistributedTPU
- uid: TensorFlow.TFGraph.Sigmoid*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sigmoid
  nameWithType: TFGraph.Sigmoid
  fullName: TFGraph.Sigmoid
- uid: TensorFlow.TFGraph.SigmoidCrossEntropyWithLogits*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SigmoidCrossEntropyWithLogits
  nameWithType: TFGraph.SigmoidCrossEntropyWithLogits
  fullName: TFGraph.SigmoidCrossEntropyWithLogits
- uid: TensorFlow.TFGraph.SigmoidGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SigmoidGrad
  nameWithType: TFGraph.SigmoidGrad
  fullName: TFGraph.SigmoidGrad
- uid: TensorFlow.TFGraph.Sign*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sign
  nameWithType: TFGraph.Sign
  fullName: TFGraph.Sign
- uid: TensorFlow.TFGraph.Sin*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sin
  nameWithType: TFGraph.Sin
  fullName: TFGraph.Sin
- uid: TensorFlow.TFGraph.Sinh*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sinh
  nameWithType: TFGraph.Sinh
  fullName: TFGraph.Sinh
- uid: TensorFlow.TFGraph.Size*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Size
  nameWithType: TFGraph.Size
  fullName: TFGraph.Size
- uid: TensorFlow.TFGraph.SkipDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SkipDataset
  nameWithType: TFGraph.SkipDataset
  fullName: TFGraph.SkipDataset
- uid: TensorFlow.TFGraph.Skipgram*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Skipgram
  nameWithType: TFGraph.Skipgram
  fullName: TFGraph.Skipgram
- uid: TensorFlow.TFGraph.Slice*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Slice
  nameWithType: TFGraph.Slice
  fullName: TFGraph.Slice
- uid: TensorFlow.TFGraph.Snapshot*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Snapshot
  nameWithType: TFGraph.Snapshot
  fullName: TFGraph.Snapshot
- uid: TensorFlow.TFGraph.Softmax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Softmax
  nameWithType: TFGraph.Softmax
  fullName: TFGraph.Softmax
- uid: TensorFlow.TFGraph.SoftmaxCrossEntropyWithLogits*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SoftmaxCrossEntropyWithLogits
  nameWithType: TFGraph.SoftmaxCrossEntropyWithLogits
  fullName: TFGraph.SoftmaxCrossEntropyWithLogits
- uid: TensorFlow.TFGraph.Softplus*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Softplus
  nameWithType: TFGraph.Softplus
  fullName: TFGraph.Softplus
- uid: TensorFlow.TFGraph.SoftplusGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SoftplusGrad
  nameWithType: TFGraph.SoftplusGrad
  fullName: TFGraph.SoftplusGrad
- uid: TensorFlow.TFGraph.Softsign*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Softsign
  nameWithType: TFGraph.Softsign
  fullName: TFGraph.Softsign
- uid: TensorFlow.TFGraph.SoftsignGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SoftsignGrad
  nameWithType: TFGraph.SoftsignGrad
  fullName: TFGraph.SoftsignGrad
- uid: TensorFlow.TFGraph.SpaceToBatch*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SpaceToBatch
  nameWithType: TFGraph.SpaceToBatch
  fullName: TFGraph.SpaceToBatch
- uid: TensorFlow.TFGraph.SpaceToBatchND*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SpaceToBatchND
  nameWithType: TFGraph.SpaceToBatchND
  fullName: TFGraph.SpaceToBatchND
- uid: TensorFlow.TFGraph.SpaceToDepth*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SpaceToDepth
  nameWithType: TFGraph.SpaceToDepth
  fullName: TFGraph.SpaceToDepth
- uid: TensorFlow.TFGraph.SparseAccumulatorApplyGradient*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseAccumulatorApplyGradient
  nameWithType: TFGraph.SparseAccumulatorApplyGradient
  fullName: TFGraph.SparseAccumulatorApplyGradient
- uid: TensorFlow.TFGraph.SparseAccumulatorTakeGradient*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseAccumulatorTakeGradient
  nameWithType: TFGraph.SparseAccumulatorTakeGradient
  fullName: TFGraph.SparseAccumulatorTakeGradient
- uid: TensorFlow.TFGraph.SparseAdd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseAdd
  nameWithType: TFGraph.SparseAdd
  fullName: TFGraph.SparseAdd
- uid: TensorFlow.TFGraph.SparseAddGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseAddGrad
  nameWithType: TFGraph.SparseAddGrad
  fullName: TFGraph.SparseAddGrad
- uid: TensorFlow.TFGraph.SparseApplyAdadelta*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyAdadelta
  nameWithType: TFGraph.SparseApplyAdadelta
  fullName: TFGraph.SparseApplyAdadelta
- uid: TensorFlow.TFGraph.SparseApplyAdagrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyAdagrad
  nameWithType: TFGraph.SparseApplyAdagrad
  fullName: TFGraph.SparseApplyAdagrad
- uid: TensorFlow.TFGraph.SparseApplyAdagradDA*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyAdagradDA
  nameWithType: TFGraph.SparseApplyAdagradDA
  fullName: TFGraph.SparseApplyAdagradDA
- uid: TensorFlow.TFGraph.SparseApplyCenteredRMSProp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyCenteredRMSProp
  nameWithType: TFGraph.SparseApplyCenteredRMSProp
  fullName: TFGraph.SparseApplyCenteredRMSProp
- uid: TensorFlow.TFGraph.SparseApplyFtrl*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyFtrl
  nameWithType: TFGraph.SparseApplyFtrl
  fullName: TFGraph.SparseApplyFtrl
- uid: TensorFlow.TFGraph.SparseApplyFtrlV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyFtrlV2
  nameWithType: TFGraph.SparseApplyFtrlV2
  fullName: TFGraph.SparseApplyFtrlV2
- uid: TensorFlow.TFGraph.SparseApplyMomentum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyMomentum
  nameWithType: TFGraph.SparseApplyMomentum
  fullName: TFGraph.SparseApplyMomentum
- uid: TensorFlow.TFGraph.SparseApplyProximalAdagrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyProximalAdagrad
  nameWithType: TFGraph.SparseApplyProximalAdagrad
  fullName: TFGraph.SparseApplyProximalAdagrad
- uid: TensorFlow.TFGraph.SparseApplyProximalGradientDescent*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyProximalGradientDescent
  nameWithType: TFGraph.SparseApplyProximalGradientDescent
  fullName: TFGraph.SparseApplyProximalGradientDescent
- uid: TensorFlow.TFGraph.SparseApplyRMSProp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseApplyRMSProp
  nameWithType: TFGraph.SparseApplyRMSProp
  fullName: TFGraph.SparseApplyRMSProp
- uid: TensorFlow.TFGraph.SparseConcat*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseConcat
  nameWithType: TFGraph.SparseConcat
  fullName: TFGraph.SparseConcat
- uid: TensorFlow.TFGraph.SparseConditionalAccumulator*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseConditionalAccumulator
  nameWithType: TFGraph.SparseConditionalAccumulator
  fullName: TFGraph.SparseConditionalAccumulator
- uid: TensorFlow.TFGraph.SparseCross*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseCross
  nameWithType: TFGraph.SparseCross
  fullName: TFGraph.SparseCross
- uid: TensorFlow.TFGraph.SparseDenseCwiseAdd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseDenseCwiseAdd
  nameWithType: TFGraph.SparseDenseCwiseAdd
  fullName: TFGraph.SparseDenseCwiseAdd
- uid: TensorFlow.TFGraph.SparseDenseCwiseDiv*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseDenseCwiseDiv
  nameWithType: TFGraph.SparseDenseCwiseDiv
  fullName: TFGraph.SparseDenseCwiseDiv
- uid: TensorFlow.TFGraph.SparseDenseCwiseMul*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseDenseCwiseMul
  nameWithType: TFGraph.SparseDenseCwiseMul
  fullName: TFGraph.SparseDenseCwiseMul
- uid: TensorFlow.TFGraph.SparseFillEmptyRows*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseFillEmptyRows
  nameWithType: TFGraph.SparseFillEmptyRows
  fullName: TFGraph.SparseFillEmptyRows
- uid: TensorFlow.TFGraph.SparseFillEmptyRowsGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseFillEmptyRowsGrad
  nameWithType: TFGraph.SparseFillEmptyRowsGrad
  fullName: TFGraph.SparseFillEmptyRowsGrad
- uid: TensorFlow.TFGraph.SparseMatMul*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseMatMul
  nameWithType: TFGraph.SparseMatMul
  fullName: TFGraph.SparseMatMul
- uid: TensorFlow.TFGraph.SparseReduceMax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseReduceMax
  nameWithType: TFGraph.SparseReduceMax
  fullName: TFGraph.SparseReduceMax
- uid: TensorFlow.TFGraph.SparseReduceMaxSparse*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseReduceMaxSparse
  nameWithType: TFGraph.SparseReduceMaxSparse
  fullName: TFGraph.SparseReduceMaxSparse
- uid: TensorFlow.TFGraph.SparseReduceSum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseReduceSum
  nameWithType: TFGraph.SparseReduceSum
  fullName: TFGraph.SparseReduceSum
- uid: TensorFlow.TFGraph.SparseReduceSumSparse*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseReduceSumSparse
  nameWithType: TFGraph.SparseReduceSumSparse
  fullName: TFGraph.SparseReduceSumSparse
- uid: TensorFlow.TFGraph.SparseReorder*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseReorder
  nameWithType: TFGraph.SparseReorder
  fullName: TFGraph.SparseReorder
- uid: TensorFlow.TFGraph.SparseReshape*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseReshape
  nameWithType: TFGraph.SparseReshape
  fullName: TFGraph.SparseReshape
- uid: TensorFlow.TFGraph.SparseSegmentMean*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentMean
  nameWithType: TFGraph.SparseSegmentMean
  fullName: TFGraph.SparseSegmentMean
- uid: TensorFlow.TFGraph.SparseSegmentMeanGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentMeanGrad
  nameWithType: TFGraph.SparseSegmentMeanGrad
  fullName: TFGraph.SparseSegmentMeanGrad
- uid: TensorFlow.TFGraph.SparseSegmentMeanWithNumSegments*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentMeanWithNumSegments
  nameWithType: TFGraph.SparseSegmentMeanWithNumSegments
  fullName: TFGraph.SparseSegmentMeanWithNumSegments
- uid: TensorFlow.TFGraph.SparseSegmentSqrtN*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentSqrtN
  nameWithType: TFGraph.SparseSegmentSqrtN
  fullName: TFGraph.SparseSegmentSqrtN
- uid: TensorFlow.TFGraph.SparseSegmentSqrtNGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentSqrtNGrad
  nameWithType: TFGraph.SparseSegmentSqrtNGrad
  fullName: TFGraph.SparseSegmentSqrtNGrad
- uid: TensorFlow.TFGraph.SparseSegmentSqrtNWithNumSegments*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentSqrtNWithNumSegments
  nameWithType: TFGraph.SparseSegmentSqrtNWithNumSegments
  fullName: TFGraph.SparseSegmentSqrtNWithNumSegments
- uid: TensorFlow.TFGraph.SparseSegmentSum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentSum
  nameWithType: TFGraph.SparseSegmentSum
  fullName: TFGraph.SparseSegmentSum
- uid: TensorFlow.TFGraph.SparseSegmentSumWithNumSegments*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSegmentSumWithNumSegments
  nameWithType: TFGraph.SparseSegmentSumWithNumSegments
  fullName: TFGraph.SparseSegmentSumWithNumSegments
- uid: TensorFlow.TFGraph.SparseSlice*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSlice
  nameWithType: TFGraph.SparseSlice
  fullName: TFGraph.SparseSlice
- uid: TensorFlow.TFGraph.SparseSliceGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSliceGrad
  nameWithType: TFGraph.SparseSliceGrad
  fullName: TFGraph.SparseSliceGrad
- uid: TensorFlow.TFGraph.SparseSoftmax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSoftmax
  nameWithType: TFGraph.SparseSoftmax
  fullName: TFGraph.SparseSoftmax
- uid: TensorFlow.TFGraph.SparseSoftmaxCrossEntropyWithLogits*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSoftmaxCrossEntropyWithLogits
  nameWithType: TFGraph.SparseSoftmaxCrossEntropyWithLogits
  fullName: TFGraph.SparseSoftmaxCrossEntropyWithLogits
- uid: TensorFlow.TFGraph.SparseSparseMaximum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSparseMaximum
  nameWithType: TFGraph.SparseSparseMaximum
  fullName: TFGraph.SparseSparseMaximum
- uid: TensorFlow.TFGraph.SparseSparseMinimum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSparseMinimum
  nameWithType: TFGraph.SparseSparseMinimum
  fullName: TFGraph.SparseSparseMinimum
- uid: TensorFlow.TFGraph.SparseSplit*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseSplit
  nameWithType: TFGraph.SparseSplit
  fullName: TFGraph.SparseSplit
- uid: TensorFlow.TFGraph.SparseTensorDenseAdd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseTensorDenseAdd
  nameWithType: TFGraph.SparseTensorDenseAdd
  fullName: TFGraph.SparseTensorDenseAdd
- uid: TensorFlow.TFGraph.SparseTensorDenseMatMul*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseTensorDenseMatMul
  nameWithType: TFGraph.SparseTensorDenseMatMul
  fullName: TFGraph.SparseTensorDenseMatMul
- uid: TensorFlow.TFGraph.SparseTensorSliceDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseTensorSliceDataset
  nameWithType: TFGraph.SparseTensorSliceDataset
  fullName: TFGraph.SparseTensorSliceDataset
- uid: TensorFlow.TFGraph.SparseToDense*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseToDense
  nameWithType: TFGraph.SparseToDense
  fullName: TFGraph.SparseToDense
- uid: TensorFlow.TFGraph.SparseToSparseSetOperation*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SparseToSparseSetOperation
  nameWithType: TFGraph.SparseToSparseSetOperation
  fullName: TFGraph.SparseToSparseSetOperation
- uid: TensorFlow.TFGraph.Split*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Split
  nameWithType: TFGraph.Split
  fullName: TFGraph.Split
- uid: TensorFlow.TFGraph.SplitV*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SplitV
  nameWithType: TFGraph.SplitV
  fullName: TFGraph.SplitV
- uid: TensorFlow.TFGraph.Sqrt*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sqrt
  nameWithType: TFGraph.Sqrt
  fullName: TFGraph.Sqrt
- uid: TensorFlow.TFGraph.SqrtGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SqrtGrad
  nameWithType: TFGraph.SqrtGrad
  fullName: TFGraph.SqrtGrad
- uid: TensorFlow.TFGraph.Square*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Square
  nameWithType: TFGraph.Square
  fullName: TFGraph.Square
- uid: TensorFlow.TFGraph.SquaredDifference*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: SquaredDifference
  nameWithType: TFGraph.SquaredDifference
  fullName: TFGraph.SquaredDifference
- uid: TensorFlow.TFGraph.Squeeze*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Squeeze
  nameWithType: TFGraph.Squeeze
  fullName: TFGraph.Squeeze
- uid: TensorFlow.TFGraph.Stack*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Stack
  nameWithType: TFGraph.Stack
  fullName: TFGraph.Stack
- uid: TensorFlow.TFGraph.StackClose*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackClose
  nameWithType: TFGraph.StackClose
  fullName: TFGraph.StackClose
- uid: TensorFlow.TFGraph.StackCloseV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackCloseV2
  nameWithType: TFGraph.StackCloseV2
  fullName: TFGraph.StackCloseV2
- uid: TensorFlow.TFGraph.StackPop*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackPop
  nameWithType: TFGraph.StackPop
  fullName: TFGraph.StackPop
- uid: TensorFlow.TFGraph.StackPopV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackPopV2
  nameWithType: TFGraph.StackPopV2
  fullName: TFGraph.StackPopV2
- uid: TensorFlow.TFGraph.StackPush*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackPush
  nameWithType: TFGraph.StackPush
  fullName: TFGraph.StackPush
- uid: TensorFlow.TFGraph.StackPushV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackPushV2
  nameWithType: TFGraph.StackPushV2
  fullName: TFGraph.StackPushV2
- uid: TensorFlow.TFGraph.StackV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StackV2
  nameWithType: TFGraph.StackV2
  fullName: TFGraph.StackV2
- uid: TensorFlow.TFGraph.Stage*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Stage
  nameWithType: TFGraph.Stage
  fullName: TFGraph.Stage
- uid: TensorFlow.TFGraph.StageClear*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StageClear
  nameWithType: TFGraph.StageClear
  fullName: TFGraph.StageClear
- uid: TensorFlow.TFGraph.StagePeek*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StagePeek
  nameWithType: TFGraph.StagePeek
  fullName: TFGraph.StagePeek
- uid: TensorFlow.TFGraph.StageSize*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StageSize
  nameWithType: TFGraph.StageSize
  fullName: TFGraph.StageSize
- uid: TensorFlow.TFGraph.StatelessMultinomial*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StatelessMultinomial
  nameWithType: TFGraph.StatelessMultinomial
  fullName: TFGraph.StatelessMultinomial
- uid: TensorFlow.TFGraph.StatelessRandomNormal*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StatelessRandomNormal
  nameWithType: TFGraph.StatelessRandomNormal
  fullName: TFGraph.StatelessRandomNormal
- uid: TensorFlow.TFGraph.StatelessRandomUniform*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StatelessRandomUniform
  nameWithType: TFGraph.StatelessRandomUniform
  fullName: TFGraph.StatelessRandomUniform
- uid: TensorFlow.TFGraph.StatelessTruncatedNormal*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StatelessTruncatedNormal
  nameWithType: TFGraph.StatelessTruncatedNormal
  fullName: TFGraph.StatelessTruncatedNormal
- uid: TensorFlow.TFGraph.StaticRegexFullMatch*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StaticRegexFullMatch
  nameWithType: TFGraph.StaticRegexFullMatch
  fullName: TFGraph.StaticRegexFullMatch
- uid: TensorFlow.TFGraph.StaticRegexReplace*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StaticRegexReplace
  nameWithType: TFGraph.StaticRegexReplace
  fullName: TFGraph.StaticRegexReplace
- uid: TensorFlow.TFGraph.StopGradient*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StopGradient
  nameWithType: TFGraph.StopGradient
  fullName: TFGraph.StopGradient
- uid: TensorFlow.TFGraph.StridedSlice*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StridedSlice
  nameWithType: TFGraph.StridedSlice
  fullName: TFGraph.StridedSlice
- uid: TensorFlow.TFGraph.StridedSliceAssign*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StridedSliceAssign
  nameWithType: TFGraph.StridedSliceAssign
  fullName: TFGraph.StridedSliceAssign
- uid: TensorFlow.TFGraph.StridedSliceGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StridedSliceGrad
  nameWithType: TFGraph.StridedSliceGrad
  fullName: TFGraph.StridedSliceGrad
- uid: TensorFlow.TFGraph.StringFormat*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringFormat
  nameWithType: TFGraph.StringFormat
  fullName: TFGraph.StringFormat
- uid: TensorFlow.TFGraph.StringJoin*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringJoin
  nameWithType: TFGraph.StringJoin
  fullName: TFGraph.StringJoin
- uid: TensorFlow.TFGraph.StringLength*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringLength
  nameWithType: TFGraph.StringLength
  fullName: TFGraph.StringLength
- uid: TensorFlow.TFGraph.StringSplit*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringSplit
  nameWithType: TFGraph.StringSplit
  fullName: TFGraph.StringSplit
- uid: TensorFlow.TFGraph.StringSplitV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringSplitV2
  nameWithType: TFGraph.StringSplitV2
  fullName: TFGraph.StringSplitV2
- uid: TensorFlow.TFGraph.StringStrip*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringStrip
  nameWithType: TFGraph.StringStrip
  fullName: TFGraph.StringStrip
- uid: TensorFlow.TFGraph.StringToHashBucket*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringToHashBucket
  nameWithType: TFGraph.StringToHashBucket
  fullName: TFGraph.StringToHashBucket
- uid: TensorFlow.TFGraph.StringToHashBucketFast*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringToHashBucketFast
  nameWithType: TFGraph.StringToHashBucketFast
  fullName: TFGraph.StringToHashBucketFast
- uid: TensorFlow.TFGraph.StringToHashBucketStrong*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringToHashBucketStrong
  nameWithType: TFGraph.StringToHashBucketStrong
  fullName: TFGraph.StringToHashBucketStrong
- uid: TensorFlow.TFGraph.StringToNumber*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: StringToNumber
  nameWithType: TFGraph.StringToNumber
  fullName: TFGraph.StringToNumber
- uid: TensorFlow.TFGraph.Sub*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sub
  nameWithType: TFGraph.Sub
  fullName: TFGraph.Sub
- uid: TensorFlow.TFGraph.Sum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Sum
  nameWithType: TFGraph.Sum
  fullName: TFGraph.Sum
- uid: TensorFlow.TFGraph.Svd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Svd
  nameWithType: TFGraph.Svd
  fullName: TFGraph.Svd
- uid: TensorFlow.TFGraph.Switch*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Switch
  nameWithType: TFGraph.Switch
  fullName: TFGraph.Switch
- uid: TensorFlow.TFGraph.TakeDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TakeDataset
  nameWithType: TFGraph.TakeDataset
  fullName: TFGraph.TakeDataset
- uid: TensorFlow.TFGraph.TakeManySparseFromTensorsMap*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TakeManySparseFromTensorsMap
  nameWithType: TFGraph.TakeManySparseFromTensorsMap
  fullName: TFGraph.TakeManySparseFromTensorsMap
- uid: TensorFlow.TFGraph.Tan*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Tan
  nameWithType: TFGraph.Tan
  fullName: TFGraph.Tan
- uid: TensorFlow.TFGraph.Tanh*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Tanh
  nameWithType: TFGraph.Tanh
  fullName: TFGraph.Tanh
- uid: TensorFlow.TFGraph.TanhGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TanhGrad
  nameWithType: TFGraph.TanhGrad
  fullName: TFGraph.TanhGrad
- uid: TensorFlow.TFGraph.TemporaryVariable*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TemporaryVariable
  nameWithType: TFGraph.TemporaryVariable
  fullName: TFGraph.TemporaryVariable
- uid: TensorFlow.TFGraph.TensorArrayCloseV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayCloseV2
  nameWithType: TFGraph.TensorArrayCloseV2
  fullName: TFGraph.TensorArrayCloseV2
- uid: TensorFlow.TFGraph.TensorArrayCloseV3*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayCloseV3
  nameWithType: TFGraph.TensorArrayCloseV3
  fullName: TFGraph.TensorArrayCloseV3
- uid: TensorFlow.TFGraph.TensorArrayConcatV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayConcatV2
  nameWithType: TFGraph.TensorArrayConcatV2
  fullName: TFGraph.TensorArrayConcatV2
- uid: TensorFlow.TFGraph.TensorArrayConcatV3*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayConcatV3
  nameWithType: TFGraph.TensorArrayConcatV3
  fullName: TFGraph.TensorArrayConcatV3
- uid: TensorFlow.TFGraph.TensorArrayGatherV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayGatherV2
  nameWithType: TFGraph.TensorArrayGatherV2
  fullName: TFGraph.TensorArrayGatherV2
- uid: TensorFlow.TFGraph.TensorArrayGatherV3*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayGatherV3
  nameWithType: TFGraph.TensorArrayGatherV3
  fullName: TFGraph.TensorArrayGatherV3
- uid: TensorFlow.TFGraph.TensorArrayGradV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayGradV2
  nameWithType: TFGraph.TensorArrayGradV2
  fullName: TFGraph.TensorArrayGradV2
- uid: TensorFlow.TFGraph.TensorArrayGradV3*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayGradV3
  nameWithType: TFGraph.TensorArrayGradV3
  fullName: TFGraph.TensorArrayGradV3
- uid: TensorFlow.TFGraph.TensorArrayGradWithShape*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayGradWithShape
  nameWithType: TFGraph.TensorArrayGradWithShape
  fullName: TFGraph.TensorArrayGradWithShape
- uid: TensorFlow.TFGraph.TensorArrayReadV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayReadV2
  nameWithType: TFGraph.TensorArrayReadV2
  fullName: TFGraph.TensorArrayReadV2
- uid: TensorFlow.TFGraph.TensorArrayReadV3*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayReadV3
  nameWithType: TFGraph.TensorArrayReadV3
  fullName: TFGraph.TensorArrayReadV3
- uid: TensorFlow.TFGraph.TensorArrayScatterV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayScatterV2
  nameWithType: TFGraph.TensorArrayScatterV2
  fullName: TFGraph.TensorArrayScatterV2
- uid: TensorFlow.TFGraph.TensorArrayScatterV3*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayScatterV3
  nameWithType: TFGraph.TensorArrayScatterV3
  fullName: TFGraph.TensorArrayScatterV3
- uid: TensorFlow.TFGraph.TensorArraySizeV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArraySizeV2
  nameWithType: TFGraph.TensorArraySizeV2
  fullName: TFGraph.TensorArraySizeV2
- uid: TensorFlow.TFGraph.TensorArraySizeV3*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArraySizeV3
  nameWithType: TFGraph.TensorArraySizeV3
  fullName: TFGraph.TensorArraySizeV3
- uid: TensorFlow.TFGraph.TensorArraySplitV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArraySplitV2
  nameWithType: TFGraph.TensorArraySplitV2
  fullName: TFGraph.TensorArraySplitV2
- uid: TensorFlow.TFGraph.TensorArraySplitV3*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArraySplitV3
  nameWithType: TFGraph.TensorArraySplitV3
  fullName: TFGraph.TensorArraySplitV3
- uid: TensorFlow.TFGraph.TensorArrayV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayV2
  nameWithType: TFGraph.TensorArrayV2
  fullName: TFGraph.TensorArrayV2
- uid: TensorFlow.TFGraph.TensorArrayV3*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayV3
  nameWithType: TFGraph.TensorArrayV3
  fullName: TFGraph.TensorArrayV3
- uid: TensorFlow.TFGraph.TensorArrayWriteV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayWriteV2
  nameWithType: TFGraph.TensorArrayWriteV2
  fullName: TFGraph.TensorArrayWriteV2
- uid: TensorFlow.TFGraph.TensorArrayWriteV3*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorArrayWriteV3
  nameWithType: TFGraph.TensorArrayWriteV3
  fullName: TFGraph.TensorArrayWriteV3
- uid: TensorFlow.TFGraph.TensorDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorDataset
  nameWithType: TFGraph.TensorDataset
  fullName: TFGraph.TensorDataset
- uid: TensorFlow.TFGraph.TensorListElementShape*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListElementShape
  nameWithType: TFGraph.TensorListElementShape
  fullName: TFGraph.TensorListElementShape
- uid: TensorFlow.TFGraph.TensorListFromTensor*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListFromTensor
  nameWithType: TFGraph.TensorListFromTensor
  fullName: TFGraph.TensorListFromTensor
- uid: TensorFlow.TFGraph.TensorListGather*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListGather
  nameWithType: TFGraph.TensorListGather
  fullName: TFGraph.TensorListGather
- uid: TensorFlow.TFGraph.TensorListGetItem*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListGetItem
  nameWithType: TFGraph.TensorListGetItem
  fullName: TFGraph.TensorListGetItem
- uid: TensorFlow.TFGraph.TensorListLength*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListLength
  nameWithType: TFGraph.TensorListLength
  fullName: TFGraph.TensorListLength
- uid: TensorFlow.TFGraph.TensorListPopBack*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListPopBack
  nameWithType: TFGraph.TensorListPopBack
  fullName: TFGraph.TensorListPopBack
- uid: TensorFlow.TFGraph.TensorListPushBack*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListPushBack
  nameWithType: TFGraph.TensorListPushBack
  fullName: TFGraph.TensorListPushBack
- uid: TensorFlow.TFGraph.TensorListReserve*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListReserve
  nameWithType: TFGraph.TensorListReserve
  fullName: TFGraph.TensorListReserve
- uid: TensorFlow.TFGraph.TensorListScatter*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListScatter
  nameWithType: TFGraph.TensorListScatter
  fullName: TFGraph.TensorListScatter
- uid: TensorFlow.TFGraph.TensorListSetItem*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListSetItem
  nameWithType: TFGraph.TensorListSetItem
  fullName: TFGraph.TensorListSetItem
- uid: TensorFlow.TFGraph.TensorListStack*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorListStack
  nameWithType: TFGraph.TensorListStack
  fullName: TFGraph.TensorListStack
- uid: TensorFlow.TFGraph.TensorSliceDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorSliceDataset
  nameWithType: TFGraph.TensorSliceDataset
  fullName: TFGraph.TensorSliceDataset
- uid: TensorFlow.TFGraph.TensorSummary*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorSummary
  nameWithType: TFGraph.TensorSummary
  fullName: TFGraph.TensorSummary
- uid: TensorFlow.TFGraph.TensorSummaryV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TensorSummaryV2
  nameWithType: TFGraph.TensorSummaryV2
  fullName: TFGraph.TensorSummaryV2
- uid: TensorFlow.TFGraph.TextLineDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TextLineDataset
  nameWithType: TFGraph.TextLineDataset
  fullName: TFGraph.TextLineDataset
- uid: TensorFlow.TFGraph.TextLineReader*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TextLineReader
  nameWithType: TFGraph.TextLineReader
  fullName: TFGraph.TextLineReader
- uid: TensorFlow.TFGraph.TextLineReaderV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TextLineReaderV2
  nameWithType: TFGraph.TextLineReaderV2
  fullName: TFGraph.TextLineReaderV2
- uid: TensorFlow.TFGraph.TFRecordDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TFRecordDataset
  nameWithType: TFGraph.TFRecordDataset
  fullName: TFGraph.TFRecordDataset
- uid: TensorFlow.TFGraph.TFRecordReader*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TFRecordReader
  nameWithType: TFGraph.TFRecordReader
  fullName: TFGraph.TFRecordReader
- uid: TensorFlow.TFGraph.TFRecordReaderV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TFRecordReaderV2
  nameWithType: TFGraph.TFRecordReaderV2
  fullName: TFGraph.TFRecordReaderV2
- uid: TensorFlow.TFGraph.ThreadUnsafeUnigramCandidateSampler*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ThreadUnsafeUnigramCandidateSampler
  nameWithType: TFGraph.ThreadUnsafeUnigramCandidateSampler
  fullName: TFGraph.ThreadUnsafeUnigramCandidateSampler
- uid: TensorFlow.TFGraph.Tile*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Tile
  nameWithType: TFGraph.Tile
  fullName: TFGraph.Tile
- uid: TensorFlow.TFGraph.TileGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TileGrad
  nameWithType: TFGraph.TileGrad
  fullName: TFGraph.TileGrad
- uid: TensorFlow.TFGraph.Timestamp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Timestamp
  nameWithType: TFGraph.Timestamp
  fullName: TFGraph.Timestamp
- uid: TensorFlow.TFGraph.ToFunction*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ToFunction
  nameWithType: TFGraph.ToFunction
  fullName: TFGraph.ToFunction
- uid: TensorFlow.TFGraph.ToGraphDef*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ToGraphDef
  nameWithType: TFGraph.ToGraphDef
  fullName: TFGraph.ToGraphDef
- uid: TensorFlow.TFGraph.TopK*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TopK
  nameWithType: TFGraph.TopK
  fullName: TFGraph.TopK
- uid: TensorFlow.TFGraph.TopKV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TopKV2
  nameWithType: TFGraph.TopKV2
  fullName: TFGraph.TopKV2
- uid: TensorFlow.TFGraph.ToString*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ToString
  nameWithType: TFGraph.ToString
  fullName: TFGraph.ToString
- uid: TensorFlow.TFGraph.TPUEmbeddingActivations*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TPUEmbeddingActivations
  nameWithType: TFGraph.TPUEmbeddingActivations
  fullName: TFGraph.TPUEmbeddingActivations
- uid: TensorFlow.TFGraph.TPUReplicatedInput*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TPUReplicatedInput
  nameWithType: TFGraph.TPUReplicatedInput
  fullName: TFGraph.TPUReplicatedInput
- uid: TensorFlow.TFGraph.TPUReplicatedOutput*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TPUReplicatedOutput
  nameWithType: TFGraph.TPUReplicatedOutput
  fullName: TFGraph.TPUReplicatedOutput
- uid: TensorFlow.TFGraph.Transpose*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Transpose
  nameWithType: TFGraph.Transpose
  fullName: TFGraph.Transpose
- uid: TensorFlow.TFGraph.TruncateDiv*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TruncateDiv
  nameWithType: TFGraph.TruncateDiv
  fullName: TFGraph.TruncateDiv
- uid: TensorFlow.TFGraph.TruncatedNormal*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TruncatedNormal
  nameWithType: TFGraph.TruncatedNormal
  fullName: TFGraph.TruncatedNormal
- uid: TensorFlow.TFGraph.TruncateMod*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TruncateMod
  nameWithType: TFGraph.TruncateMod
  fullName: TFGraph.TruncateMod
- uid: TensorFlow.TFGraph.TryEvaluateConstant*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TryEvaluateConstant
  nameWithType: TFGraph.TryEvaluateConstant
  fullName: TFGraph.TryEvaluateConstant
- uid: TensorFlow.TFGraph.TryRpc*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: TryRpc
  nameWithType: TFGraph.TryRpc
  fullName: TFGraph.TryRpc
- uid: TensorFlow.TFGraph.Unbatch*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Unbatch
  nameWithType: TFGraph.Unbatch
  fullName: TFGraph.Unbatch
- uid: TensorFlow.TFGraph.UnbatchGrad*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnbatchGrad
  nameWithType: TFGraph.UnbatchGrad
  fullName: TFGraph.UnbatchGrad
- uid: TensorFlow.TFGraph.UnicodeScript*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnicodeScript
  nameWithType: TFGraph.UnicodeScript
  fullName: TFGraph.UnicodeScript
- uid: TensorFlow.TFGraph.UniformCandidateSampler*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UniformCandidateSampler
  nameWithType: TFGraph.UniformCandidateSampler
  fullName: TFGraph.UniformCandidateSampler
- uid: TensorFlow.TFGraph.Unique*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Unique
  nameWithType: TFGraph.Unique
  fullName: TFGraph.Unique
- uid: TensorFlow.TFGraph.UniqueV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UniqueV2
  nameWithType: TFGraph.UniqueV2
  fullName: TFGraph.UniqueV2
- uid: TensorFlow.TFGraph.UniqueWithCounts*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UniqueWithCounts
  nameWithType: TFGraph.UniqueWithCounts
  fullName: TFGraph.UniqueWithCounts
- uid: TensorFlow.TFGraph.UniqueWithCountsV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UniqueWithCountsV2
  nameWithType: TFGraph.UniqueWithCountsV2
  fullName: TFGraph.UniqueWithCountsV2
- uid: TensorFlow.TFGraph.Unpack*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Unpack
  nameWithType: TFGraph.Unpack
  fullName: TFGraph.Unpack
- uid: TensorFlow.TFGraph.UnravelIndex*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnravelIndex
  nameWithType: TFGraph.UnravelIndex
  fullName: TFGraph.UnravelIndex
- uid: TensorFlow.TFGraph.UnsortedSegmentMax*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnsortedSegmentMax
  nameWithType: TFGraph.UnsortedSegmentMax
  fullName: TFGraph.UnsortedSegmentMax
- uid: TensorFlow.TFGraph.UnsortedSegmentMin*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnsortedSegmentMin
  nameWithType: TFGraph.UnsortedSegmentMin
  fullName: TFGraph.UnsortedSegmentMin
- uid: TensorFlow.TFGraph.UnsortedSegmentProd*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnsortedSegmentProd
  nameWithType: TFGraph.UnsortedSegmentProd
  fullName: TFGraph.UnsortedSegmentProd
- uid: TensorFlow.TFGraph.UnsortedSegmentSum*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UnsortedSegmentSum
  nameWithType: TFGraph.UnsortedSegmentSum
  fullName: TFGraph.UnsortedSegmentSum
- uid: TensorFlow.TFGraph.Unstage*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Unstage
  nameWithType: TFGraph.Unstage
  fullName: TFGraph.Unstage
- uid: TensorFlow.TFGraph.UpperBound*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: UpperBound
  nameWithType: TFGraph.UpperBound
  fullName: TFGraph.UpperBound
- uid: TensorFlow.TFGraph.VarHandleOp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: VarHandleOp
  nameWithType: TFGraph.VarHandleOp
  fullName: TFGraph.VarHandleOp
- uid: TensorFlow.TFGraph.Variable*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Variable
  nameWithType: TFGraph.Variable
  fullName: TFGraph.Variable
- uid: TensorFlow.TFGraph.VariableShape*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: VariableShape
  nameWithType: TFGraph.VariableShape
  fullName: TFGraph.VariableShape
- uid: TensorFlow.TFGraph.VariableV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: VariableV2
  nameWithType: TFGraph.VariableV2
  fullName: TFGraph.VariableV2
- uid: TensorFlow.TFGraph.VarIsInitializedOp*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: VarIsInitializedOp
  nameWithType: TFGraph.VarIsInitializedOp
  fullName: TFGraph.VarIsInitializedOp
- uid: TensorFlow.TFGraph.Versions*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Versions
  nameWithType: TFGraph.Versions
  fullName: TFGraph.Versions
- uid: TensorFlow.TFGraph.Where*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Where
  nameWithType: TFGraph.Where
  fullName: TFGraph.Where
- uid: TensorFlow.TFGraph.While*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: While
  nameWithType: TFGraph.While
  fullName: TFGraph.While
- uid: TensorFlow.TFGraph.WholeFileReader*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WholeFileReader
  nameWithType: TFGraph.WholeFileReader
  fullName: TFGraph.WholeFileReader
- uid: TensorFlow.TFGraph.WholeFileReaderV2*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WholeFileReaderV2
  nameWithType: TFGraph.WholeFileReaderV2
  fullName: TFGraph.WholeFileReaderV2
- uid: TensorFlow.TFGraph.WindowDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WindowDataset
  nameWithType: TFGraph.WindowDataset
  fullName: TFGraph.WindowDataset
- uid: TensorFlow.TFGraph.WithDependencies*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WithDependencies
  nameWithType: TFGraph.WithDependencies
  fullName: TFGraph.WithDependencies
- uid: TensorFlow.TFGraph.WithScope*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WithScope
  nameWithType: TFGraph.WithScope
  fullName: TFGraph.WithScope
- uid: TensorFlow.TFGraph.WorkerHeartbeat*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WorkerHeartbeat
  nameWithType: TFGraph.WorkerHeartbeat
  fullName: TFGraph.WorkerHeartbeat
- uid: TensorFlow.TFGraph.WriteFile*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: WriteFile
  nameWithType: TFGraph.WriteFile
  fullName: TFGraph.WriteFile
- uid: TensorFlow.TFGraph.Xdivy*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Xdivy
  nameWithType: TFGraph.Xdivy
  fullName: TFGraph.Xdivy
- uid: TensorFlow.TFGraph.Xlogy*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Xlogy
  nameWithType: TFGraph.Xlogy
  fullName: TFGraph.Xlogy
- uid: TensorFlow.TFGraph.Zeros*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Zeros
  nameWithType: TFGraph.Zeros
  fullName: TFGraph.Zeros
- uid: TensorFlow.TFGraph.ZerosLike*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ZerosLike
  nameWithType: TFGraph.ZerosLike
  fullName: TFGraph.ZerosLike
- uid: TensorFlow.TFGraph.Zeta*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: Zeta
  nameWithType: TFGraph.Zeta
  fullName: TFGraph.Zeta
- uid: TensorFlow.TFGraph.ZipDataset*
  parent: TensorFlow.TFGraph
  isExternal: false
  name: ZipDataset
  nameWithType: TFGraph.ZipDataset
  fullName: TFGraph.ZipDataset
- uid: TensorFlow.TFDisposable.Dispose
  parent: TensorFlow.TFDisposable
  isExternal: false
  name: Dispose()
  nameWithType: TFDisposable.Dispose()
  fullName: TFDisposable.Dispose()
- uid: TensorFlow.TFDisposableThreadSafe.Dispose(System.Boolean)
  parent: TensorFlow.TFDisposableThreadSafe
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: TFDisposableThreadSafe.Dispose(Boolean)
  fullName: TFDisposableThreadSafe.Dispose(Boolean)
- uid: TensorFlow.TFDisposable.Handle
  parent: TensorFlow.TFDisposable
  isExternal: false
  name: Handle
  nameWithType: TFDisposable.Handle
  fullName: TFDisposable.Handle
