<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class TFGraph
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class TFGraph
   ">
    <meta name="generator" content="docfx 2.18.2.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="TensorFlow.TFGraph">
  
  
  <h1 id="TensorFlow_TFGraph" data-uid="TensorFlow.TFGraph">Class TFGraph
  </h1>
  <div class="markdown level0 summary"><p>Represents a computation graph.  Graphs may be shared between sessions and are thread safe.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><span class="xref">System.Object</span></div>
    <div class="level1"><a class="xref" href="TensorFlow.TFDisposable.html">TFDisposable</a></div>
    <div class="level2"><a class="xref" href="TensorFlow.TFDisposableThreadSafe.html">TFDisposableThreadSafe</a></div>
    <div class="level3"><span class="xref">TFGraph</span></div>
  </div>
  <div class="inheritedMembers">
    <h5>Inherited Members</h5>
    <div>
      <a class="xref" href="TensorFlow.TFDisposable.html#TensorFlow_TFDisposable_Dispose">TFDisposable.Dispose()</a>
    </div>
    <div>
      <a class="xref" href="TensorFlow.TFDisposable.html#TensorFlow_TFDisposable_Handle">TFDisposable.Handle</a>
    </div>
    <div>
      <a class="xref" href="TensorFlow.TFDisposableThreadSafe.html#TensorFlow_TFDisposableThreadSafe_Dispose_System_Boolean_">TFDisposableThreadSafe.Dispose(Boolean)</a>
    </div>
  </div>
  <h6><strong>Namespace</strong>: <a class="xref" href="../TensorFlow.html">TensorFlow</a></h6>
  <h6><strong>Assembly</strong>: TensorFlowSharp.dll</h6>
  <h5 id="TensorFlow_TFGraph_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public class TFGraph : TensorFlow.TFDisposableThreadSafe</code></pre>
  </div>
  <h5 id="TensorFlow_TFGraph_remarks"><strong>Remarks</strong></h5>
  <div class="markdown level0 remarks"><p>
            Graphs consist of operations (represented by TFOperation objects), these can be named, or 
            the runtime will automatically assign a name.
            </p>
    <p>
            For debugging purposes, you might want to group operations together, for this, call the
            WithScope method with your new scope, which will create a new namespace for your object names.
            </p>
    <p>
            For example, if you call WithScope (&quot;demo&quot;), and add an operation named &quot;add&quot; inside the
            scope, the full name of the operation will be &quot;demo/add&quot;, if you create a new scope inside, say
            &quot;hot&quot;, and add a &quot;sub&quot; operation there the result will be &quot;demo/hot/sub&quot;.
            </p></div>
  <h3 id="constructors">Constructors
  </h3>
  
  
  <a id="TensorFlow_TFGraph__ctor_" data-uid="TensorFlow.TFGraph.#ctor*"></a>
  <h4 id="TensorFlow_TFGraph__ctor" data-uid="TensorFlow.TFGraph.#ctor">TFGraph()</h4>
  <div class="markdown level1 summary"><p>Initializes a new instance of the <a class="xref" href="TensorFlow.TFGraph.html">TFGraph</a> class.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TFGraph ();</code></pre>
  </div>
  <h3 id="properties">Properties
  </h3>
  
  
  <a id="TensorFlow_TFGraph_CurrentDependencies_" data-uid="TensorFlow.TFGraph.CurrentDependencies*"></a>
  <h4 id="TensorFlow_TFGraph_CurrentDependencies" data-uid="TensorFlow.TFGraph.CurrentDependencies">CurrentDependencies</h4>
  <div class="markdown level1 summary"><p>Returns the current variable dependencies in use. New tensors and operations will be created
            with an added input dependency to the operations specified in this property. To change this, 
            use the WithDependencies method.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation[] CurrentDependencies { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a>[]</td>
        <td><p>The current input dependencies to be used for new tensors and operations.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_CurrentNameScope_" data-uid="TensorFlow.TFGraph.CurrentNameScope*"></a>
  <h4 id="TensorFlow_TFGraph_CurrentNameScope" data-uid="TensorFlow.TFGraph.CurrentNameScope">CurrentNameScope</h4>
  <div class="markdown level1 summary"><p>Returns the current name scope in use, to change this, use the WithScope method.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public string CurrentNameScope { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><p>The current name scope.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Functions_" data-uid="TensorFlow.TFGraph.Functions*"></a>
  <h4 id="TensorFlow_TFGraph_Functions" data-uid="TensorFlow.TFGraph.Functions">Functions</h4>
  <div class="markdown level1 summary"><p>Returns an the functions that have been defined in the graph.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFFunction[] Functions { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFFunction.html">TFFunction</a>[]</td>
        <td><p>The functions.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Item_" data-uid="TensorFlow.TFGraph.Item*"></a>
  <h4 id="TensorFlow_TFGraph_Item_System_String_" data-uid="TensorFlow.TFGraph.Item(System.String)">Item(String)</h4>
  <div class="markdown level1 summary"><p>Gets the <a class="xref" href="TensorFlow.TFGraph.html">TFGraph</a> with the specified name, or null if the named operation does not exist in the graph.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation this[string name] { get; }</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">name</span></td>
        <td><p>Name to lookup.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_NumFunctions_" data-uid="TensorFlow.TFGraph.NumFunctions*"></a>
  <h4 id="TensorFlow_TFGraph_NumFunctions" data-uid="TensorFlow.TFGraph.NumFunctions">NumFunctions</h4>
  <div class="markdown level1 summary"><p>Returns the number of TF_Functions registered in this graph.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int NumFunctions { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number functions.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Seed_" data-uid="TensorFlow.TFGraph.Seed*"></a>
  <h4 id="TensorFlow_TFGraph_Seed" data-uid="TensorFlow.TFGraph.Seed">Seed</h4>
  <div class="markdown level1 summary"><p>Gets or sets the graph random seed, see remarks for details.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Nullable&lt;int&gt; Seed { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int32</span>&gt;</td>
        <td><p>The seed.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Seed_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Operations that rely on a random seed actually derive it from two seeds:
              the graph-level and operation-level seeds.This sets the graph-level seed.</p>
<pre><code>         Its interactions with operation-level seeds is as follows:
         1. If neither the graph-level nor the operation seed is set:
            A random seed is used for this op.
         2. If the graph-level seed is set, but the operation seed is not:
            The system deterministically picks an operation seed in conjunction
            with the graph-level seed so that it gets a unique random sequence.
         3. If the graph-level seed is not set, but the operation seed is set:
            A default graph-level seed and the specified operation seed are used to
            determine the random sequence.
         4. If both the graph-level and the operation seed are set:
            Both seeds are used in conjunction to determine the random sequence.
</code></pre></div>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="TensorFlow_TFGraph_Abort_" data-uid="TensorFlow.TFGraph.Abort*"></a>
  <h4 id="TensorFlow_TFGraph_Abort_System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Abort(System.String,System.Nullable{System.Boolean},System.String)">Abort(String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Raise a exception to abort the process when called.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation Abort (string error_msg = null, Nullable&lt;bool&gt; exit_without_error = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">error_msg</span></td>
        <td><p>Optional argument
              A string which is the message associated with the exception.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">exit_without_error</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Abort&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Abort_System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If exit_without_error is true, the process will exit normally,
              otherwise it will exit with a SIGABORT signal.</p>
<pre><code>          Returns nothing but an exception.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Abs_" data-uid="TensorFlow.TFGraph.Abs*"></a>
  <h4 id="TensorFlow_TFGraph_Abs_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Abs(TensorFlow.TFOutput,System.String)">Abs(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the absolute value of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Abs (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Abs&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Abs_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a tensor <code>x</code>, this operation returns a tensor containing the absolute
              value of each element in <code>x</code>. For example, if x is an input element and y is
              an output element, this operation computes \(y = |x|\).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AccumulateNV2_" data-uid="TensorFlow.TFGraph.AccumulateNV2*"></a>
  <h4 id="TensorFlow_TFGraph_AccumulateNV2_TensorFlow_TFOutput___TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.AccumulateNV2(TensorFlow.TFOutput[],TensorFlow.TFShape,System.String)">AccumulateNV2(TFOutput[], TFShape, String)</h4>
  <div class="markdown level1 summary"><p>Returns the element-wise sum of a list of tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AccumulateNV2 (TensorFlow.TFOutput[] inputs, TensorFlow.TFShape shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>A list of <code>Tensor</code> objects, each with same shape and type.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>Shape of elements of <code>inputs</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AccumulateNV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AccumulateNV2_TensorFlow_TFOutput___TensorFlow_TFShape_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>tf.accumulate_n_v2</code> performs the same operation as <code>tf.add_n</code>, but does not
              wait for all of its inputs to be ready before beginning to sum. This can
              save memory if inputs are ready at different times, since minimum temporary
              storage is proportional to the output size rather than the inputs size.</p>
<pre><code>          Unlike the original &lt;code&gt;accumulate_n&lt;/code&gt;, &lt;code&gt;accumulate_n_v2&lt;/code&gt; is differentiable.

          Returns a &lt;code&gt;Tensor&lt;/code&gt; of same shape and type as the elements of &lt;code&gt;inputs&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_AccumulatorApplyGradient_" data-uid="TensorFlow.TFGraph.AccumulatorApplyGradient*"></a>
  <h4 id="TensorFlow_TFGraph_AccumulatorApplyGradient_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.AccumulatorApplyGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">AccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Applies a gradient to a given accumulator.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation AccumulatorApplyGradient (TensorFlow.TFOutput handle, TensorFlow.TFOutput local_step, TensorFlow.TFOutput gradient, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a accumulator.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">local_step</span></td>
        <td><p>The local_step value at which the gradient was computed.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient</span></td>
        <td><p>A tensor of the gradient to be accumulated.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AccumulatorApplyGradient&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AccumulatorApplyGradient_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Does not add if local_step is lesser than the accumulator&#39;s global_step.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AccumulatorNumAccumulated_" data-uid="TensorFlow.TFGraph.AccumulatorNumAccumulated*"></a>
  <h4 id="TensorFlow_TFGraph_AccumulatorNumAccumulated_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.AccumulatorNumAccumulated(TensorFlow.TFOutput,System.String)">AccumulatorNumAccumulated(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the number of gradients aggregated in the given accumulators.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AccumulatorNumAccumulated (TensorFlow.TFOutput handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to an accumulator.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AccumulatorNumAccumulated&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The number of gradients aggregated in the given accumulator.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_AccumulatorSetGlobalStep_" data-uid="TensorFlow.TFGraph.AccumulatorSetGlobalStep*"></a>
  <h4 id="TensorFlow_TFGraph_AccumulatorSetGlobalStep_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.AccumulatorSetGlobalStep(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">AccumulatorSetGlobalStep(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Updates the accumulator with a new value for global_step.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation AccumulatorSetGlobalStep (TensorFlow.TFOutput handle, TensorFlow.TFOutput new_global_step, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to an accumulator.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">new_global_step</span></td>
        <td><p>The new global_step value to set.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AccumulatorSetGlobalStep&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AccumulatorSetGlobalStep_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Logs warning if the accumulator&#39;s value is already higher than
              new_global_step.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AccumulatorTakeGradient_" data-uid="TensorFlow.TFGraph.AccumulatorTakeGradient*"></a>
  <h4 id="TensorFlow_TFGraph_AccumulatorTakeGradient_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.AccumulatorTakeGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">AccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Extracts the average gradient in the given ConditionalAccumulator.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AccumulatorTakeGradient (TensorFlow.TFOutput handle, TensorFlow.TFOutput num_required, TensorFlow.TFDataType dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to an accumulator.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_required</span></td>
        <td><p>Number of gradients required before we return an aggregate.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The data type of accumulated gradients. Needs to correspond to the type
              of the accumulator.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AccumulatorTakeGradient&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The average of the accumulated gradients.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AccumulatorTakeGradient_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The op blocks until sufficient (i.e., more than num_required)
              gradients have been accumulated.  If the accumulator has already
              aggregated more than num_required gradients, it returns the average of
              the accumulated gradients.  Also automatically increments the recorded
              global_step in the accumulator by 1, and resets the aggregate to 0.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Acos_" data-uid="TensorFlow.TFGraph.Acos*"></a>
  <h4 id="TensorFlow_TFGraph_Acos_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Acos(TensorFlow.TFOutput,System.String)">Acos(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes acos of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Acos (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Acos&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Acosh_" data-uid="TensorFlow.TFGraph.Acosh*"></a>
  <h4 id="TensorFlow_TFGraph_Acosh_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Acosh(TensorFlow.TFOutput,System.String)">Acosh(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes inverse hyperbolic cosine of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Acosh (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Acosh&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Add_" data-uid="TensorFlow.TFGraph.Add*"></a>
  <h4 id="TensorFlow_TFGraph_Add_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Add(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Add(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns x + y element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Add (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Add&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Add_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>Add</code> supports broadcasting. <code>AddN</code> does not. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AddGradients_" data-uid="TensorFlow.TFGraph.AddGradients*"></a>
  <h4 id="TensorFlow_TFGraph_AddGradients_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.AddGradients(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFStatus)">AddGradients(TFOutput[], TFOutput[], TFOutput[], TFStatus)</h4>
  <div class="markdown level1 summary"><p>Adds a gradient: the operations needed to compute the partial derivatives of sum of <code>y</code>` wrt to <code>x</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] AddGradients (TensorFlow.TFOutput[] y, TensorFlow.TFOutput[] x, TensorFlow.TFOutput[] dx = null, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">y</span></td>
        <td><p>The y elements.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">x</span></td>
        <td><p>The x elements.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">dx</span></td>
        <td><p>Initial gradients, which represent the symbolic partial derivatives of some loss function <code>L</code> w.r.t. <code>y</code> ).<br>            If the parameter is null, the implementation will use dx for &#39;OnesLike&#39; for all shapes in <code>y</code></p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The partial derivatives, the size of the array is the same as the length of the <code>y</code> array.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AddGradients_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFStatus__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>d(y[0] + y[1]+ ...)/dx[0], d(y[0] + y[1] + ...)/dx[1]z...</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AddGradients_" data-uid="TensorFlow.TFGraph.AddGradients*"></a>
  <h4 id="TensorFlow_TFGraph_AddGradients_System_String_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.AddGradients(System.String,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFStatus)">AddGradients(String, TFOutput[], TFOutput[], TFOutput[], TFStatus)</h4>
  <div class="markdown level1 summary"><p>Adds a gradient: the operations needed to compute the partial derivatives of sum of <code>y</code>` wrt to <code>x</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] AddGradients (string prefix, TensorFlow.TFOutput[] y, TensorFlow.TFOutput[] x, TensorFlow.TFOutput[] dx = null, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">prefix</span></td>
        <td><p>names the scope into which all gradients operations are being added.  This must be unique within 
            the provided graph otherwise this operation will fail.  If the value is null, the default prefixing behaviour takes
            place, see AddGradients for more details.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">y</span></td>
        <td><p>The y elements.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">x</span></td>
        <td><p>The x elements.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">dx</span></td>
        <td><p>Initial gradients, which represent the symbolic partial derivatives of some loss function <code>L</code> w.r.t. <code>y</code> ).<br>            If the parameter is null, the implementation will use dx for &#39;OnesLike&#39; for all shapes in <code>y</code></p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The partial derivatives, the size of the array is the same as the length of the <code>y</code> array.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AddGradients_System_String_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFStatus__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>d(y[0] + y[1]+ ...)/dx[0], d(y[0] + y[1] + ...)/dx[1]z...</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AddInitVariable_" data-uid="TensorFlow.TFGraph.AddInitVariable*"></a>
  <h4 id="TensorFlow_TFGraph_AddInitVariable_TensorFlow_TFOperation_" data-uid="TensorFlow.TFGraph.AddInitVariable(TensorFlow.TFOperation)">AddInitVariable(TFOperation)</h4>
  <div class="markdown level1 summary"><p>Registers a specified variable as an initialization variable.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddInitVariable (TensorFlow.TFOperation variable);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><span class="parametername">variable</span></td>
        <td><p>Variable to register.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AddInitVariable_TensorFlow_TFOperation__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>
            This is a convenience method to track the variables that need to be initialized in the graph,
            you can retrieve the list of all those variables by calling the <a class="xref" href="TensorFlow.TFGraph.html#TensorFlow_TFGraph_GetGlobalVariablesInitializer">GetGlobalVariablesInitializer()</a>
            which will return this list and clear the state at that point.
            </p>
    <p>
            You typically use this method from helper methods to register all the variables that you want
            initialized, and a higher level method will retrieve all these variables and initialize them
            at their convenience.
            </p></div>
  
  
  <a id="TensorFlow_TFGraph_AddManySparseToTensorsMap_" data-uid="TensorFlow.TFGraph.AddManySparseToTensorsMap*"></a>
  <h4 id="TensorFlow_TFGraph_AddManySparseToTensorsMap_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.AddManySparseToTensorsMap(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)">AddManySparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Add an <code>N</code>-minibatch <code>SparseTensor</code> to a <code>SparseTensorsMap</code>, return <code>N</code> handles.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AddManySparseToTensorsMap (TensorFlow.TFOutput sparse_indices, TensorFlow.TFOutput sparse_values, TensorFlow.TFOutput sparse_shape, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_indices</span></td>
        <td><p>2-D.  The <code>indices</code> of the minibatch <code>SparseTensor</code>.
              <code>sparse_indices[:, 0]</code> must be ordered values in <code>[0, N)</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_values</span></td>
        <td><p>1-D.  The <code>values</code> of the minibatch <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_shape</span></td>
        <td><p>1-D.  The <code>shape</code> of the minibatch <code>SparseTensor</code>.
              The minibatch size <code>N == sparse_shape[0]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              The container name for the <code>SparseTensorsMap</code> created by this op.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              The shared name for the <code>SparseTensorsMap</code> created by this op.
              If blank, the new Operation&#39;s unique name is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AddManySparseToTensorsMap&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>1-D.  The handles of the <code>SparseTensor</code> now stored in the
              <code>SparseTensorsMap</code>.  Shape: <code>[N]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AddManySparseToTensorsMap_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>A <code>SparseTensor</code> of rank <code>R</code> is represented by three tensors: <code>sparse_indices</code>,
              <code>sparse_values</code>, and <code>sparse_shape</code>, where</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
           sparse_indices.shape[1] == sparse_shape.shape[0] == R
           &lt;/code&gt;&lt;/pre&gt;

          An &lt;code&gt;N&lt;/code&gt;-minibatch of &lt;code&gt;SparseTensor&lt;/code&gt; objects is represented as a &lt;code&gt;SparseTensor&lt;/code&gt;
          having a first &lt;code&gt;sparse_indices&lt;/code&gt; column taking values between &lt;code&gt;[0, N)&lt;/code&gt;, where
          the minibatch size &lt;code&gt;N == sparse_shape[0]&lt;/code&gt;.

          The input &lt;code&gt;SparseTensor&lt;/code&gt; must have rank &lt;code&gt;R&lt;/code&gt; greater than 1, and the first
          dimension is treated as the minibatch dimension.  Elements of the &lt;code&gt;SparseTensor&lt;/code&gt;
          must be sorted in increasing order of this first dimension.  The stored
          &lt;code&gt;SparseTensor&lt;/code&gt; objects pointed to by each row of the output &lt;code&gt;sparse_handles&lt;/code&gt;
          will have rank &lt;code&gt;R-1&lt;/code&gt;.

          The &lt;code&gt;SparseTensor&lt;/code&gt; values can then be read out as part of a minibatch by passing
          the given keys as vector elements to &lt;code&gt;TakeManySparseFromTensorsMap&lt;/code&gt;.  To ensure
          the correct &lt;code&gt;SparseTensorsMap&lt;/code&gt; is accessed, ensure that the same
          &lt;code&gt;container&lt;/code&gt; and &lt;code&gt;shared_name&lt;/code&gt; are passed to that Op.  If no &lt;code&gt;shared_name&lt;/code&gt;
          is provided here, instead use the *name* of the Operation created by calling
          &lt;code&gt;AddManySparseToTensorsMap&lt;/code&gt; as the &lt;code&gt;shared_name&lt;/code&gt; passed to
          &lt;code&gt;TakeManySparseFromTensorsMap&lt;/code&gt;.  Ensure the Operations are colocated.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_AddN_" data-uid="TensorFlow.TFGraph.AddN*"></a>
  <h4 id="TensorFlow_TFGraph_AddN_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.AddN(TensorFlow.TFOutput[],System.String)">AddN(TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Add all input tensors element wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AddN (TensorFlow.TFOutput[] inputs, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>Must all be the same size and shape.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AddN&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_AddSparseToTensorsMap_" data-uid="TensorFlow.TFGraph.AddSparseToTensorsMap*"></a>
  <h4 id="TensorFlow_TFGraph_AddSparseToTensorsMap_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.AddSparseToTensorsMap(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)">AddSparseToTensorsMap(TFOutput, TFOutput, TFOutput, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Add a <code>SparseTensor</code> to a <code>SparseTensorsMap</code> return its handle.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AddSparseToTensorsMap (TensorFlow.TFOutput sparse_indices, TensorFlow.TFOutput sparse_values, TensorFlow.TFOutput sparse_shape, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_indices</span></td>
        <td><p>2-D.  The <code>indices</code> of the <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_values</span></td>
        <td><p>1-D.  The <code>values</code> of the <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_shape</span></td>
        <td><p>1-D.  The <code>shape</code> of the <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              The container name for the <code>SparseTensorsMap</code> created by this op.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              The shared name for the <code>SparseTensorsMap</code> created by this op.
              If blank, the new Operation&#39;s unique name is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AddSparseToTensorsMap&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>0-D.  The handle of the <code>SparseTensor</code> now stored in the
              <code>SparseTensorsMap</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AddSparseToTensorsMap_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>A <code>SparseTensor</code> is represented by three tensors: <code>sparse_indices</code>,
              <code>sparse_values</code>, and <code>sparse_shape</code>.</p>
<pre><code>          This operator takes the given &lt;code&gt;SparseTensor&lt;/code&gt; and adds it to a container
          object (a &lt;code&gt;SparseTensorsMap&lt;/code&gt;).  A unique key within this container is generated
          in the form of an &lt;code&gt;int64&lt;/code&gt;, and this is the value that is returned.

          The &lt;code&gt;SparseTensor&lt;/code&gt; can then be read out as part of a minibatch by passing
          the key as a vector element to &lt;code&gt;TakeManySparseFromTensorsMap&lt;/code&gt;.  To ensure
          the correct &lt;code&gt;SparseTensorsMap&lt;/code&gt; is accessed, ensure that the same
          &lt;code&gt;container&lt;/code&gt; and &lt;code&gt;shared_name&lt;/code&gt; are passed to that Op.  If no &lt;code&gt;shared_name&lt;/code&gt;
          is provided here, instead use the *name* of the Operation created by calling
          &lt;code&gt;AddSparseToTensorsMap&lt;/code&gt; as the &lt;code&gt;shared_name&lt;/code&gt; passed to
          &lt;code&gt;TakeManySparseFromTensorsMap&lt;/code&gt;.  Ensure the Operations are colocated.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_AddV2_" data-uid="TensorFlow.TFGraph.AddV2*"></a>
  <h4 id="TensorFlow_TFGraph_AddV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.AddV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">AddV2(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns x + y element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AddV2 (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AddV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AddV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>Add</code> supports broadcasting. <code>AddN</code> does not. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AdjustContrast_" data-uid="TensorFlow.TFGraph.AdjustContrast*"></a>
  <h4 id="TensorFlow_TFGraph_AdjustContrast_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.AdjustContrast(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">AdjustContrast(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated. Disallowed in GraphDef version &gt;= 2.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AdjustContrast (TensorFlow.TFOutput images, TensorFlow.TFOutput contrast_factor, TensorFlow.TFOutput min_value, TensorFlow.TFOutput max_value, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">images</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">contrast_factor</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_value</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_value</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AdjustContrast&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_AdjustContrastv2_" data-uid="TensorFlow.TFGraph.AdjustContrastv2*"></a>
  <h4 id="TensorFlow_TFGraph_AdjustContrastv2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.AdjustContrastv2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">AdjustContrastv2(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Adjust the contrast of one or more images.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AdjustContrastv2 (TensorFlow.TFOutput images, TensorFlow.TFOutput contrast_factor, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">images</span></td>
        <td><p>Images to adjust.  At least 3-D.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">contrast_factor</span></td>
        <td><p>A float multiplier for adjusting contrast.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AdjustContrastv2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The contrast-adjusted image or images.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AdjustContrastv2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>images</code> is a tensor of at least 3 dimensions.  The last 3 dimensions are
              interpreted as <code>[height, width, channels]</code>.  The other dimensions only
              represent a collection of images, such as <code>[batch, height, width, channels].</code></p>
<pre><code>          Contrast is adjusted independently for each channel of each image.

          For each channel, the Op first computes the mean of the image pixels in the
          channel and then adjusts each component of each pixel to
          &lt;code&gt;(x - mean) * contrast_factor + mean&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_AdjustHue_" data-uid="TensorFlow.TFGraph.AdjustHue*"></a>
  <h4 id="TensorFlow_TFGraph_AdjustHue_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.AdjustHue(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">AdjustHue(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Adjust the hue of one or more images.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AdjustHue (TensorFlow.TFOutput images, TensorFlow.TFOutput delta, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">images</span></td>
        <td><p>Images to adjust.  At least 3-D.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">delta</span></td>
        <td><p>A float delta to add to the hue.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AdjustHue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The hue-adjusted image or images.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AdjustHue_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>images</code> is a tensor of at least 3 dimensions.  The last dimension is
              interpretted as channels, and must be three.</p>
<pre><code>          The input image is considered in the RGB colorspace. Conceptually, the RGB
          colors are first mapped into HSV. A delta is then applied all the hue values,
          and then remapped back to RGB colorspace.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_AdjustSaturation_" data-uid="TensorFlow.TFGraph.AdjustSaturation*"></a>
  <h4 id="TensorFlow_TFGraph_AdjustSaturation_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.AdjustSaturation(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">AdjustSaturation(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Adjust the saturation of one or more images.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AdjustSaturation (TensorFlow.TFOutput images, TensorFlow.TFOutput scale, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">images</span></td>
        <td><p>Images to adjust.  At least 3-D.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">scale</span></td>
        <td><p>A float scale to add to the saturation.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AdjustSaturation&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The hue-adjusted image or images.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AdjustSaturation_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>images</code> is a tensor of at least 3 dimensions.  The last dimension is
              interpretted as channels, and must be three.</p>
<pre><code>          The input image is considered in the RGB colorspace. Conceptually, the RGB
          colors are first mapped into HSV. A scale is then applied all the saturation
          values, and then remapped back to RGB colorspace.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_All_" data-uid="TensorFlow.TFGraph.All*"></a>
  <h4 id="TensorFlow_TFGraph_All_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.All(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">All(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the &quot;logical and&quot; of elements across dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput All (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable&lt;bool&gt; keep_dims = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The tensor to reduce.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reduction_indices</span></td>
        <td><p>The dimensions to reduce. Must be in the range
              <code>[-rank(input), rank(input))</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>Optional argument
              If true, retain reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;All&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_All_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
              <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
              <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
              retained with length 1.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AllCandidateSampler_" data-uid="TensorFlow.TFGraph.AllCandidateSampler*"></a>
  <h4 id="TensorFlow_TFGraph_AllCandidateSampler_TensorFlow_TFOutput_System_Int64_System_Int64_System_Boolean_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.AllCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">AllCandidateSampler(TFOutput, Int64, Int64, Boolean, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Generates labels for candidate sampling with a learned unigram distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; AllCandidateSampler (TensorFlow.TFOutput true_classes, long num_true, long num_sampled, bool unique, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">true_classes</span></td>
        <td><p>A batch_size * num_true matrix, in which each row contains the
              IDs of the num_true target_classes in the corresponding original label.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_true</span></td>
        <td><p>Number of true labels per context.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_sampled</span></td>
        <td><p>Number of candidates to produce.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">unique</span></td>
        <td><p>If unique is true, we sample with rejection, so that all sampled
              candidates in a batch are unique. This requires some approximation to
              estimate the post-rejection sampling probabilities.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              An second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AllCandidateSampler&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sampled_candidates: A vector of length num_sampled, in which each element is
              the ID of a sampled candidate.
              true_expected_count: A batch_size * num_true matrix, representing
              the number of times each candidate is expected to occur in a batch
              of sampled candidates. If unique=true, then this is a probability.
              sampled_expected_count: A vector of length num_sampled, for each sampled
              candidate representing the number of times the candidate is expected
              to occur in a batch of sampled candidates.  If unique=true, then this is a
              probability.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AllCandidateSampler_TensorFlow_TFOutput_System_Int64_System_Int64_System_Boolean_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>See explanations of candidate sampling and the data formats at
              go/candidate-sampling.</p>
<pre><code>          For each batch, this op picks a single set of sampled candidate labels.

          The advantages of sampling candidates per-batch are simplicity and the
          possibility of efficient dense matrix multiplication. The disadvantage is that
          the sampled candidates must be chosen independently of the context and of the
          true labels.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_AllToAll_" data-uid="TensorFlow.TFGraph.AllToAll*"></a>
  <h4 id="TensorFlow_TFGraph_AllToAll_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.AllToAll(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,System.String)">AllToAll(TFOutput, TFOutput, Int64, Int64, Int64, String)</h4>
  <div class="markdown level1 summary"><p>An Op to exchange data across TPU replicas. On each replica, the input is</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AllToAll (TensorFlow.TFOutput input, TensorFlow.TFOutput group_assignment, long concat_dimension, long split_dimension, long split_count, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The local input to the sum.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">group_assignment</span></td>
        <td><p>An int32 tensor with shape
              [num_groups, num_replicas_per_group]. <code>group_assignment[i]</code> represents the
              replica ids in the ith subgroup.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">concat_dimension</span></td>
        <td><p>The dimension number to concatenate.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">split_dimension</span></td>
        <td><p>The dimension number to split.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">split_count</span></td>
        <td><p>The number of splits, this number must equal to the sub-group
              size(group_assignment.get_shape()[1])</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AllToAll&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The exchanged result.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AllToAll_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>split into <code>split_count</code> blocks along <code>split_dimension</code> and send to the other
              replicas given group_assignment. After receiving <code>split_count</code> - 1 blocks from
              other replicas, we concatenate the blocks along <code>concat_dimension</code> as the
              output.</p>
<pre><code>          For example, suppose there are 2 TPU replicas:
          replica 0 receives input: &lt;code&gt;[[A, B]]&lt;/code&gt;
          replica 1 receives input: &lt;code&gt;[[C, D]]&lt;/code&gt;

          group_assignment=&lt;code&gt;[[0, 1]]&lt;/code&gt;
          concat_dimension=0
          split_dimension=1
          split_count=2

          replica 0&#39;s output: &lt;code&gt;[[A], [C]]&lt;/code&gt;
          replica 1&#39;s output: &lt;code&gt;[[B], [D]]&lt;/code&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Angle_" data-uid="TensorFlow.TFGraph.Angle*"></a>
  <h4 id="TensorFlow_TFGraph_Angle_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.Angle(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">Angle(TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns the argument of a complex number.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Angle (TensorFlow.TFOutput input, Nullable&lt;TensorFlow.TFDataType&gt; Tout = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">Tout</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Angle&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Angle_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of
              type <code>float</code> that is the argument of each element in <code>input</code>. All elements in
              <code>input</code> must be complex numbers of the form \(a + bj\), where <em>a</em>
              is the real part and <em>b</em> is the imaginary part.</p>
<pre><code>          The argument returned by this operation is of the form \\(atan2(b, a)\\).

          For example:

           &lt;pre&gt;&lt;code&gt;
          # tensor &#39;input&#39; is [-2.25 + 4.75j, 3.25 + 5.75j]
          tf.angle(input) ==&amp;gt; [2.0132, 1.056]
           &lt;/code&gt;&lt;/pre&gt;

          @compatibility(numpy)
          Equivalent to np.angle.
          @end_compatibility
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_AnonymousIterator_" data-uid="TensorFlow.TFGraph.AnonymousIterator*"></a>
  <h4 id="TensorFlow_TFGraph_AnonymousIterator_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.AnonymousIterator(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">AnonymousIterator(TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>A container for an iterator resource.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AnonymousIterator (TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AnonymousIterator&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A handle to the iterator that can be passed to a &quot;MakeIterator&quot; or
              &quot;IteratorGetNext&quot; op. In contrast to Iterator, AnonymousIterator prevents
              resource sharing by name, and does not keep a reference to the resource
              container.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Any_" data-uid="TensorFlow.TFGraph.Any*"></a>
  <h4 id="TensorFlow_TFGraph_Any_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Any(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">Any(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the &quot;logical or&quot; of elements across dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Any (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable&lt;bool&gt; keep_dims = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The tensor to reduce.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reduction_indices</span></td>
        <td><p>The dimensions to reduce. Must be in the range
              <code>[-rank(input), rank(input))</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>Optional argument
              If true, retain reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Any&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Any_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
              <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
              <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
              retained with length 1.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ApplyAdadelta_" data-uid="TensorFlow.TFGraph.ApplyAdadelta*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyAdadelta_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the adadelta scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyAdadelta (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput accum_update, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum_update</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rho</span></td>
        <td><p>Decay factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Constant factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, updating of the var, accum and update_accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyAdadelta&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ApplyAdadelta_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>accum = rho() * accum + (1 - rho()) * grad.square();
              update = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;
              update_accum = rho() * update_accum + (1 - rho()) * update.square();
              var -= update;</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ApplyAdagrad_" data-uid="TensorFlow.TFGraph.ApplyAdagrad*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">ApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the adagrad scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, Nullable&lt;bool&gt; update_slots = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">update_slots</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyAdagrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ApplyAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>accum += grad * grad
              var -= lr * grad * (1 / sqrt(accum))</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ApplyAdagradDA_" data-uid="TensorFlow.TFGraph.ApplyAdagradDA*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyAdagradDA_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the proximal adagrad scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyAdagradDA (TensorFlow.TFOutput var, TensorFlow.TFOutput gradient_accumulator, TensorFlow.TFOutput gradient_squared_accumulator, TensorFlow.TFOutput grad, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput global_step, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_accumulator</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_squared_accumulator</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">global_step</span></td>
        <td><p>Training step number. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyAdagradDA&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ApplyAdam_" data-uid="TensorFlow.TFGraph.ApplyAdam*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyAdam_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyAdam(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">ApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the Adam algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyAdam (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput v, TensorFlow.TFOutput beta1_power, TensorFlow.TFOutput beta2_power, TensorFlow.TFOutput lr, TensorFlow.TFOutput beta1, TensorFlow.TFOutput beta2, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, Nullable&lt;bool&gt; use_nesterov = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">m</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">v</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta1_power</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta2_power</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta1</span></td>
        <td><p>Momentum factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta2</span></td>
        <td><p>Momentum factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Ridge term. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var, m, and v tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_nesterov</span></td>
        <td><p>Optional argument
              If <code>True</code>, uses the nesterov update.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyAdam&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ApplyAdam_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>$$lr_t := \text{learning_rate} * \sqrt{1 - beta_2^t} / (1 - beta_1^t)$$
              $$m_t := beta_1 * m_{t-1} + (1 - beta_1) * g$$
              $$v_t := beta_2 * v_{t-1} + (1 - beta_2) * g * g$$
              $$variable := variable - lr_t * m_t / (\sqrt{v_t} + \epsilon)$$</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ApplyAdaMax_" data-uid="TensorFlow.TFGraph.ApplyAdaMax*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyAdaMax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyAdaMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the AdaMax algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyAdaMax (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput v, TensorFlow.TFOutput beta1_power, TensorFlow.TFOutput lr, TensorFlow.TFOutput beta1, TensorFlow.TFOutput beta2, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">m</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">v</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta1_power</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta1</span></td>
        <td><p>Momentum factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta2</span></td>
        <td><p>Momentum factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Ridge term. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var, m, and v tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyAdaMax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ApplyAdaMax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>m_t &lt;- beta1 * m_{t-1} + (1 - beta1) * g
              v_t &lt;- max(beta2 * v_{t-1}, abs(g))
              variable &lt;- variable - learning_rate / (1 - beta1^t) * m_t / (v_t + epsilon)</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ApplyAddSign_" data-uid="TensorFlow.TFGraph.ApplyAddSign*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyAddSign_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyAddSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the AddSign update.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyAddSign (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput lr, TensorFlow.TFOutput alpha, TensorFlow.TFOutput sign_decay, TensorFlow.TFOutput beta, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">m</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">alpha</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sign_decay</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and m tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyAddSign&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ApplyAddSign_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>m_t &lt;- beta1 * m_{t-1} + (1 - beta1) * g
              update &lt;- (alpha + sign_decay * sign(g) *sign(m)) * g
              variable &lt;- variable - lr_t * update</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ApplyCenteredRMSProp_" data-uid="TensorFlow.TFGraph.ApplyCenteredRMSProp*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyCenteredRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the centered RMSProp algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyCenteredRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput mg, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mg</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ms</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mom</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rho</span></td>
        <td><p>Decay rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momentum</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Ridge term. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var, mg, ms, and mom tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyCenteredRMSProp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ApplyCenteredRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The centered RMSProp algorithm uses an estimate of the centered second moment
              (i.e., the variance) for normalization, as opposed to regular RMSProp, which
              uses the (uncentered) second moment. This often helps with training, but is
              slightly more expensive in terms of computation and memory.</p>
<pre><code>          Note that in dense implementation of this algorithm, mg, ms, and mom will
          update even if the grad is zero, but in this sparse implementation, mg, ms,
          and mom will not update in iterations during which the grad is zero.

          mean_square = decay * mean_square + (1-decay) * gradient ** 2
          mean_grad = decay * mean_grad + (1-decay) * gradient

          Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)

          mg &amp;lt;- rho * mg_{t-1} + (1-rho) * grad
          ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
          mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)
          var &amp;lt;- var - mom
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ApplyFtrl_" data-uid="TensorFlow.TFGraph.ApplyFtrl*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyFtrl_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the Ftrl-proximal scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyFtrl (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput lr_power, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">linear</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regulariation. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regulariation. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr_power</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyFtrl&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ApplyFtrl_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>accum_new = accum + grad * grad
              linear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
              accum = accum_new</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ApplyFtrlV2_" data-uid="TensorFlow.TFGraph.ApplyFtrlV2*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyFtrlV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the Ftrl-proximal scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyFtrlV2 (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput l2_shrinkage, TensorFlow.TFOutput lr_power, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">linear</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regulariation. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 shrinkage regulariation. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2_shrinkage</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr_power</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyFtrlV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ApplyFtrlV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>grad_with_shrinkage = grad + 2 * l2_shrinkage * var
              accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
              linear += grad_with_shrinkage +
              (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
              accum = accum_new</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ApplyGradientDescent_" data-uid="TensorFlow.TFGraph.ApplyGradientDescent*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyGradientDescent_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; by subtracting &#39;alpha&#39; * &#39;delta&#39; from it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyGradientDescent (TensorFlow.TFOutput var, TensorFlow.TFOutput alpha, TensorFlow.TFOutput delta, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">alpha</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">delta</span></td>
        <td><p>The change.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyGradientDescent&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ApplyMomentum_" data-uid="TensorFlow.TFGraph.ApplyMomentum*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyMomentum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">ApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the momentum scheme. Set use_nesterov = True if you</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyMomentum (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, TensorFlow.TFOutput momentum, Nullable&lt;bool&gt; use_locking = null, Nullable&lt;bool&gt; use_nesterov = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momentum</span></td>
        <td><p>Momentum. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_nesterov</span></td>
        <td><p>Optional argument
              If <code>True</code>, the tensor passed to compute grad will be
              var - lr * momentum * accum, so in the end, the var you get is actually
              var - lr * momentum * accum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyMomentum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ApplyMomentum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>want to use Nesterov momentum.</p>
<pre><code>          accum = accum * momentum + grad
          var -= lr * accum
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ApplyPowerSign_" data-uid="TensorFlow.TFGraph.ApplyPowerSign*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyPowerSign_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyPowerSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the AddSign update.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyPowerSign (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput lr, TensorFlow.TFOutput logbase, TensorFlow.TFOutput sign_decay, TensorFlow.TFOutput beta, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">m</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">logbase</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sign_decay</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and m tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyPowerSign&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ApplyPowerSign_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>m_t &lt;- beta1 * m_{t-1} + (1 - beta1) * g
              update &lt;- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g
              variable &lt;- variable - lr_t * update</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ApplyProximalAdagrad_" data-uid="TensorFlow.TFGraph.ApplyProximalAdagrad*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyProximalAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;<em>var&#39; and &#39;</em>accum&#39; according to FOBOS with Adagrad learning rate.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyProximalAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyProximalAdagrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ApplyProximalAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>accum += grad * grad
              prox_v = var - lr * grad * (1 / sqrt(accum))
              var = sign(prox_v)/(1+lr<em>l2) * max{|prox_v|-lr</em>l1,0}</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ApplyProximalGradientDescent_" data-uid="TensorFlow.TFGraph.ApplyProximalGradientDescent*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyProximalGradientDescent_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; as FOBOS algorithm with fixed learning rate.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyProximalGradientDescent (TensorFlow.TFOutput var, TensorFlow.TFOutput alpha, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput delta, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">alpha</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">delta</span></td>
        <td><p>The change.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyProximalGradientDescent&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ApplyProximalGradientDescent_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>prox_v = var - alpha * delta
              var = sign(prox_v)/(1+alpha<em>l2) * max{|prox_v|-alpha</em>l1,0}</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ApplyRMSProp_" data-uid="TensorFlow.TFGraph.ApplyRMSProp*"></a>
  <h4 id="TensorFlow_TFGraph_ApplyRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the RMSProp algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApplyRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ms</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mom</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rho</span></td>
        <td><p>Decay rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momentum</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Ridge term. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var, ms, and mom tensors is protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApplyRMSProp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ApplyRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that in dense implementation of this algorithm, ms and mom will
              update even if the grad is zero, but in this sparse implementation, ms
              and mom will not update in iterations during which the grad is zero.</p>
<pre><code>          mean_square = decay * mean_square + (1-decay) * gradient ** 2
          Delta = learning_rate * gradient / sqrt(mean_square + epsilon)

          ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
          mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
          var &amp;lt;- var - mom
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ApproximateEqual_" data-uid="TensorFlow.TFGraph.ApproximateEqual*"></a>
  <h4 id="TensorFlow_TFGraph_ApproximateEqual_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_String_" data-uid="TensorFlow.TFGraph.ApproximateEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String)">ApproximateEqual(TFOutput, TFOutput, Nullable&lt;Single&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns the truth value of abs(x-y) &lt; tolerance element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ApproximateEqual (TensorFlow.TFOutput x, TensorFlow.TFOutput y, Nullable&lt;float&gt; tolerance = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">tolerance</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ApproximateEqual&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ArgMax_" data-uid="TensorFlow.TFGraph.ArgMax*"></a>
  <h4 id="TensorFlow_TFGraph_ArgMax_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.ArgMax(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">ArgMax(TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns the index with the largest value across dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ArgMax (TensorFlow.TFOutput input, TensorFlow.TFOutput dimension, Nullable&lt;TensorFlow.TFDataType&gt; output_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dimension</span></td>
        <td><p>int32 or int64, must be in the range <code>[-rank(input), rank(input))</code>.
              Describes which dimension of the input Tensor to reduce across. For vectors,
              use dimension = 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">output_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ArgMax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ArgMax_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that in case of ties the identity of the return value is not guaranteed.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ArgMin_" data-uid="TensorFlow.TFGraph.ArgMin*"></a>
  <h4 id="TensorFlow_TFGraph_ArgMin_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.ArgMin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">ArgMin(TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns the index with the smallest value across dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ArgMin (TensorFlow.TFOutput input, TensorFlow.TFOutput dimension, Nullable&lt;TensorFlow.TFDataType&gt; output_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dimension</span></td>
        <td><p>int32 or int64, must be in the range <code>[-rank(input), rank(input))</code>.
              Describes which dimension of the input Tensor to reduce across. For vectors,
              use dimension = 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">output_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ArgMin&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ArgMin_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that in case of ties the identity of the return value is not guaranteed.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Asin_" data-uid="TensorFlow.TFGraph.Asin*"></a>
  <h4 id="TensorFlow_TFGraph_Asin_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Asin(TensorFlow.TFOutput,System.String)">Asin(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes asin of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Asin (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Asin&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Asinh_" data-uid="TensorFlow.TFGraph.Asinh*"></a>
  <h4 id="TensorFlow_TFGraph_Asinh_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Asinh(TensorFlow.TFOutput,System.String)">Asinh(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes inverse hyperbolic sine of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Asinh (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Asinh&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Assert_" data-uid="TensorFlow.TFGraph.Assert*"></a>
  <h4 id="TensorFlow_TFGraph_Assert_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.Assert(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">Assert(TFOutput, TFOutput[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Asserts that the given condition is true.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation Assert (TensorFlow.TFOutput condition, TensorFlow.TFOutput[] data, Nullable&lt;long&gt; summarize = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">condition</span></td>
        <td><p>The condition to evaluate.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">data</span></td>
        <td><p>The tensors to print out when condition is false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">summarize</span></td>
        <td><p>Optional argument
              Print this many entries of each tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Assert&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Assert_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If <code>condition</code> evaluates to false, print the list of tensors in <code>data</code>.
              <code>summarize</code> determines how many entries of the tensors to print.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Assign_" data-uid="TensorFlow.TFGraph.Assign*"></a>
  <h4 id="TensorFlow_TFGraph_Assign_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Assign(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">Assign(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;ref&#39; by assigning &#39;value&#39; to it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Assign (TensorFlow.TFOutput reference, TensorFlow.TFOutput value, Nullable&lt;bool&gt; validate_shape = null, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>Should be from a <code>Variable</code> node. May be uninitialized.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>The value to be assigned to the variable.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">validate_shape</span></td>
        <td><p>Optional argument
              If true, the operation will validate that the shape
              of &#39;value&#39; matches the shape of the Tensor being assigned to.  If false,
              &#39;ref&#39; will take on the shape of &#39;value&#39;.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the assignment will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Assign&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>= Same as &quot;ref&quot;.  Returned as a convenience for operations that want
              to use the new value after the variable has been reset.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Assign_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation outputs &quot;ref&quot; after the assignment is done.
              This makes it easier to chain operations that need to use the reset value.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AssignAdd_" data-uid="TensorFlow.TFGraph.AssignAdd*"></a>
  <h4 id="TensorFlow_TFGraph_AssignAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.AssignAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">AssignAdd(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;ref&#39; by adding &#39;value&#39; to it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AssignAdd (TensorFlow.TFOutput reference, TensorFlow.TFOutput value, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>The value to be added to the variable.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the addition will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AssignAdd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>= Same as &quot;ref&quot;.  Returned as a convenience for operations that want
              to use the new value after the variable has been updated.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AssignAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation outputs &quot;ref&quot; after the update is done.
              This makes it easier to chain operations that need to use the reset value.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AssignAddVariableOp_" data-uid="TensorFlow.TFGraph.AssignAddVariableOp*"></a>
  <h4 id="TensorFlow_TFGraph_AssignAddVariableOp_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.AssignAddVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">AssignAddVariableOp(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Adds a value to the current value of a variable.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation AssignAddVariableOp (TensorFlow.TFOutput resource, TensorFlow.TFOutput value, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>handle to the resource in which to store the variable.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>the value by which the variable will be incremented.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AssignAddVariableOp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AssignAddVariableOp_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Any ReadVariableOp with a control dependency on this op is guaranteed to
              see the incremented value or a subsequent newer one.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AssignSub_" data-uid="TensorFlow.TFGraph.AssignSub*"></a>
  <h4 id="TensorFlow_TFGraph_AssignSub_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.AssignSub(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">AssignSub(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;ref&#39; by subtracting &#39;value&#39; from it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AssignSub (TensorFlow.TFOutput reference, TensorFlow.TFOutput value, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>The value to be subtracted to the variable.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AssignSub&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>= Same as &quot;ref&quot;.  Returned as a convenience for operations that want
              to use the new value after the variable has been updated.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AssignSub_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation outputs &quot;ref&quot; after the update is done.
              This makes it easier to chain operations that need to use the reset value.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AssignSubVariableOp_" data-uid="TensorFlow.TFGraph.AssignSubVariableOp*"></a>
  <h4 id="TensorFlow_TFGraph_AssignSubVariableOp_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.AssignSubVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">AssignSubVariableOp(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Subtracts a value from the current value of a variable.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation AssignSubVariableOp (TensorFlow.TFOutput resource, TensorFlow.TFOutput value, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>handle to the resource in which to store the variable.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>the value by which the variable will be incremented.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AssignSubVariableOp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AssignSubVariableOp_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Any ReadVariableOp with a control dependency on this op is guaranteed to
              see the decremented value or a subsequent newer one.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AssignVariableOp_" data-uid="TensorFlow.TFGraph.AssignVariableOp*"></a>
  <h4 id="TensorFlow_TFGraph_AssignVariableOp_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.AssignVariableOp(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">AssignVariableOp(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Assigns a new value to a variable.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation AssignVariableOp (TensorFlow.TFOutput resource, TensorFlow.TFOutput value, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>handle to the resource in which to store the variable.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>the value to set the new tensor to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AssignVariableOp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AssignVariableOp_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Any ReadVariableOp with a control dependency on this op is guaranteed to return
              this value or a subsequent newer value of the variable.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AsString_" data-uid="TensorFlow.TFGraph.AsString*"></a>
  <h4 id="TensorFlow_TFGraph_AsString_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.AsString(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String,System.String)">AsString(TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Converts each entry in the given tensor to strings.  Supports many numeric</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AsString (TensorFlow.TFOutput input, Nullable&lt;long&gt; precision = null, Nullable&lt;bool&gt; scientific = null, Nullable&lt;bool&gt; shortest = null, Nullable&lt;long&gt; width = null, string fill = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">precision</span></td>
        <td><p>Optional argument
              The post-decimal precision to use for floating point numbers.
              Only used if precision &gt; -1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">scientific</span></td>
        <td><p>Optional argument
              Use scientific notation for floating point numbers.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">shortest</span></td>
        <td><p>Optional argument
              Use shortest representation (either scientific or standard) for
              floating point numbers.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">width</span></td>
        <td><p>Optional argument
              Pad pre-decimal numbers to this width.
              Applies to both floating point and integer numbers.
              Only used if width &gt; -1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">fill</span></td>
        <td><p>Optional argument
              The value to pad if width &gt; -1.  If empty, pads with spaces.
              Another typical value is &#39;0&#39;.  String cannot be longer than 1 character.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AsString&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AsString_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>types and boolean.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Atan_" data-uid="TensorFlow.TFGraph.Atan*"></a>
  <h4 id="TensorFlow_TFGraph_Atan_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Atan(TensorFlow.TFOutput,System.String)">Atan(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes atan of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Atan (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Atan&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Atan2_" data-uid="TensorFlow.TFGraph.Atan2*"></a>
  <h4 id="TensorFlow_TFGraph_Atan2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Atan2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Atan2(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes arctangent of <code>y/x</code> element-wise, respecting signs of the arguments.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Atan2 (TensorFlow.TFOutput y, TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Atan2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Atan2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This is the angle ( \theta \in [-\pi, \pi] ) such that
              [ x = r \cos(\theta) ]
              and
              [ y = r \sin(\theta) ]
              where (r = \sqrt(x^2 + y^2) ).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Atanh_" data-uid="TensorFlow.TFGraph.Atanh*"></a>
  <h4 id="TensorFlow_TFGraph_Atanh_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Atanh(TensorFlow.TFOutput,System.String)">Atanh(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes inverse hyperbolic tangent of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Atanh (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Atanh&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_AudioSpectrogram_" data-uid="TensorFlow.TFGraph.AudioSpectrogram*"></a>
  <h4 id="TensorFlow_TFGraph_AudioSpectrogram_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.AudioSpectrogram(TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)">AudioSpectrogram(TFOutput, Int64, Int64, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Produces a visualization of audio data over time.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AudioSpectrogram (TensorFlow.TFOutput input, long window_size, long stride, Nullable&lt;bool&gt; magnitude_squared = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Float representation of audio data.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">window_size</span></td>
        <td><p>How wide the input window is in samples. For the highest efficiency
              this should be a power of two, but other values are accepted.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">stride</span></td>
        <td><p>How widely apart the center of adjacent sample windows should be.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">magnitude_squared</span></td>
        <td><p>Optional argument
              Whether to return the squared magnitude or just the
              magnitude. Using squared magnitude can avoid extra calculations.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AudioSpectrogram&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>3D representation of the audio frequencies as an image.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AudioSpectrogram_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Spectrograms are a standard way of representing audio information as a series of
              slices of frequency information, one slice for each window of time. By joining
              these together into a sequence, they form a distinctive fingerprint of the sound
              over time.</p>
<pre><code>          This op expects to receive audio data as an input, stored as floats in the range
          -1 to 1, together with a window width in samples, and a stride specifying how
          far to move the window between slices. From this it generates a three
          dimensional output. The lowest dimension has an amplitude value for each
          frequency during that time slice. The next dimension is time, with successive
          frequency slices. The final dimension is for the channels in the input, so a
          stereo audio input would have two here for example.

          This means the layout when converted and saved as an image is rotated 90 degrees
          clockwise from a typical spectrogram. Time is descending down the Y axis, and
          the frequency decreases from left to right.

          Each value in the result represents the square root of the sum of the real and
          imaginary parts of an FFT on the current window of samples. In this way, the
          lowest dimension represents the power of each frequency in the current window,
          and adjacent windows are concatenated in the next dimension.

          To get a more intuitive and visual look at what this operation does, you can run
          tensorflow/examples/wav_to_spectrogram to read in an audio file and save out the
          resulting spectrogram as a PNG image.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_AudioSummary_" data-uid="TensorFlow.TFGraph.AudioSummary*"></a>
  <h4 id="TensorFlow_TFGraph_AudioSummary_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Single_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.AudioSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Nullable{System.Int64},System.String)">AudioSummary(TFOutput, TFOutput, Single, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Outputs a <code>Summary</code> protocol buffer with audio.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AudioSummary (TensorFlow.TFOutput tag, TensorFlow.TFOutput tensor, float sample_rate, Nullable&lt;long&gt; max_outputs = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tag</span></td>
        <td><p>Scalar. Used to build the <code>tag</code> attribute of the summary values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>2-D of shape <code>[batch_size, frames]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span></td>
        <td><span class="parametername">sample_rate</span></td>
        <td><p>The sample rate of the signal in hertz.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">max_outputs</span></td>
        <td><p>Optional argument
              Max number of batch elements to generate audio for.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AudioSummary&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Scalar. Serialized <code>Summary</code> protocol buffer.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AudioSummary_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Single_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The summary has up to <code>max_outputs</code> summary values containing audio. The
              audio is built from <code>tensor</code> which must be 3-D with shape <code>[batch_size,
              frames, channels]</code> or 2-D with shape <code>[batch_size, frames]</code>. The values are
              assumed to be in the range of <code>[-1.0, 1.0]</code> with a sample rate of <code>sample_rate</code>.</p>
<pre><code>          The &lt;code&gt;tag&lt;/code&gt; argument is a scalar &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;.  It is used to
          build the &lt;code&gt;tag&lt;/code&gt; of the summary values:

          *  If &lt;code&gt;max_outputs&lt;/code&gt; is 1, the summary value tag is &#39;*tag*/audio&#39;.
          *  If &lt;code&gt;max_outputs&lt;/code&gt; is greater than 1, the summary value tags are
          generated sequentially as &#39;*tag*/audio/0&#39;, &#39;*tag*/audio/1&#39;, etc.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_AudioSummaryV2_" data-uid="TensorFlow.TFGraph.AudioSummaryV2*"></a>
  <h4 id="TensorFlow_TFGraph_AudioSummaryV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.AudioSummaryV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)">AudioSummaryV2(TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Outputs a <code>Summary</code> protocol buffer with audio.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AudioSummaryV2 (TensorFlow.TFOutput tag, TensorFlow.TFOutput tensor, TensorFlow.TFOutput sample_rate, Nullable&lt;long&gt; max_outputs = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tag</span></td>
        <td><p>Scalar. Used to build the <code>tag</code> attribute of the summary values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>2-D of shape <code>[batch_size, frames]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sample_rate</span></td>
        <td><p>The sample rate of the signal in hertz.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">max_outputs</span></td>
        <td><p>Optional argument
              Max number of batch elements to generate audio for.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AudioSummaryV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Scalar. Serialized <code>Summary</code> protocol buffer.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AudioSummaryV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The summary has up to <code>max_outputs</code> summary values containing audio. The
              audio is built from <code>tensor</code> which must be 3-D with shape <code>[batch_size,
              frames, channels]</code> or 2-D with shape <code>[batch_size, frames]</code>. The values are
              assumed to be in the range of <code>[-1.0, 1.0]</code> with a sample rate of <code>sample_rate</code>.</p>
<pre><code>          The &lt;code&gt;tag&lt;/code&gt; argument is a scalar &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;.  It is used to
          build the &lt;code&gt;tag&lt;/code&gt; of the summary values:

          *  If &lt;code&gt;max_outputs&lt;/code&gt; is 1, the summary value tag is &#39;*tag*/audio&#39;.
          *  If &lt;code&gt;max_outputs&lt;/code&gt; is greater than 1, the summary value tags are
          generated sequentially as &#39;*tag*/audio/0&#39;, &#39;*tag*/audio/1&#39;, etc.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_AvgPool_" data-uid="TensorFlow.TFGraph.AvgPool*"></a>
  <h4 id="TensorFlow_TFGraph_AvgPool_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.AvgPool(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">AvgPool(TFOutput, Int64[], Int64[], String, String, String)</h4>
  <div class="markdown level1 summary"><p>Performs average pooling on the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AvgPool (TensorFlow.TFOutput value, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>The size of the sliding window for each dimension of <code>value</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of <code>value</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, in_channels, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AvgPool&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The average pooled output tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_AvgPool_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Each entry in <code>output</code> is the mean of the corresponding size <code>ksize</code>
              window in <code>value</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_AvgPool3D_" data-uid="TensorFlow.TFGraph.AvgPool3D*"></a>
  <h4 id="TensorFlow_TFGraph_AvgPool3D_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.AvgPool3D(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">AvgPool3D(TFOutput, Int64[], Int64[], String, String, String)</h4>
  <div class="markdown level1 summary"><p>Performs 3D average pooling on the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AvgPool3D (TensorFlow.TFOutput input, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>1-D tensor of length 5. The size of the window for each dimension of
              the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D tensor of length 5. The stride of the sliding window for each
              dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              The data format of the input and output data. With the
              default format &quot;NDHWC&quot;, the data is stored in the order of:
              [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCDHW&quot;, the data storage order is:
              [batch, in_channels, in_depth, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AvgPool3D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The average pooled output tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_AvgPool3DGrad_" data-uid="TensorFlow.TFGraph.AvgPool3DGrad*"></a>
  <h4 id="TensorFlow_TFGraph_AvgPool3DGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.AvgPool3DGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">AvgPool3DGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)</h4>
  <div class="markdown level1 summary"><p>Computes gradients of average pooling function.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AvgPool3DGrad (TensorFlow.TFOutput orig_input_shape, TensorFlow.TFOutput grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_input_shape</span></td>
        <td><p>The original input dimensions.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>1-D tensor of length 5. The size of the window for each dimension of
              the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D tensor of length 5. The stride of the sliding window for each
              dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              The data format of the input and output data. With the
              default format &quot;NDHWC&quot;, the data is stored in the order of:
              [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCDHW&quot;, the data storage order is:
              [batch, in_channels, in_depth, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AvgPool3DGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The backprop for input.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_AvgPoolGrad_" data-uid="TensorFlow.TFGraph.AvgPoolGrad*"></a>
  <h4 id="TensorFlow_TFGraph_AvgPoolGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.AvgPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">AvgPoolGrad(TFOutput, TFOutput, Int64[], Int64[], String, String, String)</h4>
  <div class="markdown level1 summary"><p>Computes gradients of the average pooling function.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput AvgPoolGrad (TensorFlow.TFOutput orig_input_shape, TensorFlow.TFOutput grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_input_shape</span></td>
        <td><p>1-D.  Shape of the original input to <code>avg_pool</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.  Gradients w.r.t.
              the output of <code>avg_pool</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>The size of the sliding window for each dimension of the input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, in_channels, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;AvgPoolGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D.  Gradients w.r.t. the input of <code>avg_pool</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Barrier_" data-uid="TensorFlow.TFGraph.Barrier*"></a>
  <h4 id="TensorFlow_TFGraph_Barrier_TensorFlow_TFDataType___TensorFlow_TFShape___System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.Barrier(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)">Barrier(TFDataType[], TFShape[], Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Defines a barrier that persists across different graph executions.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Barrier (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable&lt;long&gt; capacity = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a value.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>Optional argument
              The shape of each component in a value. Each shape must be 1 in the
              first dimension. The length of this attr must be the same as the length of
              component_types.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument
              The capacity of the barrier.  The default capacity is MAX_INT32,
              which is the largest capacity of the underlying queue.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this barrier is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this barrier will be shared under the given name
              across multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Barrier&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to the barrier.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Barrier_TensorFlow_TFDataType___TensorFlow_TFShape___System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>A barrier represents a key-value map, where each key is a string, and
              each value is a tuple of tensors.</p>
<pre><code>          At runtime, the barrier contains &#39;complete&#39; and &#39;incomplete&#39;
          elements. A complete element has defined tensors for all components of
          its value tuple, and may be accessed using BarrierTakeMany. An
          incomplete element has some undefined components in its value tuple,
          and may be updated using BarrierInsertMany.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_BarrierClose_" data-uid="TensorFlow.TFGraph.BarrierClose*"></a>
  <h4 id="TensorFlow_TFGraph_BarrierClose_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.BarrierClose(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">BarrierClose(TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Closes the given barrier.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation BarrierClose (TensorFlow.TFOutput handle, Nullable&lt;bool&gt; cancel_pending_enqueues = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a barrier.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">cancel_pending_enqueues</span></td>
        <td><p>Optional argument
              If true, all pending enqueue requests that are
              blocked on the barrier&#39;s queue will be canceled. InsertMany will fail, even
              if no new key is introduced.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BarrierClose&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BarrierClose_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation signals that no more new elements will be inserted in the
              given barrier. Subsequent InsertMany that try to introduce a new key will fail.
              Subsequent InsertMany operations that just add missing components to already
              existing elements will continue to succeed. Subsequent TakeMany operations will
              continue to succeed if sufficient completed elements remain in the barrier.
              Subsequent TakeMany operations that would block will fail immediately.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BarrierIncompleteSize_" data-uid="TensorFlow.TFGraph.BarrierIncompleteSize*"></a>
  <h4 id="TensorFlow_TFGraph_BarrierIncompleteSize_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BarrierIncompleteSize(TensorFlow.TFOutput,System.String)">BarrierIncompleteSize(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the number of incomplete elements in the given barrier.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BarrierIncompleteSize (TensorFlow.TFOutput handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a barrier.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BarrierIncompleteSize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The number of incomplete elements (i.e. those with some of their value
              components not set) in the barrier.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_BarrierInsertMany_" data-uid="TensorFlow.TFGraph.BarrierInsertMany*"></a>
  <h4 id="TensorFlow_TFGraph_BarrierInsertMany_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.BarrierInsertMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">BarrierInsertMany(TFOutput, TFOutput, TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>For each key, assigns the respective value to the specified component.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation BarrierInsertMany (TensorFlow.TFOutput handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, long component_index, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a barrier.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">keys</span></td>
        <td><p>A one-dimensional tensor of keys, with length n.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>An any-dimensional tensor of values, which are associated with the
              respective keys. The 0th dimension must have length n.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">component_index</span></td>
        <td><p>The component of the barrier elements that is being assigned.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BarrierInsertMany&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BarrierInsertMany_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If a key is not found in the barrier, this operation will create a new
              incomplete element. If a key is found in the barrier, and the element
              already has a value at component_index, this operation will fail with
              INVALID_ARGUMENT, and leave the barrier in an undefined state.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BarrierReadySize_" data-uid="TensorFlow.TFGraph.BarrierReadySize*"></a>
  <h4 id="TensorFlow_TFGraph_BarrierReadySize_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BarrierReadySize(TensorFlow.TFOutput,System.String)">BarrierReadySize(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the number of complete elements in the given barrier.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BarrierReadySize (TensorFlow.TFOutput handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a barrier.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BarrierReadySize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The number of complete elements (i.e. those with all of their value
              components set) in the barrier.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_BarrierTakeMany_" data-uid="TensorFlow.TFGraph.BarrierTakeMany*"></a>
  <h4 id="TensorFlow_TFGraph_BarrierTakeMany_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.BarrierTakeMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)">BarrierTakeMany(TFOutput, TFOutput, TFDataType[], Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Takes the given number of completed elements from a barrier.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[]&gt; BarrierTakeMany (TensorFlow.TFOutput handle, TensorFlow.TFOutput num_elements, TensorFlow.TFDataType[] component_types, Nullable&lt;bool&gt; allow_small_batch = null, Nullable&lt;bool&gt; wait_for_incomplete = null, Nullable&lt;long&gt; timeout_ms = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a barrier.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_elements</span></td>
        <td><p>A single-element tensor containing the number of elements to
              take.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">allow_small_batch</span></td>
        <td><p>Optional argument
              Allow to return less than num_elements items if barrier is
              already closed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">wait_for_incomplete</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">timeout_ms</span></td>
        <td><p>Optional argument
              If the queue is empty, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BarrierTakeMany&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              indices: A one-dimensional tensor of indices, with length num_elems.
              These indices refer to the batch in which the values were placed into the
              barrier (starting with MIN_LONG and increasing with each BarrierInsertMany).
              keys: A one-dimensional tensor of keys, with length num_elements.
              values: One any-dimensional tensor per component in a barrier element. All
              values have length num_elements in the 0th dimension.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BarrierTakeMany_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation concatenates completed-element component tensors along
              the 0th dimension to make a single component tensor.</p>
<pre><code>          Elements come out of the barrier when they are complete, and in the order
          in which they were placed into the barrier.  The indices output provides
          information about the batch in which each element was originally inserted
          into the barrier.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Batch_" data-uid="TensorFlow.TFGraph.Batch*"></a>
  <h4 id="TensorFlow_TFGraph_Batch_TensorFlow_TFOutput___System_Int64_System_Int64_System_Int64_System_Int64_System_Nullable_System_Int64__System_Int64___System_String_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.Batch(TensorFlow.TFOutput[],System.Int64,System.Int64,System.Int64,System.Int64,System.Nullable{System.Int64},System.Int64[],System.String,System.String,System.String,System.String)">Batch(TFOutput[], Int64, Int64, Int64, Int64, Nullable&lt;Int64&gt;, Int64[], String, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Batches all input tensors nondeterministically.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput&gt; Batch (TensorFlow.TFOutput[] in_tensors, long num_batch_threads, long max_batch_size, long batch_timeout_micros, long grad_timeout_micros, Nullable&lt;long&gt; max_enqueued_batches = null, long[] allowed_batch_sizes = null, string container = null, string shared_name = null, string batching_queue = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">in_tensors</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_batch_threads</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">max_batch_size</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">batch_timeout_micros</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">grad_timeout_micros</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">max_enqueued_batches</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">allowed_batch_sizes</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">batching_queue</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Batch&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              batched_tensors:
              batch_index:
              id:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Batch_TensorFlow_TFOutput___System_Int64_System_Int64_System_Int64_System_Int64_System_Nullable_System_Int64__System_Int64___System_String_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>When many instances of this Op are being run concurrently with the same
              container/shared_name in the same device, some will output zero-shaped Tensors
              and others will output Tensors of size up to max_batch_size.</p>
<pre><code>          All Tensors in in_tensors are batched together (so, for example, labels and
          features should be batched with a single instance of this operation.

          Each invocation of batch emits an &lt;code&gt;id&lt;/code&gt; scalar which will be used to identify
          this particular invocation when doing unbatch or its gradient.

          Each op which emits a non-empty batch will also emit a non-empty batch_index
          Tensor, which, is a [K, 3] matrix where each row contains the invocation&#39;s id,
          start, and length of elements of each set of Tensors present in batched_tensors.

          Batched tensors are concatenated along the first dimension, and all tensors in
          in_tensors must have the first dimension of the same size.

          in_tensors: The tensors to be batched.
          num_batch_threads: Number of scheduling threads for processing batches of work.
          Determines the number of batches processed in parallel.
          max_batch_size: Batch sizes will never be bigger than this.
          batch_timeout_micros: Maximum number of microseconds to wait before outputting
          an incomplete batch.
          allowed_batch_sizes: Optional list of allowed batch sizes. If left empty, does
          nothing. Otherwise, supplies a list of batch sizes, causing the op to pad
          batches up to one of those sizes. The entries must increase monotonically, and
          the final entry must equal max_batch_size.
          grad_timeout_micros: The timeout to use for the gradient. See Unbatch.
          batched_tensors: Either empty tensors or a batch of concatenated Tensors.
          batch_index: If out_tensors is non-empty, has information to invert it.
          container: Controls the scope of sharing of this batch.
          id: always contains a scalar with a unique ID for this invocation of Batch.
          shared_name: Concurrently running instances of batch in the same device with the
          same container and shared_name will batch their elements together. If left
          empty, the op name will be used as the shared name.
          T: the types of tensors to be batched.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_BatchDataset_" data-uid="TensorFlow.TFGraph.BatchDataset*"></a>
  <h4 id="TensorFlow_TFGraph_BatchDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.BatchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">BatchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that batches <code>batch_size</code> elements from <code>input_dataset</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BatchDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput batch_size, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">batch_size</span></td>
        <td><p>A scalar representing the number of elements to accumulate in a
              batch.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BatchDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_BatchDatasetV2_" data-uid="TensorFlow.TFGraph.BatchDatasetV2*"></a>
  <h4 id="TensorFlow_TFGraph_BatchDatasetV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.BatchDatasetV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">BatchDatasetV2(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that batches <code>batch_size</code> elements from <code>input_dataset</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BatchDatasetV2 (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput batch_size, TensorFlow.TFOutput drop_remainder, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">batch_size</span></td>
        <td><p>A scalar representing the number of elements to accumulate in a batch.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">drop_remainder</span></td>
        <td><p>A scalar representing whether the last batch should be dropped in case its size
              is smaller than desired.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BatchDatasetV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_BatchMatMul_" data-uid="TensorFlow.TFGraph.BatchMatMul*"></a>
  <h4 id="TensorFlow_TFGraph_BatchMatMul_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.BatchMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">BatchMatMul(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Multiplies slices of two tensors in batches.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BatchMatMul (TensorFlow.TFOutput x, TensorFlow.TFOutput y, Nullable&lt;bool&gt; adj_x = null, Nullable&lt;bool&gt; adj_y = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>2-D or higher with shape <code>[..., r_x, c_x]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>2-D or higher with shape <code>[..., r_y, c_y]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">adj_x</span></td>
        <td><p>Optional argument
              If <code>True</code>, adjoint the slices of <code>x</code>. Defaults to <code>False</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">adj_y</span></td>
        <td><p>Optional argument
              If <code>True</code>, adjoint the slices of <code>y</code>. Defaults to <code>False</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BatchMatMul&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>3-D or higher with shape <code>[..., r_o, c_o]</code>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BatchMatMul_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Multiplies all slices of <code>Tensor</code><code>x</code> and <code>y</code> (each slice can be
              viewed as an element of a batch), and arranges the individual results
              in a single output tensor of the same batch size. Each of the
              individual slices can optionally be adjointed (to adjoint a matrix
              means to transpose and conjugate it) before multiplication by setting
              the <code>adj_x</code> or <code>adj_y</code> flag to <code>True</code>, which are by default <code>False</code>.</p>
<pre><code>          The input tensors &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are 2-D or higher with shape &lt;code&gt;[..., r_x, c_x]&lt;/code&gt;
          and &lt;code&gt;[..., r_y, c_y]&lt;/code&gt;.

          The output tensor is 2-D or higher with shape &lt;code&gt;[..., r_o, c_o]&lt;/code&gt;, where:

          r_o = c_x if adj_x else r_x
          c_o = r_y if adj_y else c_y

          It is computed as:

          output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_BatchNormWithGlobalNormalization_" data-uid="TensorFlow.TFGraph.BatchNormWithGlobalNormalization*"></a>
  <h4 id="TensorFlow_TFGraph_BatchNormWithGlobalNormalization_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Single_System_Boolean_System_String_" data-uid="TensorFlow.TFGraph.BatchNormWithGlobalNormalization(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Boolean,System.String)">BatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)</h4>
  <div class="markdown level1 summary"><p>Batch normalization.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BatchNormWithGlobalNormalization (TensorFlow.TFOutput t, TensorFlow.TFOutput m, TensorFlow.TFOutput v, TensorFlow.TFOutput beta, TensorFlow.TFOutput gamma, float variance_epsilon, bool scale_after_normalization, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">t</span></td>
        <td><p>A 4D input Tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">m</span></td>
        <td><p>A 1D mean Tensor with size matching the last dimension of t.
              This is the first output from tf.nn.moments,
              or a saved moving average thereof.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">v</span></td>
        <td><p>A 1D variance Tensor with size matching the last dimension of t.
              This is the second output from tf.nn.moments,
              or a saved moving average thereof.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta</span></td>
        <td><p>A 1D beta Tensor with size matching the last dimension of t.
              An offset to be added to the normalized tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gamma</span></td>
        <td><p>A 1D gamma Tensor with size matching the last dimension of t.
              If &quot;scale_after_normalization&quot; is true, this tensor will be multiplied
              with the normalized tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span></td>
        <td><span class="parametername">variance_epsilon</span></td>
        <td><p>A small float number to avoid dividing by 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">scale_after_normalization</span></td>
        <td><p>A bool indicating whether the resulted tensor
              needs to be multiplied with gamma.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BatchNormWithGlobalNormalization&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BatchNormWithGlobalNormalization_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Single_System_Boolean_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op is deprecated. Prefer <code>tf.nn.batch_normalization</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BatchNormWithGlobalNormalizationGrad_" data-uid="TensorFlow.TFGraph.BatchNormWithGlobalNormalizationGrad*"></a>
  <h4 id="TensorFlow_TFGraph_BatchNormWithGlobalNormalizationGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Single_System_Boolean_System_String_" data-uid="TensorFlow.TFGraph.BatchNormWithGlobalNormalizationGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Single,System.Boolean,System.String)">BatchNormWithGlobalNormalizationGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Single, Boolean, String)</h4>
  <div class="markdown level1 summary"><p>Gradients for batch normalization.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; BatchNormWithGlobalNormalizationGrad (TensorFlow.TFOutput t, TensorFlow.TFOutput m, TensorFlow.TFOutput v, TensorFlow.TFOutput gamma, TensorFlow.TFOutput backprop, float variance_epsilon, bool scale_after_normalization, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">t</span></td>
        <td><p>A 4D input Tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">m</span></td>
        <td><p>A 1D mean Tensor with size matching the last dimension of t.
              This is the first output from tf.nn.moments,
              or a saved moving average thereof.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">v</span></td>
        <td><p>A 1D variance Tensor with size matching the last dimension of t.
              This is the second output from tf.nn.moments,
              or a saved moving average thereof.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gamma</span></td>
        <td><p>A 1D gamma Tensor with size matching the last dimension of t.
              If &quot;scale_after_normalization&quot; is true, this Tensor will be multiplied
              with the normalized Tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">backprop</span></td>
        <td><p>4D backprop Tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span></td>
        <td><span class="parametername">variance_epsilon</span></td>
        <td><p>A small float number to avoid dividing by 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">scale_after_normalization</span></td>
        <td><p>A bool indicating whether the resulted tensor
              needs to be multiplied with gamma.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BatchNormWithGlobalNormalizationGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              dx: 4D backprop tensor for input.
              dm: 1D backprop tensor for mean.
              dv: 1D backprop tensor for variance.
              db: 1D backprop tensor for beta.
              dg: 1D backprop tensor for gamma.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BatchNormWithGlobalNormalizationGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Single_System_Boolean_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op is deprecated. See <code>tf.nn.batch_normalization</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BatchToSpace_" data-uid="TensorFlow.TFGraph.BatchToSpace*"></a>
  <h4 id="TensorFlow_TFGraph_BatchToSpace_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.BatchToSpace(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">BatchToSpace(TFOutput, TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>BatchToSpace for 4-D tensors of type T.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BatchToSpace (TensorFlow.TFOutput input, TensorFlow.TFOutput crops, long block_size, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D tensor with shape
              <code>[batch<em>block_size</em>block_size, height_pad/block_size, width_pad/block_size,
              depth]</code>. Note that the batch size of the input tensor must be divisible by
              <code>block_size * block_size</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">crops</span></td>
        <td><p>2-D tensor of non-negative integers with shape <code>[2, 2]</code>. It specifies
              how many elements to crop from the intermediate result across the spatial
              dimensions as follows:</p>
<pre><code>          crops = [[crop_top, crop_bottom], [crop_left, crop_right]]
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">block_size</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BatchToSpace&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape <code>[batch, height, width, depth]</code>, where:</p>
<pre><code>          height = height_pad - crop_top - crop_bottom
          width = width_pad - crop_left - crop_right

          The attr &lt;code&gt;block_size&lt;/code&gt; must be greater than one. It indicates the block size.

          Some examples:

          (1) For the following input of shape &lt;code&gt;[4, 1, 1, 1]&lt;/code&gt; and block_size of 2:

           &lt;pre&gt;&lt;code&gt;
          [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1], [2]], [[3], [4]]]]
           &lt;/code&gt;&lt;/pre&gt;

          (2) For the following input of shape &lt;code&gt;[4, 1, 1, 3]&lt;/code&gt; and block_size of 2:

           &lt;pre&gt;&lt;code&gt;
          [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1, 2, 3], [4, 5, 6]],
          [[7, 8, 9], [10, 11, 12]]]]
           &lt;/code&gt;&lt;/pre&gt;

          (3) For the following input of shape &lt;code&gt;[4, 2, 2, 1]&lt;/code&gt; and block_size of 2:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1], [3]], [[9], [11]]],
          [[[2], [4]], [[10], [12]]],
          [[[5], [7]], [[13], [15]]],
          [[[6], [8]], [[14], [16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[1, 4, 4, 1]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          x = [[[1],   [2],  [3],  [4]],
          [[5],   [6],  [7],  [8]],
          [[9],  [10], [11],  [12]],
          [[13], [14], [15],  [16]]]
           &lt;/code&gt;&lt;/pre&gt;

          (4) For the following input of shape &lt;code&gt;[8, 1, 2, 1]&lt;/code&gt; and block_size of 2:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],
          [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[2, 2, 4, 1]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1], [3]], [[5], [7]]],
          [[[2], [4]], [[10], [12]]],
          [[[5], [7]], [[13], [15]]],
          [[[6], [8]], [[14], [16]]]]
           &lt;/code&gt;&lt;/pre&gt;
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BatchToSpace_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This is a legacy version of the more general BatchToSpaceND.</p>
<pre><code>          Rearranges (permutes) data from batch into blocks of spatial data, followed by
          cropping. This is the reverse transformation of SpaceToBatch. More specifically,
          this op outputs a copy of the input tensor where values from the &lt;code&gt;batch&lt;/code&gt;
          dimension are moved in spatial blocks to the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; dimensions,
          followed by cropping along the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; dimensions.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_BatchToSpaceND_" data-uid="TensorFlow.TFGraph.BatchToSpaceND*"></a>
  <h4 id="TensorFlow_TFGraph_BatchToSpaceND_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BatchToSpaceND(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">BatchToSpaceND(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>BatchToSpace for N-D tensors of type T.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BatchToSpaceND (TensorFlow.TFOutput input, TensorFlow.TFOutput block_shape, TensorFlow.TFOutput crops, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>N-D with shape <code>input_shape = [batch] + spatial_shape + remaining_shape</code>,
              where spatial_shape has M dimensions.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">block_shape</span></td>
        <td><p>1-D with shape <code>[M]</code>, all values must be &gt;= 1.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">crops</span></td>
        <td><p>2-D with shape <code>[M, 2]</code>, all values must be &gt;= 0.
              <code>crops[i] = [crop_start, crop_end]</code> specifies the amount to crop from input
              dimension <code>i + 1</code>, which corresponds to spatial dimension <code>i</code>.  It is
              required that
              <code>crop_start[i] + crop_end[i] &lt;= block_shape[i] * input_shape[i + 1]</code>.</p>
<pre><code>          This operation is equivalent to the following steps:

          1. Reshape &lt;code&gt;input&lt;/code&gt; to &lt;code&gt;reshaped&lt;/code&gt; of shape:
          [block_shape[0], ..., block_shape[M-1],
          batch / prod(block_shape),
          input_shape[1], ..., input_shape[N-1]]

          2. Permute dimensions of &lt;code&gt;reshaped&lt;/code&gt; to produce &lt;code&gt;permuted&lt;/code&gt; of shape
          [batch / prod(block_shape),

          input_shape[1], block_shape[0],
          ...,
          input_shape[M], block_shape[M-1],

          input_shape[M+1], ..., input_shape[N-1]]

          3. Reshape &lt;code&gt;permuted&lt;/code&gt; to produce &lt;code&gt;reshaped_permuted&lt;/code&gt; of shape
          [batch / prod(block_shape),

          input_shape[1] * block_shape[0],
          ...,
          input_shape[M] * block_shape[M-1],

          input_shape[M+1],
          ...,
          input_shape[N-1]]

          4. Crop the start and end of dimensions &lt;code&gt;[1, ..., M]&lt;/code&gt; of
          &lt;code&gt;reshaped_permuted&lt;/code&gt; according to &lt;code&gt;crops&lt;/code&gt; to produce the output of shape:
          [batch / prod(block_shape),

          input_shape[1] * block_shape[0] - crops[0,0] - crops[0,1],
          ...,
          input_shape[M] * block_shape[M-1] - crops[M-1,0] - crops[M-1,1],

          input_shape[M+1], ..., input_shape[N-1]]

          Some examples:

          (1) For the following input of shape &lt;code&gt;[4, 1, 1, 1]&lt;/code&gt;, &lt;code&gt;block_shape = [2, 2]&lt;/code&gt;, and
          &lt;code&gt;crops = [[0, 0], [0, 0]]&lt;/code&gt;:

           &lt;pre&gt;&lt;code&gt;
          [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1], [2]], [[3], [4]]]]
           &lt;/code&gt;&lt;/pre&gt;

          (2) For the following input of shape &lt;code&gt;[4, 1, 1, 3]&lt;/code&gt;, &lt;code&gt;block_shape = [2, 2]&lt;/code&gt;, and
          &lt;code&gt;crops = [[0, 0], [0, 0]]&lt;/code&gt;:

           &lt;pre&gt;&lt;code&gt;
          [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1, 2, 3], [4, 5, 6]],
          [[7, 8, 9], [10, 11, 12]]]]
           &lt;/code&gt;&lt;/pre&gt;

          (3) For the following input of shape &lt;code&gt;[4, 2, 2, 1]&lt;/code&gt;, &lt;code&gt;block_shape = [2, 2]&lt;/code&gt;, and
          &lt;code&gt;crops = [[0, 0], [0, 0]]&lt;/code&gt;:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1], [3]], [[9], [11]]],
          [[[2], [4]], [[10], [12]]],
          [[[5], [7]], [[13], [15]]],
          [[[6], [8]], [[14], [16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[1, 4, 4, 1]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          x = [[[1],   [2],  [3],  [4]],
          [[5],   [6],  [7],  [8]],
          [[9],  [10], [11],  [12]],
          [[13], [14], [15],  [16]]]
           &lt;/code&gt;&lt;/pre&gt;

          (4) For the following input of shape &lt;code&gt;[8, 1, 3, 1]&lt;/code&gt;, &lt;code&gt;block_shape = [2, 2]&lt;/code&gt;, and
          &lt;code&gt;crops = [[0, 0], [2, 0]]&lt;/code&gt;:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[0], [1], [3]]], [[[0], [9], [11]]],
          [[[0], [2], [4]]], [[[0], [10], [12]]],
          [[[0], [5], [7]]], [[[0], [13], [15]]],
          [[[0], [6], [8]]], [[[0], [14], [16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[2, 2, 4, 1]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1],   [2],  [3],  [4]],
          [[5],   [6],  [7],  [8]]],
          [[[9],  [10], [11],  [12]],
          [[13], [14], [15],  [16]]]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BatchToSpaceND&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BatchToSpaceND_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation reshapes the &quot;batch&quot; dimension 0 into <code>M + 1</code> dimensions of shape
              <code>block_shape + [batch]</code>, interleaves these blocks back into the grid defined by
              the spatial dimensions <code>[1, ..., M]</code>, to obtain a result with the same rank as
              the input.  The spatial dimensions of this intermediate result are then
              optionally cropped according to <code>crops</code> to produce the output.  This is the
              reverse of SpaceToBatch.  See below for a precise description.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BesselI0e_" data-uid="TensorFlow.TFGraph.BesselI0e*"></a>
  <h4 id="TensorFlow_TFGraph_BesselI0e_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BesselI0e(TensorFlow.TFOutput,System.String)">BesselI0e(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the Bessel i0e function of <code>x</code> element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BesselI0e (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BesselI0e&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BesselI0e_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Exponentially scaled modified Bessel function of order 0 defined as
              <code>bessel_i0e(x) = exp(-abs(x)) bessel_i0(x)</code>.</p>
<pre><code>          This function is faster and numerically stabler than &lt;code&gt;bessel_i0(x)&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_BesselI1e_" data-uid="TensorFlow.TFGraph.BesselI1e*"></a>
  <h4 id="TensorFlow_TFGraph_BesselI1e_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BesselI1e(TensorFlow.TFOutput,System.String)">BesselI1e(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the Bessel i1e function of <code>x</code> element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BesselI1e (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BesselI1e&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BesselI1e_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Exponentially scaled modified Bessel function of order 0 defined as
              <code>bessel_i1e(x) = exp(-abs(x)) bessel_i1(x)</code>.</p>
<pre><code>          This function is faster and numerically stabler than &lt;code&gt;bessel_i1(x)&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Betainc_" data-uid="TensorFlow.TFGraph.Betainc*"></a>
  <h4 id="TensorFlow_TFGraph_Betainc_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Betainc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Betainc(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Compute the regularized incomplete beta integral \(I_x(a, b)\).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Betainc (TensorFlow.TFOutput a, TensorFlow.TFOutput b, TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Betainc&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Betainc_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The regularized incomplete beta integral is defined as:</p>
<pre><code>          \\(I_x(a, b) = \frac{B(x; a, b)}{B(a, b)}\\)

          where


          \\(B(x; a, b) = \int_0^x t^{a-1} (1 - t)^{b-1} dt\\)


          is the incomplete beta function and \\(B(a, b)\\) is the *complete*
          beta function.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_BiasAdd_" data-uid="TensorFlow.TFGraph.BiasAdd*"></a>
  <h4 id="TensorFlow_TFGraph_BiasAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.BiasAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">BiasAdd(TFOutput, TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>Adds <code>bias</code> to <code>value</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BiasAdd (TensorFlow.TFOutput value, TensorFlow.TFOutput bias, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>Any number of dimensions.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">bias</span></td>
        <td><p>1-D with size the last dimension of <code>value</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the bias tensor will be added to the last dimension
              of the value tensor.
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, in_channels, in_height, in_width].
              The tensor will be added to &quot;in_channels&quot;, the third-to-the-last
              dimension.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BiasAdd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Broadcasted sum of <code>value</code> and <code>bias</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BiasAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This is a special case of <code>tf.add</code> where <code>bias</code> is restricted to be 1-D.
              Broadcasting is supported, so <code>value</code> may have any number of dimensions.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BiasAddGrad_" data-uid="TensorFlow.TFGraph.BiasAddGrad*"></a>
  <h4 id="TensorFlow_TFGraph_BiasAddGrad_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.BiasAddGrad(TensorFlow.TFOutput,System.String,System.String)">BiasAddGrad(TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>The backward operation for &quot;BiasAdd&quot; on the &quot;bias&quot; tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BiasAddGrad (TensorFlow.TFOutput out_backprop, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">out_backprop</span></td>
        <td><p>Any number of dimensions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the bias tensor will be added to the last dimension
              of the value tensor.
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, in_channels, in_height, in_width].
              The tensor will be added to &quot;in_channels&quot;, the third-to-the-last
              dimension.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BiasAddGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>1-D with size the feature dimension of <code>out_backprop</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BiasAddGrad_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>It accumulates all the values from out_backprop into the feature dimension.
              For NHWC data format, the feature dimension is the last. For NCHW data format,
              the feature dimension is the third-to-last.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BiasAddV1_" data-uid="TensorFlow.TFGraph.BiasAddV1*"></a>
  <h4 id="TensorFlow_TFGraph_BiasAddV1_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BiasAddV1(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">BiasAddV1(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Adds <code>bias</code> to <code>value</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BiasAddV1 (TensorFlow.TFOutput value, TensorFlow.TFOutput bias, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>Any number of dimensions.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">bias</span></td>
        <td><p>1-D with size the last dimension of <code>value</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BiasAddV1&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Broadcasted sum of <code>value</code> and <code>bias</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BiasAddV1_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This is a deprecated version of BiasAdd and will be soon removed.</p>
<pre><code>          This is a special case of &lt;code&gt;tf.add&lt;/code&gt; where &lt;code&gt;bias&lt;/code&gt; is restricted to be 1-D.
          Broadcasting is supported, so &lt;code&gt;value&lt;/code&gt; may have any number of dimensions.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_BigQueryReader_" data-uid="TensorFlow.TFGraph.BigQueryReader*"></a>
  <h4 id="TensorFlow_TFGraph_BigQueryReader_System_String_System_String_System_String_System_String___System_Int64_System_String_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.BigQueryReader(System.String,System.String,System.String,System.String[],System.Int64,System.String,System.String,System.String,System.String)">BigQueryReader(String, String, String, String[], Int64, String, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A Reader that outputs rows from a BigQuery table as tensorflow Examples.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BigQueryReader (string project_id, string dataset_id, string table_id, string[] columns, long timestamp_millis, string container = null, string shared_name = null, string test_end_point = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">project_id</span></td>
        <td><p>GCP project ID.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">dataset_id</span></td>
        <td><p>BigQuery Dataset ID.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Table to read.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">columns</span></td>
        <td><p>List of columns to read. Leave empty to read all columns.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">timestamp_millis</span></td>
        <td><p>Table snapshot timestamp in millis since epoch. Relative
              (negative or zero) snapshot times are not allowed. For more details, see
              &#39;Table Decorators&#39; in BigQuery docs.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">test_end_point</span></td>
        <td><p>Optional argument
              Do not use. For testing purposes only.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BigQueryReader&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Bincount_" data-uid="TensorFlow.TFGraph.Bincount*"></a>
  <h4 id="TensorFlow_TFGraph_Bincount_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Bincount(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Bincount(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Counts the number of occurrences of each value in an integer array.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Bincount (TensorFlow.TFOutput arr, TensorFlow.TFOutput size, TensorFlow.TFOutput weights, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">arr</span></td>
        <td><p>int32 <code>Tensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>non-negative int32 scalar <code>Tensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">weights</span></td>
        <td><p>is an int32, int64, float32, or float64 <code>Tensor</code> with the same
              shape as <code>arr</code>, or a length-0 <code>Tensor</code>, in which case it acts as all weights
              equal to 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Bincount&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>1D <code>Tensor</code> with length equal to <code>size</code>. The counts or summed weights for
              each value in the range [0, size).
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Bincount_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Outputs a vector with length <code>size</code> and the same dtype as <code>weights</code>. If
              <code>weights</code> are empty, then index <code>i</code> stores the number of times the value <code>i</code> is
              counted in <code>arr</code>. If <code>weights</code> are non-empty, then index <code>i</code> stores the sum of
              the value in <code>weights</code> at each index where the corresponding value in <code>arr</code> is
              <code>i</code>.</p>
<pre><code>          Values in &lt;code&gt;arr&lt;/code&gt; outside of the range [0, size) are ignored.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Bitcast_" data-uid="TensorFlow.TFGraph.Bitcast*"></a>
  <h4 id="TensorFlow_TFGraph_Bitcast_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.Bitcast(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">Bitcast(TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Bitcasts a tensor from one type to another without copying data.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Bitcast (TensorFlow.TFOutput input, TensorFlow.TFDataType type, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">type</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Bitcast&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Bitcast_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a tensor <code>input</code>, this operation returns a tensor that has the same buffer
              data as <code>input</code> with datatype <code>type</code>.</p>
<pre><code>          If the input datatype &lt;code&gt;T&lt;/code&gt; is larger than the output datatype &lt;code&gt;type&lt;/code&gt; then the
          shape changes from [...] to [..., sizeof(&lt;code&gt;T&lt;/code&gt;)/sizeof(&lt;code&gt;type&lt;/code&gt;)].

          If &lt;code&gt;T&lt;/code&gt; is smaller than &lt;code&gt;type&lt;/code&gt;, the operator requires that the rightmost
          dimension be equal to sizeof(&lt;code&gt;type&lt;/code&gt;)/sizeof(&lt;code&gt;T&lt;/code&gt;). The shape then goes from
          [..., sizeof(&lt;code&gt;type&lt;/code&gt;)/sizeof(&lt;code&gt;T&lt;/code&gt;)] to [...].

          *NOTE*: Bitcast is implemented as a low-level cast, so machines with different
          endian orderings will give different results.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_BitwiseAnd_" data-uid="TensorFlow.TFGraph.BitwiseAnd*"></a>
  <h4 id="TensorFlow_TFGraph_BitwiseAnd_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BitwiseAnd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">BitwiseAnd(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Elementwise computes the bitwise AND of <code>x</code> and <code>y</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BitwiseAnd (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BitwiseAnd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BitwiseAnd_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The result will have those bits set, that are set in both <code>x</code> and <code>y</code>. The
              computation is performed on the underlying representations of <code>x</code> and <code>y</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BitwiseOr_" data-uid="TensorFlow.TFGraph.BitwiseOr*"></a>
  <h4 id="TensorFlow_TFGraph_BitwiseOr_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BitwiseOr(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">BitwiseOr(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Elementwise computes the bitwise OR of <code>x</code> and <code>y</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BitwiseOr (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BitwiseOr&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BitwiseOr_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The result will have those bits set, that are set in <code>x</code>, <code>y</code> or both. The
              computation is performed on the underlying representations of <code>x</code> and <code>y</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BitwiseXor_" data-uid="TensorFlow.TFGraph.BitwiseXor*"></a>
  <h4 id="TensorFlow_TFGraph_BitwiseXor_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BitwiseXor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">BitwiseXor(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Elementwise computes the bitwise XOR of <code>x</code> and <code>y</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BitwiseXor (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BitwiseXor&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BitwiseXor_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The result will have those bits set, that are different in <code>x</code> and <code>y</code>. The
              computation is performed on the underlying representations of <code>x</code> and <code>y</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesBucketize_" data-uid="TensorFlow.TFGraph.BoostedTreesBucketize*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesBucketize_TensorFlow_TFOutput___TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesBucketize(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)">BoostedTreesBucketize(TFOutput[], TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Bucketize each feature based on bucket boundaries.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] BoostedTreesBucketize (TensorFlow.TFOutput[] float_values, TensorFlow.TFOutput[] bucket_boundaries, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">float_values</span></td>
        <td><p>float; List of Rank 1 Tensor each containing float values for a single feature.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">bucket_boundaries</span></td>
        <td><p>float; List of Rank 1 Tensors each containing the bucket boundaries for a single
              feature.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesBucketize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>int; List of Rank 1 Tensors each containing the bucketized values for a single feature.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BoostedTreesBucketize_TensorFlow_TFOutput___TensorFlow_TFOutput___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that returns a list of float tensors, where each tensor represents the
              bucketized values for a single feature.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesCalculateBestGainsPerFeature_" data-uid="TensorFlow.TFGraph.BoostedTreesCalculateBestGainsPerFeature*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesCalculateBestGainsPerFeature_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesCalculateBestGainsPerFeature(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">BoostedTreesCalculateBestGainsPerFeature(TFOutput, TFOutput[], TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>Calculates gains for each feature and returns the best possible split information for the feature.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]&gt; BoostedTreesCalculateBestGainsPerFeature (TensorFlow.TFOutput node_id_range, TensorFlow.TFOutput[] stats_summary_list, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput tree_complexity, TensorFlow.TFOutput min_node_weight, long max_splits, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">node_id_range</span></td>
        <td><p>A Rank 1 tensor (shape=[2]) to specify the range [first, last) of node ids to process within <code>stats_summary_list</code>. The nodes are iterated between the two nodes specified by the tensor, as like <code>for node_id in range(node_id_range[0], node_id_range[1])</code> (Note that the last index node_id_range[1] is exclusive).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">stats_summary_list</span></td>
        <td><p>A list of Rank 3 tensor (#shape=[max_splits, bucket, 2]) for accumulated stats summary (gradient/hessian) per node per buckets for each feature. The first dimension of the tensor is the maximum number of splits, and thus not all elements of it will be used, but only the indexes specified by node_ids will be used.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>l1 regularization factor on leaf weights, per instance based.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>l2 regularization factor on leaf weights, per instance based.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tree_complexity</span></td>
        <td><p>adjustment to the gain, per leaf based.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_node_weight</span></td>
        <td><p>mininum avg of hessians in a node before required for the node to be considered for splitting.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">max_splits</span></td>
        <td><p>the number of nodes that can be split in the whole tree. Used as a dimension of output tensors.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesCalculateBestGainsPerFeature&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              node_ids_list: An output list of Rank 1 tensors indicating possible split node ids for each feature. The length of the list is num_features, but each tensor has different size as each feature provides different possible nodes. See above for details like shapes and sizes.
              gains_list: An output list of Rank 1 tensors indicating the best gains for each feature to split for certain nodes. See above for details like shapes and sizes.
              thresholds_list: An output list of Rank 1 tensors indicating the bucket id to compare with (as a threshold) for split in each node. See above for details like shapes and sizes.
              left_node_contribs_list: A list of Rank 2 tensors indicating the contribution of the left nodes when branching from parent nodes (given by the tensor element in the output node_ids_list) to the left direction by the given threshold for each feature. This value will be used to make the left node value by adding to the parent node value. Second dimension size is 1 for 1-dimensional logits, but would be larger for multi-class problems. See above for details like shapes and sizes.
              right_node_contribs_list: A list of Rank 2 tensors, with the same shape/conditions as left_node_contribs_list, but just that the value is for the right node.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BoostedTreesCalculateBestGainsPerFeature_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The split information is the best threshold (bucket id), gains and left/right node contributions per node for each feature.</p>
<pre><code>          It is possible that not all nodes can be split on each feature. Hence, the list of possible nodes can differ between the features. Therefore, we return &lt;code&gt;node_ids_list&lt;/code&gt; for each feature, containing the list of nodes that this feature can be used to split.

          In this manner, the output is the best split per features and per node, so that it needs to be combined later to produce the best split for each node (among all possible features).

          The length of output lists are all of the same length, &lt;code&gt;num_features&lt;/code&gt;.
          The output shapes are compatible in a way that the first dimension of all tensors of all lists are the same and equal to the number of possible split nodes for each feature.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesCenterBias_" data-uid="TensorFlow.TFGraph.BoostedTreesCenterBias*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesCenterBias_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesCenterBias(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">BoostedTreesCenterBias(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Calculates the prior from the training data (the bias) and fills in the first node with the logits&#39; prior. Returns a boolean indicating whether to continue centering.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BoostedTreesCenterBias (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput mean_gradients, TensorFlow.TFOutput mean_hessians, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tree_ensemble_handle</span></td>
        <td><p>Handle to the tree ensemble.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mean_gradients</span></td>
        <td><p>A tensor with shape=[logits_dimension] with mean of gradients for a first node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mean_hessians</span></td>
        <td><p>A tensor with shape=[logits_dimension] mean of hessians for a first node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>l1 regularization factor on leaf weights, per instance based.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>l2 regularization factor on leaf weights, per instance based.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesCenterBias&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Bool, whether to continue bias centering.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesCreateEnsemble_" data-uid="TensorFlow.TFGraph.BoostedTreesCreateEnsemble*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesCreateEnsemble_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesCreateEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">BoostedTreesCreateEnsemble(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Creates a tree ensemble model and returns a handle to it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation BoostedTreesCreateEnsemble (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput stamp_token, TensorFlow.TFOutput tree_ensemble_serialized, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tree_ensemble_handle</span></td>
        <td><p>Handle to the tree ensemble resource to be created.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">stamp_token</span></td>
        <td><p>Token to use as the initial value of the resource stamp.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tree_ensemble_serialized</span></td>
        <td><p>Serialized proto of the tree ensemble.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesCreateEnsemble&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesCreateQuantileStreamResource_" data-uid="TensorFlow.TFGraph.BoostedTreesCreateQuantileStreamResource*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesCreateQuantileStreamResource_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesCreateQuantileStreamResource(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)">BoostedTreesCreateQuantileStreamResource(TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Create the Resource for Quantile Streams.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation BoostedTreesCreateQuantileStreamResource (TensorFlow.TFOutput quantile_stream_resource_handle, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput num_streams, Nullable&lt;long&gt; max_elements = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">quantile_stream_resource_handle</span></td>
        <td><p>resource; Handle to quantile stream resource.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>float; The required approximation error of the stream resource.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_streams</span></td>
        <td><p>int; The number of streams managed by the resource that shares the same epsilon.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">max_elements</span></td>
        <td><p>Optional argument
              int; The maximum number of data points that can be fed to the stream.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesCreateQuantileStreamResource&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesDeserializeEnsemble_" data-uid="TensorFlow.TFGraph.BoostedTreesDeserializeEnsemble*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesDeserializeEnsemble_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesDeserializeEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">BoostedTreesDeserializeEnsemble(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Deserializes a serialized tree ensemble config and replaces current tree</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation BoostedTreesDeserializeEnsemble (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput stamp_token, TensorFlow.TFOutput tree_ensemble_serialized, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tree_ensemble_handle</span></td>
        <td><p>Handle to the tree ensemble.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">stamp_token</span></td>
        <td><p>Token to use as the new value of the resource stamp.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tree_ensemble_serialized</span></td>
        <td><p>Serialized proto of the ensemble.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesDeserializeEnsemble&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BoostedTreesDeserializeEnsemble_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>ensemble.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesEnsembleResourceHandleOp_" data-uid="TensorFlow.TFGraph.BoostedTreesEnsembleResourceHandleOp*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesEnsembleResourceHandleOp_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesEnsembleResourceHandleOp(System.String,System.String,System.String)">BoostedTreesEnsembleResourceHandleOp(String, String, String)</h4>
  <div class="markdown level1 summary"><p>Creates a handle to a BoostedTreesEnsembleResource</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BoostedTreesEnsembleResourceHandleOp (string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesEnsembleResourceHandleOp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesExampleDebugOutputs_" data-uid="TensorFlow.TFGraph.BoostedTreesExampleDebugOutputs*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesExampleDebugOutputs_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Int64_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesExampleDebugOutputs(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)">BoostedTreesExampleDebugOutputs(TFOutput, TFOutput[], Int64, String)</h4>
  <div class="markdown level1 summary"><p>Debugging/model interpretability outputs for each example.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BoostedTreesExampleDebugOutputs (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput[] bucketized_features, long logits_dimension, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tree_ensemble_handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">bucketized_features</span></td>
        <td><p>A list of rank 1 Tensors containing bucket id for each
              feature.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">logits_dimension</span></td>
        <td><p>scalar, dimension of the logits, to be used for constructing the protos in
              examples_debug_outputs_serialized.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesExampleDebugOutputs&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Output rank 1 Tensor containing a proto serialized as a string for each example.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BoostedTreesExampleDebugOutputs_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>It traverses all the trees and computes debug metrics for individual examples,
              such as getting split feature ids and logits after each split along the decision
              path used to compute directional feature contributions.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesGetEnsembleStates_" data-uid="TensorFlow.TFGraph.BoostedTreesGetEnsembleStates*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesGetEnsembleStates_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesGetEnsembleStates(TensorFlow.TFOutput,System.String)">BoostedTreesGetEnsembleStates(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Retrieves the tree ensemble resource stamp token, number of trees and growing statistics.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; BoostedTreesGetEnsembleStates (TensorFlow.TFOutput tree_ensemble_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tree_ensemble_handle</span></td>
        <td><p>Handle to the tree ensemble.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesGetEnsembleStates&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              stamp_token: Stamp token of the tree ensemble resource.
              num_trees: The number of trees in the tree ensemble resource.
              num_finalized_trees: The number of trees that were finished successfully.
              num_attempted_layers: The number of layers we attempted to build (but not necessarily succeeded).
              last_layer_nodes_range: Rank size 2 tensor that contains start and end ids of the nodes in the latest
              layer.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesMakeQuantileSummaries_" data-uid="TensorFlow.TFGraph.BoostedTreesMakeQuantileSummaries*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesMakeQuantileSummaries_TensorFlow_TFOutput___TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesMakeQuantileSummaries(TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">BoostedTreesMakeQuantileSummaries(TFOutput[], TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Makes the summary of quantiles for the batch.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] BoostedTreesMakeQuantileSummaries (TensorFlow.TFOutput[] float_values, TensorFlow.TFOutput example_weights, TensorFlow.TFOutput epsilon, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">float_values</span></td>
        <td><p>float; List of Rank 1 Tensors each containing values for a single feature.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">example_weights</span></td>
        <td><p>float; Rank 1 Tensor with weights per instance.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>float; The required maximum approximation error.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesMakeQuantileSummaries&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>float; List of Rank 2 Tensors each containing the quantile summary
              (value, weight, min_rank, max_rank) of a single feature.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BoostedTreesMakeQuantileSummaries_TensorFlow_TFOutput___TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that takes a list of tensors (one tensor per feature) and outputs the
              quantile summaries for each tensor.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesMakeStatsSummary_" data-uid="TensorFlow.TFGraph.BoostedTreesMakeStatsSummary*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesMakeStatsSummary_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Int64_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesMakeStatsSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.Int64,System.String)">BoostedTreesMakeStatsSummary(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, Int64, String)</h4>
  <div class="markdown level1 summary"><p>Makes the summary of accumulated stats for the batch.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BoostedTreesMakeStatsSummary (TensorFlow.TFOutput node_ids, TensorFlow.TFOutput gradients, TensorFlow.TFOutput hessians, TensorFlow.TFOutput[] bucketized_features_list, long max_splits, long num_buckets, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">node_ids</span></td>
        <td><p>int32 Rank 1 Tensor containing node ids, which each example falls into for the requested layer.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradients</span></td>
        <td><p>float32; Rank 2 Tensor (shape=[#examples, 1]) for gradients.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">hessians</span></td>
        <td><p>float32; Rank 2 Tensor (shape=[#examples, 1]) for hessians.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">bucketized_features_list</span></td>
        <td><p>int32 list of Rank 1 Tensors, each containing the bucketized feature (for each feature column).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">max_splits</span></td>
        <td><p>int; the maximum number of splits possible in the whole tree.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_buckets</span></td>
        <td><p>int; equals to the maximum possible value of bucketized feature.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesMakeStatsSummary&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>output Rank 4 Tensor (shape=[#features, #splits, #buckets, 2]) containing accumulated stats put into the corresponding node and bucket. The first index of 4th dimension refers to gradients, and the second to hessians.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BoostedTreesMakeStatsSummary_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Int64_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The summary stats contains gradients and hessians accumulated into the corresponding node and bucket for each example.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesPredict_" data-uid="TensorFlow.TFGraph.BoostedTreesPredict*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesPredict_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Int64_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesPredict(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)">BoostedTreesPredict(TFOutput, TFOutput[], Int64, String)</h4>
  <div class="markdown level1 summary"><p>Runs multiple additive regression ensemble predictors on input instances and</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BoostedTreesPredict (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput[] bucketized_features, long logits_dimension, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tree_ensemble_handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">bucketized_features</span></td>
        <td><p>A list of rank 1 Tensors containing bucket id for each
              feature.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">logits_dimension</span></td>
        <td><p>scalar, dimension of the logits, to be used for partial logits
              shape.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesPredict&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Output rank 2 Tensor containing logits for each example.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BoostedTreesPredict_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>computes the logits. It is designed to be used during prediction.
              It traverses all the trees and calculates the final score for each instance.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesQuantileStreamResourceAddSummaries_" data-uid="TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceAddSummaries*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesQuantileStreamResourceAddSummaries_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceAddSummaries(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)">BoostedTreesQuantileStreamResourceAddSummaries(TFOutput, TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Add the quantile summaries to each quantile stream resource.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation BoostedTreesQuantileStreamResourceAddSummaries (TensorFlow.TFOutput quantile_stream_resource_handle, TensorFlow.TFOutput[] summaries, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">quantile_stream_resource_handle</span></td>
        <td><p>resource handle referring to a QuantileStreamResource.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">summaries</span></td>
        <td><p>string; List of Rank 2 Tensor each containing the summaries for a single feature.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesQuantileStreamResourceAddSummaries&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BoostedTreesQuantileStreamResourceAddSummaries_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that adds a list of quantile summaries to a quantile stream resource. Each
              summary Tensor is rank 2, containing summaries (value, weight, min_rank, max_rank)
              for a single feature.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesQuantileStreamResourceFlush_" data-uid="TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceFlush*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesQuantileStreamResourceFlush_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceFlush(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">BoostedTreesQuantileStreamResourceFlush(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Flush the summaries for a quantile stream resource.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation BoostedTreesQuantileStreamResourceFlush (TensorFlow.TFOutput quantile_stream_resource_handle, TensorFlow.TFOutput num_buckets, Nullable&lt;bool&gt; generate_quantiles = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">quantile_stream_resource_handle</span></td>
        <td><p>resource handle referring to a QuantileStreamResource.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_buckets</span></td>
        <td><p>int; approximate number of buckets unless using generate_quantiles.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">generate_quantiles</span></td>
        <td><p>Optional argument
              bool; If True, the output will be the num_quantiles for each stream where the ith
              entry is the ith quantile of the input with an approximation error of epsilon.
              Duplicate values may be present.
              If False, the output will be the points in the histogram that we got which roughly
              translates to 1/epsilon boundaries and without any duplicates.
              Default to False.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesQuantileStreamResourceFlush&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BoostedTreesQuantileStreamResourceFlush_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that flushes the summaries for a quantile stream resource.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesQuantileStreamResourceGetBucketBoundaries_" data-uid="TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceGetBucketBoundaries*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesQuantileStreamResourceGetBucketBoundaries_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceGetBucketBoundaries(TensorFlow.TFOutput,System.Int64,System.String)">BoostedTreesQuantileStreamResourceGetBucketBoundaries(TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>Generate the bucket boundaries for each feature based on accumulated summaries.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] BoostedTreesQuantileStreamResourceGetBucketBoundaries (TensorFlow.TFOutput quantile_stream_resource_handle, long num_features, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">quantile_stream_resource_handle</span></td>
        <td><p>resource handle referring to a QuantileStreamResource.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_features</span></td>
        <td><p>inferred int; number of features to get bucket boundaries for.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesQuantileStreamResourceGetBucketBoundaries&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>float; List of Rank 1 Tensors each containing the bucket boundaries for a feature.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BoostedTreesQuantileStreamResourceGetBucketBoundaries_TensorFlow_TFOutput_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that returns a list of float tensors for a quantile stream resource. Each
              tensor is Rank 1 containing bucket boundaries for a single feature.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesQuantileStreamResourceHandleOp_" data-uid="TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceHandleOp*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesQuantileStreamResourceHandleOp_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesQuantileStreamResourceHandleOp(System.String,System.String,System.String)">BoostedTreesQuantileStreamResourceHandleOp(String, String, String)</h4>
  <div class="markdown level1 summary"><p>Creates a handle to a BoostedTreesQuantileStreamResource.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BoostedTreesQuantileStreamResourceHandleOp (string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesQuantileStreamResourceHandleOp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesSerializeEnsemble_" data-uid="TensorFlow.TFGraph.BoostedTreesSerializeEnsemble*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesSerializeEnsemble_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesSerializeEnsemble(TensorFlow.TFOutput,System.String)">BoostedTreesSerializeEnsemble(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Serializes the tree ensemble to a proto.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; BoostedTreesSerializeEnsemble (TensorFlow.TFOutput tree_ensemble_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tree_ensemble_handle</span></td>
        <td><p>Handle to the tree ensemble.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesSerializeEnsemble&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              stamp_token: Stamp token of the tree ensemble resource.
              tree_ensemble_serialized: Serialized proto of the ensemble.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesTrainingPredict_" data-uid="TensorFlow.TFGraph.BoostedTreesTrainingPredict*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesTrainingPredict_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Int64_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesTrainingPredict(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String)">BoostedTreesTrainingPredict(TFOutput, TFOutput, TFOutput, TFOutput[], Int64, String)</h4>
  <div class="markdown level1 summary"><p>Runs multiple additive regression ensemble predictors on input instances and</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; BoostedTreesTrainingPredict (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput cached_tree_ids, TensorFlow.TFOutput cached_node_ids, TensorFlow.TFOutput[] bucketized_features, long logits_dimension, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tree_ensemble_handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">cached_tree_ids</span></td>
        <td><p>Rank 1 Tensor containing cached tree ids which is the starting
              tree of prediction.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">cached_node_ids</span></td>
        <td><p>Rank 1 Tensor containing cached node id which is the starting
              node of prediction.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">bucketized_features</span></td>
        <td><p>A list of rank 1 Tensors containing bucket id for each
              feature.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">logits_dimension</span></td>
        <td><p>scalar, dimension of the logits, to be used for partial logits
              shape.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesTrainingPredict&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              partial_logits: Rank 2 Tensor containing logits update (with respect to cached
              values stored) for each example.
              tree_ids: Rank 1 Tensor containing new tree ids for each example.
              node_ids: Rank 1 Tensor containing new node ids in the new tree_ids.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BoostedTreesTrainingPredict_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>computes the update to cached logits. It is designed to be used during training.
              It traverses the trees starting from cached tree id and cached node id and
              calculates the updates to be pushed to the cache.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BoostedTreesUpdateEnsemble_" data-uid="TensorFlow.TFGraph.BoostedTreesUpdateEnsemble*"></a>
  <h4 id="TensorFlow_TFGraph_BoostedTreesUpdateEnsemble_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.BoostedTreesUpdateEnsemble(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">BoostedTreesUpdateEnsemble(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>Updates the tree ensemble by either adding a layer to the last tree being grown</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation BoostedTreesUpdateEnsemble (TensorFlow.TFOutput tree_ensemble_handle, TensorFlow.TFOutput feature_ids, TensorFlow.TFOutput[] node_ids, TensorFlow.TFOutput[] gains, TensorFlow.TFOutput[] thresholds, TensorFlow.TFOutput[] left_node_contribs, TensorFlow.TFOutput[] right_node_contribs, TensorFlow.TFOutput max_depth, TensorFlow.TFOutput learning_rate, long pruning_mode, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tree_ensemble_handle</span></td>
        <td><p>Handle to the ensemble variable.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">feature_ids</span></td>
        <td><p>Rank 1 tensor with ids for each feature. This is the real id of
              the feature that will be used in the split.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">node_ids</span></td>
        <td><p>List of rank 1 tensors representing the nodes for which this feature
              has a split.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">gains</span></td>
        <td><p>List of rank 1 tensors representing the gains for each of the feature&#39;s
              split.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">thresholds</span></td>
        <td><p>List of rank 1 tensors representing the thesholds for each of the
              feature&#39;s split.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">left_node_contribs</span></td>
        <td><p>List of rank 2 tensors with left leaf contribs for each of
              the feature&#39;s splits. Will be added to the previous node values to constitute
              the values of the left nodes.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">right_node_contribs</span></td>
        <td><p>List of rank 2 tensors with right leaf contribs for each
              of the feature&#39;s splits. Will be added to the previous node values to constitute
              the values of the right nodes.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_depth</span></td>
        <td><p>Max depth of the tree to build.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">learning_rate</span></td>
        <td><p>shrinkage const for each new tree.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">pruning_mode</span></td>
        <td><p>0-No pruning, 1-Pre-pruning, 2-Post-pruning.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BoostedTreesUpdateEnsemble&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BoostedTreesUpdateEnsemble_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>or by starting a new tree.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BroadcastArgs_" data-uid="TensorFlow.TFGraph.BroadcastArgs*"></a>
  <h4 id="TensorFlow_TFGraph_BroadcastArgs_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BroadcastArgs(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">BroadcastArgs(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Return the shape of s0 op s1 with broadcast.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BroadcastArgs (TensorFlow.TFOutput s0, TensorFlow.TFOutput s1, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">s0</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">s1</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BroadcastArgs&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BroadcastArgs_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given <code>s0</code> and <code>s1</code>, tensors that represent shapes, compute <code>r0</code>, the
              broadcasted shape. <code>s0</code>, <code>s1</code> and <code>r0</code> are all integer vectors.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BroadcastGradientArgs_" data-uid="TensorFlow.TFGraph.BroadcastGradientArgs*"></a>
  <h4 id="TensorFlow_TFGraph_BroadcastGradientArgs_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BroadcastGradientArgs(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">BroadcastGradientArgs(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Return the reduction indices for computing gradients of s0 op s1 with broadcast.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; BroadcastGradientArgs (TensorFlow.TFOutput s0, TensorFlow.TFOutput s1, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">s0</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">s1</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BroadcastGradientArgs&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              r0:
              r1:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BroadcastGradientArgs_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This is typically used by gradient computations for a broadcasting operation.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_BroadcastTo_" data-uid="TensorFlow.TFGraph.BroadcastTo*"></a>
  <h4 id="TensorFlow_TFGraph_BroadcastTo_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.BroadcastTo(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">BroadcastTo(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Broadcast an array for a compatible shape.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput BroadcastTo (TensorFlow.TFOutput input, TensorFlow.TFOutput shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A Tensor to broadcast.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>An 1-D <code>int</code> Tensor. The shape of the desired output.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;BroadcastTo&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A Tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_BroadcastTo_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Broadcasting is the process of making arrays to have compatible shapes
              for arithmetic operations. Two shapes are compatible if for each
              dimension pair they are either equal or one of them is one. When trying
              to broadcast a Tensor to a shape, it starts with the trailing dimensions,
              and works its way forward.</p>
<pre><code>          For example,
           &lt;pre&gt;&lt;code&gt;
          &amp;gt;&amp;gt;&amp;gt; x = tf.constant([1, 2, 3])
          &amp;gt;&amp;gt;&amp;gt; y = tf.broadcast_to(x, [3, 3])
          &amp;gt;&amp;gt;&amp;gt; sess.run(y)
          array([[1, 2, 3],
          [1, 2, 3],
          [1, 2, 3]], dtype=int32)
           &lt;/code&gt;&lt;/pre&gt;
          In the above example, the input Tensor with the shape of &lt;code&gt;[1, 3]&lt;/code&gt;
          is broadcasted to output Tensor with shape of &lt;code&gt;[3, 3]&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Bucketize_" data-uid="TensorFlow.TFGraph.Bucketize*"></a>
  <h4 id="TensorFlow_TFGraph_Bucketize_TensorFlow_TFOutput_System_Single___System_String_" data-uid="TensorFlow.TFGraph.Bucketize(TensorFlow.TFOutput,System.Single[],System.String)">Bucketize(TFOutput, Single[], String)</h4>
  <div class="markdown level1 summary"><p>Bucketizes &#39;input&#39; based on &#39;boundaries&#39;.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Bucketize (TensorFlow.TFOutput input, float[] boundaries, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Any shape of Tensor contains with int or float type.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span>[]</td>
        <td><span class="parametername">boundaries</span></td>
        <td><p>A sorted list of floats gives the boundary of the buckets.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Bucketize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same shape with &#39;input&#39;, each value of input replaced with bucket index.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.digitize.
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Bucketize_TensorFlow_TFOutput_System_Single___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>For example, if the inputs are
              boundaries = [0, 10, 100]
              input = [[-5, 10000]
              [150,   10]
              [5,    100]]</p>
<pre><code>          then the output will be
          output = [[0, 3]
          [3, 2]
          [1, 3]]
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_CacheDataset_" data-uid="TensorFlow.TFGraph.CacheDataset*"></a>
  <h4 id="TensorFlow_TFGraph_CacheDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.CacheDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">CacheDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that caches elements from <code>input_dataset</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CacheDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput filename, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filename</span></td>
        <td><p>A path on the filesystem where we should cache the dataset. Note: this
              will be a directory.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CacheDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CacheDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>A CacheDataset will iterate over the input_dataset, and store tensors. If the
              cache already exists, the cache will be used. If the cache is inappropriate
              (e.g. cannot be opened, contains tensors of the wrong shape / size), an error
              will the returned when used.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Cast_" data-uid="TensorFlow.TFGraph.Cast*"></a>
  <h4 id="TensorFlow_TFGraph_Cast_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Cast(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)">Cast(TFOutput, TFDataType, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Cast x of type SrcT to y of DstT.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Cast (TensorFlow.TFOutput x, TensorFlow.TFDataType DstT, Nullable&lt;bool&gt; Truncate = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">DstT</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">Truncate</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Cast&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Ceil_" data-uid="TensorFlow.TFGraph.Ceil*"></a>
  <h4 id="TensorFlow_TFGraph_Ceil_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Ceil(TensorFlow.TFOutput,System.String)">Ceil(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns element-wise smallest integer not less than x.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Ceil (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Ceil&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_CheckNumerics_" data-uid="TensorFlow.TFGraph.CheckNumerics*"></a>
  <h4 id="TensorFlow_TFGraph_CheckNumerics_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.CheckNumerics(TensorFlow.TFOutput,System.String,System.String)">CheckNumerics(TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>Checks a tensor for NaN and Inf values.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CheckNumerics (TensorFlow.TFOutput tensor, string message, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">message</span></td>
        <td><p>Prefix of the error message.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CheckNumerics&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CheckNumerics_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>When run, reports an <code>InvalidArgument</code> error if <code>tensor</code> has any values
              that are not a number (NaN) or infinity (Inf). Otherwise, passes <code>tensor</code> as-is.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Cholesky_" data-uid="TensorFlow.TFGraph.Cholesky*"></a>
  <h4 id="TensorFlow_TFGraph_Cholesky_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Cholesky(TensorFlow.TFOutput,System.String)">Cholesky(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the Cholesky decomposition of one or more square matrices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Cholesky (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Shape is <code>[..., M, M]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Cholesky&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Shape is <code>[..., M, M]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Cholesky_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
              form square matrices.</p>
<pre><code>          The input has to be symmetric and positive definite. Only the lower-triangular
          part of the input will be used for this operation. The upper-triangular part
          will not be read.

          The output is a tensor of the same shape as the input
          containing the Cholesky decompositions for all input submatrices &lt;code&gt;[..., :, :]&lt;/code&gt;.

          **Note**: The gradient computation on GPU is faster for large matrices but
          not for large batch dimensions when the submatrices are small. In this
          case it might be faster to use the CPU.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_CholeskyGrad_" data-uid="TensorFlow.TFGraph.CholeskyGrad*"></a>
  <h4 id="TensorFlow_TFGraph_CholeskyGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.CholeskyGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">CholeskyGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the reverse mode backpropagated gradient of the Cholesky algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CholeskyGrad (TensorFlow.TFOutput l, TensorFlow.TFOutput grad, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l</span></td>
        <td><p>Output of batch Cholesky algorithm l = cholesky(A). Shape is <code>[..., M, M]</code>.
              Algorithm depends only on lower triangular part of the innermost matrices of
              this tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>df/dl where f is some scalar function. Shape is <code>[..., M, M]</code>.
              Algorithm depends only on lower triangular part of the innermost matrices of
              this tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CholeskyGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Symmetrized version of df/dA . Shape is <code>[..., M, M]</code>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CholeskyGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>For an explanation see &quot;Differentiation of the Cholesky algorithm&quot; by
              Iain Murray <a href="http://arxiv.org/abs/1602.07527">http://arxiv.org/abs/1602.07527</a>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ClipByAverageNorm_" data-uid="TensorFlow.TFGraph.ClipByAverageNorm*"></a>
  <h4 id="TensorFlow_TFGraph_ClipByAverageNorm_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ClipByAverageNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ClipByAverageNorm(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Clips tensor values to a maximum average L2-norm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ClipByAverageNorm (TensorFlow.TFOutput x, TensorFlow.TFOutput clip_norm, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>The input tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">clip_norm</span></td>
        <td><p>A maximum clipping value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Name of the oper.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ClipByAverageNorm_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a tensor <code>x</code>, and a maximum clip value <code>clip_norm</code>, this operation 
            normalizes <code>x</code> so that its its average L2-norm is less than or equal to <code>clip_norm</code>.
            Specifically, if the average L2-norm is already less than or equal to <code>clip_norm</code>, then <code>x</code>
            is not modified. If the average L2-norm is greater than <code>clip_norm</code>, then this operation returns a tensor of the same
            type and shape as <code>x</code> with its values set to: <code>t* clip_norm / l2norm_avg(t)</code>. In this case, 
            the average L2-norm of the output tensor is <code>clip_norm</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ClipByNorm_" data-uid="TensorFlow.TFGraph.ClipByNorm*"></a>
  <h4 id="TensorFlow_TFGraph_ClipByNorm_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFOutput__System_String_" data-uid="TensorFlow.TFGraph.ClipByNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.String)">ClipByNorm(TFOutput, TFOutput, Nullable&lt;TFOutput&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Clips tensor values to a maximum L2-norm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ClipByNorm (TensorFlow.TFOutput x, TensorFlow.TFOutput clip_norm, Nullable&lt;TensorFlow.TFOutput&gt; axes = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>The tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">clip_norm</span></td>
        <td><p>The minimum value to clip by. A 0 - D(scalar) tensor, or a tensor with the same shape as <code>x</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><span class="parametername">axes</span></td>
        <td><p>The minimum value to clip by. A 0 - D(scalar) tensor, or a tensor with the same shape as <code>x</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Operation name, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A clipped <a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ClipByNorm_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFOutput__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>
            Given a tensor <code>x</code>, and a maximum clip value <code>clip_norm</code>, this operation normalizes 
            <code>x</code> so that its L2-norm is less than or equal to <code>clip_norm</code>, along the dimensions 
            given in <code>axes</code>. Specifically, in the default case where all dimensions are used for calculation, if
            the L2-norm of <code>x</code> is already less than or equal to <code>clip_norm</code>, then <code>x</code>
            is not modified. If the L2-norm is greater than <code>clip_norm</code>, then this operation returns a tensor of 
            the same type and shape as <code>x</code> with its values set to: <code>t* clip_norm / l2norm(t)</code></p></div>
  
  
  <a id="TensorFlow_TFGraph_ClipByValue_" data-uid="TensorFlow.TFGraph.ClipByValue*"></a>
  <h4 id="TensorFlow_TFGraph_ClipByValue_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ClipByValue(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ClipByValue(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Clips tensor values to a specified min and max.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ClipByValue (TensorFlow.TFOutput t, TensorFlow.TFOutput clip_value_min, TensorFlow.TFOutput clip_value_max, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">t</span></td>
        <td><p>A <code>Tensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">clip_value_min</span></td>
        <td><p>A 0-D (scalar) <code>Tensor</code>, or a <code>Tensor</code> with the same shape
              as <code>t</code>. The minimum value to clip by.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">clip_value_max</span></td>
        <td><p>A 0-D (scalar) <code>Tensor</code>, or a <code>Tensor</code> with the same shape
              as <code>t</code>. The maximum value to clip by.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ClipByValue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A clipped <code>Tensor</code> with the same shape as input &#39;t&#39;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ClipByValue_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a tensor <code>t</code>, this operation returns a tensor of the same type and
              shape as <code>t</code> with its values clipped to <code>clip_value_min</code> and <code>clip_value_max</code>.
              Any values less than <code>clip_value_min</code> are set to <code>clip_value_min</code>. Any values
              greater than <code>clip_value_max</code> are set to <code>clip_value_max</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_CollectiveBcastRecv_" data-uid="TensorFlow.TFGraph.CollectiveBcastRecv*"></a>
  <h4 id="TensorFlow_TFGraph_CollectiveBcastRecv_TensorFlow_TFDataType_System_Int64_System_Int64_System_Int64_TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.CollectiveBcastRecv(TensorFlow.TFDataType,System.Int64,System.Int64,System.Int64,TensorFlow.TFShape,System.String)">CollectiveBcastRecv(TFDataType, Int64, Int64, Int64, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>Receives a tensor value broadcast from another device.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CollectiveBcastRecv (TensorFlow.TFDataType T, long group_size, long group_key, long instance_key, TensorFlow.TFShape shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">T</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">group_size</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">group_key</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">instance_key</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CollectiveBcastRecv&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_CollectiveBcastSend_" data-uid="TensorFlow.TFGraph.CollectiveBcastSend*"></a>
  <h4 id="TensorFlow_TFGraph_CollectiveBcastSend_TensorFlow_TFOutput_System_Int64_System_Int64_System_Int64_TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.CollectiveBcastSend(TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,TensorFlow.TFShape,System.String)">CollectiveBcastSend(TFOutput, Int64, Int64, Int64, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>Broadcasts a tensor value to one or more other devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CollectiveBcastSend (TensorFlow.TFOutput input, long group_size, long group_key, long instance_key, TensorFlow.TFShape shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">group_size</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">group_key</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">instance_key</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CollectiveBcastSend&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_CollectivePermute_" data-uid="TensorFlow.TFGraph.CollectivePermute*"></a>
  <h4 id="TensorFlow_TFGraph_CollectivePermute_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.CollectivePermute(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">CollectivePermute(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>An Op to permute tensors across replicated TPU instances. Each instance</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CollectivePermute (TensorFlow.TFOutput input, TensorFlow.TFOutput source_target_pairs, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The local input to be permuted. Currently only supports float and
              bfloat16.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">source_target_pairs</span></td>
        <td><p>A tensor with shape [num_pairs, 2].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CollectivePermute&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The permuted input.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CollectivePermute_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>supplies its own input.</p>
<pre><code>          For example, suppose there are 4 TPU instances: &lt;code&gt;[A, B, C, D]&lt;/code&gt;. Passing
          source_target_pairs=&lt;code&gt;[[0,1],[1,2],[2,3],[3,0]]&lt;/code&gt; gets the outputs:
          &lt;code&gt;[D, A, B, C]&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_CollectiveReduce_" data-uid="TensorFlow.TFGraph.CollectiveReduce*"></a>
  <h4 id="TensorFlow_TFGraph_CollectiveReduce_TensorFlow_TFOutput_System_Int64_System_Int64_System_Int64_System_String_System_String_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.CollectiveReduce(TensorFlow.TFOutput,System.Int64,System.Int64,System.Int64,System.String,System.String,System.Int64[],System.String)">CollectiveReduce(TFOutput, Int64, Int64, Int64, String, String, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Mutually reduces multiple tensors of identical type and shape.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CollectiveReduce (TensorFlow.TFOutput input, long group_size, long group_key, long instance_key, string merge_op, string final_op, long[] subdiv_offsets, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">group_size</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">group_key</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">instance_key</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">merge_op</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">final_op</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">subdiv_offsets</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CollectiveReduce&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_CompareAndBitpack_" data-uid="TensorFlow.TFGraph.CompareAndBitpack*"></a>
  <h4 id="TensorFlow_TFGraph_CompareAndBitpack_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.CompareAndBitpack(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">CompareAndBitpack(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Compare values of <code>input</code> to <code>threshold</code> and pack resulting bits into a <code>uint8</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CompareAndBitpack (TensorFlow.TFOutput input, TensorFlow.TFOutput threshold, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Values to compare against <code>threshold</code> and bitpack.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">threshold</span></td>
        <td><p>Threshold to compare against.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CompareAndBitpack&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The bitpacked comparisons.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CompareAndBitpack_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Each comparison returns a boolean <code>true</code> (if <code>input_value &gt; threshold</code>)
              or and <code>false</code> otherwise.</p>
<pre><code>          This operation is useful for Locality-Sensitive-Hashing (LSH) and other
          algorithms that use hashing approximations of cosine and &lt;code&gt;L2&lt;/code&gt; distances;
          codes can be generated from an input via:

           &lt;pre&gt;&lt;code&gt;
          codebook_size = 50
          codebook_bits = codebook_size * 32
          codebook = tf.get_variable(&#39;codebook&#39;, [x.shape[-1].value, codebook_bits],
          dtype=x.dtype,
          initializer=tf.orthogonal_initializer())
          codes = compare_and_threshold(tf.matmul(x, codebook), threshold=0.)
          codes = tf.bitcast(codes, tf.int32)  # go from uint8 to int32
          # now codes has shape x.shape[:-1] + [codebook_size]
           &lt;/code&gt;&lt;/pre&gt;

          **NOTE**: Currently, the innermost dimension of the tensor must be divisible
          by 8.

          Given an &lt;code&gt;input&lt;/code&gt; shaped &lt;code&gt;[s0, s1, ..., s_n]&lt;/code&gt;, the output is
          a &lt;code&gt;uint8&lt;/code&gt; tensor shaped &lt;code&gt;[s0, s1, ..., s_n / 8]&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Complex_" data-uid="TensorFlow.TFGraph.Complex*"></a>
  <h4 id="TensorFlow_TFGraph_Complex_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.Complex(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">Complex(TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Converts two real numbers to a complex number.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Complex (TensorFlow.TFOutput real, TensorFlow.TFOutput imag, Nullable&lt;TensorFlow.TFDataType&gt; Tout = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">real</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">imag</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">Tout</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Complex&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Complex_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a tensor <code>real</code> representing the real part of a complex number, and a
              tensor <code>imag</code> representing the imaginary part of a complex number, this
              operation returns complex numbers elementwise of the form \(a + bj\), where
              <em>a</em> represents the <code>real</code> part and <em>b</em> represents the <code>imag</code> part.</p>
<pre><code>          The input tensors &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;imag&lt;/code&gt; must have the same shape.

          For example:

           &lt;pre&gt;&lt;code&gt;
          # tensor &#39;real&#39; is [2.25, 3.25]
          # tensor &lt;code&gt;imag&lt;/code&gt; is [4.75, 5.75]
          tf.complex(real, imag) ==&amp;gt; [[2.25 + 4.75j], [3.25 + 5.75j]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ComplexAbs_" data-uid="TensorFlow.TFGraph.ComplexAbs*"></a>
  <h4 id="TensorFlow_TFGraph_ComplexAbs_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.ComplexAbs(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">ComplexAbs(TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the complex absolute value of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ComplexAbs (TensorFlow.TFOutput x, Nullable&lt;TensorFlow.TFDataType&gt; Tout = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">Tout</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ComplexAbs&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ComplexAbs_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a tensor <code>x</code> of complex numbers, this operation returns a tensor of type
              <code>float</code> or <code>double</code> that is the absolute value of each element in <code>x</code>. All
              elements in <code>x</code> must be complex numbers of the form \(a + bj\). The absolute
              value is computed as \( \sqrt{a^2 + b^2}\).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ComputeAccidentalHits_" data-uid="TensorFlow.TFGraph.ComputeAccidentalHits*"></a>
  <h4 id="TensorFlow_TFGraph_ComputeAccidentalHits_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.ComputeAccidentalHits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">ComputeAccidentalHits(TFOutput, TFOutput, Int64, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the ids of the positions in sampled_candidates that match true_labels.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; ComputeAccidentalHits (TensorFlow.TFOutput true_classes, TensorFlow.TFOutput sampled_candidates, long num_true, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">true_classes</span></td>
        <td><p>The true_classes output of UnpackSparseLabels.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sampled_candidates</span></td>
        <td><p>The sampled_candidates output of CandidateSampler.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_true</span></td>
        <td><p>Number of true labels per context.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              An second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ComputeAccidentalHits&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              indices: A vector of indices corresponding to rows of true_candidates.
              ids: A vector of IDs of positions in sampled_candidates that match a true_label
              for the row with the corresponding index in indices.
              weights: A vector of the same length as indices and ids, in which each element
              is -FLOAT_MAX.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ComputeAccidentalHits_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>When doing log-odds NCE, the result of this op should be passed through a
              SparseToDense op, then added to the logits of the sampled candidates. This has
              the effect of &#39;removing&#39; the sampled labels that match the true labels by
              making the classifier sure that they are sampled labels.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Concat_" data-uid="TensorFlow.TFGraph.Concat*"></a>
  <h4 id="TensorFlow_TFGraph_Concat_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.Concat(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)">Concat(TFOutput, TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Concatenates tensors along one dimension.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Concat (TensorFlow.TFOutput concat_dim, TensorFlow.TFOutput[] values, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">concat_dim</span></td>
        <td><p>0-D.  The dimension along which to concatenate.  Must be in the
              range [0, rank(values)).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">values</span></td>
        <td><p>The <code>N</code> Tensors to concatenate. Their ranks and types must match,
              and their sizes must match in all dimensions except <code>concat_dim</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Concat&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A <code>Tensor</code> with the concatenation of values stacked along the
              <code>concat_dim</code> dimension.  This tensor&#39;s shape matches that of <code>values</code> except
              in <code>concat_dim</code> where it has the sum of the sizes.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ConcatenateDataset_" data-uid="TensorFlow.TFGraph.ConcatenateDataset*"></a>
  <h4 id="TensorFlow_TFGraph_ConcatenateDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.ConcatenateDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">ConcatenateDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that concatenates <code>input_dataset</code> with <code>another_dataset</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ConcatenateDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput another_dataset, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">another_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ConcatenateDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ConcatOffset_" data-uid="TensorFlow.TFGraph.ConcatOffset*"></a>
  <h4 id="TensorFlow_TFGraph_ConcatOffset_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.ConcatOffset(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)">ConcatOffset(TFOutput, TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Computes offsets of concat inputs within its output.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] ConcatOffset (TensorFlow.TFOutput concat_dim, TensorFlow.TFOutput[] shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">concat_dim</span></td>
        <td><p>The dimension along which to concatenate.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">shape</span></td>
        <td><p>The <code>N</code> int32 vectors representing shape of tensors being concatenated.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ConcatOffset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The <code>N</code> int32 vectors representing the starting offset
              of input tensors within the concatenated output.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ConcatOffset_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>For example:</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          # &#39;x&#39; is [2, 2, 7]
          # &#39;y&#39; is [2, 3, 7]
          # &#39;z&#39; is [2, 5, 7]
          concat_offset(2, [x, y, z]) =&amp;gt; [0, 0, 0], [0, 2, 0], [0, 5, 0]
           &lt;/code&gt;&lt;/pre&gt;

          This is typically used by gradient computations for a concat operation.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ConcatV2_" data-uid="TensorFlow.TFGraph.ConcatV2*"></a>
  <h4 id="TensorFlow_TFGraph_ConcatV2_TensorFlow_TFOutput___TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ConcatV2(TensorFlow.TFOutput[],TensorFlow.TFOutput,System.String)">ConcatV2(TFOutput[], TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Concatenates tensors along one dimension.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ConcatV2 (TensorFlow.TFOutput[] values, TensorFlow.TFOutput axis, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">values</span></td>
        <td><p>List of <code>N</code> Tensors to concatenate. Their ranks and types must match,
              and their sizes must match in all dimensions except <code>concat_dim</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">axis</span></td>
        <td><p>0-D.  The dimension along which to concatenate.  Must be in the
              range [-rank(values), rank(values)).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ConcatV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A <code>Tensor</code> with the concatenation of values stacked along the
              <code>concat_dim</code> dimension.  This tensor&#39;s shape matches that of <code>values</code> except
              in <code>concat_dim</code> where it has the sum of the sizes.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Cond_" data-uid="TensorFlow.TFGraph.Cond*"></a>
  <h4 id="TensorFlow_TFGraph_Cond_TensorFlow_TFOutput_System_Func_TensorFlow_TFOutput__System_Func_TensorFlow_TFOutput__System_String_" data-uid="TensorFlow.TFGraph.Cond(TensorFlow.TFOutput,System.Func{TensorFlow.TFOutput},System.Func{TensorFlow.TFOutput},System.String)">Cond(TFOutput, Func&lt;TFOutput&gt;, Func&lt;TFOutput&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns <code>true_fn</code> if the predicate <code>pred</code> is <code>true</code> else <code>false_fn</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Cond (TensorFlow.TFOutput pred, Func&lt;TensorFlow.TFOutput&gt; true_fn, Func&lt;TensorFlow.TFOutput&gt; false_fn, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">pred</span></td>
        <td><p>A scalar determining whether to return the result of true_fn or false_fn.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Func</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><span class="parametername">true_fn</span></td>
        <td><p>The callable to be performed if pred is true.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Func</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><span class="parametername">false_fn</span></td>
        <td><p>The callable to be performed if pred is false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Optional name prefix for the returned tensors.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>TFOutput.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ConditionalAccumulator_" data-uid="TensorFlow.TFGraph.ConditionalAccumulator*"></a>
  <h4 id="TensorFlow_TFGraph_ConditionalAccumulator_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.ConditionalAccumulator(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String,System.String)">ConditionalAccumulator(TFDataType, TFShape, String, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A conditional accumulator for aggregating gradients.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ConditionalAccumulator (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string container = null, string shared_name = null, string reduction_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of the value being accumulated.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the values, can be [], in which case shape is unknown.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this accumulator is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this accumulator will be shared under the
              given name across multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">reduction_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ConditionalAccumulator&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to the accumulator.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ConditionalAccumulator_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The accumulator accepts gradients marked with local_step greater or
              equal to the most recent global_step known to the accumulator. The
              average can be extracted from the accumulator, provided sufficient
              gradients have been accumulated. Extracting the average automatically
              resets the aggregate to 0, and increments the global_step recorded by
              the accumulator.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ConfigureDistributedTPU_" data-uid="TensorFlow.TFGraph.ConfigureDistributedTPU*"></a>
  <h4 id="TensorFlow_TFGraph_ConfigureDistributedTPU_System_String_System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ConfigureDistributedTPU(System.String,System.String,System.Nullable{System.Boolean},System.String)">ConfigureDistributedTPU(String, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>An op that sets up the centralized structures for a distributed TPU</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ConfigureDistributedTPU (string embedding_config = null, string tpu_embedding_config = null, Nullable&lt;bool&gt; is_global_init = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">embedding_config</span></td>
        <td><p>Optional argument
              Reserved. Do not use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">tpu_embedding_config</span></td>
        <td><p>Optional argument
              Serialized tensorflow.tpu.TPUEmbeddingConfiguration that
              describes the embedding lookups of the program.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">is_global_init</span></td>
        <td><p>Optional argument
              Reserved. Do not use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ConfigureDistributedTPU&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A serialized tensorflow.tpu.TopologyProto that describes the TPU
              topology.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ConfigureDistributedTPU_System_String_System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>system.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Conj_" data-uid="TensorFlow.TFGraph.Conj*"></a>
  <h4 id="TensorFlow_TFGraph_Conj_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Conj(TensorFlow.TFOutput,System.String)">Conj(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the complex conjugate of a complex number.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Conj (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Conj&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Conj_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of
              complex numbers that are the complex conjugate of each element in <code>input</code>. The
              complex numbers in <code>input</code> must be of the form \(a + bj\), where <em>a</em> is the
              real part and <em>b</em> is the imaginary part.</p>
<pre><code>          The complex conjugate returned by this operation is of the form \\(a - bj\\).

          For example:

           &lt;pre&gt;&lt;code&gt;
          # tensor &#39;input&#39; is [-2.25 + 4.75j, 3.25 + 5.75j]
          tf.conj(input) ==&amp;gt; [-2.25 - 4.75j, 3.25 - 5.75j]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ConjugateTranspose_" data-uid="TensorFlow.TFGraph.ConjugateTranspose*"></a>
  <h4 id="TensorFlow_TFGraph_ConjugateTranspose_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ConjugateTranspose(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ConjugateTranspose(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Shuffle dimensions of x according to a permutation and conjugate the result.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ConjugateTranspose (TensorFlow.TFOutput x, TensorFlow.TFOutput perm, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">perm</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ConjugateTranspose&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ConjugateTranspose_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The output <code>y</code> has the same rank as <code>x</code>. The shapes of <code>x</code> and <code>y</code> satisfy:
              <code>y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]</code><code>y[i,j,k,...,s,t,u] == conj(x[perm[i], perm[j], perm[k],...,perm[s], perm[t], perm[u]])</code></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Const_" data-uid="TensorFlow.TFGraph.Const*"></a>
  <h4 id="TensorFlow_TFGraph_Const_TensorFlow_TFTensor_System_String_" data-uid="TensorFlow.TFGraph.Const(TensorFlow.TFTensor,System.String)">Const(TFTensor, String)</h4>
  <div class="markdown level1 summary"><p>Creates a constant operation from a TFTensor or constant</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Const (TensorFlow.TFTensor value, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFTensor.html">TFTensor</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>Value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Oper name.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Const_TensorFlow_TFTensor_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Since TFTensor have implicit conversion operators, you can call this method with
            a constant like this: graph.Const (23)</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Const_" data-uid="TensorFlow.TFGraph.Const*"></a>
  <h4 id="TensorFlow_TFGraph_Const_TensorFlow_TFTensor_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.Const(TensorFlow.TFTensor,TensorFlow.TFDataType,System.String)">Const(TFTensor, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Returns a constant tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Const (TensorFlow.TFTensor value, TensorFlow.TFDataType dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFTensor.html">TFTensor</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>Attr <code>value</code> is the tensor to return.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Const&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Constant_" data-uid="TensorFlow.TFGraph.Constant*"></a>
  <h4 id="TensorFlow_TFGraph_Constant_System_Object_TensorFlow_TFShape_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.Constant(System.Object,TensorFlow.TFShape,TensorFlow.TFDataType,System.String)">Constant(Object, TFShape, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Create a constant tensor based on a shape
            Used by Zeros and Ones</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Constant (object value, TensorFlow.TFShape tfshape, TensorFlow.TFDataType dtype = TensorFlow.TFDataType.Double, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Object</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>Value for tensor</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">tfshape</span></td>
        <td><p>Shape of the tensor</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>Optional Type of the Zero value. Default: Double</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Operation name, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ConsumeMutexLock_" data-uid="TensorFlow.TFGraph.ConsumeMutexLock*"></a>
  <h4 id="TensorFlow_TFGraph_ConsumeMutexLock_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ConsumeMutexLock(TensorFlow.TFOutput,System.String)">ConsumeMutexLock(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>This op consumes a lock created by <code>MutexLock</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ConsumeMutexLock (TensorFlow.TFOutput mutex_lock, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mutex_lock</span></td>
        <td><p>A tensor returned by <code>MutexLock</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ConsumeMutexLock&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ConsumeMutexLock_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op exists to consume a tensor created by <code>MutexLock</code> (other than
              direct control dependencies).  It should be the only that consumes the tensor,
              and will raise an error if it is not.  Its only purpose is to keep the
              mutex lock tensor alive until it is consumed by this op.</p>
<pre><code>          **NOTE**: This operation must run on the same device as its input.  This may
          be enforced via the &lt;code&gt;colocate_with&lt;/code&gt; mechanism.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ControlTrigger_" data-uid="TensorFlow.TFGraph.ControlTrigger*"></a>
  <h4 id="TensorFlow_TFGraph_ControlTrigger_System_String_" data-uid="TensorFlow.TFGraph.ControlTrigger(System.String)">ControlTrigger(String)</h4>
  <div class="markdown level1 summary"><p>Does nothing. Serves as a control trigger for scheduling.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ControlTrigger (string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ControlTrigger&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ControlTrigger_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Only useful as a placeholder for control edges.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Conv2D_" data-uid="TensorFlow.TFGraph.Conv2D*"></a>
  <h4 id="TensorFlow_TFGraph_Conv2D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_Nullable_System_Boolean__System_String_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.Conv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)">Conv2D(TFOutput, TFOutput, Int64[], String, Nullable&lt;Boolean&gt;, String, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Computes a 2-D convolution given 4-D <code>input</code> and <code>filter</code> tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Conv2D (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, long[] strides, string padding, Nullable&lt;bool&gt; use_cudnn_on_gpu = null, string data_format = null, long[] dilations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A 4-D tensor. The dimension order is interpreted according to the value
              of <code>data_format</code>, see below for details.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>A 4-D tensor of shape
              <code>[filter_height, filter_width, in_channels, out_channels]</code></p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D tensor of length 4.  The stride of the sliding window for each
              dimension of <code>input</code>. The dimension order is determined by the value of
              <code>data_format</code>, see below for details.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_cudnn_on_gpu</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, height, width, channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, channels, height, width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">dilations</span></td>
        <td><p>Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each
              filter element on that dimension. The dimension order is determined by the
              value of <code>data_format</code>, see above for details. Dilations in the batch and
              depth dimensions must be 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Conv2D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A 4-D tensor. The dimension order is determined by the value of
              <code>data_format</code>, see below for details.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Conv2D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_Nullable_System_Boolean__System_String_System_Int64___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
              and a filter / kernel tensor of shape
              <code>[filter_height, filter_width, in_channels, out_channels]</code>, this op
              performs the following:</p>
<pre><code>          1. Flattens the filter to a 2-D matrix with shape
          &lt;code&gt;[filter_height * filter_width * in_channels, output_channels]&lt;/code&gt;.
          2. Extracts image patches from the input tensor to form a *virtual*
          tensor of shape &lt;code&gt;[batch, out_height, out_width,
          filter_height * filter_width * in_channels]&lt;/code&gt;.
          3. For each patch, right-multiplies the filter matrix and the image patch
          vector.

          In detail, with the default NHWC format,

          output[b, i, j, k] =
          sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *
          filter[di, dj, q, k]

          Must have &lt;code&gt;strides[0] = strides[3] = 1&lt;/code&gt;.  For the most common case of the same
          horizontal and vertices strides, &lt;code&gt;strides = [1, stride, stride, 1]&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Conv2DBackpropFilter_" data-uid="TensorFlow.TFGraph.Conv2DBackpropFilter*"></a>
  <h4 id="TensorFlow_TFGraph_Conv2DBackpropFilter_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_Nullable_System_Boolean__System_String_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.Conv2DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)">Conv2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable&lt;Boolean&gt;, String, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradients of convolution with respect to the filter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Conv2DBackpropFilter (TensorFlow.TFOutput input, TensorFlow.TFOutput filter_sizes, TensorFlow.TFOutput out_backprop, long[] strides, string padding, Nullable&lt;bool&gt; use_cudnn_on_gpu = null, string data_format = null, long[] dilations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter_sizes</span></td>
        <td><p>An integer vector representing the tensor shape of <code>filter</code>,
              where <code>filter</code> is a 4-D
              <code>[filter_height, filter_width, in_channels, out_channels]</code> tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">out_backprop</span></td>
        <td><p>4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
              Gradients w.r.t. the output of the convolution.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the input
              of the convolution. Must be in the same order as the dimension specified with
              format.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_cudnn_on_gpu</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, in_channels, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">dilations</span></td>
        <td><p>Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each filter
              element on that dimension. The dimension order is determined by the value of
              <code>data_format</code>, see above for details. Dilations in the batch and depth
              dimensions must be 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Conv2DBackpropFilter&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape
              <code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
              the <code>filter</code> input of the convolution.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Conv2DBackpropInput_" data-uid="TensorFlow.TFGraph.Conv2DBackpropInput*"></a>
  <h4 id="TensorFlow_TFGraph_Conv2DBackpropInput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_Nullable_System_Boolean__System_String_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.Conv2DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)">Conv2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Nullable&lt;Boolean&gt;, String, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradients of convolution with respect to the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Conv2DBackpropInput (TensorFlow.TFOutput input_sizes, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, string padding, Nullable&lt;bool&gt; use_cudnn_on_gpu = null, string data_format = null, long[] dilations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_sizes</span></td>
        <td><p>An integer vector representing the shape of <code>input</code>,
              where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>4-D with shape
              <code>[filter_height, filter_width, in_channels, out_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">out_backprop</span></td>
        <td><p>4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
              Gradients w.r.t. the output of the convolution.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the input
              of the convolution. Must be in the same order as the dimension specified with
              format.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_cudnn_on_gpu</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, in_channels, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">dilations</span></td>
        <td><p>Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each filter
              element on that dimension. The dimension order is determined by the value of
              <code>data_format</code>, see above for details. Dilations in the batch and depth
              dimensions must be 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Conv2DBackpropInput&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.  Gradient
              w.r.t. the input of the convolution.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Conv3D_" data-uid="TensorFlow.TFGraph.Conv3D*"></a>
  <h4 id="TensorFlow_TFGraph_Conv3D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_String_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.Conv3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)">Conv3D(TFOutput, TFOutput, Int64[], String, String, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Computes a 3-D convolution given 5-D <code>input</code> and <code>filter</code> tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Conv3D (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Shape <code>[batch, in_depth, in_height, in_width, in_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>Shape <code>[filter_depth, filter_height, filter_width, in_channels,
              out_channels]</code>. <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D tensor of length 5. The stride of the sliding window for each
              dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              The data format of the input and output data. With the
              default format &quot;NDHWC&quot;, the data is stored in the order of:
              [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCDHW&quot;, the data storage order is:
              [batch, in_channels, in_depth, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">dilations</span></td>
        <td><p>Optional argument
              1-D tensor of length 5.  The dilation factor for each dimension of
              <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each
              filter element on that dimension. The dimension order is determined by the
              value of <code>data_format</code>, see above for details. Dilations in the batch and
              depth dimensions must be 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Conv3D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Conv3D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_String_System_Int64___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>In signal processing, cross-correlation is a measure of similarity of
              two waveforms as a function of a time-lag applied to one of them. This
              is also known as a sliding dot product or sliding inner-product.</p>
<pre><code>          Our Conv3D implements a form of cross-correlation.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Conv3DBackpropFilter_" data-uid="TensorFlow.TFGraph.Conv3DBackpropFilter*"></a>
  <h4 id="TensorFlow_TFGraph_Conv3DBackpropFilter_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.Conv3DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Int64[],System.String)">Conv3DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradients of 3-D convolution with respect to the filter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Conv3DBackpropFilter (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, string padding, long[] dilations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Shape <code>[batch, depth, rows, cols, in_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
              <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">out_backprop</span></td>
        <td><p>Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
              out_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D tensor of length 5. The stride of the sliding window for each
              dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">dilations</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Conv3DBackpropFilter&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Conv3DBackpropFilterV2_" data-uid="TensorFlow.TFGraph.Conv3DBackpropFilterV2*"></a>
  <h4 id="TensorFlow_TFGraph_Conv3DBackpropFilterV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_String_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.Conv3DBackpropFilterV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)">Conv3DBackpropFilterV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradients of 3-D convolution with respect to the filter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Conv3DBackpropFilterV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput filter_sizes, TensorFlow.TFOutput out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Shape <code>[batch, depth, rows, cols, in_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter_sizes</span></td>
        <td><p>An integer vector representing the tensor shape of <code>filter</code>,
              where <code>filter</code> is a 5-D
              <code>[filter_depth, filter_height, filter_width, in_channels, out_channels]</code>
              tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">out_backprop</span></td>
        <td><p>Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
              out_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D tensor of length 5. The stride of the sliding window for each
              dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              The data format of the input and output data. With the
              default format &quot;NDHWC&quot;, the data is stored in the order of:
              [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCDHW&quot;, the data storage order is:
              [batch, in_channels, in_depth, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">dilations</span></td>
        <td><p>Optional argument
              1-D tensor of length 5.  The dilation factor for each dimension of
              <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each
              filter element on that dimension. The dimension order is determined by the
              value of <code>data_format</code>, see above for details. Dilations in the batch and
              depth dimensions must be 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Conv3DBackpropFilterV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Conv3DBackpropInput_" data-uid="TensorFlow.TFGraph.Conv3DBackpropInput*"></a>
  <h4 id="TensorFlow_TFGraph_Conv3DBackpropInput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.Conv3DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Int64[],System.String)">Conv3DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradients of 3-D convolution with respect to the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Conv3DBackpropInput (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, string padding, long[] dilations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Shape <code>[batch, depth, rows, cols, in_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
              <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">out_backprop</span></td>
        <td><p>Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
              out_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D tensor of length 5. The stride of the sliding window for each
              dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">dilations</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Conv3DBackpropInput&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Conv3DBackpropInputV2_" data-uid="TensorFlow.TFGraph.Conv3DBackpropInputV2*"></a>
  <h4 id="TensorFlow_TFGraph_Conv3DBackpropInputV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_String_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.Conv3DBackpropInputV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)">Conv3DBackpropInputV2(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradients of 3-D convolution with respect to the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Conv3DBackpropInputV2 (TensorFlow.TFOutput input_sizes, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_sizes</span></td>
        <td><p>An integer vector representing the tensor shape of <code>input</code>,
              where <code>input</code> is a 5-D
              <code>[batch, depth, rows, cols, in_channels]</code> tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
              <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">out_backprop</span></td>
        <td><p>Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
              out_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D tensor of length 5. The stride of the sliding window for each
              dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              The data format of the input and output data. With the
              default format &quot;NDHWC&quot;, the data is stored in the order of:
              [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCDHW&quot;, the data storage order is:
              [batch, in_channels, in_depth, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">dilations</span></td>
        <td><p>Optional argument
              1-D tensor of length 5.  The dilation factor for each dimension of
              <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each
              filter element on that dimension. The dimension order is determined by the
              value of <code>data_format</code>, see above for details. Dilations in the batch and
              depth dimensions must be 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Conv3DBackpropInputV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Copy_" data-uid="TensorFlow.TFGraph.Copy*"></a>
  <h4 id="TensorFlow_TFGraph_Copy_TensorFlow_TFOutput_System_String_System_String___System_String_" data-uid="TensorFlow.TFGraph.Copy(TensorFlow.TFOutput,System.String,System.String[],System.String)">Copy(TFOutput, String, String[], String)</h4>
  <div class="markdown level1 summary"><p>Copy Op.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Copy (TensorFlow.TFOutput input, string tensor_name = null, string[] debug_ops_spec = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">tensor_name</span></td>
        <td><p>Optional argument
              The name of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">debug_ops_spec</span></td>
        <td><p>Optional argument
              A list of debug op spec (op, url, gated_grpc) for attached debug
              ops. Each element of the list has the format
              &lt;debug_op&gt;;&lt;grpc_url&gt;;&lt;gated_grpc&gt;, wherein gated_grpc is boolean represented
              as 0/1. E.g., &quot;DebugIdentity;grpc://foo:3333;1&quot;,
              &quot;DebugIdentity;file:///tmp/tfdbg_1;0&quot;.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Copy&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Output tensor, deep-copied from input.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Copy_TensorFlow_TFOutput_System_String_System_String___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Performs CPU-to-CPU or GPU-to-GPU deep-copying of tensor, depending on the
              device on which the tensor is allocated.
              N.B.: If the all downstream attached debug ops are disabled given the current
              gRPC gating status, the output will simply forward the input tensor without
              deep-copying. See the documentation of Debug* ops for more details.</p>
<pre><code>          Unlike the CopyHost Op, this op does not have HostMemory constraint on its
          input or output.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_CopyHost_" data-uid="TensorFlow.TFGraph.CopyHost*"></a>
  <h4 id="TensorFlow_TFGraph_CopyHost_TensorFlow_TFOutput_System_String_System_String___System_String_" data-uid="TensorFlow.TFGraph.CopyHost(TensorFlow.TFOutput,System.String,System.String[],System.String)">CopyHost(TFOutput, String, String[], String)</h4>
  <div class="markdown level1 summary"><p>Copy Host Op.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CopyHost (TensorFlow.TFOutput input, string tensor_name = null, string[] debug_ops_spec = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">tensor_name</span></td>
        <td><p>Optional argument
              The name of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">debug_ops_spec</span></td>
        <td><p>Optional argument
              A list of debug op spec (op, url, gated_grpc) for attached debug
              ops. Each element of the list has the format
              &lt;debug_op&gt;;&lt;grpc_url&gt;;&lt;gated_grpc&gt;, wherein gated_grpc is boolean represented
              as 0/1. E.g., &quot;DebugIdentity;grpc://foo:3333;1&quot;,
              &quot;DebugIdentity;file:///tmp/tfdbg_1;0&quot;.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CopyHost&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Output tensor, deep-copied from input.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CopyHost_TensorFlow_TFOutput_System_String_System_String___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Performs CPU-to-CPU deep-copying of tensor.
              N.B.: If the all downstream attached debug ops are disabled given the current
              gRPC gating status, the output will simply forward the input tensor without
              deep-copying. See the documentation of Debug* ops for more details.</p>
<pre><code>          Unlike the Copy Op, this op has HostMemory constraint on its input or output.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Cos_" data-uid="TensorFlow.TFGraph.Cos*"></a>
  <h4 id="TensorFlow_TFGraph_Cos_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Cos(TensorFlow.TFOutput,System.String)">Cos(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes cos of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Cos (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Cos&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Cosh_" data-uid="TensorFlow.TFGraph.Cosh*"></a>
  <h4 id="TensorFlow_TFGraph_Cosh_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Cosh(TensorFlow.TFOutput,System.String)">Cosh(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes hyperbolic cosine of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Cosh (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Cosh&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_CountUpTo_" data-uid="TensorFlow.TFGraph.CountUpTo*"></a>
  <h4 id="TensorFlow_TFGraph_CountUpTo_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.CountUpTo(TensorFlow.TFOutput,System.Int64,System.String)">CountUpTo(TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>Increments &#39;ref&#39; until it reaches &#39;limit&#39;.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CountUpTo (TensorFlow.TFOutput reference, long limit, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>Should be from a scalar <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">limit</span></td>
        <td><p>If incrementing ref would bring it above limit, instead generates an
              &#39;OutOfRange&#39; error.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CountUpTo&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A copy of the input before increment. If nothing else modifies the
              input, the values produced will all be distinct.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_CropAndResize_" data-uid="TensorFlow.TFGraph.CropAndResize*"></a>
  <h4 id="TensorFlow_TFGraph_CropAndResize_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Nullable_System_Single__System_String_" data-uid="TensorFlow.TFGraph.CropAndResize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Single},System.String)">CropAndResize(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable&lt;Single&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Extracts crops from the input image tensor and resizes them.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CropAndResize (TensorFlow.TFOutput image, TensorFlow.TFOutput boxes, TensorFlow.TFOutput box_ind, TensorFlow.TFOutput crop_size, string method = null, Nullable&lt;float&gt; extrapolation_value = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">image</span></td>
        <td><p>A 4-D tensor of shape <code>[batch, image_height, image_width, depth]</code>.
              Both <code>image_height</code> and <code>image_width</code> need to be positive.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">boxes</span></td>
        <td><p>A 2-D tensor of shape <code>[num_boxes, 4]</code>. The <code>i</code>-th row of the tensor
              specifies the coordinates of a box in the <code>box_ind[i]</code> image and is specified
              in normalized coordinates <code>[y1, x1, y2, x2]</code>. A normalized coordinate value of
              <code>y</code> is mapped to the image coordinate at <code>y * (image_height - 1)</code>, so as the
              <code>[0, 1]</code> interval of normalized image height is mapped to
              <code>[0, image_height - 1]</code> in image height coordinates. We do allow <code>y1</code> &gt; <code>y2</code>, in
              which case the sampled crop is an up-down flipped version of the original
              image. The width dimension is treated similarly. Normalized coordinates
              outside the <code>[0, 1]</code> range are allowed, in which case we use
              <code>extrapolation_value</code> to extrapolate the input image values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">box_ind</span></td>
        <td><p>A 1-D tensor of shape <code>[num_boxes]</code> with int32 values in <code>[0, batch)</code>.
              The value of <code>box_ind[i]</code> specifies the image that the <code>i</code>-th box refers to.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">crop_size</span></td>
        <td><p>A 1-D tensor of 2 elements, <code>size = [crop_height, crop_width]</code>. All
              cropped image patches are resized to this size. The aspect ratio of the image
              content is not preserved. Both <code>crop_height</code> and <code>crop_width</code> need to be
              positive.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">method</span></td>
        <td><p>Optional argument
              A string specifying the sampling method for resizing. It can be either
              <code>&quot;bilinear&quot;</code> or <code>&quot;nearest&quot;</code> and default to <code>&quot;bilinear&quot;</code>. Currently two sampling
              methods are supported: Bilinear and Nearest Neighbor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">extrapolation_value</span></td>
        <td><p>Optional argument
              Value used for extrapolation, when applicable.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CropAndResize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A 4-D tensor of shape <code>[num_boxes, crop_height, crop_width, depth]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CropAndResize_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Nullable_System_Single__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Extracts crops from the input image tensor and resizes them using bilinear
              sampling or nearest neighbor sampling (possibly with aspect ratio change) to a
              common output size specified by <code>crop_size</code>. This is more general than the
              <code>crop_to_bounding_box</code> op which extracts a fixed size slice from the input image
              and does not allow resizing or aspect ratio change.</p>
<pre><code>          Returns a tensor with &lt;code&gt;crops&lt;/code&gt; from the input &lt;code&gt;image&lt;/code&gt; at positions defined at the
          bounding box locations in &lt;code&gt;boxes&lt;/code&gt;. The cropped boxes are all resized (with
          bilinear or nearest neighbor interpolation) to a fixed
          &lt;code&gt;size = [crop_height, crop_width]&lt;/code&gt;. The result is a 4-D tensor
          &lt;code&gt;[num_boxes, crop_height, crop_width, depth]&lt;/code&gt;. The resizing is corner aligned.
          In particular, if &lt;code&gt;boxes = [[0, 0, 1, 1]]&lt;/code&gt;, the method will give identical
          results to using &lt;code&gt;tf.image.resize_bilinear()&lt;/code&gt; or
          &lt;code&gt;tf.image.resize_nearest_neighbor()&lt;/code&gt;(depends on the &lt;code&gt;method&lt;/code&gt; argument) with
          &lt;code&gt;align_corners=True&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_CropAndResizeGradBoxes_" data-uid="TensorFlow.TFGraph.CropAndResizeGradBoxes*"></a>
  <h4 id="TensorFlow_TFGraph_CropAndResizeGradBoxes_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.CropAndResizeGradBoxes(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">CropAndResizeGradBoxes(TFOutput, TFOutput, TFOutput, TFOutput, String, String)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CropAndResizeGradBoxes (TensorFlow.TFOutput grads, TensorFlow.TFOutput image, TensorFlow.TFOutput boxes, TensorFlow.TFOutput box_ind, string method = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grads</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">image</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">boxes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">box_ind</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">method</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_CropAndResizeGradImage_" data-uid="TensorFlow.TFGraph.CropAndResizeGradImage*"></a>
  <h4 id="TensorFlow_TFGraph_CropAndResizeGradImage_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_System_String_" data-uid="TensorFlow.TFGraph.CropAndResizeGradImage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String)">CropAndResizeGradImage(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String, String)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CropAndResizeGradImage (TensorFlow.TFOutput grads, TensorFlow.TFOutput boxes, TensorFlow.TFOutput box_ind, TensorFlow.TFOutput image_size, TensorFlow.TFDataType T, string method = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grads</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">boxes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">box_ind</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">image_size</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">T</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">method</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Cross_" data-uid="TensorFlow.TFGraph.Cross*"></a>
  <h4 id="TensorFlow_TFGraph_Cross_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Cross(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Cross(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Compute the pairwise cross product.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Cross (TensorFlow.TFOutput a, TensorFlow.TFOutput b, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a</span></td>
        <td><p>A tensor containing 3-element vectors.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b</span></td>
        <td><p>Another tensor, of same type and shape as <code>a</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Cross&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Pairwise cross product of the vectors in <code>a</code> and <code>b</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Cross_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>a</code> and <code>b</code> must be the same shape; they can either be simple 3-element vectors,
              or any shape where the innermost dimension is 3. In the latter case, each pair
              of corresponding 3-element vectors is cross-multiplied independently.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_CrossReplicaSum_" data-uid="TensorFlow.TFGraph.CrossReplicaSum*"></a>
  <h4 id="TensorFlow_TFGraph_CrossReplicaSum_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.CrossReplicaSum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">CrossReplicaSum(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>An Op to sum inputs across replicated TPU instances. Each instance supplies its</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CrossReplicaSum (TensorFlow.TFOutput input, TensorFlow.TFOutput group_assignment, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The local input to the sum.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">group_assignment</span></td>
        <td><p>An int32 tensor with shape
              [num_groups, num_replicas_per_group]. <code>group_assignment[i]</code> represents the
              replica ids in the ith subgroup.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CrossReplicaSum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The sum of all the distributed inputs.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CrossReplicaSum_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>own input.</p>
<pre><code>          For example, suppose there are 8 TPU instances: &lt;code&gt;[A, B, C, D, E, F, G, H]&lt;/code&gt;.
          Passing group_assignment=&lt;code&gt;[[0,2,4,6],[1,3,5,7]]&lt;/code&gt; sets &lt;code&gt;A, C, E, G&lt;/code&gt; as group 0,
          and &lt;code&gt;B, D, F, H&lt;/code&gt; as group 1. Thus we get the outputs:
          &lt;code&gt;[A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H, A+C+E+G, B+D+F+H]&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_CTCBeamSearchDecoder_" data-uid="TensorFlow.TFGraph.CTCBeamSearchDecoder*"></a>
  <h4 id="TensorFlow_TFGraph_CTCBeamSearchDecoder_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.CTCBeamSearchDecoder(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)">CTCBeamSearchDecoder(TFOutput, TFOutput, Int64, Int64, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Performs beam search decoding on the logits given in input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput&gt; CTCBeamSearchDecoder (TensorFlow.TFOutput inputs, TensorFlow.TFOutput sequence_length, long beam_width, long top_paths, Nullable&lt;bool&gt; merge_repeated = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">inputs</span></td>
        <td><p>3-D, shape: <code>(max_time x batch_size x num_classes)</code>, the logits.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sequence_length</span></td>
        <td><p>A vector containing sequence lengths, size <code>(batch)</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">beam_width</span></td>
        <td><p>A scalar &gt;= 0 (beam search beam width).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">top_paths</span></td>
        <td><p>A scalar &gt;= 0, &lt;= beam_width (controls output size).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">merge_repeated</span></td>
        <td><p>Optional argument
              If true, merge repeated classes in output.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CTCBeamSearchDecoder&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              decoded_indices: A list (length: top_paths) of indices matrices.  Matrix j,
              size <code>(total_decoded_outputs[j] x 2)</code>, has indices of a
              <code>SparseTensor&lt;int64, 2&gt;</code>.  The rows store: [batch, time].
              decoded_values: A list (length: top_paths) of values vectors.  Vector j,
              size <code>(length total_decoded_outputs[j])</code>, has the values of a
              <code>SparseTensor&lt;int64, 2&gt;</code>.  The vector stores the decoded classes for beam j.
              decoded_shape: A list (length: top_paths) of shape vector.  Vector j,
              size <code>(2)</code>, stores the shape of the decoded <code>SparseTensor[j]</code>.
              Its values are: <code>[batch_size, max_decoded_length[j]]</code>.
              log_probability: A matrix, shaped: <code>(batch_size x top_paths)</code>.  The
              sequence log-probabilities.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CTCBeamSearchDecoder_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>A note about the attribute merge_repeated: For the beam search decoder,
              this means that if consecutive entries in a beam are the same, only
              the first of these is emitted.  That is, when the top path is &quot;A B B B B&quot;,
              &quot;A B&quot; is returned if merge_repeated = True but &quot;A B B B B&quot; is
              returned if merge_repeated = False.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_CTCGreedyDecoder_" data-uid="TensorFlow.TFGraph.CTCGreedyDecoder*"></a>
  <h4 id="TensorFlow_TFGraph_CTCGreedyDecoder_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.CTCGreedyDecoder(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">CTCGreedyDecoder(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Performs greedy decoding on the logits given in inputs.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; CTCGreedyDecoder (TensorFlow.TFOutput inputs, TensorFlow.TFOutput sequence_length, Nullable&lt;bool&gt; merge_repeated = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">inputs</span></td>
        <td><p>3-D, shape: <code>(max_time x batch_size x num_classes)</code>, the logits.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sequence_length</span></td>
        <td><p>A vector containing sequence lengths, size <code>(batch_size)</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">merge_repeated</span></td>
        <td><p>Optional argument
              If True, merge repeated classes in output.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CTCGreedyDecoder&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              decoded_indices: Indices matrix, size <code>(total_decoded_outputs x 2)</code>,
              of a <code>SparseTensor&lt;int64, 2&gt;</code>.  The rows store: [batch, time].
              decoded_values: Values vector, size: <code>(total_decoded_outputs)</code>,
              of a <code>SparseTensor&lt;int64, 2&gt;</code>.  The vector stores the decoded classes.
              decoded_shape: Shape vector, size <code>(2)</code>, of the decoded SparseTensor.
              Values are: <code>[batch_size, max_decoded_length]</code>.
              log_probability: Matrix, size <code>(batch_size x 1)</code>, containing sequence
              log-probabilities.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CTCGreedyDecoder_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>A note about the attribute merge_repeated: if enabled, when
              consecutive logits&#39; maximum indices are the same, only the first of
              these is emitted.  Labeling the blank &#39;*&#39;, the sequence &quot;A B B * B B&quot;
              becomes &quot;A B B&quot; if merge_repeated = True and &quot;A B B B B&quot; if
              merge_repeated = False.</p>
<pre><code>          Regardless of the value of merge_repeated, if the maximum index of a given
          time and batch corresponds to the blank, index &lt;code&gt;(num_classes - 1)&lt;/code&gt;, no new
          element is emitted.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_CTCLoss_" data-uid="TensorFlow.TFGraph.CTCLoss*"></a>
  <h4 id="TensorFlow_TFGraph_CTCLoss_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.CTCLoss(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">CTCLoss(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Calculates the CTC Loss (log probability) for each batch entry.  Also calculates</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; CTCLoss (TensorFlow.TFOutput inputs, TensorFlow.TFOutput labels_indices, TensorFlow.TFOutput labels_values, TensorFlow.TFOutput sequence_length, Nullable&lt;bool&gt; preprocess_collapse_repeated = null, Nullable&lt;bool&gt; ctc_merge_repeated = null, Nullable&lt;bool&gt; ignore_longer_outputs_than_inputs = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">inputs</span></td>
        <td><p>3-D, shape: <code>(max_time x batch_size x num_classes)</code>, the logits.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">labels_indices</span></td>
        <td><p>The indices of a <code>SparseTensor&lt;int32, 2&gt;</code>.
              <code>labels_indices(i, :) == [b, t]</code> means <code>labels_values(i)</code> stores the id for
              <code>(batch b, time t)</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">labels_values</span></td>
        <td><p>The values (labels) associated with the given batch and time.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sequence_length</span></td>
        <td><p>A vector containing sequence lengths (batch).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">preprocess_collapse_repeated</span></td>
        <td><p>Optional argument
              Scalar, if true then repeated labels are
              collapsed prior to the CTC calculation.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">ctc_merge_repeated</span></td>
        <td><p>Optional argument
              Scalar.  If set to false, <em>during</em> CTC calculation
              repeated non-blank labels will not be merged and are interpreted as
              individual labels.  This is a simplified version of CTC.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">ignore_longer_outputs_than_inputs</span></td>
        <td><p>Optional argument
              Scalar. If set to true, during CTC
              calculation, items that have longer output sequences than input sequences
              are skipped: they don&#39;t contribute to the loss term and have zero-gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CTCLoss&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              loss: A vector (batch) containing log-probabilities.
              gradient: The gradient of <code>loss</code>.  3-D, shape:
              <code>(max_time x batch_size x num_classes)</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CTCLoss_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>the gradient.  This class performs the softmax operation for you, so inputs
              should be e.g. linear projections of outputs by an LSTM.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_CudnnRNN_" data-uid="TensorFlow.TFGraph.CudnnRNN*"></a>
  <h4 id="TensorFlow_TFGraph_CudnnRNN_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.CudnnRNN(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">CudnnRNN(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable&lt;Single&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>A RNN backed by cuDNN.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; CudnnRNN (TensorFlow.TFOutput input, TensorFlow.TFOutput input_h, TensorFlow.TFOutput input_c, TensorFlow.TFOutput parameters, string rnn_mode = null, string input_mode = null, string direction = null, Nullable&lt;float&gt; dropout = null, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, Nullable&lt;bool&gt; is_training = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_h</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_c</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">rnn_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">input_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">direction</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">dropout</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">is_training</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CudnnRNN&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output:
              output_h:
              output_c:
              reserve_space:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CudnnRNN_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the RNN from the input and initial states, with respect to the params
              buffer.</p>
<pre><code>          rnn_mode: Indicates the type of the RNN model.
          input_mode: Indicate whether there is a linear projection between the input and
          the actual computation before the first layer. &#39;skip_input&#39; is only allowed
          when input_size == num_units; &#39;auto_select&#39; implies &#39;skip_input&#39; when
          input_size == num_units; otherwise, it implies &#39;linear_input&#39;.
          direction: Indicates whether a bidirectional model will be used. Should be
          &quot;unidirectional&quot; or &quot;bidirectional&quot;.
          dropout: Dropout probability. When set to 0., dropout is disabled.
          seed: The 1st part of a seed to initialize dropout.
          seed2: The 2nd part of a seed to initialize dropout.
          input: A 3-D tensor with the shape of [seq_length, batch_size, input_size].
          input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,
          num_units].
          input_c: For LSTM, a 3-D tensor with the shape of
          [num_layer * dir, batch, num_units]. For other models, it is ignored.
          params: A 1-D tensor that contains the weights and biases in an opaque layout.
          The size must be created through CudnnRNNParamsSize, and initialized
          separately. Note that they might not be compatible across different
          generations. So it is a good idea to save and restore
          output: A 3-D tensor with the shape of [seq_length, batch_size,
          dir * num_units].
          output_h: The same shape has input_h.
          output_c: The same shape as input_c for LSTM. An empty tensor for other models.
          is_training: Indicates whether this operation is used for inferenece or
          training.
          reserve_space: An opaque tensor that can be used in backprop calculation. It
          is only produced if is_training is false.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_CudnnRNNBackprop_" data-uid="TensorFlow.TFGraph.CudnnRNNBackprop*"></a>
  <h4 id="TensorFlow_TFGraph_CudnnRNNBackprop_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.CudnnRNNBackprop(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">CudnnRNNBackprop(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable&lt;Single&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Backprop step of CudnnRNN.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; CudnnRNNBackprop (TensorFlow.TFOutput input, TensorFlow.TFOutput input_h, TensorFlow.TFOutput input_c, TensorFlow.TFOutput parameters, TensorFlow.TFOutput output, TensorFlow.TFOutput output_h, TensorFlow.TFOutput output_c, TensorFlow.TFOutput output_backprop, TensorFlow.TFOutput output_h_backprop, TensorFlow.TFOutput output_c_backprop, TensorFlow.TFOutput reserve_space, string rnn_mode = null, string input_mode = null, string direction = null, Nullable&lt;float&gt; dropout = null, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_h</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_c</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_h</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_c</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_backprop</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_h_backprop</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_c_backprop</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reserve_space</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">rnn_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">input_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">direction</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">dropout</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CudnnRNNBackprop&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              input_backprop:
              input_h_backprop:
              input_c_backprop:
              params_backprop:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CudnnRNNBackprop_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Compute the backprop of both data and weights in a RNN.</p>
<pre><code>          rnn_mode: Indicates the type of the RNN model.
          input_mode: Indicate whether there is a linear projection between the input and
          the actual computation before the first layer. &#39;skip_input&#39; is only allowed
          when input_size == num_units; &#39;auto_select&#39; implies &#39;skip_input&#39; when
          input_size == num_units; otherwise, it implies &#39;linear_input&#39;.
          direction: Indicates whether a bidirectional model will be used. Should be
          &quot;unidirectional&quot; or &quot;bidirectional&quot;.
          dropout: Dropout probability. When set to 0., dropout is disabled.
          seed: The 1st part of a seed to initialize dropout.
          seed2: The 2nd part of a seed to initialize dropout.
          input: A 3-D tensor with the shape of [seq_length, batch_size, input_size].
          input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,
          num_units].
          input_c: For LSTM, a 3-D tensor with the shape of
          [num_layer * dir, batch, num_units]. For other models, it is ignored.
          params: A 1-D tensor that contains the weights and biases in an opaque layout.
          The size must be created through CudnnRNNParamsSize, and initialized
          separately. Note that they might not be compatible across different
          generations. So it is a good idea to save and restore
          output: A 3-D tensor with the shape of [seq_length, batch_size,
          dir * num_units].
          output_h: The same shape has input_h.
          output_c: The same shape as input_c for LSTM. An empty tensor for other models.
          output_backprop: A 3-D tensor with the same shape as output in the forward pass.
          output_h_backprop: A 3-D tensor with the same shape as output_h in the forward
          pass.
          output_c_backprop: A 3-D tensor with the same shape as output_c in the forward
          pass.
          reserve_space: The same reserve_space produced in for forward operation.
          input_backprop: The backprop to input in the forward pass. Has the same shape
          as input.
          input_h_backprop: The backprop to input_h in the forward pass. Has the same
          shape as input_h.
          input_c_backprop: The backprop to input_c in the forward pass. Has the same
          shape as input_c.
          params_backprop: The backprop to the params buffer in the forward pass. Has the
          same shape as params.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_CudnnRNNBackpropV2_" data-uid="TensorFlow.TFGraph.CudnnRNNBackpropV2*"></a>
  <h4 id="TensorFlow_TFGraph_CudnnRNNBackpropV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.CudnnRNNBackpropV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">CudnnRNNBackpropV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable&lt;Single&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Backprop step of CudnnRNN.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; CudnnRNNBackpropV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput input_h, TensorFlow.TFOutput input_c, TensorFlow.TFOutput parameters, TensorFlow.TFOutput output, TensorFlow.TFOutput output_h, TensorFlow.TFOutput output_c, TensorFlow.TFOutput output_backprop, TensorFlow.TFOutput output_h_backprop, TensorFlow.TFOutput output_c_backprop, TensorFlow.TFOutput reserve_space, TensorFlow.TFOutput host_reserved, string rnn_mode = null, string input_mode = null, string direction = null, Nullable&lt;float&gt; dropout = null, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_h</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_c</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_h</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_c</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_backprop</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_h_backprop</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_c_backprop</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reserve_space</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">host_reserved</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">rnn_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">input_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">direction</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">dropout</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CudnnRNNBackpropV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              input_backprop:
              input_h_backprop:
              input_c_backprop:
              params_backprop:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CudnnRNNBackpropV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Compute the backprop of both data and weights in a RNN. Takes an extra
              &quot;host_reserved&quot; inupt than CudnnRNNBackprop, which is used to determine RNN
              cudnnRNNAlgo_t and cudnnMathType_t.</p>
<pre><code>          rnn_mode: Indicates the type of the RNN model.
          input_mode: Indicates whether there is a linear projection between the input and
          the actual computation before the first layer. &#39;skip_input&#39; is only allowed
          when input_size == num_units; &#39;auto_select&#39; implies &#39;skip_input&#39; when
          input_size == num_units; otherwise, it implies &#39;linear_input&#39;.
          direction: Indicates whether a bidirectional model will be used. Should be
          &quot;unidirectional&quot; or &quot;bidirectional&quot;.
          dropout: Dropout probability. When set to 0., dropout is disabled.
          seed: The 1st part of a seed to initialize dropout.
          seed2: The 2nd part of a seed to initialize dropout.
          input: A 3-D tensor with the shape of [seq_length, batch_size, input_size].
          input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,
          num_units].
          input_c: For LSTM, a 3-D tensor with the shape of
          [num_layer * dir, batch, num_units]. For other models, it is ignored.
          params: A 1-D tensor that contains the weights and biases in an opaque layout.
          The size must be created through CudnnRNNParamsSize, and initialized
          separately. Note that they might not be compatible across different
          generations. So it is a good idea to save and restore
          output: A 3-D tensor with the shape of [seq_length, batch_size,
          dir * num_units].
          output_h: The same shape has input_h.
          output_c: The same shape as input_c for LSTM. An empty tensor for other models.
          output_backprop: A 3-D tensor with the same shape as output in the forward pass.
          output_h_backprop: A 3-D tensor with the same shape as output_h in the forward
          pass.
          output_c_backprop: A 3-D tensor with the same shape as output_c in the forward
          pass.
          reserve_space: The same reserve_space produced in the forward operation.
          host_reserved: The same host_reserved produced in the forward operation.
          input_backprop: The backprop to input in the forward pass. Has the same shape
          as input.
          input_h_backprop: The backprop to input_h in the forward pass. Has the same
          shape as input_h.
          input_c_backprop: The backprop to input_c in the forward pass. Has the same
          shape as input_c.
          params_backprop: The backprop to the params buffer in the forward pass. Has the
          same shape as params.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_CudnnRNNCanonicalToParams_" data-uid="TensorFlow.TFGraph.CudnnRNNCanonicalToParams*"></a>
  <h4 id="TensorFlow_TFGraph_CudnnRNNCanonicalToParams_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFOutput___System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.CudnnRNNCanonicalToParams(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">CudnnRNNCanonicalToParams(TFOutput, TFOutput, TFOutput, TFOutput[], TFOutput[], String, String, String, Nullable&lt;Single&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Converts CudnnRNN params from canonical form to usable form.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CudnnRNNCanonicalToParams (TensorFlow.TFOutput num_layers, TensorFlow.TFOutput num_units, TensorFlow.TFOutput input_size, TensorFlow.TFOutput[] weights, TensorFlow.TFOutput[] biases, string rnn_mode = null, string input_mode = null, string direction = null, Nullable&lt;float&gt; dropout = null, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_layers</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_units</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_size</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">weights</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">biases</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">rnn_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">input_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">direction</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">dropout</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CudnnRNNCanonicalToParams&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CudnnRNNCanonicalToParams_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFOutput___System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Writes a set of weights into the opaque params buffer so they can be used in
              upcoming training or inferences.</p>
<pre><code>          Note that the params buffer may not be compatible across different GPUs. So any
          save and restoration should be converted to and from the canonical weights and
          biases.

          num_layers: Specifies the number of layers in the RNN model.
          num_units: Specifies the size of the hidden state.
          input_size: Specifies the size of the input state.
          weights: the canonical form of weights that can be used for saving
          and restoration. They are more likely to be compatible across different
          generations.
          biases: the canonical form of biases that can be used for saving
          and restoration. They are more likely to be compatible across different
          generations.
          num_params: number of parameter sets for all layers.
          Each layer may contain multiple parameter sets, with each set consisting of
          a weight matrix and a bias vector.
          rnn_mode: Indicates the type of the RNN model.
          input_mode: Indicate whether there is a linear projection between the input and
          The actual computation before the first layer. &#39;skip_input&#39; is only allowed
          when input_size == num_units; &#39;auto_select&#39; implies &#39;skip_input&#39; when
          input_size == num_units; otherwise, it implies &#39;linear_input&#39;.
          direction: Indicates whether a bidirectional model will be used.
          dir = (direction == bidirectional) ? 2 : 1
          dropout: dropout probability. When set to 0., dropout is disabled.
          seed: the 1st part of a seed to initialize dropout.
          seed2: the 2nd part of a seed to initialize dropout.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_CudnnRNNParamsSize_" data-uid="TensorFlow.TFGraph.CudnnRNNParamsSize*"></a>
  <h4 id="TensorFlow_TFGraph_CudnnRNNParamsSize_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.CudnnRNNParamsSize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">CudnnRNNParamsSize(TFOutput, TFOutput, TFOutput, TFDataType, TFDataType, String, String, String, Nullable&lt;Single&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes size of weights that can be used by a Cudnn RNN model.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput CudnnRNNParamsSize (TensorFlow.TFOutput num_layers, TensorFlow.TFOutput num_units, TensorFlow.TFOutput input_size, TensorFlow.TFDataType T, TensorFlow.TFDataType S, string rnn_mode = null, string input_mode = null, string direction = null, Nullable&lt;float&gt; dropout = null, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_layers</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_units</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_size</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">T</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">S</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">rnn_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">input_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">direction</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">dropout</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CudnnRNNParamsSize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CudnnRNNParamsSize_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Return the params size that can be used by the Cudnn RNN model. Subsequent
              weight allocation and initialization should use this size.</p>
<pre><code>          num_layers: Specifies the number of layers in the RNN model.
          num_units: Specifies the size of the hidden state.
          input_size: Specifies the size of the input state.
          rnn_mode: Indicates the type of the RNN model.
          input_mode: Indicate whether there is a linear projection between the input and
          The actual computation before the first layer. &#39;skip_input&#39; is only allowed
          when input_size == num_units; &#39;auto_select&#39; implies &#39;skip_input&#39; when
          input_size == num_units; otherwise, it implies &#39;linear_input&#39;.
          direction: Indicates whether a bidirectional model will be used.
          dir = (direction == bidirectional) ? 2 : 1
          dropout: dropout probability. When set to 0., dropout is disabled.
          seed: the 1st part of a seed to initialize dropout.
          seed2: the 2nd part of a seed to initialize dropout.
          params_size: The size of the params buffer that should be allocated and
          initialized for this RNN model. Note that this params buffer may not be
          compatible across GPUs. Please use CudnnRNNParamsWeights and
          CudnnRNNParamsBiases to save and restore them in a way that is compatible
          across different runs.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_CudnnRNNParamsToCanonical_" data-uid="TensorFlow.TFGraph.CudnnRNNParamsToCanonical*"></a>
  <h4 id="TensorFlow_TFGraph_CudnnRNNParamsToCanonical_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.CudnnRNNParamsToCanonical(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">CudnnRNNParamsToCanonical(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String, String, String, Nullable&lt;Single&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Retrieves CudnnRNN params in canonical form.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput[],TensorFlow.TFOutput[]&gt; CudnnRNNParamsToCanonical (TensorFlow.TFOutput num_layers, TensorFlow.TFOutput num_units, TensorFlow.TFOutput input_size, TensorFlow.TFOutput parameters, long num_params, string rnn_mode = null, string input_mode = null, string direction = null, Nullable&lt;float&gt; dropout = null, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_layers</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_units</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_size</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_params</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">rnn_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">input_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">direction</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">dropout</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CudnnRNNParamsToCanonical&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              weights:
              biases:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CudnnRNNParamsToCanonical_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Retrieves a set of weights from the opaque params buffer that can be saved and
              restored in a way compatible with future runs.</p>
<pre><code>          Note that the params buffer may not be compatible across different GPUs. So any
          save and restoration should be converted to and from the canonical weights and
          biases.

          num_layers: Specifies the number of layers in the RNN model.
          num_units: Specifies the size of the hidden state.
          input_size: Specifies the size of the input state.
          num_params: number of parameter sets for all layers.
          Each layer may contain multiple parameter sets, with each set consisting of
          a weight matrix and a bias vector.
          weights: the canonical form of weights that can be used for saving
          and restoration. They are more likely to be compatible across different
          generations.
          biases: the canonical form of biases that can be used for saving
          and restoration. They are more likely to be compatible across different
          generations.
          rnn_mode: Indicates the type of the RNN model.
          input_mode: Indicate whether there is a linear projection between the input and
          The actual computation before the first layer. &#39;skip_input&#39; is only allowed
          when input_size == num_units; &#39;auto_select&#39; implies &#39;skip_input&#39; when
          input_size == num_units; otherwise, it implies &#39;linear_input&#39;.
          direction: Indicates whether a bidirectional model will be used.
          dir = (direction == bidirectional) ? 2 : 1
          dropout: dropout probability. When set to 0., dropout is disabled.
          seed: the 1st part of a seed to initialize dropout.
          seed2: the 2nd part of a seed to initialize dropout.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_CudnnRNNV2_" data-uid="TensorFlow.TFGraph.CudnnRNNV2*"></a>
  <h4 id="TensorFlow_TFGraph_CudnnRNNV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.CudnnRNNV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">CudnnRNNV2(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String, Nullable&lt;Single&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>A RNN backed by cuDNN.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; CudnnRNNV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput input_h, TensorFlow.TFOutput input_c, TensorFlow.TFOutput parameters, string rnn_mode = null, string input_mode = null, string direction = null, Nullable&lt;float&gt; dropout = null, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, Nullable&lt;bool&gt; is_training = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_h</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_c</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">rnn_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">input_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">direction</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">dropout</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">is_training</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;CudnnRNNV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output:
              output_h:
              output_c:
              reserve_space:
              host_reserved:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_CudnnRNNV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the RNN from the input and initial states, with respect to the params
              buffer. Produces one extra output &quot;host_reserved&quot; than CudnnRNN.</p>
<pre><code>          rnn_mode: Indicates the type of the RNN model.
          input_mode: Indicates whether there is a linear projection between the input and
          the actual computation before the first layer. &#39;skip_input&#39; is only allowed
          when input_size == num_units; &#39;auto_select&#39; implies &#39;skip_input&#39; when
          input_size == num_units; otherwise, it implies &#39;linear_input&#39;.
          direction: Indicates whether a bidirectional model will be used. Should be
          &quot;unidirectional&quot; or &quot;bidirectional&quot;.
          dropout: Dropout probability. When set to 0., dropout is disabled.
          seed: The 1st part of a seed to initialize dropout.
          seed2: The 2nd part of a seed to initialize dropout.
          input: A 3-D tensor with the shape of [seq_length, batch_size, input_size].
          input_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,
          num_units].
          input_c: For LSTM, a 3-D tensor with the shape of
          [num_layer * dir, batch, num_units]. For other models, it is ignored.
          params: A 1-D tensor that contains the weights and biases in an opaque layout.
          The size must be created through CudnnRNNParamsSize, and initialized
          separately. Note that they might not be compatible across different
          generations. So it is a good idea to save and restore
          output: A 3-D tensor with the shape of [seq_length, batch_size,
          dir * num_units].
          output_h: The same shape has input_h.
          output_c: The same shape as input_c for LSTM. An empty tensor for other models.
          is_training: Indicates whether this operation is used for inferenece or
          training.
          reserve_space: An opaque tensor that can be used in backprop calculation. It
          is only produced if is_training is true.
          host_reserved: An opaque tensor that can be used in backprop calculation. It is
          only produced if is_training is true. It is output on host memory rather than
          device memory.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Cumprod_" data-uid="TensorFlow.TFGraph.Cumprod*"></a>
  <h4 id="TensorFlow_TFGraph_Cumprod_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Cumprod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">Cumprod(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Compute the cumulative product of the tensor <code>x</code> along <code>axis</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Cumprod (TensorFlow.TFOutput x, TensorFlow.TFOutput axis, Nullable&lt;bool&gt; exclusive = null, Nullable&lt;bool&gt; reverse = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>,
              <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>,
              <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">axis</span></td>
        <td><p>A <code>Tensor</code> of type <code>int32</code> (default: 0). Must be in the range
              <code>[-rank(x), rank(x))</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">exclusive</span></td>
        <td><p>Optional argument
              If <code>True</code>, perform exclusive cumprod.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">reverse</span></td>
        <td><p>Optional argument
              A <code>bool</code> (default: False).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Cumprod&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Cumprod_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>By default, this op performs an inclusive cumprod, which means that the first
              element of the input is identical to the first element of the output:</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          tf.cumprod([a, b, c])  # =&amp;gt; [a, a * b, a * b * c]
           &lt;/code&gt;&lt;/pre&gt;

          By setting the &lt;code&gt;exclusive&lt;/code&gt; kwarg to &lt;code&gt;True&lt;/code&gt;, an exclusive cumprod is
          performed instead:

           &lt;pre&gt;&lt;code&gt;
          tf.cumprod([a, b, c], exclusive=True)  # =&amp;gt; [1, a, a * b]
           &lt;/code&gt;&lt;/pre&gt;

          By setting the &lt;code&gt;reverse&lt;/code&gt; kwarg to &lt;code&gt;True&lt;/code&gt;, the cumprod is performed in the
          opposite direction:

           &lt;pre&gt;&lt;code&gt;
          tf.cumprod([a, b, c], reverse=True)  # =&amp;gt; [a * b * c, b * c, c]
           &lt;/code&gt;&lt;/pre&gt;

          This is more efficient than using separate &lt;code&gt;tf.reverse&lt;/code&gt; ops.

          The &lt;code&gt;reverse&lt;/code&gt; and &lt;code&gt;exclusive&lt;/code&gt; kwargs can also be combined:

           &lt;pre&gt;&lt;code&gt;
          tf.cumprod([a, b, c], exclusive=True, reverse=True)  # =&amp;gt; [b * c, c, 1]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Cumsum_" data-uid="TensorFlow.TFGraph.Cumsum*"></a>
  <h4 id="TensorFlow_TFGraph_Cumsum_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Cumsum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">Cumsum(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Compute the cumulative sum of the tensor <code>x</code> along <code>axis</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Cumsum (TensorFlow.TFOutput x, TensorFlow.TFOutput axis, Nullable&lt;bool&gt; exclusive = null, Nullable&lt;bool&gt; reverse = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>A <code>Tensor</code>. Must be one of the following types: <code>float32</code>, <code>float64</code>,
              <code>int64</code>, <code>int32</code>, <code>uint8</code>, <code>uint16</code>, <code>int16</code>, <code>int8</code>, <code>complex64</code>,
              <code>complex128</code>, <code>qint8</code>, <code>quint8</code>, <code>qint32</code>, <code>half</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">axis</span></td>
        <td><p>A <code>Tensor</code> of type <code>int32</code> (default: 0). Must be in the range
              <code>[-rank(x), rank(x))</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">exclusive</span></td>
        <td><p>Optional argument
              If <code>True</code>, perform exclusive cumsum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">reverse</span></td>
        <td><p>Optional argument
              A <code>bool</code> (default: False).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Cumsum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Cumsum_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>By default, this op performs an inclusive cumsum, which means that the first
              element of the input is identical to the first element of the output:</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          tf.cumsum([a, b, c])  # =&amp;gt; [a, a + b, a + b + c]
           &lt;/code&gt;&lt;/pre&gt;

          By setting the &lt;code&gt;exclusive&lt;/code&gt; kwarg to &lt;code&gt;True&lt;/code&gt;, an exclusive cumsum is
          performed instead:

           &lt;pre&gt;&lt;code&gt;
          tf.cumsum([a, b, c], exclusive=True)  # =&amp;gt; [0, a, a + b]
           &lt;/code&gt;&lt;/pre&gt;

          By setting the &lt;code&gt;reverse&lt;/code&gt; kwarg to &lt;code&gt;True&lt;/code&gt;, the cumsum is performed in the
          opposite direction:

           &lt;pre&gt;&lt;code&gt;
          tf.cumsum([a, b, c], reverse=True)  # =&amp;gt; [a + b + c, b + c, c]
           &lt;/code&gt;&lt;/pre&gt;

          This is more efficient than using separate &lt;code&gt;tf.reverse&lt;/code&gt; ops.

          The &lt;code&gt;reverse&lt;/code&gt; and &lt;code&gt;exclusive&lt;/code&gt; kwargs can also be combined:

           &lt;pre&gt;&lt;code&gt;
          tf.cumsum([a, b, c], exclusive=True, reverse=True)  # =&amp;gt; [b + c, c, 0]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DataFormatDimMap_" data-uid="TensorFlow.TFGraph.DataFormatDimMap*"></a>
  <h4 id="TensorFlow_TFGraph_DataFormatDimMap_TensorFlow_TFOutput_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.DataFormatDimMap(TensorFlow.TFOutput,System.String,System.String,System.String)">DataFormatDimMap(TFOutput, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Returns the dimension index in the destination data format given the one in</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DataFormatDimMap (TensorFlow.TFOutput x, string src_format = null, string dst_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>A Tensor with each element as a dimension index in source data format.
              Must be in the range [-4, 4).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">src_format</span></td>
        <td><p>Optional argument
              source data format.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">dst_format</span></td>
        <td><p>Optional argument
              destination data format.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DataFormatDimMap&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A Tensor with each element as a dimension index in destination data format.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DataFormatDimMap_TensorFlow_TFOutput_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>the source data format.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DataFormatVecPermute_" data-uid="TensorFlow.TFGraph.DataFormatVecPermute*"></a>
  <h4 id="TensorFlow_TFGraph_DataFormatVecPermute_TensorFlow_TFOutput_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.DataFormatVecPermute(TensorFlow.TFOutput,System.String,System.String,System.String)">DataFormatVecPermute(TFOutput, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Returns the permuted vector/tensor in the destination data format given the</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DataFormatVecPermute (TensorFlow.TFOutput x, string src_format = null, string dst_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>Vector of size 4 or Tensor of shape (4, 2) in source data format.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">src_format</span></td>
        <td><p>Optional argument
              source data format.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">dst_format</span></td>
        <td><p>Optional argument
              destination data format.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DataFormatVecPermute&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Vector of size 4 or Tensor of shape (4, 2) in destination data format.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DataFormatVecPermute_TensorFlow_TFOutput_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>one in the source data format.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DatasetToGraph_" data-uid="TensorFlow.TFGraph.DatasetToGraph*"></a>
  <h4 id="TensorFlow_TFGraph_DatasetToGraph_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.DatasetToGraph(TensorFlow.TFOutput,System.String)">DatasetToGraph(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns a serialized GraphDef representing <code>input_dataset</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DatasetToGraph (TensorFlow.TFOutput input_dataset, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>A variant tensor representing the dataset to return the graph representation for.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DatasetToGraph&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The graph representation of the dataset (as serialized GraphDef).
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DatasetToGraph_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Returns a graph representation for <code>input_dataset</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DatasetToSingleElement_" data-uid="TensorFlow.TFGraph.DatasetToSingleElement*"></a>
  <h4 id="TensorFlow_TFGraph_DatasetToSingleElement_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.DatasetToSingleElement(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">DatasetToSingleElement(TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Outputs the single element from the given dataset.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] DatasetToSingleElement (TensorFlow.TFOutput dataset, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dataset</span></td>
        <td><p>A handle to a dataset that contains a single element.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DatasetToSingleElement&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The components of the single element of <code>input</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_DebugGradientIdentity_" data-uid="TensorFlow.TFGraph.DebugGradientIdentity*"></a>
  <h4 id="TensorFlow_TFGraph_DebugGradientIdentity_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.DebugGradientIdentity(TensorFlow.TFOutput,System.String)">DebugGradientIdentity(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Identity op for gradient debugging.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DebugGradientIdentity (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DebugGradientIdentity&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DebugGradientIdentity_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op is hidden from public in Python. It is used by TensorFlow Debugger to
              register gradient tensors for gradient debugging.
              This op operates on non-reference-type tensors.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DebugGradientRefIdentity_" data-uid="TensorFlow.TFGraph.DebugGradientRefIdentity*"></a>
  <h4 id="TensorFlow_TFGraph_DebugGradientRefIdentity_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.DebugGradientRefIdentity(TensorFlow.TFOutput,System.String)">DebugGradientRefIdentity(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Identity op for gradient debugging.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DebugGradientRefIdentity (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DebugGradientRefIdentity&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DebugGradientRefIdentity_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op is hidden from public in Python. It is used by TensorFlow Debugger to
              register gradient tensors for gradient debugging.
              This op operates on reference-type tensors.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DebugIdentity_" data-uid="TensorFlow.TFGraph.DebugIdentity*"></a>
  <h4 id="TensorFlow_TFGraph_DebugIdentity_TensorFlow_TFOutput_System_String_System_String_System_String___System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.DebugIdentity(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Boolean},System.String)">DebugIdentity(TFOutput, String, String, String[], Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Debug Identity Op.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DebugIdentity (TensorFlow.TFOutput input, string device_name = null, string tensor_name = null, string[] debug_urls = null, Nullable&lt;bool&gt; gated_grpc = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Input tensor, non-Reference type.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">device_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">tensor_name</span></td>
        <td><p>Optional argument
              Name of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">debug_urls</span></td>
        <td><p>Optional argument
              List of URLs to debug targets, e.g.,
              file:///foo/tfdbg_dump, grpc:://localhost:11011</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">gated_grpc</span></td>
        <td><p>Optional argument
              Whether this op will be gated. If any of the debug_urls of this
              debug node is of the grpc:// scheme, when the value of this attribute is set
              to True, the data will not actually be sent via the grpc stream unless this
              debug op has been enabled at the debug_url. If all of the debug_urls of this
              debug node are of the grpc:// scheme and the debug op is enabled at none of
              them, the output will be an empty Tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DebugIdentity&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Output tensor that equals the input tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DebugIdentity_TensorFlow_TFOutput_System_String_System_String_System_String___System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Provides an identity mapping of the non-Ref type input tensor for debugging.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DebugNanCount_" data-uid="TensorFlow.TFGraph.DebugNanCount*"></a>
  <h4 id="TensorFlow_TFGraph_DebugNanCount_TensorFlow_TFOutput_System_String_System_String_System_String___System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.DebugNanCount(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Boolean},System.String)">DebugNanCount(TFOutput, String, String, String[], Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Debug NaN Value Counter Op</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DebugNanCount (TensorFlow.TFOutput input, string device_name = null, string tensor_name = null, string[] debug_urls = null, Nullable&lt;bool&gt; gated_grpc = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Input tensor, non-Reference type.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">device_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">tensor_name</span></td>
        <td><p>Optional argument
              Name of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">debug_urls</span></td>
        <td><p>Optional argument
              List of URLs to debug targets, e.g.,
              file:///foo/tfdbg_dump, grpc:://localhost:11011.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">gated_grpc</span></td>
        <td><p>Optional argument
              Whether this op will be gated. If any of the debug_urls of this
              debug node is of the grpc:// scheme, when the value of this attribute is set
              to True, the data will not actually be sent via the grpc stream unless this
              debug op has been enabled at the debug_url. If all of the debug_urls of this
              debug node are of the grpc:// scheme and the debug op is enabled at none of
              them, the output will be an empty Tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DebugNanCount&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>An integer output tensor that is the number of NaNs in the input.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DebugNanCount_TensorFlow_TFOutput_System_String_System_String_System_String___System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Counts number of NaNs in the input tensor, for debugging.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DebugNumericSummary_" data-uid="TensorFlow.TFGraph.DebugNumericSummary*"></a>
  <h4 id="TensorFlow_TFGraph_DebugNumericSummary_TensorFlow_TFOutput_System_String_System_String_System_String___System_Nullable_System_Single__System_Nullable_System_Single__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.DebugNumericSummary(TensorFlow.TFOutput,System.String,System.String,System.String[],System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">DebugNumericSummary(TFOutput, String, String, String[], Nullable&lt;Single&gt;, Nullable&lt;Single&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Debug Numeric Summary Op.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DebugNumericSummary (TensorFlow.TFOutput input, string device_name = null, string tensor_name = null, string[] debug_urls = null, Nullable&lt;float&gt; lower_bound = null, Nullable&lt;float&gt; upper_bound = null, Nullable&lt;bool&gt; mute_if_healthy = null, Nullable&lt;bool&gt; gated_grpc = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Input tensor, non-Reference type, float or double.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">device_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">tensor_name</span></td>
        <td><p>Optional argument
              Name of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">debug_urls</span></td>
        <td><p>Optional argument
              List of URLs to debug targets, e.g.,
              file:///foo/tfdbg_dump, grpc:://localhost:11011</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">lower_bound</span></td>
        <td><p>Optional argument
              (float) The lower bound &lt;= which values will be included in the
              generalized -inf count. Default: -inf.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">upper_bound</span></td>
        <td><p>Optional argument
              (float) The upper bound &gt;= which values will be included in the
              generalized +inf count. Default: +inf.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">mute_if_healthy</span></td>
        <td><p>Optional argument
              (bool) Do not send data to the debug URLs unless at least one
              of elements [2], [3] and <a href="i.e., the nan count and the generalized -inf and
              inf counts">7</a> is non-zero.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">gated_grpc</span></td>
        <td><p>Optional argument
              Whether this op will be gated. If any of the debug_urls of this
              debug node is of the grpc:// scheme, when the value of this attribute is set
              to True, the data will not actually be sent via the grpc stream unless this
              debug op has been enabled at the debug_url. If all of the debug_urls of this
              debug node are of the grpc:// scheme and the debug op is enabled at none of
              them, the output will be an empty Tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DebugNumericSummary&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A double tensor of shape [14 + nDimensions], where nDimensions is the
              the number of dimensions of the tensor&#39;s shape. The elements of output are:
              [0]: is initialized (1.0) or not (0.0).
              [1]: total number of elements
              [2]: NaN element count
              [3]: generalized -inf count: elements &lt;= lower_bound. lower_bound is -inf by
              default.
              [4]: negative element count (excluding -inf), if lower_bound is the default
              -inf. Otherwise, this is the count of elements &gt; lower_bound and &lt; 0.
              [5]: zero element count
              [6]: positive element count (excluding +inf), if upper_bound is the default
              -inf. Otherwise, this is the count of elements &lt; upper_bound and &gt; 0.
              [7]: generalized +inf count, elements &gt;= upper_bound. upper_bound is +inf by
              default.
              Output elements [1:8] are all zero, if the tensor is uninitialized.
              [8]: minimum of all non-inf and non-NaN elements.
              If uninitialized or no such element exists: +inf.
              [9]: maximum of all non-inf and non-NaN elements.
              If uninitialized or no such element exists: -inf.
              [10]: mean of all non-inf and non-NaN elements.
              If uninitialized or no such element exists: NaN.
              [11]: variance of all non-inf and non-NaN elements.
              If uninitialized or no such element exists: NaN.
              [12]: Data type of the tensor encoded as an enum integer. See the DataType
              proto for more details.
              [13]: Number of dimensions of the tensor (ndims).
              [14+]: Sizes of the dimensions.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DebugNumericSummary_TensorFlow_TFOutput_System_String_System_String_System_String___System_Nullable_System_Single__System_Nullable_System_Single__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Provide a basic summary of numeric value types, range and distribution.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DecodeAndCropJpeg_" data-uid="TensorFlow.TFGraph.DecodeAndCropJpeg*"></a>
  <h4 id="TensorFlow_TFGraph_DecodeAndCropJpeg_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Single__System_String_System_String_" data-uid="TensorFlow.TFGraph.DecodeAndCropJpeg(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Single},System.String,System.String)">DecodeAndCropJpeg(TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Single&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Decode and Crop a JPEG-encoded image to a uint8 tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DecodeAndCropJpeg (TensorFlow.TFOutput contents, TensorFlow.TFOutput crop_window, Nullable&lt;long&gt; channels = null, Nullable&lt;long&gt; ratio = null, Nullable&lt;bool&gt; fancy_upscaling = null, Nullable&lt;bool&gt; try_recover_truncated = null, Nullable&lt;float&gt; acceptable_fraction = null, string dct_method = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">contents</span></td>
        <td><p>0-D.  The JPEG-encoded image.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">crop_window</span></td>
        <td><p>1-D.  The crop window: [crop_y, crop_x, crop_height, crop_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">channels</span></td>
        <td><p>Optional argument
              Number of color channels for the decoded image.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">ratio</span></td>
        <td><p>Optional argument
              Downscaling ratio.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">fancy_upscaling</span></td>
        <td><p>Optional argument
              If true use a slower but nicer upscaling of the
              chroma planes (yuv420/422 only).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">try_recover_truncated</span></td>
        <td><p>Optional argument
              If true try to recover an image from truncated input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">acceptable_fraction</span></td>
        <td><p>Optional argument
              The minimum required fraction of lines before a truncated
              input is accepted.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">dct_method</span></td>
        <td><p>Optional argument
              string specifying a hint about the algorithm used for
              decompression.  Defaults to &quot;&quot; which maps to a system-specific
              default.  Currently valid values are [&quot;INTEGER_FAST&quot;,
              &quot;INTEGER_ACCURATE&quot;].  The hint may be ignored (e.g., the internal
              jpeg library changes to a version that does not have that specific
              option.)</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DecodeAndCropJpeg&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>3-D with shape <code>[height, width, channels]</code>..
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DecodeAndCropJpeg_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Single__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The attr <code>channels</code> indicates the desired number of color channels for the
              decoded image.</p>
<pre><code>          Accepted values are:

          *   0: Use the number of channels in the JPEG-encoded image.
          *   1: output a grayscale image.
          *   3: output an RGB image.

          If needed, the JPEG-encoded image is transformed to match the requested number
          of color channels.

          The attr &lt;code&gt;ratio&lt;/code&gt; allows downscaling the image by an integer factor during
          decoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than
          downscaling the image later.


          It is equivalent to a combination of decode and crop, but much faster by only
          decoding partial jpeg image.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DecodeBase64_" data-uid="TensorFlow.TFGraph.DecodeBase64*"></a>
  <h4 id="TensorFlow_TFGraph_DecodeBase64_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.DecodeBase64(TensorFlow.TFOutput,System.String)">DecodeBase64(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Decode web-safe base64-encoded strings.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DecodeBase64 (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Base64 strings to decode.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DecodeBase64&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Decoded strings.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DecodeBase64_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Input may or may not have padding at the end. See EncodeBase64 for padding.
              Web-safe means that input must use - and _ instead of + and /.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DecodeBmp_" data-uid="TensorFlow.TFGraph.DecodeBmp*"></a>
  <h4 id="TensorFlow_TFGraph_DecodeBmp_TensorFlow_TFOutput_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.DecodeBmp(TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)">DecodeBmp(TFOutput, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Decode the first frame of a BMP-encoded image to a uint8 tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DecodeBmp (TensorFlow.TFOutput contents, Nullable&lt;long&gt; channels = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">contents</span></td>
        <td><p>0-D.  The BMP-encoded image.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">channels</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DecodeBmp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>3-D with shape <code>[height, width, channels]</code>. RGB order
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DecodeBmp_TensorFlow_TFOutput_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The attr <code>channels</code> indicates the desired number of color channels for the
              decoded image.</p>
<pre><code>          Accepted values are:

          *   0: Use the number of channels in the BMP-encoded image.
          *   3: output an RGB image.
          *   4: output an RGBA image.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DecodeCompressed_" data-uid="TensorFlow.TFGraph.DecodeCompressed*"></a>
  <h4 id="TensorFlow_TFGraph_DecodeCompressed_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.DecodeCompressed(TensorFlow.TFOutput,System.String,System.String)">DecodeCompressed(TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>Decompress strings.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DecodeCompressed (TensorFlow.TFOutput bytes, string compression_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">bytes</span></td>
        <td><p>A Tensor of string which is compressed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">compression_type</span></td>
        <td><p>Optional argument
              A scalar containing either (i) the empty string (no
              compression), (ii) &quot;ZLIB&quot;, or (iii) &quot;GZIP&quot;.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DecodeCompressed&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A Tensor with the same shape as input <code>bytes</code>, uncompressed
              from bytes.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DecodeCompressed_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op decompresses each element of the <code>bytes</code> input <code>Tensor</code>, which
              is assumed to be compressed using the given <code>compression_type</code>.</p>
<pre><code>          The &lt;code&gt;output&lt;/code&gt; is a string &lt;code&gt;Tensor&lt;/code&gt; of the same shape as &lt;code&gt;bytes&lt;/code&gt;,
          each element containing the decompressed data from the corresponding
          element in &lt;code&gt;bytes&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DecodeCSV_" data-uid="TensorFlow.TFGraph.DecodeCSV*"></a>
  <h4 id="TensorFlow_TFGraph_DecodeCSV_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String_System_Nullable_System_Boolean__System_String_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.DecodeCSV(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String,System.Nullable{System.Boolean},System.String,System.Int64[],System.String)">DecodeCSV(TFOutput, TFOutput[], String, Nullable&lt;Boolean&gt;, String, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Convert CSV records to tensors. Each column maps to one tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] DecodeCSV (TensorFlow.TFOutput records, TensorFlow.TFOutput[] record_defaults, string field_delim = null, Nullable&lt;bool&gt; use_quote_delim = null, string na_value = null, long[] select_cols = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">records</span></td>
        <td><p>Each string is a record/row in the csv and all records should have
              the same format.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">record_defaults</span></td>
        <td><p>One tensor per column of the input record, with either a
              scalar default value for that column or an empty vector if the column is
              required.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">field_delim</span></td>
        <td><p>Optional argument
              char delimiter to separate fields in a record.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_quote_delim</span></td>
        <td><p>Optional argument
              If false, treats double quotation marks as regular
              characters inside of the string fields (ignoring RFC 4180, Section 2,
              Bullet 5).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">na_value</span></td>
        <td><p>Optional argument
              Additional string to recognize as NA/NaN.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">select_cols</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DecodeCSV&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>Each tensor will have the same shape as records.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DecodeCSV_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String_System_Nullable_System_Boolean__System_String_System_Int64___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>RFC 4180 format is expected for the CSV records.
              (<a href="https://tools.ietf.org/html/rfc4180">https://tools.ietf.org/html/rfc4180</a>)
              Note that we allow leading and trailing spaces with int or float field.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DecodeGif_" data-uid="TensorFlow.TFGraph.DecodeGif*"></a>
  <h4 id="TensorFlow_TFGraph_DecodeGif_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.DecodeGif(TensorFlow.TFOutput,System.String)">DecodeGif(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Decode the first frame of a GIF-encoded image to a uint8 tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DecodeGif (TensorFlow.TFOutput contents, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">contents</span></td>
        <td><p>0-D.  The GIF-encoded image.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DecodeGif&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape <code>[num_frames, height, width, 3]</code>. RGB order
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DecodeGif_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>GIF with frame or transparency compression are not supported
              convert animated GIF from compressed to uncompressed by:</p>
<pre><code>          convert $src.gif -coalesce $dst.gif

          This op also supports decoding JPEGs and PNGs, though it is cleaner to use
          &lt;code&gt;tf.image.decode_image&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DecodeJpeg_" data-uid="TensorFlow.TFGraph.DecodeJpeg*"></a>
  <h4 id="TensorFlow_TFGraph_DecodeJpeg_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Single__System_String_System_String_" data-uid="TensorFlow.TFGraph.DecodeJpeg(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Single},System.String,System.String)">DecodeJpeg(TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Single&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Decode a JPEG-encoded image to a uint8 tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DecodeJpeg (TensorFlow.TFOutput contents, Nullable&lt;long&gt; channels = null, Nullable&lt;long&gt; ratio = null, Nullable&lt;bool&gt; fancy_upscaling = null, Nullable&lt;bool&gt; try_recover_truncated = null, Nullable&lt;float&gt; acceptable_fraction = null, string dct_method = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">contents</span></td>
        <td><p>0-D.  The JPEG-encoded image.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">channels</span></td>
        <td><p>Optional argument
              Number of color channels for the decoded image.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">ratio</span></td>
        <td><p>Optional argument
              Downscaling ratio.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">fancy_upscaling</span></td>
        <td><p>Optional argument
              If true use a slower but nicer upscaling of the
              chroma planes (yuv420/422 only).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">try_recover_truncated</span></td>
        <td><p>Optional argument
              If true try to recover an image from truncated input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">acceptable_fraction</span></td>
        <td><p>Optional argument
              The minimum required fraction of lines before a truncated
              input is accepted.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">dct_method</span></td>
        <td><p>Optional argument
              string specifying a hint about the algorithm used for
              decompression.  Defaults to &quot;&quot; which maps to a system-specific
              default.  Currently valid values are [&quot;INTEGER_FAST&quot;,
              &quot;INTEGER_ACCURATE&quot;].  The hint may be ignored (e.g., the internal
              jpeg library changes to a version that does not have that specific
              option.)</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DecodeJpeg&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>3-D with shape <code>[height, width, channels]</code>..
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DecodeJpeg_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Single__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The attr <code>channels</code> indicates the desired number of color channels for the
              decoded image.</p>
<pre><code>          Accepted values are:

          *   0: Use the number of channels in the JPEG-encoded image.
          *   1: output a grayscale image.
          *   3: output an RGB image.

          If needed, the JPEG-encoded image is transformed to match the requested number
          of color channels.

          The attr &lt;code&gt;ratio&lt;/code&gt; allows downscaling the image by an integer factor during
          decoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than
          downscaling the image later.


          This op also supports decoding PNGs and non-animated GIFs since the interface is
          the same, though it is cleaner to use &lt;code&gt;tf.image.decode_image&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DecodeJSONExample_" data-uid="TensorFlow.TFGraph.DecodeJSONExample*"></a>
  <h4 id="TensorFlow_TFGraph_DecodeJSONExample_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.DecodeJSONExample(TensorFlow.TFOutput,System.String)">DecodeJSONExample(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Convert JSON-encoded Example records to binary protocol buffer strings.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DecodeJSONExample (TensorFlow.TFOutput json_examples, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">json_examples</span></td>
        <td><p>Each string is a JSON object serialized according to the JSON
              mapping of the Example proto.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DecodeJSONExample&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Each string is a binary Example protocol buffer corresponding
              to the respective element of <code>json_examples</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DecodeJSONExample_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op translates a tensor containing Example records, encoded using
              the <a href="https://developers.google.com/protocol-buffers/docs/proto3#json">standard JSON
              mapping</a>,
              into a tensor containing the same records encoded as binary protocol
              buffers. The resulting tensor can then be fed to any of the other
              Example-parsing ops.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DecodePng_" data-uid="TensorFlow.TFGraph.DecodePng*"></a>
  <h4 id="TensorFlow_TFGraph_DecodePng_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.DecodePng(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)">DecodePng(TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Decode a PNG-encoded image to a uint8 or uint16 tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DecodePng (TensorFlow.TFOutput contents, Nullable&lt;long&gt; channels = null, Nullable&lt;TensorFlow.TFDataType&gt; dtype = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">contents</span></td>
        <td><p>0-D.  The PNG-encoded image.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">channels</span></td>
        <td><p>Optional argument
              Number of color channels for the decoded image.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">dtype</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DecodePng&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>3-D with shape <code>[height, width, channels]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DecodePng_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The attr <code>channels</code> indicates the desired number of color channels for the
              decoded image.</p>
<pre><code>          Accepted values are:

          *   0: Use the number of channels in the PNG-encoded image.
          *   1: output a grayscale image.
          *   3: output an RGB image.
          *   4: output an RGBA image.

          If needed, the PNG-encoded image is transformed to match the requested number
          of color channels.

          This op also supports decoding JPEGs and non-animated GIFs since the interface
          is the same, though it is cleaner to use &lt;code&gt;tf.image.decode_image&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DecodeProtoV2_" data-uid="TensorFlow.TFGraph.DecodeProtoV2*"></a>
  <h4 id="TensorFlow_TFGraph_DecodeProtoV2_TensorFlow_TFOutput_System_String_System_String___TensorFlow_TFDataType___System_String_System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.DecodeProtoV2(TensorFlow.TFOutput,System.String,System.String[],TensorFlow.TFDataType[],System.String,System.String,System.Nullable{System.Boolean},System.String)">DecodeProtoV2(TFOutput, String, String[], TFDataType[], String, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>The op extracts fields from a serialized protocol buffers message into tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput[]&gt; DecodeProtoV2 (TensorFlow.TFOutput bytes, string message_type, string[] field_names, TensorFlow.TFDataType[] output_types, string descriptor_source = null, string message_format = null, Nullable&lt;bool&gt; sanitize = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">bytes</span></td>
        <td><p>Tensor of serialized protos with shape <code>batch_shape</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">message_type</span></td>
        <td><p>Name of the proto message type to decode.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">field_names</span></td>
        <td><p>List of strings containing proto field names.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>List of TF types to use for the respective field in field_names.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">descriptor_source</span></td>
        <td><p>Optional argument
              Either the special value <code>local://</code> or a path to a file containing
              a serialized <code>FileDescriptorSet</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">message_format</span></td>
        <td><p>Optional argument
              Either <code>binary</code> or <code>text</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">sanitize</span></td>
        <td><p>Optional argument
              Whether to sanitize the result or not.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DecodeProtoV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sizes: Tensor of int32 with shape <code>[batch_shape, len(field_names)]</code>.
              Each entry is the number of values found for the corresponding field.
              Optional fields may have 0 or 1 values.
              values: List of tensors containing values for the corresponding field.
              <code>values[i]</code> has datatype <code>output_types[i]</code>
              and shape <code>[batch_shape, max(sizes[...,i])]</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DecodeProtoV2_TensorFlow_TFOutput_System_String_System_String___TensorFlow_TFDataType___System_String_System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The <code>decode_proto</code> op extracts fields from a serialized protocol buffers
              message into tensors.  The fields in <code>field_names</code> are decoded and converted
              to the corresponding <code>output_types</code> if possible.</p>
<pre><code>          A &lt;code&gt;message_type&lt;/code&gt; name must be provided to give context for the field
          names. The actual message descriptor can be looked up either in the
          linked-in descriptor pool or a filename provided by the caller using
          the &lt;code&gt;descriptor_source&lt;/code&gt; attribute.

          Each output tensor is a dense tensor. This means that it is padded to
          hold the largest number of repeated elements seen in the input
          minibatch. (The shape is also padded by one to prevent zero-sized
          dimensions). The actual repeat counts for each example in the
          minibatch can be found in the &lt;code&gt;sizes&lt;/code&gt; output. In many cases the output
          of &lt;code&gt;decode_proto&lt;/code&gt; is fed immediately into tf.squeeze if missing values
          are not a concern. When using tf.squeeze, always pass the squeeze
          dimension explicitly to avoid surprises.

          For the most part, the mapping between Proto field types and
          TensorFlow dtypes is straightforward. However, there are a few
          special cases:

          - A proto field that contains a submessage or group can only be converted
          to &lt;code&gt;DT_STRING&lt;/code&gt; (the serialized submessage). This is to reduce the
          complexity of the API. The resulting string can be used as input
          to another instance of the decode_proto op.

          - TensorFlow lacks support for unsigned integers. The ops represent uint64
          types as a &lt;code&gt;DT_INT64&lt;/code&gt; with the same twos-complement bit pattern
          (the obvious way). Unsigned int32 values can be represented exactly by
          specifying type &lt;code&gt;DT_INT64&lt;/code&gt;, or using twos-complement if the caller
          specifies &lt;code&gt;DT_INT32&lt;/code&gt; in the &lt;code&gt;output_types&lt;/code&gt; attribute.

          The &lt;code&gt;descriptor_source&lt;/code&gt; attribute selects a source of protocol
          descriptors to consult when looking up &lt;code&gt;message_type&lt;/code&gt;. This may be a
          filename containing a serialized &lt;code&gt;FileDescriptorSet&lt;/code&gt; message,
          or the special value &lt;code&gt;local://&lt;/code&gt;, in which case only descriptors linked
          into the code will be searched; the filename can be on any filesystem
          accessible to TensorFlow.

          You can build a &lt;code&gt;descriptor_source&lt;/code&gt; file using the &lt;code&gt;--descriptor_set_out&lt;/code&gt;
          and &lt;code&gt;--include_imports&lt;/code&gt; options to the protocol compiler &lt;code&gt;protoc&lt;/code&gt;.

          The &lt;code&gt;local://&lt;/code&gt; database only covers descriptors linked into the
          code via C++ libraries, not Python imports. You can link in a proto descriptor
          by creating a cc_library target with alwayslink=1.

          Both binary and text proto serializations are supported, and can be
          chosen using the &lt;code&gt;format&lt;/code&gt; attribute.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DecodeRaw_" data-uid="TensorFlow.TFGraph.DecodeRaw*"></a>
  <h4 id="TensorFlow_TFGraph_DecodeRaw_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.DecodeRaw(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)">DecodeRaw(TFOutput, TFDataType, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Reinterpret the bytes of a string as a vector of numbers.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DecodeRaw (TensorFlow.TFOutput bytes, TensorFlow.TFDataType out_type, Nullable&lt;bool&gt; little_endian = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">bytes</span></td>
        <td><p>All the elements must have the same length.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">out_type</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">little_endian</span></td>
        <td><p>Optional argument
              Whether the input <code>bytes</code> are in little-endian order.
              Ignored for <code>out_type</code> values that are stored in a single byte like
              <code>uint8</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DecodeRaw&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A Tensor with one more dimension than the input <code>bytes</code>.  The
              added dimension will have size equal to the length of the elements
              of <code>bytes</code> divided by the number of bytes to represent <code>out_type</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_DecodeWav_" data-uid="TensorFlow.TFGraph.DecodeWav*"></a>
  <h4 id="TensorFlow_TFGraph_DecodeWav_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.DecodeWav(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">DecodeWav(TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Decode a 16-bit PCM WAV file to a float tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; DecodeWav (TensorFlow.TFOutput contents, Nullable&lt;long&gt; desired_channels = null, Nullable&lt;long&gt; desired_samples = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">contents</span></td>
        <td><p>The WAV-encoded audio, usually from a file.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">desired_channels</span></td>
        <td><p>Optional argument
              Number of sample channels wanted.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">desired_samples</span></td>
        <td><p>Optional argument
              Length of audio requested.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DecodeWav&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              audio: 2-D with shape <code>[length, channels]</code>.
              sample_rate: Scalar holding the sample rate found in the WAV header.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DecodeWav_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The -32768 to 32767 signed 16-bit values will be scaled to -1.0 to 1.0 in float.</p>
<pre><code>          When desired_channels is set, if the input contains fewer channels than this
          then the last channel will be duplicated to give the requested number, else if
          the input has more channels than requested then the additional channels will be
          ignored.

          If desired_samples is set, then the audio will be cropped or padded with zeroes
          to the requested length.

          The first output contains a Tensor with the content of the audio samples. The
          lowest dimension will be the number of channels, and the second will be the
          number of samples. For example, a ten-sample-long stereo WAV file should give an
          output shape of [10, 2].
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DeepCopy_" data-uid="TensorFlow.TFGraph.DeepCopy*"></a>
  <h4 id="TensorFlow_TFGraph_DeepCopy_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.DeepCopy(TensorFlow.TFOutput,System.String)">DeepCopy(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Makes a copy of <code>x</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DeepCopy (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>The source tensor of type <code>T</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DeepCopy&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>y: A <code>Tensor</code> of type <code>T</code>. A copy of <code>x</code>. Guaranteed that <code>y</code>
              is not an alias of <code>x</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_DeleteSessionTensor_" data-uid="TensorFlow.TFGraph.DeleteSessionTensor*"></a>
  <h4 id="TensorFlow_TFGraph_DeleteSessionTensor_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.DeleteSessionTensor(TensorFlow.TFOutput,System.String)">DeleteSessionTensor(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Delete the tensor specified by its handle in the session.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation DeleteSessionTensor (TensorFlow.TFOutput handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle for a tensor stored in the session state.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DeleteSessionTensor&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_DenseToDenseSetOperation_" data-uid="TensorFlow.TFGraph.DenseToDenseSetOperation*"></a>
  <h4 id="TensorFlow_TFGraph_DenseToDenseSetOperation_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.DenseToDenseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)">DenseToDenseSetOperation(TFOutput, TFOutput, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Applies set operation along last dimension of 2 <code>Tensor</code> inputs.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; DenseToDenseSetOperation (TensorFlow.TFOutput set1, TensorFlow.TFOutput set2, string set_operation, Nullable&lt;bool&gt; validate_indices = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set1</span></td>
        <td><p><code>Tensor</code> with rank <code>n</code>. 1st <code>n-1</code> dimensions must be the same as <code>set2</code>.
              Dimension <code>n</code> contains values in a set, duplicates are allowed but ignored.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set2</span></td>
        <td><p><code>Tensor</code> with rank <code>n</code>. 1st <code>n-1</code> dimensions must be the same as <code>set1</code>.
              Dimension <code>n</code> contains values in a set, duplicates are allowed but ignored.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">set_operation</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">validate_indices</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DenseToDenseSetOperation&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              result_indices: 2D indices of a <code>SparseTensor</code>.
              result_values: 1D values of a <code>SparseTensor</code>.
              result_shape: 1D <code>Tensor</code> shape of a <code>SparseTensor</code>. <code>result_shape[0...n-1]</code> is
              the same as the 1st <code>n-1</code> dimensions of <code>set1</code> and <code>set2</code>, <code>result_shape[n]</code>
              is the max result set size across all <code>0...n-1</code> dimensions.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DenseToDenseSetOperation_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>See SetOperationOp::SetOperationFromContext for values of <code>set_operation</code>.</p>
<pre><code>          Output &lt;code&gt;result&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; represented by &lt;code&gt;result_indices&lt;/code&gt;,
          &lt;code&gt;result_values&lt;/code&gt;, and &lt;code&gt;result_shape&lt;/code&gt;. For &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; ranked &lt;code&gt;n&lt;/code&gt;, this
          has rank &lt;code&gt;n&lt;/code&gt; and the same 1st &lt;code&gt;n-1&lt;/code&gt; dimensions as &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt;. The &lt;code&gt;nth&lt;/code&gt;
          dimension contains the result of &lt;code&gt;set_operation&lt;/code&gt; applied to the corresponding
          &lt;code&gt;[0...n-1]&lt;/code&gt; dimension of &lt;code&gt;set&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DenseToSparseSetOperation_" data-uid="TensorFlow.TFGraph.DenseToSparseSetOperation*"></a>
  <h4 id="TensorFlow_TFGraph_DenseToSparseSetOperation_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.DenseToSparseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)">DenseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Applies set operation along last dimension of <code>Tensor</code> and <code>SparseTensor</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; DenseToSparseSetOperation (TensorFlow.TFOutput set1, TensorFlow.TFOutput set2_indices, TensorFlow.TFOutput set2_values, TensorFlow.TFOutput set2_shape, string set_operation, Nullable&lt;bool&gt; validate_indices = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set1</span></td>
        <td><p><code>Tensor</code> with rank <code>n</code>. 1st <code>n-1</code> dimensions must be the same as <code>set2</code>.
              Dimension <code>n</code> contains values in a set, duplicates are allowed but ignored.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set2_indices</span></td>
        <td><p>2D <code>Tensor</code>, indices of a <code>SparseTensor</code>. Must be in row-major
              order.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set2_values</span></td>
        <td><p>1D <code>Tensor</code>, values of a <code>SparseTensor</code>. Must be in row-major
              order.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set2_shape</span></td>
        <td><p>1D <code>Tensor</code>, shape of a <code>SparseTensor</code>. <code>set2_shape[0...n-1]</code> must
              be the same as the 1st <code>n-1</code> dimensions of <code>set1</code>, <code>result_shape[n]</code> is the
              max set size across <code>n-1</code> dimensions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">set_operation</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">validate_indices</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DenseToSparseSetOperation&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              result_indices: 2D indices of a <code>SparseTensor</code>.
              result_values: 1D values of a <code>SparseTensor</code>.
              result_shape: 1D <code>Tensor</code> shape of a <code>SparseTensor</code>. <code>result_shape[0...n-1]</code> is
              the same as the 1st <code>n-1</code> dimensions of <code>set1</code> and <code>set2</code>, <code>result_shape[n]</code>
              is the max result set size across all <code>0...n-1</code> dimensions.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DenseToSparseSetOperation_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>See SetOperationOp::SetOperationFromContext for values of <code>set_operation</code>.</p>
<pre><code>          Input &lt;code&gt;set2&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; represented by &lt;code&gt;set2_indices&lt;/code&gt;, &lt;code&gt;set2_values&lt;/code&gt;,
          and &lt;code&gt;set2_shape&lt;/code&gt;. For &lt;code&gt;set2&lt;/code&gt; ranked &lt;code&gt;n&lt;/code&gt;, 1st &lt;code&gt;n-1&lt;/code&gt; dimensions must be the same
          as &lt;code&gt;set1&lt;/code&gt;. Dimension &lt;code&gt;n&lt;/code&gt; contains values in a set, duplicates are allowed but
          ignored.

          If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this op validates the order and range of &lt;code&gt;set2&lt;/code&gt;
          indices.

          Output &lt;code&gt;result&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; represented by &lt;code&gt;result_indices&lt;/code&gt;,
          &lt;code&gt;result_values&lt;/code&gt;, and &lt;code&gt;result_shape&lt;/code&gt;. For &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; ranked &lt;code&gt;n&lt;/code&gt;, this
          has rank &lt;code&gt;n&lt;/code&gt; and the same 1st &lt;code&gt;n-1&lt;/code&gt; dimensions as &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt;. The &lt;code&gt;nth&lt;/code&gt;
          dimension contains the result of &lt;code&gt;set_operation&lt;/code&gt; applied to the corresponding
          &lt;code&gt;[0...n-1]&lt;/code&gt; dimension of &lt;code&gt;set&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DepthToSpace_" data-uid="TensorFlow.TFGraph.DepthToSpace*"></a>
  <h4 id="TensorFlow_TFGraph_DepthToSpace_TensorFlow_TFOutput_System_Int64_System_String_System_String_" data-uid="TensorFlow.TFGraph.DepthToSpace(TensorFlow.TFOutput,System.Int64,System.String,System.String)">DepthToSpace(TFOutput, Int64, String, String)</h4>
  <div class="markdown level1 summary"><p>DepthToSpace for tensors of type T.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DepthToSpace (TensorFlow.TFOutput input, long block_size, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">block_size</span></td>
        <td><p>The size of the spatial block, same as in Space2Depth.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DepthToSpace&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DepthToSpace_TensorFlow_TFOutput_System_Int64_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Rearranges data from depth into blocks of spatial data.
              This is the reverse transformation of SpaceToDepth. More specifically,
              this op outputs a copy of the input tensor where values from the <code>depth</code>
              dimension are moved in spatial blocks to the <code>height</code> and <code>width</code> dimensions.
              The attr <code>block_size</code> indicates the input block size and how the data is moved.</p>
<pre><code>          * Chunks of data of size &lt;code&gt;block_size * block_size&lt;/code&gt; from depth are rearranged
          into non-overlapping blocks of size &lt;code&gt;block_size x block_size&lt;/code&gt;
          * The width the output tensor is &lt;code&gt;input_depth * block_size&lt;/code&gt;, whereas the
          height is &lt;code&gt;input_height * block_size&lt;/code&gt;.
          * The Y, X coordinates within each block of the output image are determined
          by the high order component of the input channel index.
          * The depth of the input tensor must be divisible by
          &lt;code&gt;block_size * block_size&lt;/code&gt;.

          The &lt;code&gt;data_format&lt;/code&gt; attr specifies the layout of the input and output tensors
          with the following options:
          &quot;NHWC&quot;: &lt;code&gt;[ batch, height, width, channels ]&lt;/code&gt;
          &quot;NCHW&quot;: &lt;code&gt;[ batch, channels, height, width ]&lt;/code&gt;
          &quot;NCHW_VECT_C&quot;:
          &lt;code&gt;qint8 [ batch, channels / 4, height, width, 4 ]&lt;/code&gt;

          It is useful to consider the operation as transforming a 6-D Tensor.
          e.g. for data_format = NHWC,
          Each element in the input tensor can be specified via 6 coordinates,
          ordered by decreasing memory layout significance as:
          n,iY,iX,bY,bX,oC  (where n=batch index, iX, iY means X or Y coordinates
          within the input image, bX, bY means coordinates
          within the output block, oC means output channels).
          The output would be the input transposed to the following layout:
          n,iY,bY,iX,bX,oC

          This operation is useful for resizing the activations between convolutions
          (but keeping all data), e.g. instead of pooling. It is also useful for training
          purely convolutional models.

          For example, given an input of shape &lt;code&gt;[1, 1, 1, 4]&lt;/code&gt;, data_format = &quot;NHWC&quot; and
          block_size = 2:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1, 2, 3, 4]]]]

           &lt;/code&gt;&lt;/pre&gt;

          This operation will output a tensor of shape &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt;:

           &lt;pre&gt;&lt;code&gt;
          [[[[1], [2]],
          [[3], [4]]]]
           &lt;/code&gt;&lt;/pre&gt;

          Here, the input has a batch of 1 and each batch element has shape &lt;code&gt;[1, 1, 4]&lt;/code&gt;,
          the corresponding output will have 2x2 elements and will have a depth of
          1 channel (1 = &lt;code&gt;4 / (block_size * block_size)&lt;/code&gt;).
          The output element shape is &lt;code&gt;[2, 2, 1]&lt;/code&gt;.

          For an input tensor with larger depth, here of shape &lt;code&gt;[1, 1, 1, 12]&lt;/code&gt;, e.g.

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]
           &lt;/code&gt;&lt;/pre&gt;

          This operation, for block size of 2, will return the following tensor of shape
          &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt;&lt;pre&gt;&lt;code&gt;
          [[[[1, 2, 3], [4, 5, 6]],
          [[7, 8, 9], [10, 11, 12]]]]

           &lt;/code&gt;&lt;/pre&gt;

          Similarly, for the following input of shape &lt;code&gt;[1 2 2 4]&lt;/code&gt;, and a block size of 2:

           &lt;pre&gt;&lt;code&gt;
          x =  [[[[1, 2, 3, 4],
          [5, 6, 7, 8]],
          [[9, 10, 11, 12],
          [13, 14, 15, 16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          the operator will return the following tensor of shape &lt;code&gt;[1 4 4 1]&lt;/code&gt;:

           &lt;pre&gt;&lt;code&gt;
          x = [[[ [1],   [2],  [5],  [6]],
          [ [3],   [4],  [7],  [8]],
          [ [9],  [10], [13],  [14]],
          [ [11], [12], [15],  [16]]]]

           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DepthwiseConv2dNative_" data-uid="TensorFlow.TFGraph.DepthwiseConv2dNative*"></a>
  <h4 id="TensorFlow_TFGraph_DepthwiseConv2dNative_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_String_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.DepthwiseConv2dNative(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)">DepthwiseConv2dNative(TFOutput, TFOutput, Int64[], String, String, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Computes a 2-D depthwise convolution given 4-D <code>input</code> and <code>filter</code> tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DepthwiseConv2dNative (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D of length 4.  The stride of the sliding window for each dimension
              of <code>input</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, height, width, channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, channels, height, width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">dilations</span></td>
        <td><p>Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each filter
              element on that dimension. The dimension order is determined by the value of
              <code>data_format</code>, see above for details. Dilations in the batch and depth
              dimensions must be 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DepthwiseConv2dNative&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DepthwiseConv2dNative_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_String_System_Int64___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
              and a filter / kernel tensor of shape
              <code>[filter_height, filter_width, in_channels, channel_multiplier]</code>, containing
              <code>in_channels</code> convolutional filters of depth 1, <code>depthwise_conv2d</code> applies
              a different filter to each input channel (expanding from 1 channel to
              <code>channel_multiplier</code> channels for each), then concatenates the results
              together. Thus, the output has <code>in_channels * channel_multiplier</code> channels.</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          for k in 0..in_channels-1
          for q in 0..channel_multiplier-1
          output[b, i, j, k * channel_multiplier + q] =
          sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
          filter[di, dj, k, q]
           &lt;/code&gt;&lt;/pre&gt;

          Must have &lt;code&gt;strides[0] = strides[3] = 1&lt;/code&gt;.  For the most common case of the same
          horizontal and vertices strides, &lt;code&gt;strides = [1, stride, stride, 1]&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DepthwiseConv2dNativeBackpropFilter_" data-uid="TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropFilter*"></a>
  <h4 id="TensorFlow_TFGraph_DepthwiseConv2dNativeBackpropFilter_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_String_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)">DepthwiseConv2dNativeBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradients of depthwise convolution with respect to the filter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DepthwiseConv2dNativeBackpropFilter (TensorFlow.TFOutput input, TensorFlow.TFOutput filter_sizes, TensorFlow.TFOutput out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D with shape based on <code>data_format</code>.  For example, if
              <code>data_format</code> is &#39;NHWC&#39; then <code>input</code> is a 4-D <code>[batch, in_height,
              in_width, in_channels]</code> tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter_sizes</span></td>
        <td><p>An integer vector representing the tensor shape of <code>filter</code>,
              where <code>filter</code> is a 4-D
              <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code> tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">out_backprop</span></td>
        <td><p>4-D with shape  based on <code>data_format</code>.
              For example, if <code>data_format</code> is &#39;NHWC&#39; then
              out_backprop shape is <code>[batch, out_height, out_width, out_channels]</code>.
              Gradients w.r.t. the output of the convolution.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the input
              of the convolution.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, height, width, channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, channels, height, width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">dilations</span></td>
        <td><p>Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each filter
              element on that dimension. The dimension order is determined by the value of
              <code>data_format</code>, see above for details. Dilations in the batch and depth
              dimensions must be 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DepthwiseConv2dNativeBackpropFilter&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape
              <code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
              the <code>filter</code> input of the convolution.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_DepthwiseConv2dNativeBackpropInput_" data-uid="TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropInput*"></a>
  <h4 id="TensorFlow_TFGraph_DepthwiseConv2dNativeBackpropInput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_String_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.DepthwiseConv2dNativeBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.String,System.Int64[],System.String)">DepthwiseConv2dNativeBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], String, String, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradients of depthwise convolution with respect to the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DepthwiseConv2dNativeBackpropInput (TensorFlow.TFOutput input_sizes, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, string padding, string data_format = null, long[] dilations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_sizes</span></td>
        <td><p>An integer vector representing the shape of <code>input</code>, based
              on <code>data_format</code>.  For example, if <code>data_format</code> is &#39;NHWC&#39; then
              <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>4-D with shape
              <code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">out_backprop</span></td>
        <td><p>4-D with shape  based on <code>data_format</code>.
              For example, if <code>data_format</code> is &#39;NHWC&#39; then
              out_backprop shape is <code>[batch, out_height, out_width, out_channels]</code>.
              Gradients w.r.t. the output of the convolution.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the input
              of the convolution.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, height, width, channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, channels, height, width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">dilations</span></td>
        <td><p>Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each filter
              element on that dimension. The dimension order is determined by the value of
              <code>data_format</code>, see above for details. Dilations in the batch and depth
              dimensions must be 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DepthwiseConv2dNativeBackpropInput&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape according to <code>data_format</code>.  For example, if
              <code>data_format</code> is &#39;NHWC&#39;, output shape is <code>[batch, in_height,
              in_width, in_channels]</code>.  Gradient w.r.t. the input of the
              convolution.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Dequantize_" data-uid="TensorFlow.TFGraph.Dequantize*"></a>
  <h4 id="TensorFlow_TFGraph_Dequantize_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.Dequantize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">Dequantize(TFOutput, TFOutput, TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>Dequantize the &#39;input&#39; tensor into a float Tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Dequantize (TensorFlow.TFOutput input, TensorFlow.TFOutput min_range, TensorFlow.TFOutput max_range, string mode = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_range</span></td>
        <td><p>The minimum scalar value possibly produced for the input.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_range</span></td>
        <td><p>The maximum scalar value possibly produced for the input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Dequantize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Dequantize_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>[min_range, max_range] are scalar floats that specify the range for
              the &#39;input&#39; data. The &#39;mode&#39; attribute controls exactly which calculations are
              used to convert the float values to their quantized equivalents.</p>
<pre><code>          In &#39;MIN_COMBINED&#39; mode, each value of the tensor will undergo the following:

           &lt;pre&gt;&lt;code&gt;
          if T == qint8: in[i] += (range(T) + 1)/ 2.0
          out[i] = min_range + (in[i]* (max_range - min_range) / range(T))
           &lt;/code&gt;&lt;/pre&gt;
          here &lt;code&gt;range(T) = numeric_limits&amp;lt;T&amp;gt;::max() - numeric_limits&amp;lt;T&amp;gt;::min()&lt;/code&gt;

          *MIN_COMBINED Mode Example*

          If the input comes from a QuantizedRelu6, the output type is
          quint8 (range of 0-255) but the possible range of QuantizedRelu6 is
          0-6.  The min_range and max_range values are therefore 0.0 and 6.0.
          Dequantize on quint8 will take each value, cast to float, and multiply
          by 6 / 255.
          Note that if quantizedtype is qint8, the operation will additionally add
          each value by 128 prior to casting.

          If the mode is &#39;MIN_FIRST&#39;, then this approach is used:

           &lt;pre&gt;&lt;code&gt;
          num_discrete_values = 1 &amp;lt;&amp;lt; (# of bits in T)
          range_adjust = num_discrete_values / (num_discrete_values - 1)
          range = (range_max - range_min) * range_adjust
          range_scale = range / num_discrete_values
          const double offset_input = static_cast&amp;lt;double&amp;gt;(input) - lowest_quantized;
          result = range_min + ((input - numeric_limits&amp;lt;T&amp;gt;::min()) * range_scale)
           &lt;/code&gt;&lt;/pre&gt;

          *SCALED mode Example*

          &lt;code&gt;SCALED&lt;/code&gt; mode matches the quantization approach used in
          &lt;code&gt;QuantizeAndDequantize{V2|V3}&lt;/code&gt;.

          If the mode is &lt;code&gt;SCALED&lt;/code&gt;, we do not use the full range of the output type,
          choosing to elide the lowest possible value for symmetry (e.g., output range is
          -127 to 127, not -128 to 127 for signed 8 bit quantization), so that 0.0 maps to
          0.

          We first find the range of values in our tensor. The
          range we use is always centered on 0, so we find m such that
           &lt;pre&gt;&lt;code&gt;
          m = max(abs(input_min), abs(input_max))
           &lt;/code&gt;&lt;/pre&gt;

          Our input tensor range is then &lt;code&gt;[-m, m]&lt;/code&gt;.

          Next, we choose our fixed-point quantization buckets, &lt;code&gt;[min_fixed, max_fixed]&lt;/code&gt;.
          If T is signed, this is
           &lt;pre&gt;&lt;code&gt;
          num_bits = sizeof(T) * 8
          [min_fixed, max_fixed] =
          [-(1 &amp;lt;&amp;lt; (num_bits - 1) - 1), (1 &amp;lt;&amp;lt; (num_bits - 1)) - 1]
           &lt;/code&gt;&lt;/pre&gt;

          Otherwise, if T is unsigned, the fixed-point range is
           &lt;pre&gt;&lt;code&gt;
          [min_fixed, max_fixed] = [0, (1 &amp;lt;&amp;lt; num_bits) - 1]
           &lt;/code&gt;&lt;/pre&gt;

          From this we compute our scaling factor, s:
           &lt;pre&gt;&lt;code&gt;
          s = (2 * m) / (max_fixed - min_fixed)
           &lt;/code&gt;&lt;/pre&gt;

          Now we can dequantize the elements of our tensor:
           &lt;pre&gt;&lt;code&gt;
          result = input * s
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DeserializeIterator_" data-uid="TensorFlow.TFGraph.DeserializeIterator*"></a>
  <h4 id="TensorFlow_TFGraph_DeserializeIterator_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.DeserializeIterator(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">DeserializeIterator(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Converts the given variant tensor to an iterator and stores it in the given resource.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation DeserializeIterator (TensorFlow.TFOutput resource_handle, TensorFlow.TFOutput serialized, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource_handle</span></td>
        <td><p>A handle to an iterator resource.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">serialized</span></td>
        <td><p>A variant tensor storing the state of the iterator contained in the
              resource.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DeserializeIterator&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_DeserializeManySparse_" data-uid="TensorFlow.TFGraph.DeserializeManySparse*"></a>
  <h4 id="TensorFlow_TFGraph_DeserializeManySparse_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.DeserializeManySparse(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">DeserializeManySparse(TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Deserialize and concatenate <code>SparseTensors</code> from a serialized minibatch.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; DeserializeManySparse (TensorFlow.TFOutput serialized_sparse, TensorFlow.TFDataType dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">serialized_sparse</span></td>
        <td><p>2-D, The <code>N</code> serialized <code>SparseTensor</code> objects.
              Must have 3 columns.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The <code>dtype</code> of the serialized <code>SparseTensor</code> objects.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DeserializeManySparse&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sparse_indices:
              sparse_values:
              sparse_shape:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DeserializeManySparse_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The input <code>serialized_sparse</code> must be a string matrix of shape <code>[N x 3]</code> where
              <code>N</code> is the minibatch size and the rows correspond to packed outputs of
              <code>SerializeSparse</code>.  The ranks of the original <code>SparseTensor</code> objects
              must all match.  When the final <code>SparseTensor</code> is created, it has rank one
              higher than the ranks of the incoming <code>SparseTensor</code> objects
              (they have been concatenated along a new row dimension).</p>
<pre><code>          The output &lt;code&gt;SparseTensor&lt;/code&gt; object&#39;s shape values for all dimensions but the
          first are the max across the input &lt;code&gt;SparseTensor&lt;/code&gt; objects&#39; shape values
          for the corresponding dimensions.  Its first shape value is &lt;code&gt;N&lt;/code&gt;, the minibatch
          size.

          The input &lt;code&gt;SparseTensor&lt;/code&gt; objects&#39; indices are assumed ordered in
          standard lexicographic order.  If this is not the case, after this
          step run &lt;code&gt;SparseReorder&lt;/code&gt; to restore index ordering.

          For example, if the serialized input is a &lt;code&gt;[2 x 3]&lt;/code&gt; matrix representing two
          original &lt;code&gt;SparseTensor&lt;/code&gt; objects:

          index = [ 0]
          [10]
          [20]
          values = [1, 2, 3]
          shape = [50]

          and

          index = [ 2]
          [10]
          values = [4, 5]
          shape = [30]

          then the final deserialized &lt;code&gt;SparseTensor&lt;/code&gt; will be:

          index = [0  0]
          [0 10]
          [0 20]
          [1  2]
          [1 10]
          values = [1, 2, 3, 4, 5]
          shape = [2 50]
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DeserializeSparse_" data-uid="TensorFlow.TFGraph.DeserializeSparse*"></a>
  <h4 id="TensorFlow_TFGraph_DeserializeSparse_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.DeserializeSparse(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">DeserializeSparse(TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Deserialize <code>SparseTensor</code> objects.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; DeserializeSparse (TensorFlow.TFOutput serialized_sparse, TensorFlow.TFDataType dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">serialized_sparse</span></td>
        <td><p>The serialized <code>SparseTensor</code> objects. The last dimension
              must have 3 columns.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The <code>dtype</code> of the serialized <code>SparseTensor</code> objects.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DeserializeSparse&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sparse_indices:
              sparse_values:
              sparse_shape:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DeserializeSparse_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The input <code>serialized_sparse</code> must have the shape <code>[?, ?, ..., ?, 3]</code> where
              the last dimension stores serialized <code>SparseTensor</code> objects and the other N
              dimensions (N &gt;= 0) correspond to a batch. The ranks of the original
              <code>SparseTensor</code> objects must all match. When the final <code>SparseTensor</code> is
              created, its rank is the rank of the incoming <code>SparseTensor</code> objects plus N;
              the sparse tensors have been concatenated along new dimensions, one for each
              batch.</p>
<pre><code>          The output &lt;code&gt;SparseTensor&lt;/code&gt; object&#39;s shape values for the original dimensions
          are the max across the input &lt;code&gt;SparseTensor&lt;/code&gt; objects&#39; shape values for the
          corresponding dimensions. The new dimensions match the size of the batch.

          The input &lt;code&gt;SparseTensor&lt;/code&gt; objects&#39; indices are assumed ordered in
          standard lexicographic order.  If this is not the case, after this
          step run &lt;code&gt;SparseReorder&lt;/code&gt; to restore index ordering.

          For example, if the serialized input is a &lt;code&gt;[2 x 3]&lt;/code&gt; matrix representing two
          original &lt;code&gt;SparseTensor&lt;/code&gt; objects:

          index = [ 0]
          [10]
          [20]
          values = [1, 2, 3]
          shape = [50]

          and

          index = [ 2]
          [10]
          values = [4, 5]
          shape = [30]

          then the final deserialized &lt;code&gt;SparseTensor&lt;/code&gt; will be:

          index = [0  0]
          [0 10]
          [0 20]
          [1  2]
          [1 10]
          values = [1, 2, 3, 4, 5]
          shape = [2 50]
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DestroyResourceOp_" data-uid="TensorFlow.TFGraph.DestroyResourceOp*"></a>
  <h4 id="TensorFlow_TFGraph_DestroyResourceOp_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.DestroyResourceOp(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">DestroyResourceOp(TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Deletes the resource specified by the handle.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation DestroyResourceOp (TensorFlow.TFOutput resource, Nullable&lt;bool&gt; ignore_lookup_error = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>handle to the resource to delete.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">ignore_lookup_error</span></td>
        <td><p>Optional argument
              whether to ignore the error when the resource
              doesn&#39;t exist.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DestroyResourceOp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DestroyResourceOp_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>All subsequent operations using the resource will result in a NotFound
              error status.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DestroyTemporaryVariable_" data-uid="TensorFlow.TFGraph.DestroyTemporaryVariable*"></a>
  <h4 id="TensorFlow_TFGraph_DestroyTemporaryVariable_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.DestroyTemporaryVariable(TensorFlow.TFOutput,System.String,System.String)">DestroyTemporaryVariable(TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>Destroys the temporary variable and returns its final value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DestroyTemporaryVariable (TensorFlow.TFOutput reference, string var_name, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>A reference to the temporary variable tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">var_name</span></td>
        <td><p>Name of the temporary variable, usually the name of the matching
              &#39;TemporaryVariable&#39; op.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DestroyTemporaryVariable&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DestroyTemporaryVariable_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Sets output to the value of the Tensor pointed to by &#39;ref&#39;, then destroys
              the temporary variable called &#39;var_name&#39;.
              All other uses of &#39;ref&#39; <em>must</em> have executed before this op.
              This is typically achieved by chaining the ref through each assign op, or by
              using control dependencies.</p>
<pre><code>          Outputs the final value of the tensor pointed to by &#39;ref&#39;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Diag_" data-uid="TensorFlow.TFGraph.Diag*"></a>
  <h4 id="TensorFlow_TFGraph_Diag_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Diag(TensorFlow.TFOutput,System.String)">Diag(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns a diagonal tensor with a given diagonal values.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Diag (TensorFlow.TFOutput diagonal, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">diagonal</span></td>
        <td><p>Rank k tensor where k is at most 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Diag&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Diag_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a <code>diagonal</code>, this operation returns a tensor with the <code>diagonal</code> and
              everything else padded with zeros. The diagonal is computed as follows:</p>
<pre><code>          Assume &lt;code&gt;diagonal&lt;/code&gt; has dimensions [D1,..., Dk], then the output is a tensor of
          rank 2k with dimensions [D1,..., Dk, D1,..., Dk] where:

          &lt;code&gt;output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]&lt;/code&gt; and 0 everywhere else.

          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;diagonal&#39; is [1, 2, 3, 4]
          tf.diag(diagonal) ==&amp;gt; [[1, 0, 0, 0]
          [0, 2, 0, 0]
          [0, 0, 3, 0]
          [0, 0, 0, 4]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DiagPart_" data-uid="TensorFlow.TFGraph.DiagPart*"></a>
  <h4 id="TensorFlow_TFGraph_DiagPart_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.DiagPart(TensorFlow.TFOutput,System.String)">DiagPart(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the diagonal part of the tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DiagPart (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Rank k tensor where k is even and not zero.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DiagPart&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The extracted diagonal.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DiagPart_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation returns a tensor with the <code>diagonal</code> part
              of the <code>input</code>. The <code>diagonal</code> part is computed as follows:</p>
<pre><code>          Assume &lt;code&gt;input&lt;/code&gt; has dimensions &lt;code&gt;[D1,..., Dk, D1,..., Dk]&lt;/code&gt;, then the output is a
          tensor of rank &lt;code&gt;k&lt;/code&gt; with dimensions &lt;code&gt;[D1,..., Dk]&lt;/code&gt; where:

          &lt;code&gt;diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]&lt;/code&gt;.

          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;input&#39; is [[1, 0, 0, 0]
          [0, 2, 0, 0]
          [0, 0, 3, 0]
          [0, 0, 0, 4]]

          tf.diag_part(input) ==&amp;gt; [1, 2, 3, 4]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Digamma_" data-uid="TensorFlow.TFGraph.Digamma*"></a>
  <h4 id="TensorFlow_TFGraph_Digamma_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Digamma(TensorFlow.TFOutput,System.String)">Digamma(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes Psi, the derivative of Lgamma (the log of the absolute value of</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Digamma (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Digamma&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Digamma_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>Gamma(x)</code>), element-wise.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Dilation2D_" data-uid="TensorFlow.TFGraph.Dilation2D*"></a>
  <h4 id="TensorFlow_TFGraph_Dilation2D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_" data-uid="TensorFlow.TFGraph.Dilation2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">Dilation2D(TFOutput, TFOutput, Int64[], Int64[], String, String)</h4>
  <div class="markdown level1 summary"><p>Computes the grayscale dilation of 4-D <code>input</code> and 3-D <code>filter</code> tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Dilation2D (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, long[] strides, long[] rates, string padding, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D with shape <code>[batch, in_height, in_width, depth]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>3-D with shape <code>[filter_height, filter_width, depth]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the input
              tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">rates</span></td>
        <td><p>The input stride for atrous morphological dilation. Must be:
              <code>[1, rate_height, rate_width, 1]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Dilation2D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape <code>[batch, out_height, out_width, depth]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Dilation2D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The <code>input</code> tensor has shape <code>[batch, in_height, in_width, depth]</code> and the
              <code>filter</code> tensor has shape <code>[filter_height, filter_width, depth]</code>, i.e., each
              input channel is processed independently of the others with its own structuring
              function. The <code>output</code> tensor has shape
              <code>[batch, out_height, out_width, depth]</code>. The spatial dimensions of the output
              tensor depend on the <code>padding</code> algorithm. We currently only support the default
              &quot;NHWC&quot; <code>data_format</code>.</p>
<pre><code>          In detail, the grayscale morphological 2-D dilation is the max-sum correlation
          (for consistency with &lt;code&gt;conv2d&lt;/code&gt;, we use unmirrored filters):

          output[b, y, x, c] =
          max_{dy, dx} input[b,
          strides[1] * y + rates[1] * dy,
          strides[2] * x + rates[2] * dx,
          c] +
          filter[dy, dx, c]

          Max-pooling is a special case when the filter has size equal to the pooling
          kernel size and contains all zeros.

          Note on duality: The dilation of &lt;code&gt;input&lt;/code&gt; by the &lt;code&gt;filter&lt;/code&gt; is equal to the
          negation of the erosion of &lt;code&gt;-input&lt;/code&gt; by the reflected &lt;code&gt;filter&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Dilation2DBackpropFilter_" data-uid="TensorFlow.TFGraph.Dilation2DBackpropFilter*"></a>
  <h4 id="TensorFlow_TFGraph_Dilation2DBackpropFilter_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_" data-uid="TensorFlow.TFGraph.Dilation2DBackpropFilter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">Dilation2DBackpropFilter(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradient of morphological 2-D dilation with respect to the filter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Dilation2DBackpropFilter (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, long[] rates, string padding, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D with shape <code>[batch, in_height, in_width, depth]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>3-D with shape <code>[filter_height, filter_width, depth]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">out_backprop</span></td>
        <td><p>4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D of length 4. The stride of the sliding window for each dimension of
              the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">rates</span></td>
        <td><p>1-D of length 4. The input stride for atrous morphological dilation.
              Must be: <code>[1, rate_height, rate_width, 1]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Dilation2DBackpropFilter&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>3-D with shape <code>[filter_height, filter_width, depth]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Dilation2DBackpropInput_" data-uid="TensorFlow.TFGraph.Dilation2DBackpropInput*"></a>
  <h4 id="TensorFlow_TFGraph_Dilation2DBackpropInput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_" data-uid="TensorFlow.TFGraph.Dilation2DBackpropInput(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">Dilation2DBackpropInput(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradient of morphological 2-D dilation with respect to the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Dilation2DBackpropInput (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, TensorFlow.TFOutput out_backprop, long[] strides, long[] rates, string padding, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D with shape <code>[batch, in_height, in_width, depth]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>3-D with shape <code>[filter_height, filter_width, depth]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">out_backprop</span></td>
        <td><p>4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D of length 4. The stride of the sliding window for each dimension of
              the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">rates</span></td>
        <td><p>1-D of length 4. The input stride for atrous morphological dilation.
              Must be: <code>[1, rate_height, rate_width, 1]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Dilation2DBackpropInput&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape <code>[batch, in_height, in_width, depth]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Div_" data-uid="TensorFlow.TFGraph.Div*"></a>
  <h4 id="TensorFlow_TFGraph_Div_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Div(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Div(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns x / y element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Div (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Div&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Div_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>Div</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DivNoNan_" data-uid="TensorFlow.TFGraph.DivNoNan*"></a>
  <h4 id="TensorFlow_TFGraph_DivNoNan_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.DivNoNan(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">DivNoNan(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns 0 if the denominator is zero.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DivNoNan (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DivNoNan&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DivNoNan_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>DivNoNan</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DrawBoundingBoxes_" data-uid="TensorFlow.TFGraph.DrawBoundingBoxes*"></a>
  <h4 id="TensorFlow_TFGraph_DrawBoundingBoxes_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.DrawBoundingBoxes(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">DrawBoundingBoxes(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Draw bounding boxes on a batch of images.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DrawBoundingBoxes (TensorFlow.TFOutput images, TensorFlow.TFOutput boxes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">images</span></td>
        <td><p>4-D with shape <code>[batch, height, width, depth]</code>. A batch of images.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">boxes</span></td>
        <td><p>3-D with shape <code>[batch, num_bounding_boxes, 4]</code> containing bounding
              boxes.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DrawBoundingBoxes&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with the same shape as <code>images</code>. The batch of input images with
              bounding boxes drawn on the images.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DrawBoundingBoxes_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Outputs a copy of <code>images</code> but draws on top of the pixels zero or more bounding
              boxes specified by the locations in <code>boxes</code>. The coordinates of the each
              bounding box in <code>boxes</code> are encoded as <code>[y_min, x_min, y_max, x_max]</code>. The
              bounding box coordinates are floats in <code>[0.0, 1.0]</code> relative to the width and
              height of the underlying image.</p>
<pre><code>          For example, if an image is 100 x 200 pixels (height x width) and the bounding
          box is &lt;code&gt;[0.1, 0.2, 0.5, 0.9]&lt;/code&gt;, the upper-left and bottom-right coordinates of
          the bounding box will be &lt;code&gt;(40, 10)&lt;/code&gt; to &lt;code&gt;(180, 50)&lt;/code&gt; (in (x,y) coordinates).

          Parts of the bounding box may fall outside the image.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Dropout_" data-uid="TensorFlow.TFGraph.Dropout*"></a>
  <h4 id="TensorFlow_TFGraph_Dropout_TensorFlow_TFOutput_System_Double_TensorFlow_TFShape_System_Nullable_System_Int32__System_String_" data-uid="TensorFlow.TFGraph.Dropout(TensorFlow.TFOutput,System.Double,TensorFlow.TFShape,System.Nullable{System.Int32},System.String)">Dropout(TFOutput, Double, TFShape, Nullable&lt;Int32&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes dropout.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Dropout (TensorFlow.TFOutput x, double keep_prob, TensorFlow.TFShape noise_shape = null, Nullable&lt;int&gt; seed = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>A tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">keep_prob</span></td>
        <td><p>A scalar Tensor with the same type as x. The probability that each element is kept.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">noise_shape</span></td>
        <td><p>A 1-D Tensor of type int32, representing the shape for randomly generated keep/drop flags.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int32</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Integer seed used for the random distribution, using the TensorFlow SetRandomSeed .</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Operation name, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Dropout_TensorFlow_TFOutput_System_Double_TensorFlow_TFShape_System_Nullable_System_Int32__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>With probability keep_prob, outputs the input element scaled up by 1 / keep_prob, 
            otherwise outputs 0. The scaling is so that the expected sum is unchanged.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Dropout_" data-uid="TensorFlow.TFGraph.Dropout*"></a>
  <h4 id="TensorFlow_TFGraph_Dropout_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFShape_System_Nullable_System_Int32__System_String_" data-uid="TensorFlow.TFGraph.Dropout(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFShape,System.Nullable{System.Int32},System.String)">Dropout(TFOutput, TFOutput, TFShape, Nullable&lt;Int32&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes dropout.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Dropout (TensorFlow.TFOutput x, TensorFlow.TFOutput keep_prob, TensorFlow.TFShape noise_shape = null, Nullable&lt;int&gt; seed = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>A tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">keep_prob</span></td>
        <td><p>A scalar Tensor with the same type as x. The probability that each element is kept.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">noise_shape</span></td>
        <td><p>A 1-D Tensor of type int32, representing the shape for randomly generated keep/drop flags.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int32</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Integer seed used for the random distribution, using the TensorFlow SetRandomSeed .</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Operation name, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Dropout_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFShape_System_Nullable_System_Int32__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>With probability keep_prob, outputs the input element scaled up by 1 / keep_prob, 
            otherwise outputs 0. The scaling is so that the expected sum is unchanged.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_DynamicPartition_" data-uid="TensorFlow.TFGraph.DynamicPartition*"></a>
  <h4 id="TensorFlow_TFGraph_DynamicPartition_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.DynamicPartition(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">DynamicPartition(TFOutput, TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>Partitions <code>data</code> into <code>num_partitions</code> tensors using indices from <code>partitions</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] DynamicPartition (TensorFlow.TFOutput data, TensorFlow.TFOutput partitions, long num_partitions, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">partitions</span></td>
        <td><p>Any shape.  Indices in the range <code>[0, num_partitions)</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_partitions</span></td>
        <td><p>The number of partitions to output.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DynamicPartition&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DynamicPartition_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>For each index tuple <code>js</code> of size <code>partitions.ndim</code>, the slice <code>data[js, ...]</code>
              becomes part of <code>outputs[partitions[js]]</code>.  The slices with <code>partitions[js] = i</code>
              are placed in <code>outputs[i]</code> in lexicographic order of <code>js</code>, and the first
              dimension of <code>outputs[i]</code> is the number of entries in <code>partitions</code> equal to <code>i</code>.
              In detail,</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]

          outputs[i] = pack([data[js, ...] for js if partitions[js] == i])
           &lt;/code&gt;&lt;/pre&gt;&lt;code&gt;data.shape&lt;/code&gt; must start with &lt;code&gt;partitions.shape&lt;/code&gt;.

          For example:

           &lt;pre&gt;&lt;code&gt;
          # Scalar partitions.
          partitions = 1
          num_partitions = 2
          data = [10, 20]
          outputs[0] = []  # Empty with shape [0, 2]
          outputs[1] = [[10, 20]]

          # Vector partitions.
          partitions = [0, 0, 1, 1, 0]
          num_partitions = 2
          data = [10, 20, 30, 40, 50]
          outputs[0] = [10, 20, 50]
          outputs[1] = [30, 40]
           &lt;/code&gt;&lt;/pre&gt;

          See &lt;code&gt;dynamic_stitch&lt;/code&gt; for an example on how to merge partitions back.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/DynamicPartition.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_DynamicStitch_" data-uid="TensorFlow.TFGraph.DynamicStitch*"></a>
  <h4 id="TensorFlow_TFGraph_DynamicStitch_TensorFlow_TFOutput___TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.DynamicStitch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)">DynamicStitch(TFOutput[], TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Interleave the values from the <code>data</code> tensors into a single tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput DynamicStitch (TensorFlow.TFOutput[] indices, TensorFlow.TFOutput[] data, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;DynamicStitch&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_DynamicStitch_TensorFlow_TFOutput___TensorFlow_TFOutput___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Builds a merged tensor such that</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]
           &lt;/code&gt;&lt;/pre&gt;

          For example, if each &lt;code&gt;indices[m]&lt;/code&gt; is scalar or vector, we have

           &lt;pre&gt;&lt;code&gt;
          # Scalar indices:
          merged[indices[m], ...] = data[m][...]

          # Vector indices:
          merged[indices[m][i], ...] = data[m][i, ...]
           &lt;/code&gt;&lt;/pre&gt;

          Each &lt;code&gt;data[i].shape&lt;/code&gt; must start with the corresponding &lt;code&gt;indices[i].shape&lt;/code&gt;,
          and the rest of &lt;code&gt;data[i].shape&lt;/code&gt; must be constant w.r.t. &lt;code&gt;i&lt;/code&gt;.  That is, we
          must have &lt;code&gt;data[i].shape = indices[i].shape + constant&lt;/code&gt;.  In terms of this
          &lt;code&gt;constant&lt;/code&gt;, the output shape is

          merged.shape = [max(indices)] + constant

          Values are merged in order, so if an index appears in both &lt;code&gt;indices[m][i]&lt;/code&gt; and
          &lt;code&gt;indices[n][j]&lt;/code&gt; for &lt;code&gt;(m,i) &amp;lt; (n,j)&lt;/code&gt; the slice &lt;code&gt;data[n][j]&lt;/code&gt; will appear in the
          merged result. If you do not need this guarantee, ParallelDynamicStitch might
          perform better on some devices.

          For example:

           &lt;pre&gt;&lt;code&gt;
          indices[0] = 6
          indices[1] = [4, 1]
          indices[2] = [[5, 2], [0, 3]]
          data[0] = [61, 62]
          data[1] = [[41, 42], [11, 12]]
          data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]
          merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],
          [51, 52], [61, 62]]
           &lt;/code&gt;&lt;/pre&gt;

          This method can be used to merge partitions created by &lt;code&gt;dynamic_partition&lt;/code&gt;
          as illustrated on the following example:

           &lt;pre&gt;&lt;code&gt;
          # Apply function (increments x_i) on elements for which a certain condition
          # apply (x_i != -1 in this example).
          x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])
          condition_mask=tf.not_equal(x,tf.constant(-1.))
          partitioned_data = tf.dynamic_partition(
          x, tf.cast(condition_mask, tf.int32) , 2)
          partitioned_data[1] = partitioned_data[1] + 1.0
          condition_indices = tf.dynamic_partition(
          tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)
          x = tf.dynamic_stitch(condition_indices, partitioned_data)
          # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain
          # unchanged.
           &lt;/code&gt;&lt;/pre&gt;

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/DynamicStitch.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_EditDistance_" data-uid="TensorFlow.TFGraph.EditDistance*"></a>
  <h4 id="TensorFlow_TFGraph_EditDistance_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.EditDistance(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">EditDistance(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the (possibly normalized) Levenshtein Edit Distance.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput EditDistance (TensorFlow.TFOutput hypothesis_indices, TensorFlow.TFOutput hypothesis_values, TensorFlow.TFOutput hypothesis_shape, TensorFlow.TFOutput truth_indices, TensorFlow.TFOutput truth_values, TensorFlow.TFOutput truth_shape, Nullable&lt;bool&gt; normalize = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">hypothesis_indices</span></td>
        <td><p>The indices of the hypothesis list SparseTensor.
              This is an N x R int64 matrix.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">hypothesis_values</span></td>
        <td><p>The values of the hypothesis list SparseTensor.
              This is an N-length vector.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">hypothesis_shape</span></td>
        <td><p>The shape of the hypothesis list SparseTensor.
              This is an R-length vector.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">truth_indices</span></td>
        <td><p>The indices of the truth list SparseTensor.
              This is an M x R int64 matrix.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">truth_values</span></td>
        <td><p>The values of the truth list SparseTensor.
              This is an M-length vector.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">truth_shape</span></td>
        <td><p>truth indices, vector.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">normalize</span></td>
        <td><p>Optional argument
              boolean (if true, edit distances are normalized by length of truth).</p>
<pre><code>          The output is:
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;EditDistance&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A dense float tensor with rank R - 1.</p>
<pre><code>          For the example input:

          // hypothesis represents a 2x1 matrix with variable-length values:
          //   (0,0) = [&quot;a&quot;]
          //   (1,0) = [&quot;b&quot;]
          hypothesis_indices = [[0, 0, 0],
          [1, 0, 0]]
          hypothesis_values = [&quot;a&quot;, &quot;b&quot;]
          hypothesis_shape = [2, 1, 1]

          // truth represents a 2x2 matrix with variable-length values:
          //   (0,0) = []
          //   (0,1) = [&quot;a&quot;]
          //   (1,0) = [&quot;b&quot;, &quot;c&quot;]
          //   (1,1) = [&quot;a&quot;]
          truth_indices = [[0, 1, 0],
          [1, 0, 0],
          [1, 0, 1],
          [1, 1, 0]]
          truth_values = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;]
          truth_shape = [2, 2, 2]
          normalize = true

          The output will be:

          // output is a 2x2 matrix with edit distances normalized by truth lengths.
          output = [[inf, 1.0],  // (0,0): no truth, (0,1): no hypothesis
          [0.5, 1.0]]  // (1,0): addition, (1,1): no hypothesis
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_EditDistance_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The inputs are variable-length sequences provided by SparseTensors
              (hypothesis_indices, hypothesis_values, hypothesis_shape)
              and
              (truth_indices, truth_values, truth_shape).</p>
<pre><code>          The inputs are:
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Elu_" data-uid="TensorFlow.TFGraph.Elu*"></a>
  <h4 id="TensorFlow_TFGraph_Elu_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Elu(TensorFlow.TFOutput,System.String)">Elu(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes exponential linear: <code>exp(features) - 1</code> if &lt; 0, <code>features</code> otherwise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Elu (TensorFlow.TFOutput features, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Elu&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Elu_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>See <a href="http://arxiv.org/abs/1511.07289">Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)
</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_EluGrad_" data-uid="TensorFlow.TFGraph.EluGrad*"></a>
  <h4 id="TensorFlow_TFGraph_EluGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.EluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">EluGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes gradients for the exponential linear (Elu) operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput EluGrad (TensorFlow.TFOutput gradients, TensorFlow.TFOutput outputs, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradients</span></td>
        <td><p>The backpropagated gradients to the corresponding Elu operation.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">outputs</span></td>
        <td><p>The outputs of the corresponding Elu operation.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;EluGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The gradients: <code>gradients * (outputs + 1)</code> if outputs &lt; 0,
              <code>gradients</code> otherwise.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Empty_" data-uid="TensorFlow.TFGraph.Empty*"></a>
  <h4 id="TensorFlow_TFGraph_Empty_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Empty(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)">Empty(TFOutput, TFDataType, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Creates a tensor with the given shape.</p>
<pre><code>          This operation creates a tensor of &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;dtype&lt;/code&gt;.
</code></pre></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Empty (TensorFlow.TFOutput shape, TensorFlow.TFDataType dtype, Nullable&lt;bool&gt; init = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>1-D. Represents the shape of the output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">init</span></td>
        <td><p>Optional argument
              If True, initialize the returned tensor with the default value of dtype.  Otherwise, the implementation is free not to initializethe tensor&#39;s content.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Empty&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A <code>Tensor</code> of type <code>T</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_EmptyTensorList_" data-uid="TensorFlow.TFGraph.EmptyTensorList*"></a>
  <h4 id="TensorFlow_TFGraph_EmptyTensorList_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.EmptyTensorList(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">EmptyTensorList(TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Creates and returns an empty tensor list.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput EmptyTensorList (TensorFlow.TFOutput element_shape, TensorFlow.TFDataType element_dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">element_shape</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">element_dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;EmptyTensorList&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_EmptyTensorList_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>All list elements must be tensors of dtype element_dtype and shape compatible
              with element_shape.</p>
<pre><code>          handle: an empty tensor list.
          element_dtype: the type of elements in the list.
          element_shape: a shape compatible with that of elements in the list.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_EncodeBase64_" data-uid="TensorFlow.TFGraph.EncodeBase64*"></a>
  <h4 id="TensorFlow_TFGraph_EncodeBase64_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.EncodeBase64(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">EncodeBase64(TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Encode strings into web-safe base64 format.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput EncodeBase64 (TensorFlow.TFOutput input, Nullable&lt;bool&gt; pad = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Strings to be encoded.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">pad</span></td>
        <td><p>Optional argument
              Bool whether padding is applied at the ends.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;EncodeBase64&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Input strings encoded in base64.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_EncodeBase64_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Refer to the following article for more information on base64 format:
              en.wikipedia.org/wiki/Base64. Base64 strings may have padding with &#39;=&#39; at the
              end so that the encoded has length multiple of 4. See Padding section of the
              link above.</p>
<pre><code>          Web-safe means that the encoder uses - and _ instead of + and /.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_EncodeJpeg_" data-uid="TensorFlow.TFGraph.EncodeJpeg*"></a>
  <h4 id="TensorFlow_TFGraph_EncodeJpeg_TensorFlow_TFOutput_System_String_System_Nullable_System_Int64__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.EncodeJpeg(TensorFlow.TFOutput,System.String,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String)">EncodeJpeg(TFOutput, String, Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>JPEG-encode an image.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput EncodeJpeg (TensorFlow.TFOutput image, string format = null, Nullable&lt;long&gt; quality = null, Nullable&lt;bool&gt; progressive = null, Nullable&lt;bool&gt; optimize_size = null, Nullable&lt;bool&gt; chroma_downsampling = null, string density_unit = null, Nullable&lt;long&gt; x_density = null, Nullable&lt;long&gt; y_density = null, string xmp_metadata = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">image</span></td>
        <td><p>3-D with shape <code>[height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">format</span></td>
        <td><p>Optional argument
              Per pixel image format.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">quality</span></td>
        <td><p>Optional argument
              Quality of the compression from 0 to 100 (higher is better and slower).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">progressive</span></td>
        <td><p>Optional argument
              If True, create a JPEG that loads progressively (coarse to fine).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">optimize_size</span></td>
        <td><p>Optional argument
              If True, spend CPU/RAM to reduce size with no quality change.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">chroma_downsampling</span></td>
        <td><p>Optional argument
              See <a href="http://en.wikipedia.org/wiki/Chroma_subsampling">http://en.wikipedia.org/wiki/Chroma_subsampling</a>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">density_unit</span></td>
        <td><p>Optional argument
              Unit used to specify <code>x_density</code> and <code>y_density</code>:
              pixels per inch (<code>&#39;in&#39;</code>) or centimeter (<code>&#39;cm&#39;</code>).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">x_density</span></td>
        <td><p>Optional argument
              Horizontal pixels per density unit.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">y_density</span></td>
        <td><p>Optional argument
              Vertical pixels per density unit.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">xmp_metadata</span></td>
        <td><p>Optional argument
              If not empty, embed this XMP metadata in the image header.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;EncodeJpeg&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>0-D. JPEG-encoded image.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_EncodeJpeg_TensorFlow_TFOutput_System_String_System_Nullable_System_Int64__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>image</code> is a 3-D uint8 Tensor of shape <code>[height, width, channels]</code>.</p>
<pre><code>          The attr &lt;code&gt;format&lt;/code&gt; can be used to override the color format of the encoded
          output.  Values can be:

          *   &lt;code&gt;&#39;&#39;&lt;/code&gt;: Use a default format based on the number of channels in the image.
          *   &lt;code&gt;grayscale&lt;/code&gt;: Output a grayscale JPEG image.  The &lt;code&gt;channels&lt;/code&gt; dimension
          of &lt;code&gt;image&lt;/code&gt; must be 1.
          *   &lt;code&gt;rgb&lt;/code&gt;: Output an RGB JPEG image. The &lt;code&gt;channels&lt;/code&gt; dimension
          of &lt;code&gt;image&lt;/code&gt; must be 3.

          If &lt;code&gt;format&lt;/code&gt; is not specified or is the empty string, a default format is picked
          in function of the number of channels in &lt;code&gt;image&lt;/code&gt;:

          *   1: Output a grayscale image.
          *   3: Output an RGB image.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_EncodePng_" data-uid="TensorFlow.TFGraph.EncodePng*"></a>
  <h4 id="TensorFlow_TFGraph_EncodePng_TensorFlow_TFOutput_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.EncodePng(TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)">EncodePng(TFOutput, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>PNG-encode an image.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput EncodePng (TensorFlow.TFOutput image, Nullable&lt;long&gt; compression = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">image</span></td>
        <td><p>3-D with shape <code>[height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">compression</span></td>
        <td><p>Optional argument
              Compression level.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;EncodePng&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>0-D. PNG-encoded image.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_EncodePng_TensorFlow_TFOutput_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>image</code> is a 3-D uint8 or uint16 Tensor of shape <code>[height, width, channels]</code>
              where <code>channels</code> is:</p>
<pre><code>          *   1: for grayscale.
          *   2: for grayscale + alpha.
          *   3: for RGB.
          *   4: for RGBA.

          The ZLIB compression level, &lt;code&gt;compression&lt;/code&gt;, can be -1 for the PNG-encoder
          default or a value from 0 to 9.  9 is the highest compression level, generating
          the smallest output, but is slower.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_EncodeProto_" data-uid="TensorFlow.TFGraph.EncodeProto*"></a>
  <h4 id="TensorFlow_TFGraph_EncodeProto_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String___System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.EncodeProto(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String[],System.String,System.String,System.String)">EncodeProto(TFOutput, TFOutput[], String[], String, String, String)</h4>
  <div class="markdown level1 summary"><p>The op serializes protobuf messages provided in the input tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput EncodeProto (TensorFlow.TFOutput sizes, TensorFlow.TFOutput[] values, string[] field_names, string message_type, string descriptor_source = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sizes</span></td>
        <td><p>Tensor of int32 with shape <code>[batch_shape, len(field_names)]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">values</span></td>
        <td><p>List of tensors containing values for the corresponding field.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">field_names</span></td>
        <td><p>List of strings containing proto field names.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">message_type</span></td>
        <td><p>Name of the proto message type to decode.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">descriptor_source</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;EncodeProto&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Tensor of serialized protos with shape <code>batch_shape</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_EncodeProto_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String___System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The types of the tensors in <code>values</code> must match the schema for the
              fields specified in <code>field_names</code>. All the tensors in <code>values</code> must
              have a common shape prefix, <em>batch_shape</em>.</p>
<pre><code>          The &lt;code&gt;sizes&lt;/code&gt; tensor specifies repeat counts for each field.  The repeat
          count (last dimension) of a each tensor in &lt;code&gt;values&lt;/code&gt; must be greater
          than or equal to corresponding repeat count in &lt;code&gt;sizes&lt;/code&gt;.

          A &lt;code&gt;message_type&lt;/code&gt; name must be provided to give context for the field
          names. The actual message descriptor can be looked up either in the
          linked-in descriptor pool or a filename provided by the caller using
          the &lt;code&gt;descriptor_source&lt;/code&gt; attribute.

          The &lt;code&gt;descriptor_source&lt;/code&gt; attribute selects a source of protocol
          descriptors to consult when looking up &lt;code&gt;message_type&lt;/code&gt;. This may be a
          filename containing a serialized &lt;code&gt;FileDescriptorSet&lt;/code&gt; message,
          or the special value &lt;code&gt;local://&lt;/code&gt;, in which case only descriptors linked
          into the code will be searched; the filename can be on any filesystem
          accessible to TensorFlow.

          You can build a &lt;code&gt;descriptor_source&lt;/code&gt; file using the &lt;code&gt;--descriptor_set_out&lt;/code&gt;
          and &lt;code&gt;--include_imports&lt;/code&gt; options to the protocol compiler &lt;code&gt;protoc&lt;/code&gt;.

          The &lt;code&gt;local://&lt;/code&gt; database only covers descriptors linked into the
          code via C++ libraries, not Python imports. You can link in a proto descriptor
          by creating a cc_library target with alwayslink=1.

          There are a few special cases in the value mapping:

          Submessage and group fields must be pre-serialized as TensorFlow strings.

          TensorFlow lacks support for unsigned int64s, so they must be
          represented as &lt;code&gt;tf.int64&lt;/code&gt; with the same twos-complement bit pattern
          (the obvious way).

          Unsigned int32 values can be represented exactly with &lt;code&gt;tf.int64&lt;/code&gt;, or
          with sign wrapping if the input is of type &lt;code&gt;tf.int32&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_EncodeWav_" data-uid="TensorFlow.TFGraph.EncodeWav*"></a>
  <h4 id="TensorFlow_TFGraph_EncodeWav_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.EncodeWav(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">EncodeWav(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Encode audio data using the WAV file format.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput EncodeWav (TensorFlow.TFOutput audio, TensorFlow.TFOutput sample_rate, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">audio</span></td>
        <td><p>2-D with shape <code>[length, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sample_rate</span></td>
        <td><p>Scalar containing the sample frequency.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;EncodeWav&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>0-D. WAV-encoded file contents.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_EncodeWav_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation will generate a string suitable to be saved out to create a .wav
              audio file. It will be encoded in the 16-bit PCM format. It takes in float
              values in the range -1.0f to 1.0f, and any outside that value will be clamped to
              that range.</p>
<pre><code>          &lt;code&gt;audio&lt;/code&gt; is a 2-D float Tensor of shape &lt;code&gt;[length, channels]&lt;/code&gt;.
          &lt;code&gt;sample_rate&lt;/code&gt; is a scalar Tensor holding the rate to use (e.g. 44100).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_EnqueueTPUEmbeddingIntegerBatch_" data-uid="TensorFlow.TFGraph.EnqueueTPUEmbeddingIntegerBatch*"></a>
  <h4 id="TensorFlow_TFGraph_EnqueueTPUEmbeddingIntegerBatch_TensorFlow_TFOutput___TensorFlow_TFOutput_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.EnqueueTPUEmbeddingIntegerBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)">EnqueueTPUEmbeddingIntegerBatch(TFOutput[], TFOutput, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>An op that enqueues a list of input batch tensors to TPUEmbedding.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation EnqueueTPUEmbeddingIntegerBatch (TensorFlow.TFOutput[] batch, TensorFlow.TFOutput mode_override, Nullable&lt;long&gt; device_ordinal = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">batch</span></td>
        <td><p>A list of 1D tensors, one for each embedding table, containing the
              indices into the tables.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mode_override</span></td>
        <td><p>A string input that overrides the mode specified in the
              TPUEmbeddingConfiguration. Supported values are {&#39;unspecified&#39;, &#39;inference&#39;,
              &#39;training&#39;, &#39;backward_pass_only&#39;}. When set to &#39;unspecified&#39;, the mode set
              in TPUEmbeddingConfiguration is used, otherwise mode_override is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">device_ordinal</span></td>
        <td><p>Optional argument
              The TPU device to use. Should be &gt;= 0 and less than the number
              of TPU cores in the task on which the node is placed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;EnqueueTPUEmbeddingIntegerBatch&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_EnqueueTPUEmbeddingSparseBatch_" data-uid="TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseBatch*"></a>
  <h4 id="TensorFlow_TFGraph_EnqueueTPUEmbeddingSparseBatch_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput_System_Nullable_System_Int64__System_String___System_String_" data-uid="TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Nullable{System.Int64},System.String[],System.String)">EnqueueTPUEmbeddingSparseBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Nullable&lt;Int64&gt;, String[], String)</h4>
  <div class="markdown level1 summary"><p>An op that enqueues TPUEmbedding input indices from a SparseTensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation EnqueueTPUEmbeddingSparseBatch (TensorFlow.TFOutput[] sample_indices, TensorFlow.TFOutput[] embedding_indices, TensorFlow.TFOutput[] aggregation_weights, TensorFlow.TFOutput mode_override, Nullable&lt;long&gt; device_ordinal = null, string[] combiners = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">sample_indices</span></td>
        <td><p>A list of rank 1 Tensors specifying the training example and
              feature to which the corresponding embedding_indices and aggregation_weights
              values belong. sample_indices[i] must equal b * nf + f, where nf is the
              number of features from the corresponding table, f is in [0, nf), and
              b is in [0, batch size).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">embedding_indices</span></td>
        <td><p>A list of rank 1 Tensors, indices into the embedding tables.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">aggregation_weights</span></td>
        <td><p>A list of rank 1 Tensors containing per sample -- i.e. per
              (training example, feature) -- aggregation weights.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mode_override</span></td>
        <td><p>A string input that overrides the mode specified in the
              TPUEmbeddingConfiguration. Supported values are {&#39;unspecified&#39;, &#39;inference&#39;,
              &#39;training&#39;, &#39;backward_pass_only&#39;}. When set to &#39;unspecified&#39;, the mode set
              in TPUEmbeddingConfiguration is used, otherwise mode_override is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">device_ordinal</span></td>
        <td><p>Optional argument
              The TPU device to use. Should be &gt;= 0 and less than the number
              of TPU cores in the task on which the node is placed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">combiners</span></td>
        <td><p>Optional argument
              A list of string scalars, one for each embedding table that specify
              how to normalize the embedding activations after weighted summation.
              Supported combiners are &#39;mean&#39;, &#39;sum&#39;, or &#39;sqrtn&#39;. It is invalid to have
              the sum of the weights be 0 for &#39;mean&#39; or the sum of the squared weights be
              0 for &#39;sqrtn&#39;. If combiners isn&#39;t passed, the default is to use &#39;sum&#39; for
              all tables.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;EnqueueTPUEmbeddingSparseBatch&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_EnqueueTPUEmbeddingSparseBatch_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput_System_Nullable_System_Int64__System_String___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This Op eases the porting of code that uses embedding_lookup_sparse(),
              although some Python preprocessing of the SparseTensor arguments to
              embedding_lookup_sparse() is required to produce the arguments to this Op,
              since only a single EnqueueTPUEmbeddingSparseBatch Op is allowed per training
              step.</p>
<pre><code>          The tensors at corresponding positions in the three input lists
          must have the same shape, i.e. rank 1 with dim_size() equal to the total
          number of lookups into the table described by the corresponding table_id.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_EnqueueTPUEmbeddingSparseTensorBatch_" data-uid="TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseTensorBatch*"></a>
  <h4 id="TensorFlow_TFGraph_EnqueueTPUEmbeddingSparseTensorBatch_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput_System_Int64___System_Nullable_System_Int64__System_String___System_String_" data-uid="TensorFlow.TFGraph.EnqueueTPUEmbeddingSparseTensorBatch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.Int64[],System.Nullable{System.Int64},System.String[],System.String)">EnqueueTPUEmbeddingSparseTensorBatch(TFOutput[], TFOutput[], TFOutput[], TFOutput, Int64[], Nullable&lt;Int64&gt;, String[], String)</h4>
  <div class="markdown level1 summary"><p>This Op eases the porting of code that uses tf.nn.embedding_lookup_sparse().</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation EnqueueTPUEmbeddingSparseTensorBatch (TensorFlow.TFOutput[] sample_indices, TensorFlow.TFOutput[] embedding_indices, TensorFlow.TFOutput[] aggregation_weights, TensorFlow.TFOutput mode_override, long[] table_ids, Nullable&lt;long&gt; device_ordinal = null, string[] combiners = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">sample_indices</span></td>
        <td><p>A list of rank 1 Tensors specifying the training example to
              which the corresponding embedding_indices and aggregation_weights values
              belong. It corresponds to sp_ids.indices[:,0] in  embedding_lookup_sparse().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">embedding_indices</span></td>
        <td><p>A list of rank 1 Tensors, indices into the embedding tables.
              It corresponds to sp_ids.values in embedding_lookup_sparse().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">aggregation_weights</span></td>
        <td><p>A list of rank 1 Tensors containing per training example
              aggregation weights. It corresponds to sp_weights.values in
              embedding_lookup_sparse().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mode_override</span></td>
        <td><p>A string input that overrides the mode specified in the
              TPUEmbeddingConfiguration. Supported values are {&#39;unspecified&#39;, &#39;inference&#39;,
              &#39;training&#39;, &#39;backward_pass_only&#39;}. When set to &#39;unspecified&#39;, the mode set
              in TPUEmbeddingConfiguration is used, otherwise mode_override is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">table_ids</span></td>
        <td><p>A list of integers specifying the identifier of the embedding table
              (offset of TableDescriptor in the TPUEmbeddingConfiguration) to lookup the
              corresponding input. The ith input is looked up using table_ids[i]. The size
              of the table_ids list must be equal to that of sample_indices,
              embedding_indices and aggregation_weights.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">device_ordinal</span></td>
        <td><p>Optional argument
              The TPU device to use. Should be &gt;= 0 and less than the number
              of TPU cores in the task on which the node is placed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">combiners</span></td>
        <td><p>Optional argument
              A list of string scalars, one for each embedding table that specify
              how to normalize the embedding activations after weighted summation.
              Supported combiners are &#39;mean&#39;, &#39;sum&#39;, or &#39;sqrtn&#39;. It is invalid to have
              the sum of the weights be 0 for &#39;mean&#39; or the sum of the squared weights be
              0 for &#39;sqrtn&#39;. If combiners isn&#39;t passed, the default is to use &#39;sum&#39; for
              all tables.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;EnqueueTPUEmbeddingSparseTensorBatch&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_EnqueueTPUEmbeddingSparseTensorBatch_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput_System_Int64___System_Nullable_System_Int64__System_String___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>sample_indices[i], embedding_indices[i] and aggregation_weights[i] correspond
              to the ith feature. table_ids[i] indicates which embedding table to look up ith
              feature.</p>
<pre><code>          The tensors at corresponding positions in the three input lists (sample_indices,
          embedding_indices and aggregation_weights) must have the same shape, i.e. rank 1
          with dim_size() equal to the total number of lookups into the table described by
          the corresponding feature.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_EnsureShape_" data-uid="TensorFlow.TFGraph.EnsureShape*"></a>
  <h4 id="TensorFlow_TFGraph_EnsureShape_TensorFlow_TFOutput_TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.EnsureShape(TensorFlow.TFOutput,TensorFlow.TFShape,System.String)">EnsureShape(TFOutput, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>Ensures that the tensor&#39;s shape matches the expected shape.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput EnsureShape (TensorFlow.TFOutput input, TensorFlow.TFShape shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A tensor, whose shape is to be validated.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The expected (possibly partially specified) shape of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;EnsureShape&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor with the same shape and contents as the input tensor or value.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_EnsureShape_TensorFlow_TFOutput_TensorFlow_TFShape_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Raises an error if the input tensor&#39;s shape does not match the specified shape.
              Returns the input tensor otherwise.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Enter_" data-uid="TensorFlow.TFGraph.Enter*"></a>
  <h4 id="TensorFlow_TFGraph_Enter_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.Enter(TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)">Enter(TFOutput, String, Nullable&lt;Boolean&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Creates or finds a child frame, and makes <code>data</code> available to the child frame.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Enter (TensorFlow.TFOutput data, string frame_name, Nullable&lt;bool&gt; is_constant = null, Nullable&lt;long&gt; parallel_iterations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>The tensor to be made available to the child frame.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">frame_name</span></td>
        <td><p>The name of the child frame.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">is_constant</span></td>
        <td><p>Optional argument
              If true, the output is constant within the child frame.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">parallel_iterations</span></td>
        <td><p>Optional argument
              The number of iterations allowed to run in parallel.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Enter&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The same tensor as <code>data</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Enter_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op is used together with <code>Exit</code> to create loops in the graph.
              The unique <code>frame_name</code> is used by the <code>Executor</code> to identify frames. If
              <code>is_constant</code> is true, <code>output</code> is a constant in the child frame; otherwise
              it may be changed in the child frame. At most <code>parallel_iterations</code> iterations
              are run in parallel in the child frame.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Equal_" data-uid="TensorFlow.TFGraph.Equal*"></a>
  <h4 id="TensorFlow_TFGraph_Equal_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Equal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Equal(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the truth value of (x == y) element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Equal (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Equal&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Equal_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>Equal</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Erf_" data-uid="TensorFlow.TFGraph.Erf*"></a>
  <h4 id="TensorFlow_TFGraph_Erf_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Erf(TensorFlow.TFOutput,System.String)">Erf(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the Gauss error function of <code>x</code> element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Erf (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Erf&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Erfc_" data-uid="TensorFlow.TFGraph.Erfc*"></a>
  <h4 id="TensorFlow_TFGraph_Erfc_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Erfc(TensorFlow.TFOutput,System.String)">Erfc(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the complementary error function of <code>x</code> element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Erfc (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Erfc&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Exit_" data-uid="TensorFlow.TFGraph.Exit*"></a>
  <h4 id="TensorFlow_TFGraph_Exit_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Exit(TensorFlow.TFOutput,System.String)">Exit(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Exits the current frame to its parent frame.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Exit (TensorFlow.TFOutput data, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>The tensor to be made available to the parent frame.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Exit&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The same tensor as <code>data</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Exit_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Exit makes its input <code>data</code> available to the parent frame.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Exp_" data-uid="TensorFlow.TFGraph.Exp*"></a>
  <h4 id="TensorFlow_TFGraph_Exp_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Exp(TensorFlow.TFOutput,System.String)">Exp(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes exponential of x element-wise.  \(y = e^x\).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Exp (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Exp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ExpandDims_" data-uid="TensorFlow.TFGraph.ExpandDims*"></a>
  <h4 id="TensorFlow_TFGraph_ExpandDims_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ExpandDims(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ExpandDims(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Inserts a dimension of 1 into a tensor&#39;s shape.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ExpandDims (TensorFlow.TFOutput input, TensorFlow.TFOutput dim, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dim</span></td>
        <td><p>0-D (scalar). Specifies the dimension index at which to
              expand the shape of <code>input</code>. Must be in the range
              <code>[-rank(input) - 1, rank(input)]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ExpandDims&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Contains the same data as <code>input</code>, but its shape has an additional
              dimension of size 1 added.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ExpandDims_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a tensor <code>input</code>, this operation inserts a dimension of 1 at the
              dimension index <code>axis</code> of <code>input</code>&#39;s shape. The dimension index <code>axis</code> starts at
              zero; if you specify a negative number for <code>axis</code> it is counted backward from
              the end.</p>
<pre><code>          This operation is useful if you want to add a batch dimension to a single
          element. For example, if you have a single image of shape &lt;code&gt;[height, width,
          channels]&lt;/code&gt;, you can make it a batch of 1 image with &lt;code&gt;expand_dims(image, 0)&lt;/code&gt;,
          which will make the shape &lt;code&gt;[1, height, width, channels]&lt;/code&gt;.

          Other examples:

           &lt;pre&gt;&lt;code&gt;
          # &#39;t&#39; is a tensor of shape [2]
          shape(expand_dims(t, 0)) ==&amp;gt; [1, 2]
          shape(expand_dims(t, 1)) ==&amp;gt; [2, 1]
          shape(expand_dims(t, -1)) ==&amp;gt; [2, 1]

          # &#39;t2&#39; is a tensor of shape [2, 3, 5]
          shape(expand_dims(t2, 0)) ==&amp;gt; [1, 2, 3, 5]
          shape(expand_dims(t2, 2)) ==&amp;gt; [2, 3, 1, 5]
          shape(expand_dims(t2, 3)) ==&amp;gt; [2, 3, 5, 1]
           &lt;/code&gt;&lt;/pre&gt;

          This operation requires that:

          &lt;code&gt;-1-input.dims() &amp;lt;= dim &amp;lt;= input.dims()&lt;/code&gt;

          This operation is related to &lt;code&gt;squeeze()&lt;/code&gt;, which removes dimensions of
          size 1.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ExperimentalDirectedInterleaveDataset_" data-uid="TensorFlow.TFGraph.ExperimentalDirectedInterleaveDataset*"></a>
  <h4 id="TensorFlow_TFGraph_ExperimentalDirectedInterleaveDataset_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.ExperimentalDirectedInterleaveDataset(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">ExperimentalDirectedInterleaveDataset(TFOutput, TFOutput[], TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>A substitute for <code>InterleaveDataset</code> on a fixed list of <code>N</code> datasets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ExperimentalDirectedInterleaveDataset (TensorFlow.TFOutput selector_input_dataset, TensorFlow.TFOutput[] data_input_datasets, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">selector_input_dataset</span></td>
        <td><p>A dataset of scalar <code>DT_INT64</code> elements that determines which of the
              <code>N</code> data inputs should produce the next output element.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">data_input_datasets</span></td>
        <td><p><code>N</code> datasets with the same type that will be interleaved according to
              the values of <code>selector_input_dataset</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ExperimentalDirectedInterleaveDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ExperimentalIgnoreErrorsDataset_" data-uid="TensorFlow.TFGraph.ExperimentalIgnoreErrorsDataset*"></a>
  <h4 id="TensorFlow_TFGraph_ExperimentalIgnoreErrorsDataset_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.ExperimentalIgnoreErrorsDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">ExperimentalIgnoreErrorsDataset(TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that contains the elements of <code>input_dataset</code> ignoring errors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ExperimentalIgnoreErrorsDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ExperimentalIgnoreErrorsDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ExperimentalIteratorGetDevice_" data-uid="TensorFlow.TFGraph.ExperimentalIteratorGetDevice*"></a>
  <h4 id="TensorFlow_TFGraph_ExperimentalIteratorGetDevice_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ExperimentalIteratorGetDevice(TensorFlow.TFOutput,System.String)">ExperimentalIteratorGetDevice(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the name of the device on which <code>resource</code> has been placed.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ExperimentalIteratorGetDevice (TensorFlow.TFOutput resource, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ExperimentalIteratorGetDevice&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ExperimentalThreadPoolDataset_" data-uid="TensorFlow.TFGraph.ExperimentalThreadPoolDataset*"></a>
  <h4 id="TensorFlow_TFGraph_ExperimentalThreadPoolDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.ExperimentalThreadPoolDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">ExperimentalThreadPoolDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that uses a custom thread pool to compute <code>input_dataset</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ExperimentalThreadPoolDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput thread_pool, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">thread_pool</span></td>
        <td><p>A resource produced by the ThreadPoolHandle op.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ExperimentalThreadPoolDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ExperimentalThreadPoolHandle_" data-uid="TensorFlow.TFGraph.ExperimentalThreadPoolHandle*"></a>
  <h4 id="TensorFlow_TFGraph_ExperimentalThreadPoolHandle_System_Int64_System_String_System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.ExperimentalThreadPoolHandle(System.Int64,System.String,System.Nullable{System.Int64},System.String,System.String,System.String)">ExperimentalThreadPoolHandle(Int64, String, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that uses a custom thread pool to compute <code>input_dataset</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ExperimentalThreadPoolHandle (long num_threads, string display_name, Nullable&lt;long&gt; max_intra_op_parallelism = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_threads</span></td>
        <td><p>The number of threads in the thread pool.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">display_name</span></td>
        <td><p>A human-readable name for the threads that may be visible in some
              visualizations.
              threadpool.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">max_intra_op_parallelism</span></td>
        <td><p>Optional argument
              The maximum degree of parallelism to use within operations that execute on this
              threadpool.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ExperimentalThreadPoolHandle&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A resource that can be consumed by one or more ExperimentalThreadPoolDataset
              ops.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ExperimentalUniqueDataset_" data-uid="TensorFlow.TFGraph.ExperimentalUniqueDataset*"></a>
  <h4 id="TensorFlow_TFGraph_ExperimentalUniqueDataset_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.ExperimentalUniqueDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">ExperimentalUniqueDataset(TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that contains the unique elements of <code>input_dataset</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ExperimentalUniqueDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ExperimentalUniqueDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Expm1_" data-uid="TensorFlow.TFGraph.Expm1*"></a>
  <h4 id="TensorFlow_TFGraph_Expm1_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Expm1(TensorFlow.TFOutput,System.String)">Expm1(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes exponential of x - 1 element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Expm1 (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Expm1&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Expm1_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>I.e., \(y = (\exp x) - 1\).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ExtractGlimpse_" data-uid="TensorFlow.TFGraph.ExtractGlimpse*"></a>
  <h4 id="TensorFlow_TFGraph_ExtractGlimpse_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ExtractGlimpse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">ExtractGlimpse(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Extracts a glimpse from the input tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ExtractGlimpse (TensorFlow.TFOutput input, TensorFlow.TFOutput size, TensorFlow.TFOutput offsets, Nullable&lt;bool&gt; centered = null, Nullable&lt;bool&gt; normalized = null, Nullable&lt;bool&gt; uniform_noise = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A 4-D float tensor of shape <code>[batch_size, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>A 1-D tensor of 2 elements containing the size of the glimpses
              to extract.  The glimpse height must be specified first, following
              by the glimpse width.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">offsets</span></td>
        <td><p>A 2-D integer tensor of shape <code>[batch_size, 2]</code> containing
              the y, x locations of the center of each window.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">centered</span></td>
        <td><p>Optional argument
              indicates if the offset coordinates are centered relative to
              the image, in which case the (0, 0) offset is relative to the center
              of the input images. If false, the (0,0) offset corresponds to the
              upper left corner of the input images.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">normalized</span></td>
        <td><p>Optional argument
              indicates if the offset coordinates are normalized.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">uniform_noise</span></td>
        <td><p>Optional argument
              indicates if the noise should be generated using a
              uniform distribution or a Gaussian distribution.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ExtractGlimpse&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor representing the glimpses <code>[batch_size,
              glimpse_height, glimpse_width, channels]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ExtractGlimpse_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Returns a set of windows called glimpses extracted at location
              <code>offsets</code> from the input tensor. If the windows only partially
              overlaps the inputs, the non overlapping areas will be filled with
              random noise.</p>
<pre><code>          The result is a 4-D tensor of shape &lt;code&gt;[batch_size, glimpse_height,
          glimpse_width, channels]&lt;/code&gt;. The channels and batch dimensions are the
          same as that of the input tensor. The height and width of the output
          windows are specified in the &lt;code&gt;size&lt;/code&gt; parameter.

          The argument &lt;code&gt;normalized&lt;/code&gt; and &lt;code&gt;centered&lt;/code&gt; controls how the windows are built:

          * If the coordinates are normalized but not centered, 0.0 and 1.0
          correspond to the minimum and maximum of each height and width
          dimension.
          * If the coordinates are both normalized and centered, they range from
          -1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to the upper
          left corner, the lower right corner is located at (1.0, 1.0) and the
          center is at (0, 0).
          * If the coordinates are not normalized they are interpreted as
          numbers of pixels.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ExtractImagePatches_" data-uid="TensorFlow.TFGraph.ExtractImagePatches*"></a>
  <h4 id="TensorFlow_TFGraph_ExtractImagePatches_TensorFlow_TFOutput_System_Int64___System_Int64___System_Int64___System_String_System_String_" data-uid="TensorFlow.TFGraph.ExtractImagePatches(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.Int64[],System.String,System.String)">ExtractImagePatches(TFOutput, Int64[], Int64[], Int64[], String, String)</h4>
  <div class="markdown level1 summary"><p>Extract <code>patches</code> from <code>images</code> and put them in the &quot;depth&quot; output dimension.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ExtractImagePatches (TensorFlow.TFOutput images, long[] ksizes, long[] strides, long[] rates, string padding, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">images</span></td>
        <td><p>4-D Tensor with shape <code>[batch, in_rows, in_cols, depth]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksizes</span></td>
        <td><p>The size of the sliding window for each dimension of <code>images</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D of length 4. How far the centers of two consecutive patches are in
              the images. Must be: <code>[1, stride_rows, stride_cols, 1]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">rates</span></td>
        <td><p>1-D of length 4. Must be: <code>[1, rate_rows, rate_cols, 1]</code>. This is the
              input stride, specifying how far two consecutive patch samples are in the
              input. Equivalent to extracting patches with
              <code>patch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1)</code>, followed by
              subsampling them spatially by a factor of <code>rates</code>. This is equivalent to
              <code>rate</code> in dilated (a.k.a. Atrous) convolutions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
<pre><code>          We specify the size-related attributes as:

           &lt;pre&gt;&lt;code&gt;
          ksizes = [1, ksize_rows, ksize_cols, 1]
          strides = [1, strides_rows, strides_cols, 1]
          rates = [1, rates_rows, rates_cols, 1]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ExtractImagePatches&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D Tensor with shape <code>[batch, out_rows, out_cols, ksize_rows *
              ksize_cols * depth]</code> containing image patches with size
              <code>ksize_rows x ksize_cols x depth</code> vectorized in the &quot;depth&quot; dimension. Note
              <code>out_rows</code> and <code>out_cols</code> are the dimensions of the output patches.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ExtractJpegShape_" data-uid="TensorFlow.TFGraph.ExtractJpegShape*"></a>
  <h4 id="TensorFlow_TFGraph_ExtractJpegShape_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.ExtractJpegShape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">ExtractJpegShape(TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Extract the shape information of a JPEG-encoded image.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ExtractJpegShape (TensorFlow.TFOutput contents, Nullable&lt;TensorFlow.TFDataType&gt; output_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">contents</span></td>
        <td><p>0-D. The JPEG-encoded image.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">output_type</span></td>
        <td><p>Optional argument
              (Optional) The output type of the operation (int32 or int64).
              Defaults to int32.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ExtractJpegShape&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>1-D. The image shape with format [height, width, channels].
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ExtractJpegShape_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op only parses the image header, so it is much faster than DecodeJpeg.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ExtractVolumePatches_" data-uid="TensorFlow.TFGraph.ExtractVolumePatches*"></a>
  <h4 id="TensorFlow_TFGraph_ExtractVolumePatches_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_" data-uid="TensorFlow.TFGraph.ExtractVolumePatches(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">ExtractVolumePatches(TFOutput, Int64[], Int64[], String, String)</h4>
  <div class="markdown level1 summary"><p>Extract <code>patches</code> from <code>input</code> and put them in the &quot;depth&quot; output dimension. 3D extension of <code>extract_image_patches</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ExtractVolumePatches (TensorFlow.TFOutput input, long[] ksizes, long[] strides, string padding, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>5-D Tensor with shape <code>[batch, in_planes, in_rows, in_cols, depth]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksizes</span></td>
        <td><p>The size of the sliding window for each dimension of <code>input</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D of length 5. How far the centers of two consecutive patches are in
              <code>input</code>. Must be: <code>[1, stride_planes, stride_rows, stride_cols, 1]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
<pre><code>          We specify the size-related attributes as:

           &lt;pre&gt;&lt;code&gt;
          ksizes = [1, ksize_planes, ksize_rows, ksize_cols, 1]
          strides = [1, stride_planes, strides_rows, strides_cols, 1]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ExtractVolumePatches&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>5-D Tensor with shape <code>[batch, out_planes, out_rows, out_cols,
              ksize_planes * ksize_rows * ksize_cols * depth]</code> containing patches
              with size <code>ksize_planes x ksize_rows x ksize_cols x depth</code> vectorized
              in the &quot;depth&quot; dimension. Note <code>out_planes</code>, <code>out_rows</code> and <code>out_cols</code>
              are the dimensions of the output patches.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Fact_" data-uid="TensorFlow.TFGraph.Fact*"></a>
  <h4 id="TensorFlow_TFGraph_Fact_System_String_" data-uid="TensorFlow.TFGraph.Fact(System.String)">Fact(String)</h4>
  <div class="markdown level1 summary"><p>Output a fact about factorials.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Fact (string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Fact&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_FakeParam_" data-uid="TensorFlow.TFGraph.FakeParam*"></a>
  <h4 id="TensorFlow_TFGraph_FakeParam_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.FakeParam(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">FakeParam(TFDataType, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>This op is used as a placeholder in If branch functions. It doesn&#39;t provide a
              valid output when run, so must either be removed (e.g. replaced with a
              function input) or guaranteed not to be used (e.g. if mirroring an
              intermediate output needed for the gradient computation of the other branch).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FakeParam (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of the output.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The purported shape of the output. This is only used for shape inference;
              the output will not necessarily have this shape. Can be a partial shape.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FakeParam&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>\&quot;Fake\&quot; output value. This should not be consumed by another op.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_FakeQuantWithMinMaxArgs_" data-uid="TensorFlow.TFGraph.FakeQuantWithMinMaxArgs*"></a>
  <h4 id="TensorFlow_TFGraph_FakeQuantWithMinMaxArgs_TensorFlow_TFOutput_System_Nullable_System_Single__System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.FakeQuantWithMinMaxArgs(TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">FakeQuantWithMinMaxArgs(TFOutput, Nullable&lt;Single&gt;, Nullable&lt;Single&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Fake-quantize the &#39;inputs&#39; tensor, type float to &#39;outputs&#39; tensor of same type.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FakeQuantWithMinMaxArgs (TensorFlow.TFOutput inputs, Nullable&lt;float&gt; min = null, Nullable&lt;float&gt; max = null, Nullable&lt;long&gt; num_bits = null, Nullable&lt;bool&gt; narrow_range = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">inputs</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">min</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">max</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">num_bits</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">narrow_range</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FakeQuantWithMinMaxArgs&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FakeQuantWithMinMaxArgs_TensorFlow_TFOutput_System_Nullable_System_Single__System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Attributes <code>[min; max]</code> define the clamping range for the <code>inputs</code> data.
              <code>inputs</code> values are quantized into the quantization range (<code>[0; 2^num_bits - 1]</code>
              when <code>narrow_range</code> is false and <code>[1; 2^num_bits - 1]</code> when it is true) and
              then de-quantized and output as floats in <code>[min; max]</code> interval.
              <code>num_bits</code> is the bitwidth of the quantization; between 2 and 16, inclusive.</p>
<pre><code>          Quantization is called fake since the output is still in floating point.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_FakeQuantWithMinMaxArgsGradient_" data-uid="TensorFlow.TFGraph.FakeQuantWithMinMaxArgsGradient*"></a>
  <h4 id="TensorFlow_TFGraph_FakeQuantWithMinMaxArgsGradient_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.FakeQuantWithMinMaxArgsGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">FakeQuantWithMinMaxArgsGradient(TFOutput, TFOutput, Nullable&lt;Single&gt;, Nullable&lt;Single&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Compute gradients for a FakeQuantWithMinMaxArgs operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FakeQuantWithMinMaxArgsGradient (TensorFlow.TFOutput gradients, TensorFlow.TFOutput inputs, Nullable&lt;float&gt; min = null, Nullable&lt;float&gt; max = null, Nullable&lt;long&gt; num_bits = null, Nullable&lt;bool&gt; narrow_range = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradients</span></td>
        <td><p>Backpropagated gradients above the FakeQuantWithMinMaxArgs operation.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">inputs</span></td>
        <td><p>Values passed as inputs to the FakeQuantWithMinMaxArgs operation.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">min</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">max</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">num_bits</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">narrow_range</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FakeQuantWithMinMaxArgsGradient&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Backpropagated gradients below the FakeQuantWithMinMaxArgs operation:
              <code>gradients * (inputs &gt;= min &amp;&amp; inputs &lt;= max)</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_FakeQuantWithMinMaxVars_" data-uid="TensorFlow.TFGraph.FakeQuantWithMinMaxVars*"></a>
  <h4 id="TensorFlow_TFGraph_FakeQuantWithMinMaxVars_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.FakeQuantWithMinMaxVars(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">FakeQuantWithMinMaxVars(TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Fake-quantize the &#39;inputs&#39; tensor of type float via global float scalars <code>min</code></p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FakeQuantWithMinMaxVars (TensorFlow.TFOutput inputs, TensorFlow.TFOutput min, TensorFlow.TFOutput max, Nullable&lt;long&gt; num_bits = null, Nullable&lt;bool&gt; narrow_range = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">inputs</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">num_bits</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">narrow_range</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FakeQuantWithMinMaxVars&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FakeQuantWithMinMaxVars_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>and <code>max</code> to &#39;outputs&#39; tensor of same shape as <code>inputs</code>.</p>
<pre><code>          &lt;code&gt;[min; max]&lt;/code&gt; define the clamping range for the &lt;code&gt;inputs&lt;/code&gt; data.
          &lt;code&gt;inputs&lt;/code&gt; values are quantized into the quantization range (&lt;code&gt;[0; 2^num_bits - 1]&lt;/code&gt;
          when &lt;code&gt;narrow_range&lt;/code&gt; is false and &lt;code&gt;[1; 2^num_bits - 1]&lt;/code&gt; when it is true) and
          then de-quantized and output as floats in &lt;code&gt;[min; max]&lt;/code&gt; interval.
          &lt;code&gt;num_bits&lt;/code&gt; is the bitwidth of the quantization; between 2 and 16, inclusive.

          This operation has a gradient and thus allows for training &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;
          values.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_FakeQuantWithMinMaxVarsGradient_" data-uid="TensorFlow.TFGraph.FakeQuantWithMinMaxVarsGradient*"></a>
  <h4 id="TensorFlow_TFGraph_FakeQuantWithMinMaxVarsGradient_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.FakeQuantWithMinMaxVarsGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">FakeQuantWithMinMaxVarsGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Compute gradients for a FakeQuantWithMinMaxVars operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; FakeQuantWithMinMaxVarsGradient (TensorFlow.TFOutput gradients, TensorFlow.TFOutput inputs, TensorFlow.TFOutput min, TensorFlow.TFOutput max, Nullable&lt;long&gt; num_bits = null, Nullable&lt;bool&gt; narrow_range = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradients</span></td>
        <td><p>Backpropagated gradients above the FakeQuantWithMinMaxVars operation.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">inputs</span></td>
        <td><p>Values passed as inputs to the FakeQuantWithMinMaxVars operation.
              min, max: Quantization interval, scalar floats.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">num_bits</span></td>
        <td><p>Optional argument
              The bitwidth of the quantization; between 2 and 8, inclusive.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">narrow_range</span></td>
        <td><p>Optional argument
              Whether to quantize into 2^num_bits - 1 distinct values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FakeQuantWithMinMaxVarsGradient&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              backprops_wrt_input: Backpropagated gradients w.r.t. inputs:
              <code>gradients * (inputs &gt;= min &amp;&amp; inputs &lt;= max)</code>.
              backprop_wrt_min: Backpropagated gradients w.r.t. min parameter:
              <code>sum(gradients * (inputs &lt; min))</code>.
              backprop_wrt_max: Backpropagated gradients w.r.t. max parameter:
              <code>sum(gradients * (inputs &gt; max))</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_FakeQuantWithMinMaxVarsPerChannel_" data-uid="TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannel*"></a>
  <h4 id="TensorFlow_TFGraph_FakeQuantWithMinMaxVarsPerChannel_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannel(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">FakeQuantWithMinMaxVarsPerChannel(TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Fake-quantize the &#39;inputs&#39; tensor of type float and one of the shapes: <code>[d]</code>,</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FakeQuantWithMinMaxVarsPerChannel (TensorFlow.TFOutput inputs, TensorFlow.TFOutput min, TensorFlow.TFOutput max, Nullable&lt;long&gt; num_bits = null, Nullable&lt;bool&gt; narrow_range = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">inputs</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">num_bits</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">narrow_range</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FakeQuantWithMinMaxVarsPerChannel&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FakeQuantWithMinMaxVarsPerChannel_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>[b, d]</code>
    <code>[b, h, w, d]</code> via per-channel floats <code>min</code> and <code>max</code> of shape <code>[d]</code>
              to &#39;outputs&#39; tensor of same shape as <code>inputs</code>.</p>
<pre><code>          &lt;code&gt;[min; max]&lt;/code&gt; define the clamping range for the &lt;code&gt;inputs&lt;/code&gt; data.
          &lt;code&gt;inputs&lt;/code&gt; values are quantized into the quantization range (&lt;code&gt;[0; 2^num_bits - 1]&lt;/code&gt;
          when &lt;code&gt;narrow_range&lt;/code&gt; is false and &lt;code&gt;[1; 2^num_bits - 1]&lt;/code&gt; when it is true) and
          then de-quantized and output as floats in &lt;code&gt;[min; max]&lt;/code&gt; interval.
          &lt;code&gt;num_bits&lt;/code&gt; is the bitwidth of the quantization; between 2 and 16, inclusive.

          This operation has a gradient and thus allows for training &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;
          values.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_FakeQuantWithMinMaxVarsPerChannelGradient_" data-uid="TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient*"></a>
  <h4 id="TensorFlow_TFGraph_FakeQuantWithMinMaxVarsPerChannelGradient_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.FakeQuantWithMinMaxVarsPerChannelGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">FakeQuantWithMinMaxVarsPerChannelGradient(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Compute gradients for a FakeQuantWithMinMaxVarsPerChannel operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; FakeQuantWithMinMaxVarsPerChannelGradient (TensorFlow.TFOutput gradients, TensorFlow.TFOutput inputs, TensorFlow.TFOutput min, TensorFlow.TFOutput max, Nullable&lt;long&gt; num_bits = null, Nullable&lt;bool&gt; narrow_range = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradients</span></td>
        <td><p>Backpropagated gradients above the FakeQuantWithMinMaxVars operation,
              shape one of: <code>[d]</code>, <code>[b, d]</code>,  <code>[b, h, w, d]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">inputs</span></td>
        <td><p>Values passed as inputs to the FakeQuantWithMinMaxVars operation, shape
              same as <code>gradients</code>.
              min, max: Quantization interval, floats of shape <code>[d]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">num_bits</span></td>
        <td><p>Optional argument
              The bitwidth of the quantization; between 2 and 16, inclusive.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">narrow_range</span></td>
        <td><p>Optional argument
              Whether to quantize into 2^num_bits - 1 distinct values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FakeQuantWithMinMaxVarsPerChannelGradient&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              backprops_wrt_input: Backpropagated gradients w.r.t. inputs, shape same as
              <code>inputs</code>:
              <code>gradients * (inputs &gt;= min &amp;&amp; inputs &lt;= max)</code>.
              backprop_wrt_min: Backpropagated gradients w.r.t. min parameter, shape <code>[d]</code>:
              <code>sum_per_d(gradients * (inputs &lt; min))</code>.
              backprop_wrt_max: Backpropagated gradients w.r.t. max parameter, shape <code>[d]</code>:
              <code>sum_per_d(gradients * (inputs &gt; max))</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_FakeQueue_" data-uid="TensorFlow.TFGraph.FakeQueue*"></a>
  <h4 id="TensorFlow_TFGraph_FakeQueue_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.FakeQueue(TensorFlow.TFOutput,System.String)">FakeQueue(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated. Do not use.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FakeQueue (TensorFlow.TFOutput resource, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FakeQueue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_FFT_" data-uid="TensorFlow.TFGraph.FFT*"></a>
  <h4 id="TensorFlow_TFGraph_FFT_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.FFT(TensorFlow.TFOutput,System.String)">FFT(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Fast Fourier transform.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FFT (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A complex tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FFT&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A complex tensor of the same shape as <code>input</code>. The inner-most
              dimension of <code>input</code> is replaced with its 1D Fourier transform.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.fft.fft
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FFT_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the 1-dimensional discrete Fourier transform over the inner-most
              dimension of <code>input</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_FFT2D_" data-uid="TensorFlow.TFGraph.FFT2D*"></a>
  <h4 id="TensorFlow_TFGraph_FFT2D_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.FFT2D(TensorFlow.TFOutput,System.String)">FFT2D(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>2D fast Fourier transform.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FFT2D (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A complex tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FFT2D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A complex tensor of the same shape as <code>input</code>. The inner-most 2
              dimensions of <code>input</code> are replaced with their 2D Fourier transform.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.fft.fft2
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FFT2D_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the 2-dimensional discrete Fourier transform over the inner-most
              2 dimensions of <code>input</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_FFT3D_" data-uid="TensorFlow.TFGraph.FFT3D*"></a>
  <h4 id="TensorFlow_TFGraph_FFT3D_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.FFT3D(TensorFlow.TFOutput,System.String)">FFT3D(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>3D fast Fourier transform.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FFT3D (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A complex64 tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FFT3D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A complex64 tensor of the same shape as <code>input</code>. The inner-most 3
              dimensions of <code>input</code> are replaced with their 3D Fourier transform.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.fft.fftn with 3 dimensions.
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FFT3D_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the 3-dimensional discrete Fourier transform over the inner-most 3
              dimensions of <code>input</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_FIFOQueue_" data-uid="TensorFlow.TFGraph.FIFOQueue*"></a>
  <h4 id="TensorFlow_TFGraph_FIFOQueue_TensorFlow_TFDataType___TensorFlow_TFShape___System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.FIFOQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)">FIFOQueue(TFDataType[], TFShape[], Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A queue that produces elements in first-in first-out order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FIFOQueue (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable&lt;long&gt; capacity = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a value.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>Optional argument
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types. If the length of
              this attr is 0, the shapes of queue elements are not constrained, and
              only one element may be dequeued at a time.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FIFOQueue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_FIFOQueueV2_" data-uid="TensorFlow.TFGraph.FIFOQueueV2*"></a>
  <h4 id="TensorFlow_TFGraph_FIFOQueueV2_TensorFlow_TFDataType___TensorFlow_TFShape___System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.FIFOQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)">FIFOQueueV2(TFDataType[], TFShape[], Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A queue that produces elements in first-in first-out order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FIFOQueueV2 (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable&lt;long&gt; capacity = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a value.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>Optional argument
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types. If the length of
              this attr is 0, the shapes of queue elements are not constrained, and
              only one element may be dequeued at a time.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FIFOQueueV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Fill_" data-uid="TensorFlow.TFGraph.Fill*"></a>
  <h4 id="TensorFlow_TFGraph_Fill_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Fill(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Fill(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Creates a tensor filled with a scalar value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Fill (TensorFlow.TFOutput dims, TensorFlow.TFOutput value, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dims</span></td>
        <td><p>1-D. Represents the shape of the output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>0-D (scalar). Value to fill the returned tensor.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.full
          @end_compatibility
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Fill&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Fill_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation creates a tensor of shape <code>dims</code> and fills it with <code>value</code>.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          # Output tensor has shape [2, 3].
          fill([2, 3], 9) ==&amp;gt; [[9, 9, 9]
          [9, 9, 9]]
           &lt;/code&gt;&lt;/pre&gt;&lt;code&gt;tf.fill&lt;/code&gt; differs from &lt;code&gt;tf.constant&lt;/code&gt; in a few ways:

          *   &lt;code&gt;tf.fill&lt;/code&gt; only supports scalar contents, whereas &lt;code&gt;tf.constant&lt;/code&gt; supports
          Tensor values.
          *   &lt;code&gt;tf.fill&lt;/code&gt; creates an Op in the computation graph that constructs the actual
          Tensor value at runtime. This is in contrast to &lt;code&gt;tf.constant&lt;/code&gt; which embeds
          the entire Tensor into the graph with a &lt;code&gt;Const&lt;/code&gt; node.
          *   Because &lt;code&gt;tf.fill&lt;/code&gt; evaluates at graph runtime, it supports dynamic shapes
          based on other runtime Tensors, unlike &lt;code&gt;tf.constant&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_FilterByLastComponentDataset_" data-uid="TensorFlow.TFGraph.FilterByLastComponentDataset*"></a>
  <h4 id="TensorFlow_TFGraph_FilterByLastComponentDataset_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.FilterByLastComponentDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">FilterByLastComponentDataset(TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset containing elements of first component of <code>input_dataset</code> having true in the last component.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FilterByLastComponentDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FilterByLastComponentDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_FixedLengthRecordDataset_" data-uid="TensorFlow.TFGraph.FixedLengthRecordDataset*"></a>
  <h4 id="TensorFlow_TFGraph_FixedLengthRecordDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.FixedLengthRecordDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">FixedLengthRecordDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that emits the records from one or more binary files.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FixedLengthRecordDataset (TensorFlow.TFOutput filenames, TensorFlow.TFOutput header_bytes, TensorFlow.TFOutput record_bytes, TensorFlow.TFOutput footer_bytes, TensorFlow.TFOutput buffer_size, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filenames</span></td>
        <td><p>A scalar or a vector containing the name(s) of the file(s) to be
              read.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">header_bytes</span></td>
        <td><p>A scalar representing the number of bytes to skip at the
              beginning of a file.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">record_bytes</span></td>
        <td><p>A scalar representing the number of bytes in each record.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">footer_bytes</span></td>
        <td><p>A scalar representing the number of bytes to skip at the end
              of a file.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">buffer_size</span></td>
        <td><p>A scalar representing the number of bytes to buffer. Must be &gt; 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FixedLengthRecordDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_FixedLengthRecordReader_" data-uid="TensorFlow.TFGraph.FixedLengthRecordReader*"></a>
  <h4 id="TensorFlow_TFGraph_FixedLengthRecordReader_System_Int64_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.FixedLengthRecordReader(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">FixedLengthRecordReader(Int64, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A Reader that outputs fixed-length records from a file.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FixedLengthRecordReader (long record_bytes, Nullable&lt;long&gt; header_bytes = null, Nullable&lt;long&gt; footer_bytes = null, Nullable&lt;long&gt; hop_bytes = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">record_bytes</span></td>
        <td><p>Number of bytes in the record.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">header_bytes</span></td>
        <td><p>Optional argument
              Number of bytes in the header, defaults to 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">footer_bytes</span></td>
        <td><p>Optional argument
              Number of bytes in the footer, defaults to 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">hop_bytes</span></td>
        <td><p>Optional argument
              Number of bytes to hop before each read. Default of 0 means using
              record_bytes.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FixedLengthRecordReader&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_FixedLengthRecordReaderV2_" data-uid="TensorFlow.TFGraph.FixedLengthRecordReaderV2*"></a>
  <h4 id="TensorFlow_TFGraph_FixedLengthRecordReaderV2_System_Int64_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.FixedLengthRecordReaderV2(System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String,System.String)">FixedLengthRecordReaderV2(Int64, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A Reader that outputs fixed-length records from a file.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FixedLengthRecordReaderV2 (long record_bytes, Nullable&lt;long&gt; header_bytes = null, Nullable&lt;long&gt; footer_bytes = null, Nullable&lt;long&gt; hop_bytes = null, string container = null, string shared_name = null, string encoding = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">record_bytes</span></td>
        <td><p>Number of bytes in the record.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">header_bytes</span></td>
        <td><p>Optional argument
              Number of bytes in the header, defaults to 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">footer_bytes</span></td>
        <td><p>Optional argument
              Number of bytes in the footer, defaults to 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">hop_bytes</span></td>
        <td><p>Optional argument
              Number of bytes to hop before each read. Default of 0 means using
              record_bytes.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">encoding</span></td>
        <td><p>Optional argument
              The type of encoding for the file. Currently ZLIB and GZIP
              are supported. Defaults to none.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FixedLengthRecordReaderV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_FixedUnigramCandidateSampler_" data-uid="TensorFlow.TFGraph.FixedUnigramCandidateSampler*"></a>
  <h4 id="TensorFlow_TFGraph_FixedUnigramCandidateSampler_TensorFlow_TFOutput_System_Int64_System_Int64_System_Boolean_System_Int64_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Single___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.FixedUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.String,System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Single[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">FixedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, String, Nullable&lt;Single&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Single[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Generates labels for candidate sampling with a learned unigram distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; FixedUnigramCandidateSampler (TensorFlow.TFOutput true_classes, long num_true, long num_sampled, bool unique, long range_max, string vocab_file = null, Nullable&lt;float&gt; distortion = null, Nullable&lt;long&gt; num_reserved_ids = null, Nullable&lt;long&gt; num_shards = null, Nullable&lt;long&gt; shard = null, float[] unigrams = null, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">true_classes</span></td>
        <td><p>A batch_size * num_true matrix, in which each row contains the
              IDs of the num_true target_classes in the corresponding original label.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_true</span></td>
        <td><p>Number of true labels per context.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_sampled</span></td>
        <td><p>Number of candidates to randomly sample.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">unique</span></td>
        <td><p>If unique is true, we sample with rejection, so that all sampled
              candidates in a batch are unique. This requires some approximation to
              estimate the post-rejection sampling probabilities.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">range_max</span></td>
        <td><p>The sampler will sample integers from the interval [0, range_max).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">vocab_file</span></td>
        <td><p>Optional argument
              Each valid line in this file (which should have a CSV-like format)
              corresponds to a valid word ID. IDs are in sequential order, starting from
              num_reserved_ids. The last entry in each line is expected to be a value
              corresponding to the count or relative probability. Exactly one of vocab_file
              and unigrams needs to be passed to this op.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">distortion</span></td>
        <td><p>Optional argument
              The distortion is used to skew the unigram probability distribution.
              Each weight is first raised to the distortion&#39;s power before adding to the
              internal unigram distribution. As a result, distortion = 1.0 gives regular
              unigram sampling (as defined by the vocab file), and distortion = 0.0 gives
              a uniform distribution.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">num_reserved_ids</span></td>
        <td><p>Optional argument
              Optionally some reserved IDs can be added in the range [0,
              ..., num_reserved_ids) by the users. One use case is that a special unknown
              word token is used as ID 0. These IDs will have a sampling probability of 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>Optional argument
              A sampler can be used to sample from a subset of the original range
              in order to speed up the whole computation through parallelism. This parameter
              (together with &#39;shard&#39;) indicates the number of partitions that are being
              used in the overall computation.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">shard</span></td>
        <td><p>Optional argument
              A sampler can be used to sample from a subset of the original range
              in order to speed up the whole computation through parallelism. This parameter
              (together with &#39;num_shards&#39;) indicates the particular partition number of a
              sampler op, when partitioning is being used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span>[]</td>
        <td><span class="parametername">unigrams</span></td>
        <td><p>Optional argument
              A list of unigram counts or probabilities, one per ID in sequential
              order. Exactly one of vocab_file and unigrams should be passed to this op.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              An second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FixedUnigramCandidateSampler&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sampled_candidates: A vector of length num_sampled, in which each element is
              the ID of a sampled candidate.
              true_expected_count: A batch_size * num_true matrix, representing
              the number of times each candidate is expected to occur in a batch
              of sampled candidates. If unique=true, then this is a probability.
              sampled_expected_count: A vector of length num_sampled, for each sampled
              candidate representing the number of times the candidate is expected
              to occur in a batch of sampled candidates.  If unique=true, then this is a
              probability.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FixedUnigramCandidateSampler_TensorFlow_TFOutput_System_Int64_System_Int64_System_Boolean_System_Int64_System_String_System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Single___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>A unigram sampler could use a fixed unigram distribution read from a
              file or passed in as an in-memory array instead of building up the distribution
              from data on the fly. There is also an option to skew the distribution by
              applying a distortion power to the weights.</p>
<pre><code>          The vocabulary file should be in CSV-like format, with the last field
          being the weight associated with the word.

          For each batch, this op picks a single set of sampled candidate labels.

          The advantages of sampling candidates per-batch are simplicity and the
          possibility of efficient dense matrix multiplication. The disadvantage is that
          the sampled candidates must be chosen independently of the context and of the
          true labels.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Floor_" data-uid="TensorFlow.TFGraph.Floor*"></a>
  <h4 id="TensorFlow_TFGraph_Floor_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Floor(TensorFlow.TFOutput,System.String)">Floor(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns element-wise largest integer not greater than x.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Floor (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Floor&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_FloorDiv_" data-uid="TensorFlow.TFGraph.FloorDiv*"></a>
  <h4 id="TensorFlow_TFGraph_FloorDiv_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.FloorDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">FloorDiv(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns x // y element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FloorDiv (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FloorDiv&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FloorDiv_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>FloorDiv</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_FloorMod_" data-uid="TensorFlow.TFGraph.FloorMod*"></a>
  <h4 id="TensorFlow_TFGraph_FloorMod_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.FloorMod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">FloorMod(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns element-wise remainder of division. When <code>x &lt; 0</code> xor <code>y &lt; 0</code> is</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FloorMod (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FloorMod&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FloorMod_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>true, this follows Python semantics in that the result here is consistent
              with a flooring divide. E.g. <code>floor(x / y) * y + mod(x, y) = x</code>.</p>
<pre><code>          *NOTE*: &lt;code&gt;FloorMod&lt;/code&gt; supports broadcasting. More about broadcasting
          [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_FractionalAvgPool_" data-uid="TensorFlow.TFGraph.FractionalAvgPool*"></a>
  <h4 id="TensorFlow_TFGraph_FractionalAvgPool_TensorFlow_TFOutput_System_Single___System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.FractionalAvgPool(TensorFlow.TFOutput,System.Single[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">FractionalAvgPool(TFOutput, Single[], Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Performs fractional average pooling on the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; FractionalAvgPool (TensorFlow.TFOutput value, float[] pooling_ratio, Nullable&lt;bool&gt; pseudo_random = null, Nullable&lt;bool&gt; overlapping = null, Nullable&lt;bool&gt; deterministic = null, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span>[]</td>
        <td><span class="parametername">pooling_ratio</span></td>
        <td><p>Pooling ratio for each dimension of <code>value</code>, currently only
              supports row and col dimension and should be &gt;= 1.0. For example, a valid
              pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
              must be 1.0 because we don&#39;t allow pooling on batch and channels
              dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
              respectively.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">pseudo_random</span></td>
        <td><p>Optional argument
              When set to True, generates the pooling sequence in a
              pseudorandom fashion, otherwise, in a random fashion. Check paper <a href="http://arxiv.org/abs/1412.6071">Benjamin
              Graham, Fractional Max-Pooling</a> for
              difference between pseudorandom and random.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">overlapping</span></td>
        <td><p>Optional argument
              When set to True, it means when pooling, the values at the boundary
              of adjacent pooling cells are used by both cells. For example:</p>
<pre><code>          &lt;code&gt;index  0  1  2  3  4&lt;/code&gt;&lt;code&gt;value  20 5  16 3  7&lt;/code&gt;

          If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
          The result would be [41/3, 26/3] for fractional avg pooling.
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">deterministic</span></td>
        <td><p>Optional argument
              When set to True, a fixed pooling region will be used when
              iterating over a FractionalAvgPool node in the computation graph. Mainly used
              in unit test to make FractionalAvgPool deterministic.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              An second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FractionalAvgPool&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output: output tensor after fractional avg pooling.
              row_pooling_sequence: row pooling sequence, needed to calculate gradient.
              col_pooling_sequence: column pooling sequence, needed to calculate gradient.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FractionalAvgPool_TensorFlow_TFOutput_System_Single___System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Fractional average pooling is similar to Fractional max pooling in the pooling
              region generation step. The only difference is that after pooling regions are
              generated, a mean operation is performed instead of a max operation in each
              pooling region.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_FractionalAvgPoolGrad_" data-uid="TensorFlow.TFGraph.FractionalAvgPoolGrad*"></a>
  <h4 id="TensorFlow_TFGraph_FractionalAvgPoolGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.FractionalAvgPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">FractionalAvgPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes gradient of the FractionalAvgPool function.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FractionalAvgPoolGrad (TensorFlow.TFOutput orig_input_tensor_shape, TensorFlow.TFOutput out_backprop, TensorFlow.TFOutput row_pooling_sequence, TensorFlow.TFOutput col_pooling_sequence, Nullable&lt;bool&gt; overlapping = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_input_tensor_shape</span></td>
        <td><p>Original input tensor shape for <code>fractional_avg_pool</code></p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">out_backprop</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.  Gradients
              w.r.t. the output of <code>fractional_avg_pool</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">row_pooling_sequence</span></td>
        <td><p>row pooling sequence, form pooling region with
              col_pooling_sequence.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">col_pooling_sequence</span></td>
        <td><p>column pooling sequence, form pooling region with
              row_pooling sequence.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">overlapping</span></td>
        <td><p>Optional argument
              When set to True, it means when pooling, the values at the boundary
              of adjacent pooling cells are used by both cells. For example:</p>
<pre><code>          &lt;code&gt;index  0  1  2  3  4&lt;/code&gt;&lt;code&gt;value  20 5  16 3  7&lt;/code&gt;

          If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
          The result would be [41/3, 26/3] for fractional avg pooling.
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FractionalAvgPoolGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D.  Gradients w.r.t. the input of <code>fractional_avg_pool</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FractionalAvgPoolGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Unlike FractionalMaxPoolGrad, we don&#39;t need to find arg_max for
              FractionalAvgPoolGrad, we just need to evenly back-propagate each element of
              out_backprop to those indices that form the same pooling cell. Therefore, we
              just need to know the shape of original input tensor, instead of the whole
              tensor.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_FractionalMaxPool_" data-uid="TensorFlow.TFGraph.FractionalMaxPool*"></a>
  <h4 id="TensorFlow_TFGraph_FractionalMaxPool_TensorFlow_TFOutput_System_Single___System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.FractionalMaxPool(TensorFlow.TFOutput,System.Single[],System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">FractionalMaxPool(TFOutput, Single[], Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Performs fractional max pooling on the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; FractionalMaxPool (TensorFlow.TFOutput value, float[] pooling_ratio, Nullable&lt;bool&gt; pseudo_random = null, Nullable&lt;bool&gt; overlapping = null, Nullable&lt;bool&gt; deterministic = null, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span>[]</td>
        <td><span class="parametername">pooling_ratio</span></td>
        <td><p>Pooling ratio for each dimension of <code>value</code>, currently only
              supports row and col dimension and should be &gt;= 1.0. For example, a valid
              pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements
              must be 1.0 because we don&#39;t allow pooling on batch and channels
              dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions
              respectively.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">pseudo_random</span></td>
        <td><p>Optional argument
              When set to True, generates the pooling sequence in a
              pseudorandom fashion, otherwise, in a random fashion. Check paper <a href="http://arxiv.org/abs/1412.6071">Benjamin
              Graham, Fractional Max-Pooling</a> for
              difference between pseudorandom and random.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">overlapping</span></td>
        <td><p>Optional argument
              When set to True, it means when pooling, the values at the boundary
              of adjacent pooling cells are used by both cells. For example:</p>
<pre><code>          &lt;code&gt;index  0  1  2  3  4&lt;/code&gt;&lt;code&gt;value  20 5  16 3  7&lt;/code&gt;

          If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
          The result would be [20, 16] for fractional max pooling.
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">deterministic</span></td>
        <td><p>Optional argument
              When set to True, a fixed pooling region will be used when
              iterating over a FractionalMaxPool node in the computation graph. Mainly used
              in unit test to make FractionalMaxPool deterministic.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              An second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FractionalMaxPool&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output: output tensor after fractional max pooling.
              row_pooling_sequence: row pooling sequence, needed to calculate gradient.
              col_pooling_sequence: column pooling sequence, needed to calculate gradient.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FractionalMaxPool_TensorFlow_TFOutput_System_Single___System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Fractional max pooling is slightly different than regular max pooling.  In
              regular max pooling, you downsize an input set by taking the maximum value of
              smaller N x N subsections of the set (often 2x2), and try to reduce the set by
              a factor of N, where N is an integer.  Fractional max pooling, as you might
              expect from the word &quot;fractional&quot;, means that the overall reduction ratio N
              does not have to be an integer.</p>
<pre><code>          The sizes of the pooling regions are generated randomly but are fairly uniform.
          For example, let&#39;s look at the height dimension, and the constraints on the
          list of rows that will be pool boundaries.

          First we define the following:

          1.  input_row_length : the number of rows from the input set
          2.  output_row_length : which will be smaller than the input
          3.  alpha = input_row_length / output_row_length : our reduction ratio
          4.  K = floor(alpha)
          5.  row_pooling_sequence : this is the result list of pool boundary rows

          Then, row_pooling_sequence should satisfy:

          1.  a[0] = 0 : the first value of the sequence is 0
          2.  a[end] = input_row_length : the last value of the sequence is the size
          3.  K &amp;lt;= (a[i+1] - a[i]) &amp;lt;= K+1 : all intervals are K or K+1 size
          4.  length(row_pooling_sequence) = output_row_length+1

          For more details on fractional max pooling, see this paper:
          [Benjamin Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_FractionalMaxPoolGrad_" data-uid="TensorFlow.TFGraph.FractionalMaxPoolGrad*"></a>
  <h4 id="TensorFlow_TFGraph_FractionalMaxPoolGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.FractionalMaxPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">FractionalMaxPoolGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes gradient of the FractionalMaxPool function.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FractionalMaxPoolGrad (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput out_backprop, TensorFlow.TFOutput row_pooling_sequence, TensorFlow.TFOutput col_pooling_sequence, Nullable&lt;bool&gt; overlapping = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_input</span></td>
        <td><p>Original input for <code>fractional_max_pool</code></p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_output</span></td>
        <td><p>Original output for <code>fractional_max_pool</code></p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">out_backprop</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.  Gradients
              w.r.t. the output of <code>fractional_max_pool</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">row_pooling_sequence</span></td>
        <td><p>row pooling sequence, form pooling region with
              col_pooling_sequence.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">col_pooling_sequence</span></td>
        <td><p>column pooling sequence, form pooling region with
              row_pooling sequence.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">overlapping</span></td>
        <td><p>Optional argument
              When set to True, it means when pooling, the values at the boundary
              of adjacent pooling cells are used by both cells. For example:</p>
<pre><code>          &lt;code&gt;index  0  1  2  3  4&lt;/code&gt;&lt;code&gt;value  20 5  16 3  7&lt;/code&gt;

          If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.
          The result would be [20, 16] for fractional max pooling.
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FractionalMaxPoolGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D.  Gradients w.r.t. the input of <code>fractional_max_pool</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_FusedBatchNorm_" data-uid="TensorFlow.TFGraph.FusedBatchNorm*"></a>
  <h4 id="TensorFlow_TFGraph_FusedBatchNorm_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.FusedBatchNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)">FusedBatchNorm(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Single&gt;, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Batch normalization.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; FusedBatchNorm (TensorFlow.TFOutput x, TensorFlow.TFOutput scale, TensorFlow.TFOutput offset, TensorFlow.TFOutput mean, TensorFlow.TFOutput variance, Nullable&lt;float&gt; epsilon = null, string data_format = null, Nullable&lt;bool&gt; is_training = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>A 4D Tensor for input data.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">scale</span></td>
        <td><p>A 1D Tensor for scaling factor, to scale the normalized x.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">offset</span></td>
        <td><p>A 1D Tensor for offset, to shift to the normalized x.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mean</span></td>
        <td><p>A 1D Tensor for population mean. Used for inference only;
              must be empty for training.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">variance</span></td>
        <td><p>A 1D Tensor for population variance. Used for inference only;
              must be empty for training.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Optional argument
              A small float number added to the variance of x.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              The data format for x and y. Either &quot;NHWC&quot; (default) or &quot;NCHW&quot;.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">is_training</span></td>
        <td><p>Optional argument
              A bool value to indicate the operation is for training (default)
              or inference.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FusedBatchNorm&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              y: A 4D Tensor for output data.
              batch_mean: A 1D Tensor for the computed batch mean, to be used by TensorFlow
              to compute the running mean.
              batch_variance: A 1D Tensor for the computed batch variance, to be used by
              TensorFlow to compute the running variance.
              reserve_space_1: A 1D Tensor for the computed batch mean, to be reused
              in the gradient computation.
              reserve_space_2: A 1D Tensor for the computed batch variance (inverted variance
              in the cuDNN case), to be reused in the gradient computation.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FusedBatchNorm_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that the size of 4D Tensors are defined by either &quot;NHWC&quot; or &quot;NCHW&quot;.
              The size of 1D Tensors matches the dimension C of the 4D Tensors.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_FusedBatchNormGrad_" data-uid="TensorFlow.TFGraph.FusedBatchNormGrad*"></a>
  <h4 id="TensorFlow_TFGraph_FusedBatchNormGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.FusedBatchNormGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)">FusedBatchNormGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Single&gt;, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Gradient for batch normalization.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; FusedBatchNormGrad (TensorFlow.TFOutput y_backprop, TensorFlow.TFOutput x, TensorFlow.TFOutput scale, TensorFlow.TFOutput reserve_space_1, TensorFlow.TFOutput reserve_space_2, Nullable&lt;float&gt; epsilon = null, string data_format = null, Nullable&lt;bool&gt; is_training = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y_backprop</span></td>
        <td><p>A 4D Tensor for the gradient with respect to y.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>A 4D Tensor for input data.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">scale</span></td>
        <td><p>A 1D Tensor for scaling factor, to scale the normalized x.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reserve_space_1</span></td>
        <td><p>When is_training is True, a 1D Tensor for the computed batch
              mean to be reused in gradient computation. When is_training is
              False, a 1D Tensor for the population mean to be reused in both
              1st and 2nd order gradient computation.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reserve_space_2</span></td>
        <td><p>When is_training is True, a 1D Tensor for the computed batch
              variance (inverted variance in the cuDNN case) to be reused in
              gradient computation. When is_training is False, a 1D Tensor
              for the population variance to be reused in both 1st and 2nd
              order gradient computation.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Optional argument
              A small float number added to the variance of x.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              The data format for y_backprop, x, x_backprop.
              Either &quot;NHWC&quot; (default) or &quot;NCHW&quot;.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">is_training</span></td>
        <td><p>Optional argument
              A bool value to indicate the operation is for training (default)
              or inference.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FusedBatchNormGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              x_backprop: A 4D Tensor for the gradient with respect to x.
              scale_backprop: A 1D Tensor for the gradient with respect to scale.
              offset_backprop: A 1D Tensor for the gradient with respect to offset.
              reserve_space_3: Unused placeholder to match the mean input in FusedBatchNorm.
              reserve_space_4: Unused placeholder to match the variance input
              in FusedBatchNorm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FusedBatchNormGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that the size of 4D Tensors are defined by either &quot;NHWC&quot; or &quot;NCHW&quot;.
              The size of 1D Tensors matches the dimension C of the 4D Tensors.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_FusedBatchNormGradV2_" data-uid="TensorFlow.TFGraph.FusedBatchNormGradV2*"></a>
  <h4 id="TensorFlow_TFGraph_FusedBatchNormGradV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.FusedBatchNormGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)">FusedBatchNormGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Single&gt;, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Gradient for batch normalization.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; FusedBatchNormGradV2 (TensorFlow.TFOutput y_backprop, TensorFlow.TFOutput x, TensorFlow.TFOutput scale, TensorFlow.TFOutput reserve_space_1, TensorFlow.TFOutput reserve_space_2, Nullable&lt;float&gt; epsilon = null, string data_format = null, Nullable&lt;bool&gt; is_training = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y_backprop</span></td>
        <td><p>A 4D Tensor for the gradient with respect to y.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>A 4D Tensor for input data.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">scale</span></td>
        <td><p>A 1D Tensor for scaling factor, to scale the normalized x.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reserve_space_1</span></td>
        <td><p>When is_training is True, a 1D Tensor for the computed batch
              mean to be reused in gradient computation. When is_training is
              False, a 1D Tensor for the population mean to be reused in both
              1st and 2nd order gradient computation.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reserve_space_2</span></td>
        <td><p>When is_training is True, a 1D Tensor for the computed batch
              variance (inverted variance in the cuDNN case) to be reused in
              gradient computation. When is_training is False, a 1D Tensor
              for the population variance to be reused in both 1st and 2nd
              order gradient computation.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Optional argument
              A small float number added to the variance of x.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              The data format for y_backprop, x, x_backprop.
              Either &quot;NHWC&quot; (default) or &quot;NCHW&quot;.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">is_training</span></td>
        <td><p>Optional argument
              A bool value to indicate the operation is for training (default)
              or inference.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FusedBatchNormGradV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              x_backprop: A 4D Tensor for the gradient with respect to x.
              scale_backprop: A 1D Tensor for the gradient with respect to scale.
              offset_backprop: A 1D Tensor for the gradient with respect to offset.
              reserve_space_3: Unused placeholder to match the mean input in FusedBatchNorm.
              reserve_space_4: Unused placeholder to match the variance input
              in FusedBatchNorm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FusedBatchNormGradV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that the size of 4D Tensors are defined by either &quot;NHWC&quot; or &quot;NCHW&quot;.
              The size of 1D Tensors matches the dimension C of the 4D Tensors.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_FusedBatchNormV2_" data-uid="TensorFlow.TFGraph.FusedBatchNormV2*"></a>
  <h4 id="TensorFlow_TFGraph_FusedBatchNormV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.FusedBatchNormV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String,System.Nullable{System.Boolean},System.String)">FusedBatchNormV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Single&gt;, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Batch normalization.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; FusedBatchNormV2 (TensorFlow.TFOutput x, TensorFlow.TFOutput scale, TensorFlow.TFOutput offset, TensorFlow.TFOutput mean, TensorFlow.TFOutput variance, Nullable&lt;float&gt; epsilon = null, string data_format = null, Nullable&lt;bool&gt; is_training = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>A 4D Tensor for input data.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">scale</span></td>
        <td><p>A 1D Tensor for scaling factor, to scale the normalized x.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">offset</span></td>
        <td><p>A 1D Tensor for offset, to shift to the normalized x.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mean</span></td>
        <td><p>A 1D Tensor for population mean. Used for inference only;
              must be empty for training.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">variance</span></td>
        <td><p>A 1D Tensor for population variance. Used for inference only;
              must be empty for training.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Optional argument
              A small float number added to the variance of x.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              The data format for x and y. Either &quot;NHWC&quot; (default) or &quot;NCHW&quot;.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">is_training</span></td>
        <td><p>Optional argument
              A bool value to indicate the operation is for training (default)
              or inference.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FusedBatchNormV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              y: A 4D Tensor for output data.
              batch_mean: A 1D Tensor for the computed batch mean, to be used by TensorFlow
              to compute the running mean.
              batch_variance: A 1D Tensor for the computed batch variance, to be used by
              TensorFlow to compute the running variance.
              reserve_space_1: A 1D Tensor for the computed batch mean, to be reused
              in the gradient computation.
              reserve_space_2: A 1D Tensor for the computed batch variance (inverted variance
              in the cuDNN case), to be reused in the gradient computation.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FusedBatchNormV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that the size of 4D Tensors are defined by either &quot;NHWC&quot; or &quot;NCHW&quot;.
              The size of 1D Tensors matches the dimension C of the 4D Tensors.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_FusedPadConv2D_" data-uid="TensorFlow.TFGraph.FusedPadConv2D*"></a>
  <h4 id="TensorFlow_TFGraph_FusedPadConv2D_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Int64___System_String_System_String_" data-uid="TensorFlow.TFGraph.FusedPadConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Int64[],System.String,System.String)">FusedPadConv2D(TFOutput, TFOutput, TFOutput, String, Int64[], String, String)</h4>
  <div class="markdown level1 summary"><p>Performs a padding as a preprocess during a convolution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FusedPadConv2D (TensorFlow.TFOutput input, TensorFlow.TFOutput paddings, TensorFlow.TFOutput filter, string mode, long[] strides, string padding, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">paddings</span></td>
        <td><p>A two-column matrix specifying the padding sizes. The number of
              rows must be the same as the rank of <code>input</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>4-D with shape
              <code>[filter_height, filter_width, in_channels, out_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">mode</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D of length 4.  The stride of the sliding window for each dimension
              of <code>input</code>. Must be in the same order as the dimension specified with format.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FusedPadConv2D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FusedPadConv2D_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Int64___System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Similar to FusedResizeAndPadConv2d, this op allows for an optimized
              implementation where the spatial padding transformation stage is fused with the
              im2col lookup, but in this case without the bilinear filtering required for
              resizing. Fusing the padding prevents the need to write out the intermediate
              results as whole tensors, reducing memory pressure, and we can get some latency
              gains by merging the transformation calculations.
              The data_format attribute for Conv2D isn&#39;t supported by this op, and &#39;NHWC&#39;
              order is used instead.
              Internally this op uses a single per-graph scratch buffer, which means that it
              will block if multiple versions are being run in parallel. This is because this
              operator is primarily an optimization to minimize memory usage.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_FusedResizeAndPadConv2D_" data-uid="TensorFlow.TFGraph.FusedResizeAndPadConv2D*"></a>
  <h4 id="TensorFlow_TFGraph_FusedResizeAndPadConv2D_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Int64___System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.FusedResizeAndPadConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Int64[],System.String,System.Nullable{System.Boolean},System.String)">FusedResizeAndPadConv2D(TFOutput, TFOutput, TFOutput, TFOutput, String, Int64[], String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Performs a resize and padding as a preprocess during a convolution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput FusedResizeAndPadConv2D (TensorFlow.TFOutput input, TensorFlow.TFOutput size, TensorFlow.TFOutput paddings, TensorFlow.TFOutput filter, string mode, long[] strides, string padding, Nullable&lt;bool&gt; resize_align_corners = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
              new size for the images.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">paddings</span></td>
        <td><p>A two-column matrix specifying the padding sizes. The number of
              rows must be the same as the rank of <code>input</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>4-D with shape
              <code>[filter_height, filter_width, in_channels, out_channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">mode</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D of length 4.  The stride of the sliding window for each dimension
              of <code>input</code>. Must be in the same order as the dimension specified with format.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">resize_align_corners</span></td>
        <td><p>Optional argument
              If true, the centers of the 4 corner pixels of the input and output tensors are
              aligned, preserving the values at the corner pixels. Defaults to false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;FusedResizeAndPadConv2D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_FusedResizeAndPadConv2D_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Int64___System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>It&#39;s often possible to do spatial transformations more efficiently as part of
              the packing stage of a convolution, so this op allows for an optimized
              implementation where these stages are fused together. This prevents the need to
              write out the intermediate results as whole tensors, reducing memory pressure,
              and we can get some latency gains by merging the transformation calculations.
              The data_format attribute for Conv2D isn&#39;t supported by this op, and defaults to
              &#39;NHWC&#39; order.
              Internally this op uses a single per-graph scratch buffer, which means that it
              will block if multiple versions are being run in parallel. This is because this
              operator is primarily an optimization to minimize memory usage.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Gather_" data-uid="TensorFlow.TFGraph.Gather*"></a>
  <h4 id="TensorFlow_TFGraph_Gather_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Gather(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">Gather(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Gather slices from <code>params</code> according to <code>indices</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Gather (TensorFlow.TFOutput parameters, TensorFlow.TFOutput indices, Nullable&lt;bool&gt; validate_indices = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">validate_indices</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Gather&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Gather_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>indices</code> must be an integer tensor of any dimension (usually 0-D or 1-D).
              Produces an output tensor with shape <code>indices.shape + params.shape[1:]</code> where:</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          # Scalar indices
          output[:, ..., :] = params[indices, :, ... :]

          # Vector indices
          output[i, :, ..., :] = params[indices[i], :, ... :]

          # Higher rank indices
          output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]
           &lt;/code&gt;&lt;/pre&gt;

          If &lt;code&gt;indices&lt;/code&gt; is a permutation and &lt;code&gt;len(indices) == params.shape[0]&lt;/code&gt; then
          this operation will permute &lt;code&gt;params&lt;/code&gt; accordingly.

          &lt;code&gt;validate_indices&lt;/code&gt;: DEPRECATED. If this operation is assigned to CPU, values in
          &lt;code&gt;indices&lt;/code&gt; are always validated to be within range. If assigned to GPU,
          out-of-bound indices result in safe but unspecified behavior, which may include
          raising an error.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/Gather.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_GatherNd_" data-uid="TensorFlow.TFGraph.GatherNd*"></a>
  <h4 id="TensorFlow_TFGraph_GatherNd_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.GatherNd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">GatherNd(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Gather slices from <code>params</code> into a Tensor with shape specified by <code>indices</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput GatherNd (TensorFlow.TFOutput parameters, TensorFlow.TFOutput indices, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>The tensor from which to gather values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>Index tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;GatherNd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Values from <code>params</code> gathered from indices given by <code>indices</code>, with
              shape <code>indices.shape[:-1] + params.shape[indices.shape[-1]:]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_GatherNd_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>indices</code> is an K-dimensional integer tensor, best thought of as a
              (K-1)-dimensional tensor of indices into <code>params</code>, where each element defines a
              slice of <code>params</code>:</p>
<pre><code>          output[\\(i_0, ..., i_{K-2}\\)] = params[indices[\\(i_0, ..., i_{K-2}\\)]]

          Whereas in &lt;code&gt;tf.gather&lt;/code&gt;&lt;code&gt;indices&lt;/code&gt; defines slices into the first
          dimension of &lt;code&gt;params&lt;/code&gt;, in &lt;code&gt;tf.gather_nd&lt;/code&gt;, &lt;code&gt;indices&lt;/code&gt; defines slices into the
          first &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;params&lt;/code&gt;, where &lt;code&gt;N = indices.shape[-1]&lt;/code&gt;.

          The last dimension of &lt;code&gt;indices&lt;/code&gt; can be at most the rank of
          &lt;code&gt;params&lt;/code&gt;:

          indices.shape[-1] &amp;lt;= params.rank

          The last dimension of &lt;code&gt;indices&lt;/code&gt; corresponds to elements
          (if &lt;code&gt;indices.shape[-1] == params.rank&lt;/code&gt;) or slices
          (if &lt;code&gt;indices.shape[-1] &amp;lt; params.rank&lt;/code&gt;) along dimension &lt;code&gt;indices.shape[-1]&lt;/code&gt;
          of &lt;code&gt;params&lt;/code&gt;.  The output tensor has shape

          indices.shape[:-1] + params.shape[indices.shape[-1]:]

          Note that on CPU, if an out of bound index is found, an error is returned.
          On GPU, if an out of bound index is found, a 0 is stored in the
          corresponding output value.

          Some examples below.

          Simple indexing into a matrix:

           &lt;pre&gt;&lt;code&gt;
          indices = [[0, 0], [1, 1]]
          params = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]
          output = [&#39;a&#39;, &#39;d&#39;]
           &lt;/code&gt;&lt;/pre&gt;

          Slice indexing into a matrix:

           &lt;pre&gt;&lt;code&gt;
          indices = [[1], [0]]
          params = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]
          output = [[&#39;c&#39;, &#39;d&#39;], [&#39;a&#39;, &#39;b&#39;]]
           &lt;/code&gt;&lt;/pre&gt;

          Indexing into a 3-tensor:

           &lt;pre&gt;&lt;code&gt;
          indices = [[1]]
          params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
          output = [[[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]


          indices = [[0, 1], [1, 0]]
          params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
          output = [[&#39;c0&#39;, &#39;d0&#39;], [&#39;a1&#39;, &#39;b1&#39;]]


          indices = [[0, 0, 1], [1, 0, 1]]
          params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
          output = [&#39;b0&#39;, &#39;b1&#39;]
           &lt;/code&gt;&lt;/pre&gt;

          Batched indexing into a matrix:

           &lt;pre&gt;&lt;code&gt;
          indices = [[[0, 0]], [[0, 1]]]
          params = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]
          output = [[&#39;a&#39;], [&#39;b&#39;]]
           &lt;/code&gt;&lt;/pre&gt;

          Batched slice indexing into a matrix:

           &lt;pre&gt;&lt;code&gt;
          indices = [[[1]], [[0]]]
          params = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]
          output = [[[&#39;c&#39;, &#39;d&#39;]], [[&#39;a&#39;, &#39;b&#39;]]]
           &lt;/code&gt;&lt;/pre&gt;

          Batched indexing into a 3-tensor:

           &lt;pre&gt;&lt;code&gt;
          indices = [[[1]], [[0]]]
          params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
          output = [[[[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]],
          [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]]]]

          indices = [[[0, 1], [1, 0]], [[0, 0], [1, 1]]]
          params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
          output = [[[&#39;c0&#39;, &#39;d0&#39;], [&#39;a1&#39;, &#39;b1&#39;]],
          [[&#39;a0&#39;, &#39;b0&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]


          indices = [[[0, 0, 1], [1, 0, 1]], [[0, 1, 1], [1, 1, 0]]]
          params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
          output = [[&#39;b0&#39;, &#39;b1&#39;], [&#39;d0&#39;, &#39;c1&#39;]]
           &lt;/code&gt;&lt;/pre&gt;

          See also &lt;code&gt;tf.gather&lt;/code&gt; and &lt;code&gt;tf.batch_gather&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_GatherV2_" data-uid="TensorFlow.TFGraph.GatherV2*"></a>
  <h4 id="TensorFlow_TFGraph_GatherV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.GatherV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">GatherV2(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Gather slices from <code>params</code> axis <code>axis</code> according to <code>indices</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput GatherV2 (TensorFlow.TFOutput parameters, TensorFlow.TFOutput indices, TensorFlow.TFOutput axis, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>The tensor from which to gather values. Must be at least rank
              <code>axis + 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>Index tensor. Must be in range <code>[0, params.shape[axis])</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">axis</span></td>
        <td><p>The axis in <code>params</code> to gather <code>indices</code> from. Defaults to the first
              dimension. Supports negative indexes.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;GatherV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Values from <code>params</code> gathered from indices given by <code>indices</code>, with
              shape <code>params.shape[:axis] + indices.shape + params.shape[axis + 1:]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_GatherV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>indices</code> must be an integer tensor of any dimension (usually 0-D or 1-D).
              Produces an output tensor with shape <code>params.shape[:axis] + indices.shape +
              params.shape[axis + 1:]</code> where:</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          # Scalar indices (output is rank(params) - 1).
          output[a_0, ..., a_n, b_0, ..., b_n] =
          params[a_0, ..., a_n, indices, b_0, ..., b_n]

          # Vector indices (output is rank(params)).
          output[a_0, ..., a_n, i, b_0, ..., b_n] =
          params[a_0, ..., a_n, indices[i], b_0, ..., b_n]

          # Higher rank indices (output is rank(params) + rank(indices) - 1).
          output[a_0, ..., a_n, i, ..., j, b_0, ... b_n] =
          params[a_0, ..., a_n, indices[i, ..., j], b_0, ..., b_n]
           &lt;/code&gt;&lt;/pre&gt;

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/Gather.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;

          Note that on CPU, if an out of bound index is found, an error is returned.
          On GPU, if an out of bound index is found, a 0 is stored in the
          corresponding output value.

          See also &lt;code&gt;tf.batch_gather&lt;/code&gt; and &lt;code&gt;tf.gather_nd&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_GcsConfigureBlockCache_" data-uid="TensorFlow.TFGraph.GcsConfigureBlockCache*"></a>
  <h4 id="TensorFlow_TFGraph_GcsConfigureBlockCache_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.GcsConfigureBlockCache(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">GcsConfigureBlockCache(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Re-configures the GCS block cache with the new configuration values.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation GcsConfigureBlockCache (TensorFlow.TFOutput max_cache_size, TensorFlow.TFOutput block_size, TensorFlow.TFOutput max_staleness, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_cache_size</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">block_size</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_staleness</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;GcsConfigureBlockCache&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_GcsConfigureBlockCache_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If the values are the same as already configured values, this op is a no-op. If
              they are different, the current contents of the block cache is dropped, and a
              new block cache is created fresh.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_GcsConfigureCredentials_" data-uid="TensorFlow.TFGraph.GcsConfigureCredentials*"></a>
  <h4 id="TensorFlow_TFGraph_GcsConfigureCredentials_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.GcsConfigureCredentials(TensorFlow.TFOutput,System.String)">GcsConfigureCredentials(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Configures the credentials used by the GCS client of the local TF runtime.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation GcsConfigureCredentials (TensorFlow.TFOutput json, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">json</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;GcsConfigureCredentials&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_GcsConfigureCredentials_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The json input can be of the format:</p>
<pre><code>          1. Refresh Token:
          {
          &quot;client_id&quot;: &quot;&amp;lt;redacted&amp;gt;&quot;,
          &quot;client_secret&quot;: &quot;&amp;lt;redacted&amp;gt;&quot;,
          &quot;refresh_token: &quot;&amp;lt;redacted&amp;gt;&quot;,
          &quot;type&quot;: &quot;authorized_user&quot;,
          }

          2. Service Account:
          {
          &quot;type&quot;: &quot;service_account&quot;,
          &quot;project_id&quot;: &quot;&amp;lt;redacted&amp;gt;&quot;,
          &quot;private_key_id&quot;: &quot;&amp;lt;redacted&amp;gt;&quot;,
          &quot;private_key&quot;: &quot;------BEGIN PRIVATE KEY-----\n&amp;lt;REDACTED&amp;gt;\n-----END PRIVATE KEY------\n&quot;,
          &quot;client_email&quot;: &quot;&amp;lt;REDACTED&amp;gt;@&amp;lt;REDACTED&amp;gt;.iam.gserviceaccount.com&quot;,
          &quot;client_id&quot;: &quot;&amp;lt;REDACTED&amp;gt;&quot;,
          # Some additional fields elided
          }

          Note the credentials established through this method are shared across all
          sessions run on this runtime.

          Note be sure to feed the inputs to this op to ensure the credentials are not
          stored in a constant op within the graph that might accidentally be checkpointed
          or in other ways be persisted or exfiltrated.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_GenerateBigQueryReaderPartitions_" data-uid="TensorFlow.TFGraph.GenerateBigQueryReaderPartitions*"></a>
  <h4 id="TensorFlow_TFGraph_GenerateBigQueryReaderPartitions_System_String_System_String_System_String_System_String___System_Int64_System_Int64_System_String_System_String_" data-uid="TensorFlow.TFGraph.GenerateBigQueryReaderPartitions(System.String,System.String,System.String,System.String[],System.Int64,System.Int64,System.String,System.String)">GenerateBigQueryReaderPartitions(String, String, String, String[], Int64, Int64, String, String)</h4>
  <div class="markdown level1 summary"><p>Generates serialized partition messages suitable for batch reads.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput GenerateBigQueryReaderPartitions (string project_id, string dataset_id, string table_id, string[] columns, long timestamp_millis, long num_partitions, string test_end_point = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">project_id</span></td>
        <td><p>GCP project ID.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">dataset_id</span></td>
        <td><p>BigQuery Dataset ID.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Table to read.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">columns</span></td>
        <td><p>List of columns to read. Leave empty to read all columns.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">timestamp_millis</span></td>
        <td><p>Table snapshot timestamp in millis since epoch. Relative
              (negative or zero) snapshot times are not allowed. For more details, see
              &#39;Table Decorators&#39; in BigQuery docs.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_partitions</span></td>
        <td><p>Number of partitions to split the table into.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">test_end_point</span></td>
        <td><p>Optional argument
              Do not use. For testing purposes only.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;GenerateBigQueryReaderPartitions&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Serialized table partitions.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_GenerateBigQueryReaderPartitions_System_String_System_String_System_String_System_String___System_Int64_System_Int64_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op should not be used directly by clients. Instead, the
              bigquery_reader_ops.py file defines a clean interface to the reader.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_GenerateVocabRemapping_" data-uid="TensorFlow.TFGraph.GenerateVocabRemapping*"></a>
  <h4 id="TensorFlow_TFGraph_GenerateVocabRemapping_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.GenerateVocabRemapping(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String)">GenerateVocabRemapping(TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Given a path to new and old vocabulary files, returns a remapping Tensor of</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; GenerateVocabRemapping (TensorFlow.TFOutput new_vocab_file, TensorFlow.TFOutput old_vocab_file, long new_vocab_offset, long num_new_vocab, Nullable&lt;long&gt; old_vocab_size = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">new_vocab_file</span></td>
        <td><p>Path to the new vocab file.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">old_vocab_file</span></td>
        <td><p>Path to the old vocab file.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">new_vocab_offset</span></td>
        <td><p>How many entries into the new vocab file to start reading.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_new_vocab</span></td>
        <td><p>Number of entries in the new vocab file to remap.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">old_vocab_size</span></td>
        <td><p>Optional argument
              Number of entries in the old vocab file to consider.  If -1,
              use the entire old vocabulary.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;GenerateVocabRemapping&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              remapping: A Tensor of length num_new_vocab where the element at index i
              is equal to the old ID that maps to the new ID i.  This element is -1 for any
              new ID that is not found in the old vocabulary.
              num_present: Number of new vocab entries found in old vocab.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_GenerateVocabRemapping_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>length <code>num_new_vocab</code>, where <code>remapping[i]</code> contains the row number in the old
              vocabulary that corresponds to row <code>i</code> in the new vocabulary (starting at line
              <code>new_vocab_offset</code> and up to <code>num_new_vocab</code> entities), or <code>-1</code> if entry <code>i</code>
              in the new vocabulary is not in the old vocabulary.  The old vocabulary is
              constrained to the first <code>old_vocab_size</code> entries if <code>old_vocab_size</code> is not the
              default value of -1.</p>
<pre><code>          &lt;code&gt;num_vocab_offset&lt;/code&gt; enables
          use in the partitioned variable case, and should generally be set through
          examining partitioning info.  The format of the files should be a text file,
          with each line containing a single entity within the vocabulary.

          For example, with &lt;code&gt;new_vocab_file&lt;/code&gt; a text file containing each of the following
          elements on a single line: &lt;code&gt;[f0, f1, f2, f3]&lt;/code&gt;, old_vocab_file = [f1, f0, f3],
          &lt;code&gt;num_new_vocab = 3, new_vocab_offset = 1&lt;/code&gt;, the returned remapping would be
          &lt;code&gt;[0, -1, 2]&lt;/code&gt;.

          The op also returns a count of how many entries in the new vocabulary
          were present in the old vocabulary, which is used to calculate the number of
          values to initialize in a weight matrix remapping

          This functionality can be used to remap both row vocabularies (typically,
          features) and column vocabularies (typically, classes) from TensorFlow
          checkpoints.  Note that the partitioning logic relies on contiguous vocabularies
          corresponding to div-partitioned variables.  Moreover, the underlying remapping
          uses an IndexTable (as opposed to an inexact CuckooTable), so client code should
          use the corresponding index_table_from_file() as the FeatureColumn framework
          does (as opposed to tf.feature_to_id(), which uses a CuckooTable).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_GetEnumerator_" data-uid="TensorFlow.TFGraph.GetEnumerator*"></a>
  <h4 id="TensorFlow_TFGraph_GetEnumerator" data-uid="TensorFlow.TFGraph.GetEnumerator">GetEnumerator()</h4>
  <div class="markdown level1 summary"><p>Returns the enumerator that returns all the TFOperations in a graph.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(TensorFlow.TFGraph/&lt;GetEnumerator&gt;d__986))]
public System.Collections.Generic.IEnumerable&lt;TensorFlow.TFOperation&gt; GetEnumerator ();</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;<a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a>&gt;</td>
        <td><p>The enumerator.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_GetGlobalVariablesInitializer_" data-uid="TensorFlow.TFGraph.GetGlobalVariablesInitializer*"></a>
  <h4 id="TensorFlow_TFGraph_GetGlobalVariablesInitializer" data-uid="TensorFlow.TFGraph.GetGlobalVariablesInitializer">GetGlobalVariablesInitializer()</h4>
  <div class="markdown level1 summary"><p>Gets the list of all registered global variables.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation[] GetGlobalVariablesInitializer ();</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a>[]</td>
        <td><p>The array of variables that should be initialized.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_GetGlobalVariablesInitializer_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>After this method is invoked the list of pending initialization variables
            is cleared.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_GetRandomSeeds_" data-uid="TensorFlow.TFGraph.GetRandomSeeds*"></a>
  <h4 id="TensorFlow_TFGraph_GetRandomSeeds_System_Nullable_System_Int32__System_Int32__System_Int32__" data-uid="TensorFlow.TFGraph.GetRandomSeeds(System.Nullable{System.Int32},System.Int32@,System.Int32@)">GetRandomSeeds(Nullable&lt;Int32&gt;, Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Returns the graph and local seeds based on an optionally set incoming seed value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void GetRandomSeeds (Nullable&lt;int&gt; operationSeed, out int graphSeed, out int localSeed);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int32</span>&gt;</td>
        <td><span class="parametername">operationSeed</span></td>
        <td><p>The seed value that might be set.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">graphSeed</span></td>
        <td><p>Returned graph seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">localSeed</span></td>
        <td><p>Returned local seed.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_GetRandomSeeds_System_Nullable_System_Int32__System_Int32__System_Int32___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This helper function returns two seeds derived from graph-level and op-level seeds.
            Many random operations internally use the two seeds to allow user to change 
            the seed globally for a graph, or for only specific operations.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_GetSessionHandle_" data-uid="TensorFlow.TFGraph.GetSessionHandle*"></a>
  <h4 id="TensorFlow_TFGraph_GetSessionHandle_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.GetSessionHandle(TensorFlow.TFOutput,System.String)">GetSessionHandle(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Store the input tensor in the state of the current session.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput GetSessionHandle (TensorFlow.TFOutput value, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>The tensor to be stored.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;GetSessionHandle&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle for the tensor stored in the session state, represented
              as a string.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_GetSessionHandleV2_" data-uid="TensorFlow.TFGraph.GetSessionHandleV2*"></a>
  <h4 id="TensorFlow_TFGraph_GetSessionHandleV2_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.GetSessionHandleV2(TensorFlow.TFOutput,System.String)">GetSessionHandleV2(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Store the input tensor in the state of the current session.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput GetSessionHandleV2 (TensorFlow.TFOutput value, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>The tensor to be stored.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;GetSessionHandleV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle for the tensor stored in the session state, represented
              as a ResourceHandle object.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_GetSessionTensor_" data-uid="TensorFlow.TFGraph.GetSessionTensor*"></a>
  <h4 id="TensorFlow_TFGraph_GetSessionTensor_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.GetSessionTensor(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">GetSessionTensor(TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Get the value of the tensor specified by its handle.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput GetSessionTensor (TensorFlow.TFOutput handle, TensorFlow.TFDataType dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle for a tensor stored in the session state.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of the output value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;GetSessionTensor&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The tensor for the given handle.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_GetShape_" data-uid="TensorFlow.TFGraph.GetShape*"></a>
  <h4 id="TensorFlow_TFGraph_GetShape_TensorFlow_TFOutput_TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.GetShape(TensorFlow.TFOutput,TensorFlow.TFStatus)">GetShape(TFOutput, TFStatus)</h4>
  <div class="markdown level1 summary"><p>Returns the tensor shape for the specific output pparameters as an array of longs.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public long[] GetShape (TensorFlow.TFOutput output, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output</span></td>
        <td><p>The output operation to probe.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><p>null for single dimension, .</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_GetTensorNumDims_" data-uid="TensorFlow.TFGraph.GetTensorNumDims*"></a>
  <h4 id="TensorFlow_TFGraph_GetTensorNumDims_TensorFlow_TFOutput_TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.GetTensorNumDims(TensorFlow.TFOutput,TensorFlow.TFStatus)">GetTensorNumDims(TFOutput, TFStatus)</h4>
  <div class="markdown level1 summary"><p>Returns the number of dimensions of the Tensor referenced by output</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int GetTensorNumDims (TensorFlow.TFOutput output, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output</span></td>
        <td><p>The tensor to probe.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of dimensions of the tensor.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_GetTensorShape_" data-uid="TensorFlow.TFGraph.GetTensorShape*"></a>
  <h4 id="TensorFlow_TFGraph_GetTensorShape_TensorFlow_TFOutput_TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.GetTensorShape(TensorFlow.TFOutput,TensorFlow.TFStatus)">GetTensorShape(TFOutput, TFStatus)</h4>
  <div class="markdown level1 summary"><p>Returns the shape of a tensor specified in <code>output</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFShape GetTensorShape (TensorFlow.TFOutput output, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output</span></td>
        <td><p>The tensor that you want to look up.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><p>The tensor shape.    If the number of dimensions in the shape is unknown or the shape is, a scalar, the values in the array will be zero. Otherwise, each element of will be set corresponding to the size of the dimension. An  unknown dimension is represented by -1.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_GlobalNorm_" data-uid="TensorFlow.TFGraph.GlobalNorm*"></a>
  <h4 id="TensorFlow_TFGraph_GlobalNorm_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.GlobalNorm(TensorFlow.TFOutput[],System.String)">GlobalNorm(TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Computes the global norm of multiple tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput GlobalNorm (TensorFlow.TFOutput[] tensors, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">tensors</span></td>
        <td><p>The input tensors.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Operation name, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A clipped <a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_GlobalNorm_TensorFlow_TFOutput___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>
             Given a tuple or list of tensors <code>tensors</code>, this operation returns the global norm of the elements in all tensors 
             in <code>tensors</code>. The global norm is computed as: <code>global_norm = sqrt(sum([l2norm(t)**2 for t in t_list]))</code>. Any 
             entries in <code>tensors</code> that are of type None are ignored.</p></div>
  
  
  <a id="TensorFlow_TFGraph_Greater_" data-uid="TensorFlow.TFGraph.Greater*"></a>
  <h4 id="TensorFlow_TFGraph_Greater_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Greater(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Greater(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the truth value of (x &gt; y) element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Greater (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Greater&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Greater_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>Greater</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_GreaterEqual_" data-uid="TensorFlow.TFGraph.GreaterEqual*"></a>
  <h4 id="TensorFlow_TFGraph_GreaterEqual_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.GreaterEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">GreaterEqual(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the truth value of (x &gt;= y) element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput GreaterEqual (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;GreaterEqual&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_GreaterEqual_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>GreaterEqual</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_GuaranteeConst_" data-uid="TensorFlow.TFGraph.GuaranteeConst*"></a>
  <h4 id="TensorFlow_TFGraph_GuaranteeConst_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.GuaranteeConst(TensorFlow.TFOutput,System.String)">GuaranteeConst(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Gives a guarantee to the TF runtime that the input tensor is a constant.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput GuaranteeConst (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;GuaranteeConst&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_GuaranteeConst_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The runtime is then free to make optimizations based on this.</p>
<pre><code>          Only accepts value typed tensors as inputs and rejects resource variable handles
          as input.

          Returns the input tensor without modification.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_HashTable_" data-uid="TensorFlow.TFGraph.HashTable*"></a>
  <h4 id="TensorFlow_TFGraph_HashTable_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.HashTable(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)">HashTable(TFDataType, TFDataType, String, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Creates a non-initialized hash table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput HashTable (TensorFlow.TFDataType key_dtype, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable&lt;bool&gt; use_node_name_sharing = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">key_dtype</span></td>
        <td><p>Type of the table keys.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">value_dtype</span></td>
        <td><p>Type of the table values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_node_name_sharing</span></td>
        <td><p>Optional argument
              If true and shared_name is empty, the table is shared
              using the node name.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;HashTable&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_HashTable_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op creates a hash table, specifying the type of its keys and values.
              Before using the table you will have to initialize it.  After initialization the
              table will be immutable.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_HashTableV2_" data-uid="TensorFlow.TFGraph.HashTableV2*"></a>
  <h4 id="TensorFlow_TFGraph_HashTableV2_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.HashTableV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)">HashTableV2(TFDataType, TFDataType, String, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Creates a non-initialized hash table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput HashTableV2 (TensorFlow.TFDataType key_dtype, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable&lt;bool&gt; use_node_name_sharing = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">key_dtype</span></td>
        <td><p>Type of the table keys.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">value_dtype</span></td>
        <td><p>Type of the table values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_node_name_sharing</span></td>
        <td><p>Optional argument
              If true and shared_name is empty, the table is shared
              using the node name.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;HashTableV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_HashTableV2_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op creates a hash table, specifying the type of its keys and values.
              Before using the table you will have to initialize it.  After initialization the
              table will be immutable.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_HistogramFixedWidth_" data-uid="TensorFlow.TFGraph.HistogramFixedWidth*"></a>
  <h4 id="TensorFlow_TFGraph_HistogramFixedWidth_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.HistogramFixedWidth(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">HistogramFixedWidth(TFOutput, TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Return histogram of values.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput HistogramFixedWidth (TensorFlow.TFOutput values, TensorFlow.TFOutput value_range, TensorFlow.TFOutput nbins, Nullable&lt;TensorFlow.TFDataType&gt; dtype = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>Numeric <code>Tensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value_range</span></td>
        <td><p>Shape [2] <code>Tensor</code> of same <code>dtype</code> as <code>values</code>.
              values &lt;= value_range[0] will be mapped to hist[0],
              values &gt;= value_range[1] will be mapped to hist[-1].</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">nbins</span></td>
        <td><p>Scalar <code>int32 Tensor</code>.  Number of histogram bins.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">dtype</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;HistogramFixedWidth&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A 1-D <code>Tensor</code> holding histogram of values.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_HistogramFixedWidth_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given the tensor <code>values</code>, this operation returns a rank 1 histogram counting
              the number of entries in <code>values</code> that fall into every bin.  The bins are
              equal width and determined by the arguments <code>value_range</code> and <code>nbins</code>.</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          # Bins will be:  (-inf, 1), [1, 2), [2, 3), [3, 4), [4, inf)
          nbins = 5
          value_range = [0.0, 5.0]
          new_values = [-1.0, 0.0, 1.5, 2.0, 5.0, 15]

          with tf.get_default_session() as sess:
          hist = tf.histogram_fixed_width(new_values, value_range, nbins=5)
          variables.global_variables_initializer().run()
          sess.run(hist) =&amp;gt; [2, 1, 1, 0, 2]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_HistogramSummary_" data-uid="TensorFlow.TFGraph.HistogramSummary*"></a>
  <h4 id="TensorFlow_TFGraph_HistogramSummary_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.HistogramSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">HistogramSummary(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Outputs a <code>Summary</code> protocol buffer with a histogram.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput HistogramSummary (TensorFlow.TFOutput tag, TensorFlow.TFOutput values, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tag</span></td>
        <td><p>Scalar.  Tag to use for the <code>Summary.Value</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>Any shape. Values to use to build the histogram.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;HistogramSummary&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Scalar. Serialized <code>Summary</code> protocol buffer.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_HistogramSummary_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The generated
              <a href="https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto"><code>Summary</code></a>
              has one summary value containing a histogram for <code>values</code>.</p>
<pre><code>          This op reports an &lt;code&gt;InvalidArgument&lt;/code&gt; error if any value is not finite.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_HostConst_" data-uid="TensorFlow.TFGraph.HostConst*"></a>
  <h4 id="TensorFlow_TFGraph_HostConst_TensorFlow_TFTensor_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.HostConst(TensorFlow.TFTensor,TensorFlow.TFDataType,System.String)">HostConst(TFTensor, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Returns a constant tensor on the host. Only for writing C++ tests.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput HostConst (TensorFlow.TFTensor value, TensorFlow.TFDataType dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFTensor.html">TFTensor</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>Attr <code>value</code> is the tensor to return.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;HostConst&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_HSVToRGB_" data-uid="TensorFlow.TFGraph.HSVToRGB*"></a>
  <h4 id="TensorFlow_TFGraph_HSVToRGB_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.HSVToRGB(TensorFlow.TFOutput,System.String)">HSVToRGB(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Convert one or more images from HSV to RGB.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput HSVToRGB (TensorFlow.TFOutput images, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">images</span></td>
        <td><p>1-D or higher rank. HSV data to convert. Last dimension must be size 3.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;HSVToRGB&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p><code>images</code> converted to RGB.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_HSVToRGB_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Outputs a tensor of the same shape as the <code>images</code> tensor, containing the RGB
              value of the pixels. The output is only well defined if the value in <code>images</code>
              are in <code>[0,1]</code>.</p>
<pre><code>          See &lt;code&gt;rgb_to_hsv&lt;/code&gt; for a description of the HSV encoding.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Identity_" data-uid="TensorFlow.TFGraph.Identity*"></a>
  <h4 id="TensorFlow_TFGraph_Identity_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Identity(TensorFlow.TFOutput,System.String)">Identity(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Return a tensor with the same shape and contents as the input tensor or value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Identity (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Identity&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_IdentityN_" data-uid="TensorFlow.TFGraph.IdentityN*"></a>
  <h4 id="TensorFlow_TFGraph_IdentityN_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.IdentityN(TensorFlow.TFOutput[],System.String)">IdentityN(TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Returns a list of tensors with the same shapes and contents as the input</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] IdentityN (TensorFlow.TFOutput[] input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IdentityN&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IdentityN_TensorFlow_TFOutput___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>tensors.</p>
<pre><code>          This op can be used to override the gradient for complicated functions. For
          example, suppose y = f(x) and we wish to apply a custom function g for backprop
          such that dx = g(dy). In Python,

           &lt;pre&gt;&lt;code&gt;
          with tf.get_default_graph().gradient_override_map(
          {&#39;IdentityN&#39;: &#39;OverrideGradientWithG&#39;}):
          y, _ = identity_n([f(x), x])

          @tf.RegisterGradient(&#39;OverrideGradientWithG&#39;)
          def ApplyG(op, dy, _):
          return [None, g(dy)]  # Do not backprop to f(x).
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_IdentityReader_" data-uid="TensorFlow.TFGraph.IdentityReader*"></a>
  <h4 id="TensorFlow_TFGraph_IdentityReader_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.IdentityReader(System.String,System.String,System.String)">IdentityReader(String, String, String)</h4>
  <div class="markdown level1 summary"><p>A Reader that outputs the queued work as both the key and value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IdentityReader (string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IdentityReader&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IdentityReader_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>To use, enqueue strings in a Queue.  ReaderRead will take the front
              work string and output (work, work).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_IdentityReaderV2_" data-uid="TensorFlow.TFGraph.IdentityReaderV2*"></a>
  <h4 id="TensorFlow_TFGraph_IdentityReaderV2_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.IdentityReaderV2(System.String,System.String,System.String)">IdentityReaderV2(String, String, String)</h4>
  <div class="markdown level1 summary"><p>A Reader that outputs the queued work as both the key and value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IdentityReaderV2 (string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IdentityReaderV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IdentityReaderV2_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>To use, enqueue strings in a Queue.  ReaderRead will take the front
              work string and output (work, work).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_IFFT_" data-uid="TensorFlow.TFGraph.IFFT*"></a>
  <h4 id="TensorFlow_TFGraph_IFFT_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IFFT(TensorFlow.TFOutput,System.String)">IFFT(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Inverse fast Fourier transform.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IFFT (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A complex tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IFFT&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A complex tensor of the same shape as <code>input</code>. The inner-most
              dimension of <code>input</code> is replaced with its inverse 1D Fourier transform.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.fft.ifft
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IFFT_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the inverse 1-dimensional discrete Fourier transform over the
              inner-most dimension of <code>input</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_IFFT2D_" data-uid="TensorFlow.TFGraph.IFFT2D*"></a>
  <h4 id="TensorFlow_TFGraph_IFFT2D_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IFFT2D(TensorFlow.TFOutput,System.String)">IFFT2D(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Inverse 2D fast Fourier transform.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IFFT2D (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A complex tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IFFT2D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A complex tensor of the same shape as <code>input</code>. The inner-most 2
              dimensions of <code>input</code> are replaced with their inverse 2D Fourier transform.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.fft.ifft2
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IFFT2D_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the inverse 2-dimensional discrete Fourier transform over the
              inner-most 2 dimensions of <code>input</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_IFFT3D_" data-uid="TensorFlow.TFGraph.IFFT3D*"></a>
  <h4 id="TensorFlow_TFGraph_IFFT3D_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IFFT3D(TensorFlow.TFOutput,System.String)">IFFT3D(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Inverse 3D fast Fourier transform.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IFFT3D (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A complex64 tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IFFT3D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A complex64 tensor of the same shape as <code>input</code>. The inner-most 3
              dimensions of <code>input</code> are replaced with their inverse 3D Fourier transform.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.fft.ifftn with 3 dimensions.
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IFFT3D_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the inverse 3-dimensional discrete Fourier transform over the
              inner-most 3 dimensions of <code>input</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Igamma_" data-uid="TensorFlow.TFGraph.Igamma*"></a>
  <h4 id="TensorFlow_TFGraph_Igamma_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Igamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Igamma(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Compute the lower regularized incomplete Gamma function <code>P(a, x)</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Igamma (TensorFlow.TFOutput a, TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Igamma&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Igamma_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The lower regularized incomplete Gamma function is defined as:</p>
<pre><code>          \\(P(a, x) = gamma(a, x) / Gamma(a) = 1 - Q(a, x)\\)

          where

          \\(gamma(a, x) = \\int_{0}^{x} t^{a-1} exp(-t) dt\\)

          is the lower incomplete Gamma function.

          Note, above &lt;code&gt;Q(a, x)&lt;/code&gt; (&lt;code&gt;Igammac&lt;/code&gt;) is the upper regularized complete
          Gamma function.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Igammac_" data-uid="TensorFlow.TFGraph.Igammac*"></a>
  <h4 id="TensorFlow_TFGraph_Igammac_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Igammac(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Igammac(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Compute the upper regularized incomplete Gamma function <code>Q(a, x)</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Igammac (TensorFlow.TFOutput a, TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Igammac&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Igammac_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The upper regularized incomplete Gamma function is defined as:</p>
<pre><code>          \\(Q(a, x) = Gamma(a, x) / Gamma(a) = 1 - P(a, x)\\)

          where

          \\(Gamma(a, x) = int_{x}^{\infty} t^{a-1} exp(-t) dt\\)

          is the upper incomplete Gama function.

          Note, above &lt;code&gt;P(a, x)&lt;/code&gt; (&lt;code&gt;Igamma&lt;/code&gt;) is the lower regularized complete
          Gamma function.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_IgammaGradA_" data-uid="TensorFlow.TFGraph.IgammaGradA*"></a>
  <h4 id="TensorFlow_TFGraph_IgammaGradA_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IgammaGradA(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">IgammaGradA(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradient of <code>igamma(a, x)</code> wrt <code>a</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IgammaGradA (TensorFlow.TFOutput a, TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IgammaGradA&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Imag_" data-uid="TensorFlow.TFGraph.Imag*"></a>
  <h4 id="TensorFlow_TFGraph_Imag_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.Imag(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">Imag(TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns the imaginary part of a complex number.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Imag (TensorFlow.TFOutput input, Nullable&lt;TensorFlow.TFDataType&gt; Tout = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">Tout</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Imag&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Imag_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of
              type <code>float</code> that is the imaginary part of each element in <code>input</code>. All
              elements in <code>input</code> must be complex numbers of the form \(a + bj\), where <em>a</em>
              is the real part and <em>b</em> is the imaginary part returned by this operation.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          # tensor &#39;input&#39; is [-2.25 + 4.75j, 3.25 + 5.75j]
          tf.imag(input) ==&amp;gt; [4.75, 5.75]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ImageSummary_" data-uid="TensorFlow.TFGraph.ImageSummary*"></a>
  <h4 id="TensorFlow_TFGraph_ImageSummary_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__TensorFlow_TFTensor_System_String_" data-uid="TensorFlow.TFGraph.ImageSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},TensorFlow.TFTensor,System.String)">ImageSummary(TFOutput, TFOutput, Nullable&lt;Int64&gt;, TFTensor, String)</h4>
  <div class="markdown level1 summary"><p>Outputs a <code>Summary</code> protocol buffer with images.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ImageSummary (TensorFlow.TFOutput tag, TensorFlow.TFOutput tensor, Nullable&lt;long&gt; max_images = null, TensorFlow.TFTensor bad_color = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tag</span></td>
        <td><p>Scalar. Used to build the <code>tag</code> attribute of the summary values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>4-D of shape <code>[batch_size, height, width, channels]</code> where
              <code>channels</code> is 1, 3, or 4.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">max_images</span></td>
        <td><p>Optional argument
              Max number of batch elements to generate images for.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFTensor.html">TFTensor</a></td>
        <td><span class="parametername">bad_color</span></td>
        <td><p>Optional argument
              Color to use for pixels with non-finite values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ImageSummary&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Scalar. Serialized <code>Summary</code> protocol buffer.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ImageSummary_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__TensorFlow_TFTensor_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The summary has up to <code>max_images</code> summary values containing images. The
              images are built from <code>tensor</code> which must be 4-D with shape <code>[batch_size,
              height, width, channels]</code> and where <code>channels</code> can be:</p>
<pre><code>          *  1: &lt;code&gt;tensor&lt;/code&gt; is interpreted as Grayscale.
          *  3: &lt;code&gt;tensor&lt;/code&gt; is interpreted as RGB.
          *  4: &lt;code&gt;tensor&lt;/code&gt; is interpreted as RGBA.

          The images have the same number of channels as the input tensor. For float
          input, the values are normalized one image at a time to fit in the range
          &lt;code&gt;[0, 255]&lt;/code&gt;.  &lt;code&gt;uint8&lt;/code&gt; values are unchanged.  The op uses two different
          normalization algorithms:

          *  If the input values are all positive, they are rescaled so the largest one
          is 255.

          *  If any input value is negative, the values are shifted so input value 0.0
          is at 127.  They are then rescaled so that either the smallest value is 0,
          or the largest one is 255.

          The &lt;code&gt;tag&lt;/code&gt; argument is a scalar &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;.  It is used to
          build the &lt;code&gt;tag&lt;/code&gt; of the summary values:

          *  If &lt;code&gt;max_images&lt;/code&gt; is 1, the summary value tag is &#39;*tag*/image&#39;.
          *  If &lt;code&gt;max_images&lt;/code&gt; is greater than 1, the summary value tags are
          generated sequentially as &#39;*tag*/image/0&#39;, &#39;*tag*/image/1&#39;, etc.

          The &lt;code&gt;bad_color&lt;/code&gt; argument is the color to use in the generated images for
          non-finite input values.  It is a &lt;code&gt;uint8&lt;/code&gt; 1-D tensor of length &lt;code&gt;channels&lt;/code&gt;.
          Each element must be in the range &lt;code&gt;[0, 255]&lt;/code&gt; (It represents the value of a
          pixel in the output image).  Non-finite values in the input tensor are
          replaced by this tensor in the output image.  The default value is the color
          red.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ImmutableConst_" data-uid="TensorFlow.TFGraph.ImmutableConst*"></a>
  <h4 id="TensorFlow_TFGraph_ImmutableConst_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_System_String_" data-uid="TensorFlow.TFGraph.ImmutableConst(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String)">ImmutableConst(TFDataType, TFShape, String, String)</h4>
  <div class="markdown level1 summary"><p>Returns immutable tensor from memory region.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ImmutableConst (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string memory_region_name, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>Type of the returned tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>Shape of the returned tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">memory_region_name</span></td>
        <td><p>Name of readonly memory region used by the tensor, see
              NewReadOnlyMemoryRegionFromFile in tensorflow::Env.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ImmutableConst&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ImmutableConst_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The current implementation memmaps the tensor from a file.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Import_" data-uid="TensorFlow.TFGraph.Import*"></a>
  <h4 id="TensorFlow_TFGraph_Import_System_Byte___System_String_TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.Import(System.Byte[],System.String,TensorFlow.TFStatus)">Import(Byte[], String, TFStatus)</h4>
  <div class="markdown level1 summary"><p>Import a serialized graph held in a byte array into this graph, using the specified prefix.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Import (byte[] buffer, string prefix = &quot;&quot;, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Byte</span>[]</td>
        <td><span class="parametername">buffer</span></td>
        <td><p>A byte array containing the serialized graph.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">prefix</span></td>
        <td><p>A prefix that will be prepended to names of nodes in the graph when they are imported into the graph.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Import_" data-uid="TensorFlow.TFGraph.Import*"></a>
  <h4 id="TensorFlow_TFGraph_Import_System_Byte___TensorFlow_TFImportGraphDefOptions_TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.Import(System.Byte[],TensorFlow.TFImportGraphDefOptions,TensorFlow.TFStatus)">Import(Byte[], TFImportGraphDefOptions, TFStatus)</h4>
  <div class="markdown level1 summary"><p>Import a serialized graph held in a byte array into this graph, using the specified import options.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Import (byte[] buffer, TensorFlow.TFImportGraphDefOptions options, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Byte</span>[]</td>
        <td><span class="parametername">buffer</span></td>
        <td><p>A byte array containing the serialized graph.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFImportGraphDefOptions.html">TFImportGraphDefOptions</a></td>
        <td><span class="parametername">options</span></td>
        <td><p>Importing graph options.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Import_System_Byte___TensorFlow_TFImportGraphDefOptions_TensorFlow_TFStatus__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If you are tryig to load a file stored using the SavedModel file format, you should use the <span class="xref">TensorFlow.TFSession.FromSavedModel</span> API instead.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Import_" data-uid="TensorFlow.TFGraph.Import*"></a>
  <h4 id="TensorFlow_TFGraph_Import_TensorFlow_TFBuffer_System_String_TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.Import(TensorFlow.TFBuffer,System.String,TensorFlow.TFStatus)">Import(TFBuffer, String, TFStatus)</h4>
  <div class="markdown level1 summary"><p>Import a serialized graph into this graph, using the specified prefix.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Import (TensorFlow.TFBuffer graphDef, string prefix = &quot;&quot;, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFBuffer.html">TFBuffer</a></td>
        <td><span class="parametername">graphDef</span></td>
        <td><p>A buffer containing the serialized graph.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">prefix</span></td>
        <td><p>A prefix that will be prepended to names of nodes in the <code>graphDef</code> when they are imported into the graph.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Import_" data-uid="TensorFlow.TFGraph.Import*"></a>
  <h4 id="TensorFlow_TFGraph_Import_TensorFlow_TFBuffer_TensorFlow_TFImportGraphDefOptions_TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.Import(TensorFlow.TFBuffer,TensorFlow.TFImportGraphDefOptions,TensorFlow.TFStatus)">Import(TFBuffer, TFImportGraphDefOptions, TFStatus)</h4>
  <div class="markdown level1 summary"><p>Import a serialized graph into this graph, using the specified importing options.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Import (TensorFlow.TFBuffer graphDef, TensorFlow.TFImportGraphDefOptions options, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFBuffer.html">TFBuffer</a></td>
        <td><span class="parametername">graphDef</span></td>
        <td><p>A buffer containing the serialized graph.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFImportGraphDefOptions.html">TFImportGraphDefOptions</a></td>
        <td><span class="parametername">options</span></td>
        <td><p>Importing graph options.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ImportGraphDef_" data-uid="TensorFlow.TFGraph.ImportGraphDef*"></a>
  <h4 id="TensorFlow_TFGraph_ImportGraphDef_TensorFlow_TFBuffer_TensorFlow_TFImportGraphDefOptions_TensorFlow_TFOutput___TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.ImportGraphDef(TensorFlow.TFBuffer,TensorFlow.TFImportGraphDefOptions,TensorFlow.TFOutput[],TensorFlow.TFStatus)">ImportGraphDef(TFBuffer, TFImportGraphDefOptions, TFOutput[], TFStatus)</h4>
  <div class="markdown level1 summary"><p>Imports a graph serialized into the graph</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void ImportGraphDef (TensorFlow.TFBuffer graphDef, TensorFlow.TFImportGraphDefOptions options, TensorFlow.TFOutput[] returnOutputs, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFBuffer.html">TFBuffer</a></td>
        <td><span class="parametername">graphDef</span></td>
        <td><p>Serialized graph definition (in protocol buffer format).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFImportGraphDefOptions.html">TFImportGraphDefOptions</a></td>
        <td><span class="parametername">options</span></td>
        <td><p>Import options.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">returnOutputs</span></td>
        <td><p>Array large enough to contain all the return options.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ImportGraphDef_TensorFlow_TFBuffer_TensorFlow_TFImportGraphDefOptions_TensorFlow_TFOutput___TensorFlow_TFStatus__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If you are tryig to load a file stored using the SavedModel file format, you should use the <span class="xref">TensorFlow.TFSession.FromSavedModel</span> API instead.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_InfeedDequeue_" data-uid="TensorFlow.TFGraph.InfeedDequeue*"></a>
  <h4 id="TensorFlow_TFGraph_InfeedDequeue_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.InfeedDequeue(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">InfeedDequeue(TFDataType, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>A placeholder op for a value that will be fed into the computation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput InfeedDequeue (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of elements in the tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InfeedDequeue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor that will be provided using the infeed mechanism.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_InfeedDequeueTuple_" data-uid="TensorFlow.TFGraph.InfeedDequeueTuple*"></a>
  <h4 id="TensorFlow_TFGraph_InfeedDequeueTuple_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.InfeedDequeueTuple(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">InfeedDequeueTuple(TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>A placeholder op for multiple values that will be fed into the computation</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] InfeedDequeueTuple (TensorFlow.TFDataType[] dtypes, TensorFlow.TFShape[] shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>The element types of each element in <code>outputs</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>The shapes of each tensor in <code>outputs</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InfeedDequeueTuple&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>A list of tensors that will be provided using the infeed mechanism.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_InfeedDequeueTuple_TensorFlow_TFDataType___TensorFlow_TFShape___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>simultaneously as an XLA tuple.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_InfeedEnqueue_" data-uid="TensorFlow.TFGraph.InfeedEnqueue*"></a>
  <h4 id="TensorFlow_TFGraph_InfeedEnqueue_TensorFlow_TFOutput_TensorFlow_TFShape_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.InfeedEnqueue(TensorFlow.TFOutput,TensorFlow.TFShape,System.Nullable{System.Int64},System.String)">InfeedEnqueue(TFOutput, TFShape, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>An op which feeds a single Tensor value into the computation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation InfeedEnqueue (TensorFlow.TFOutput input, TensorFlow.TFShape shape = null, Nullable&lt;long&gt; device_ordinal = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A tensor that will be provided using the infeed mechanism.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>Optional argument
              The shape of the tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">device_ordinal</span></td>
        <td><p>Optional argument
              The TPU device to use. This should be -1 when the Op
              is running on a TPU device, and &gt;= 0 when the Op is running on the CPU
              device.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InfeedEnqueue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_InfeedEnqueueTuple_" data-uid="TensorFlow.TFGraph.InfeedEnqueueTuple*"></a>
  <h4 id="TensorFlow_TFGraph_InfeedEnqueueTuple_TensorFlow_TFOutput___TensorFlow_TFShape___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.InfeedEnqueueTuple(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String)">InfeedEnqueueTuple(TFOutput[], TFShape[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>An op which feeds multiple Tensor values into the computation as an XLA tuple.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation InfeedEnqueueTuple (TensorFlow.TFOutput[] inputs, TensorFlow.TFShape[] shapes, Nullable&lt;long&gt; device_ordinal = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>A list of tensors that will be provided using the infeed mechanism.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>The shapes of each tensor in <code>inputs</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">device_ordinal</span></td>
        <td><p>Optional argument
              The TPU device to use. This should be -1 when the Op
              is running on a TPU device, and &gt;= 0 when the Op is running on the CPU
              device.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InfeedEnqueueTuple&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_InitializeTable_" data-uid="TensorFlow.TFGraph.InitializeTable*"></a>
  <h4 id="TensorFlow_TFGraph_InitializeTable_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.InitializeTable(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">InitializeTable(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Table initializer that takes two tensors for keys and values respectively.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation InitializeTable (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to a table which will be initialized.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">keys</span></td>
        <td><p>Keys of type Tkey.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>Values of type Tval.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InitializeTable&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_InitializeTableFromTextFile_" data-uid="TensorFlow.TFGraph.InitializeTableFromTextFile*"></a>
  <h4 id="TensorFlow_TFGraph_InitializeTableFromTextFile_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.InitializeTableFromTextFile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">InitializeTableFromTextFile(TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Initializes a table from a text file.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation InitializeTableFromTextFile (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput filename, long key_index, long value_index, Nullable&lt;long&gt; vocab_size = null, string delimiter = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to a table which will be initialized.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filename</span></td>
        <td><p>Filename of a vocabulary text file.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">key_index</span></td>
        <td><p>Column index in a line to get the table <code>key</code> values from.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">value_index</span></td>
        <td><p>Column index that represents information of a line to get the table
              <code>value</code> values from.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">vocab_size</span></td>
        <td><p>Optional argument
              Number of elements of the file, use -1 if unknown.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">delimiter</span></td>
        <td><p>Optional argument
              Delimiter to separate fields in a line.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InitializeTableFromTextFile&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_InitializeTableFromTextFile_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>It inserts one key-value pair into the table for each line of the file.
              The key and value is extracted from the whole line content, elements from the
              split line based on <code>delimiter</code> or the line number (starting from zero).
              Where to extract the key and value from a line is specified by <code>key_index</code> and
              <code>value_index</code>.</p>
<pre><code>          - A value of -1 means use the line number(starting from zero), expects &lt;code&gt;int64&lt;/code&gt;.
          - A value of -2 means use the whole line content, expects &lt;code&gt;string&lt;/code&gt;.
          - A value &amp;gt;= 0 means use the index (starting at zero) of the split line based
          on &lt;code&gt;delimiter&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_InitializeTableFromTextFileV2_" data-uid="TensorFlow.TFGraph.InitializeTableFromTextFileV2*"></a>
  <h4 id="TensorFlow_TFGraph_InitializeTableFromTextFileV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.InitializeTableFromTextFileV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">InitializeTableFromTextFileV2(TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Initializes a table from a text file.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation InitializeTableFromTextFileV2 (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput filename, long key_index, long value_index, Nullable&lt;long&gt; vocab_size = null, string delimiter = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to a table which will be initialized.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filename</span></td>
        <td><p>Filename of a vocabulary text file.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">key_index</span></td>
        <td><p>Column index in a line to get the table <code>key</code> values from.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">value_index</span></td>
        <td><p>Column index that represents information of a line to get the table
              <code>value</code> values from.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">vocab_size</span></td>
        <td><p>Optional argument
              Number of elements of the file, use -1 if unknown.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">delimiter</span></td>
        <td><p>Optional argument
              Delimiter to separate fields in a line.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InitializeTableFromTextFileV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_InitializeTableFromTextFileV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>It inserts one key-value pair into the table for each line of the file.
              The key and value is extracted from the whole line content, elements from the
              split line based on <code>delimiter</code> or the line number (starting from zero).
              Where to extract the key and value from a line is specified by <code>key_index</code> and
              <code>value_index</code>.</p>
<pre><code>          - A value of -1 means use the line number(starting from zero), expects &lt;code&gt;int64&lt;/code&gt;.
          - A value of -2 means use the whole line content, expects &lt;code&gt;string&lt;/code&gt;.
          - A value &amp;gt;= 0 means use the index (starting at zero) of the split line based
          on &lt;code&gt;delimiter&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_InitializeTableV2_" data-uid="TensorFlow.TFGraph.InitializeTableV2*"></a>
  <h4 id="TensorFlow_TFGraph_InitializeTableV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.InitializeTableV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">InitializeTableV2(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Table initializer that takes two tensors for keys and values respectively.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation InitializeTableV2 (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to a table which will be initialized.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">keys</span></td>
        <td><p>Keys of type Tkey.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>Values of type Tval.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InitializeTableV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_InplaceAdd_" data-uid="TensorFlow.TFGraph.InplaceAdd*"></a>
  <h4 id="TensorFlow_TFGraph_InplaceAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.InplaceAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">InplaceAdd(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Adds v into specified rows of x.</p>
<pre><code>          Computes y = x; y[i, :] += v; return y.
</code></pre></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput InplaceAdd (TensorFlow.TFOutput x, TensorFlow.TFOutput i, TensorFlow.TFOutput v, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>A <code>Tensor</code> of type T.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">i</span></td>
        <td><p>A vector. Indices into the left-most dimension of <code>x</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">v</span></td>
        <td><p>A <code>Tensor</code> of type T. Same dimension sizes as x except the first dimension, which must be the same as i&#39;s size.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InplaceAdd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A <code>Tensor</code> of type T. An alias of <code>x</code>. The content of <code>y</code> is undefined if there are duplicates in <code>i</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_InplaceSub_" data-uid="TensorFlow.TFGraph.InplaceSub*"></a>
  <h4 id="TensorFlow_TFGraph_InplaceSub_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.InplaceSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">InplaceSub(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Subtracts <code>v</code> into specified rows of <code>x</code>.</p>
<pre><code>          Computes y = x; y[i, :] -= v; return y.
</code></pre></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput InplaceSub (TensorFlow.TFOutput x, TensorFlow.TFOutput i, TensorFlow.TFOutput v, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>A <code>Tensor</code> of type T.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">i</span></td>
        <td><p>A vector. Indices into the left-most dimension of <code>x</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">v</span></td>
        <td><p>A <code>Tensor</code> of type T. Same dimension sizes as x except the first dimension, which must be the same as i&#39;s size.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InplaceSub&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A <code>Tensor</code> of type T. An alias of <code>x</code>. The content of <code>y</code> is undefined if there are duplicates in <code>i</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_InplaceUpdate_" data-uid="TensorFlow.TFGraph.InplaceUpdate*"></a>
  <h4 id="TensorFlow_TFGraph_InplaceUpdate_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.InplaceUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">InplaceUpdate(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Updates specified rows with values in <code>v</code>.</p>
<pre><code>          Computes &lt;code&gt;x[i, :] = v; return x&lt;/code&gt;.
</code></pre></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput InplaceUpdate (TensorFlow.TFOutput x, TensorFlow.TFOutput i, TensorFlow.TFOutput v, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>A tensor of type <code>T</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">i</span></td>
        <td><p>A vector. Indices into the left-most dimension of <code>x</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">v</span></td>
        <td><p>A <code>Tensor</code> of type T. Same dimension sizes as x except the first dimension, which must be the same as i&#39;s size.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InplaceUpdate&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A <code>Tensor</code> of type T. An alias of <code>x</code>. The content of <code>y</code> is undefined if there are duplicates in <code>i</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_InTopK_" data-uid="TensorFlow.TFGraph.InTopK*"></a>
  <h4 id="TensorFlow_TFGraph_InTopK_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.InTopK(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">InTopK(TFOutput, TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>Says whether the targets are in the top <code>K</code> predictions.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput InTopK (TensorFlow.TFOutput predictions, TensorFlow.TFOutput targets, long k, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">predictions</span></td>
        <td><p>A <code>batch_size</code> x <code>classes</code> tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">targets</span></td>
        <td><p>A <code>batch_size</code> vector of class ids.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">k</span></td>
        <td><p>Number of top elements to look at for computing precision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InTopK&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Computed Precision at <code>k</code> as a <code>bool Tensor</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_InTopK_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This outputs a <code>batch_size</code> bool array, an entry <code>out[i]</code> is <code>true</code> if the
              prediction for the target class is among the top <code>k</code> predictions among
              all predictions for example <code>i</code>. Note that the behavior of <code>InTopK</code> differs
              from the <code>TopK</code> op in its handling of ties; if multiple classes have the
              same prediction value and straddle the top-<code>k</code> boundary, all of those
              classes are considered to be in the top <code>k</code>.</p>
<pre><code>          More formally, let

          \\(predictions_i\\) be the predictions for all classes for example &lt;code&gt;i&lt;/code&gt;,
          \\(targets_i\\) be the target class for example &lt;code&gt;i&lt;/code&gt;,
          \\(out_i\\) be the output for example &lt;code&gt;i&lt;/code&gt;,

          $$out_i = predictions_{i, targets_i} \in TopKIncludingTies(predictions_i)$$
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_InTopKV2_" data-uid="TensorFlow.TFGraph.InTopKV2*"></a>
  <h4 id="TensorFlow_TFGraph_InTopKV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.InTopKV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">InTopKV2(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Says whether the targets are in the top <code>K</code> predictions.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput InTopKV2 (TensorFlow.TFOutput predictions, TensorFlow.TFOutput targets, TensorFlow.TFOutput k, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">predictions</span></td>
        <td><p>A <code>batch_size</code> x <code>classes</code> tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">targets</span></td>
        <td><p>A <code>batch_size</code> vector of class ids.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">k</span></td>
        <td><p>Number of top elements to look at for computing precision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InTopKV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Computed precision at <code>k</code> as a <code>bool Tensor</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_InTopKV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This outputs a <code>batch_size</code> bool array, an entry <code>out[i]</code> is <code>true</code> if the
              prediction for the target class is among the top <code>k</code> predictions among
              all predictions for example <code>i</code>. Note that the behavior of <code>InTopK</code> differs
              from the <code>TopK</code> op in its handling of ties; if multiple classes have the
              same prediction value and straddle the top-<code>k</code> boundary, all of those
              classes are considered to be in the top <code>k</code>.</p>
<pre><code>          More formally, let

          \\(predictions_i\\) be the predictions for all classes for example &lt;code&gt;i&lt;/code&gt;,
          \\(targets_i\\) be the target class for example &lt;code&gt;i&lt;/code&gt;,
          \\(out_i\\) be the output for example &lt;code&gt;i&lt;/code&gt;,

          $$out_i = predictions_{i, targets_i} \in TopKIncludingTies(predictions_i)$$
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Inv_" data-uid="TensorFlow.TFGraph.Inv*"></a>
  <h4 id="TensorFlow_TFGraph_Inv_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Inv(TensorFlow.TFOutput,System.String)">Inv(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the reciprocal of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Inv (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Inv&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Inv_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>I.e., \(y = 1 / x\).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Invert_" data-uid="TensorFlow.TFGraph.Invert*"></a>
  <h4 id="TensorFlow_TFGraph_Invert_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Invert(TensorFlow.TFOutput,System.String)">Invert(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Flips all bits elementwise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Invert (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Invert&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Invert_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The result will have exactly those bits set, that are not set in <code>x</code>. The
              computation is performed on the underlying representation of x.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_InvertPermutation_" data-uid="TensorFlow.TFGraph.InvertPermutation*"></a>
  <h4 id="TensorFlow_TFGraph_InvertPermutation_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.InvertPermutation(TensorFlow.TFOutput,System.String)">InvertPermutation(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the inverse permutation of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput InvertPermutation (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>1-D.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InvertPermutation&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>1-D.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_InvertPermutation_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes the inverse of an index permutation. It takes a 1-D
              integer tensor <code>x</code>, which represents the indices of a zero-based array, and
              swaps each value with its index position. In other words, for an output tensor
              <code>y</code> and an input tensor <code>x</code>, this operation computes the following:</p>
<pre><code>          &lt;code&gt;y[x[i]] = i for i in [0, 1, ..., len(x) - 1]&lt;/code&gt;

          The values must include 0. There can be no duplicate values or negative values.

          For example:

           &lt;pre&gt;&lt;code&gt;
          # tensor &lt;code&gt;x&lt;/code&gt; is [3, 4, 0, 2, 1]
          invert_permutation(x) ==&amp;gt; [2, 4, 3, 0, 1]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_InvGrad_" data-uid="TensorFlow.TFGraph.InvGrad*"></a>
  <h4 id="TensorFlow_TFGraph_InvGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.InvGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">InvGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradient for the inverse of <code>x</code> wrt its input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput InvGrad (TensorFlow.TFOutput y, TensorFlow.TFOutput dy, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dy</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;InvGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_InvGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Specifically, <code>grad = -dy * y*y</code>, where <code>y = 1/x</code>, and <code>dy</code>
              is the corresponding input gradient.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_IRFFT_" data-uid="TensorFlow.TFGraph.IRFFT*"></a>
  <h4 id="TensorFlow_TFGraph_IRFFT_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IRFFT(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">IRFFT(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Inverse real-valued fast Fourier transform.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IRFFT (TensorFlow.TFOutput input, TensorFlow.TFOutput fft_length, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A complex64 tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">fft_length</span></td>
        <td><p>An int32 tensor of shape [1]. The FFT length.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IRFFT&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A float32 tensor of the same rank as <code>input</code>. The inner-most
              dimension of <code>input</code> is replaced with the <code>fft_length</code> samples of its inverse
              1D Fourier transform.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.fft.irfft
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IRFFT_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the inverse 1-dimensional discrete Fourier transform of a real-valued
              signal over the inner-most dimension of <code>input</code>.</p>
<pre><code>          The inner-most dimension of &lt;code&gt;input&lt;/code&gt; is assumed to be the result of &lt;code&gt;RFFT&lt;/code&gt;: the
          &lt;code&gt;fft_length / 2 + 1&lt;/code&gt; unique components of the DFT of a real-valued signal. If
          &lt;code&gt;fft_length&lt;/code&gt; is not provided, it is computed from the size of the inner-most
          dimension of &lt;code&gt;input&lt;/code&gt; (&lt;code&gt;fft_length = 2 * (inner - 1)&lt;/code&gt;). If the FFT length used to
          compute &lt;code&gt;input&lt;/code&gt; is odd, it should be provided since it cannot be inferred
          properly.

          Along the axis &lt;code&gt;IRFFT&lt;/code&gt; is computed on, if &lt;code&gt;fft_length / 2 + 1&lt;/code&gt; is smaller
          than the corresponding dimension of &lt;code&gt;input&lt;/code&gt;, the dimension is cropped. If it is
          larger, the dimension is padded with zeros.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_IRFFT2D_" data-uid="TensorFlow.TFGraph.IRFFT2D*"></a>
  <h4 id="TensorFlow_TFGraph_IRFFT2D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IRFFT2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">IRFFT2D(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Inverse 2D real-valued fast Fourier transform.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IRFFT2D (TensorFlow.TFOutput input, TensorFlow.TFOutput fft_length, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A complex64 tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">fft_length</span></td>
        <td><p>An int32 tensor of shape [2]. The FFT length for each dimension.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IRFFT2D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A float32 tensor of the same rank as <code>input</code>. The inner-most 2
              dimensions of <code>input</code> are replaced with the <code>fft_length</code> samples of their
              inverse 2D Fourier transform.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.fft.irfft2
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IRFFT2D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the inverse 2-dimensional discrete Fourier transform of a real-valued
              signal over the inner-most 2 dimensions of <code>input</code>.</p>
<pre><code>          The inner-most 2 dimensions of &lt;code&gt;input&lt;/code&gt; are assumed to be the result of &lt;code&gt;RFFT2D&lt;/code&gt;:
          The inner-most dimension contains the &lt;code&gt;fft_length / 2 + 1&lt;/code&gt; unique components of
          the DFT of a real-valued signal. If &lt;code&gt;fft_length&lt;/code&gt; is not provided, it is computed
          from the size of the inner-most 2 dimensions of &lt;code&gt;input&lt;/code&gt;. If the FFT length used
          to compute &lt;code&gt;input&lt;/code&gt; is odd, it should be provided since it cannot be inferred
          properly.

          Along each axis &lt;code&gt;IRFFT2D&lt;/code&gt; is computed on, if &lt;code&gt;fft_length&lt;/code&gt; (or
          &lt;code&gt;fft_length / 2 + 1&lt;/code&gt; for the inner-most dimension) is smaller than the
          corresponding dimension of &lt;code&gt;input&lt;/code&gt;, the dimension is cropped. If it is larger,
          the dimension is padded with zeros.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_IRFFT3D_" data-uid="TensorFlow.TFGraph.IRFFT3D*"></a>
  <h4 id="TensorFlow_TFGraph_IRFFT3D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IRFFT3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">IRFFT3D(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Inverse 3D real-valued fast Fourier transform.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IRFFT3D (TensorFlow.TFOutput input, TensorFlow.TFOutput fft_length, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A complex64 tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">fft_length</span></td>
        <td><p>An int32 tensor of shape [3]. The FFT length for each dimension.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IRFFT3D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A float32 tensor of the same rank as <code>input</code>. The inner-most 3
              dimensions of <code>input</code> are replaced with the <code>fft_length</code> samples of their
              inverse 3D real Fourier transform.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.irfftn with 3 dimensions.
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IRFFT3D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the inverse 3-dimensional discrete Fourier transform of a real-valued
              signal over the inner-most 3 dimensions of <code>input</code>.</p>
<pre><code>          The inner-most 3 dimensions of &lt;code&gt;input&lt;/code&gt; are assumed to be the result of &lt;code&gt;RFFT3D&lt;/code&gt;:
          The inner-most dimension contains the &lt;code&gt;fft_length / 2 + 1&lt;/code&gt; unique components of
          the DFT of a real-valued signal. If &lt;code&gt;fft_length&lt;/code&gt; is not provided, it is computed
          from the size of the inner-most 3 dimensions of &lt;code&gt;input&lt;/code&gt;. If the FFT length used
          to compute &lt;code&gt;input&lt;/code&gt; is odd, it should be provided since it cannot be inferred
          properly.

          Along each axis &lt;code&gt;IRFFT3D&lt;/code&gt; is computed on, if &lt;code&gt;fft_length&lt;/code&gt; (or
          &lt;code&gt;fft_length / 2 + 1&lt;/code&gt; for the inner-most dimension) is smaller than the
          corresponding dimension of &lt;code&gt;input&lt;/code&gt;, the dimension is cropped. If it is larger,
          the dimension is padded with zeros.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_IsBoostedTreesEnsembleInitialized_" data-uid="TensorFlow.TFGraph.IsBoostedTreesEnsembleInitialized*"></a>
  <h4 id="TensorFlow_TFGraph_IsBoostedTreesEnsembleInitialized_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IsBoostedTreesEnsembleInitialized(TensorFlow.TFOutput,System.String)">IsBoostedTreesEnsembleInitialized(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Checks whether a tree ensemble has been initialized.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IsBoostedTreesEnsembleInitialized (TensorFlow.TFOutput tree_ensemble_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tree_ensemble_handle</span></td>
        <td><p>Handle to the tree ensemble resouce.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IsBoostedTreesEnsembleInitialized&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>output boolean on whether it is initialized or not.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_IsBoostedTreesQuantileStreamResourceInitialized_" data-uid="TensorFlow.TFGraph.IsBoostedTreesQuantileStreamResourceInitialized*"></a>
  <h4 id="TensorFlow_TFGraph_IsBoostedTreesQuantileStreamResourceInitialized_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IsBoostedTreesQuantileStreamResourceInitialized(TensorFlow.TFOutput,System.String)">IsBoostedTreesQuantileStreamResourceInitialized(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Checks whether a quantile stream has been initialized.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IsBoostedTreesQuantileStreamResourceInitialized (TensorFlow.TFOutput quantile_stream_resource_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">quantile_stream_resource_handle</span></td>
        <td><p>resource; The reference to quantile stream resource handle.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IsBoostedTreesQuantileStreamResourceInitialized&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>bool; True if the resource is initialized, False otherwise.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IsBoostedTreesQuantileStreamResourceInitialized_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An Op that checks if quantile stream resource is initialized.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_IsFinite_" data-uid="TensorFlow.TFGraph.IsFinite*"></a>
  <h4 id="TensorFlow_TFGraph_IsFinite_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IsFinite(TensorFlow.TFOutput,System.String)">IsFinite(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns which elements of x are finite.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IsFinite (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IsFinite&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IsFinite_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>@compatibility(numpy)
              Equivalent to np.isfinite
              @end_compatibility</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_IsInf_" data-uid="TensorFlow.TFGraph.IsInf*"></a>
  <h4 id="TensorFlow_TFGraph_IsInf_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IsInf(TensorFlow.TFOutput,System.String)">IsInf(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns which elements of x are Inf.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IsInf (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IsInf&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IsInf_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>@compatibility(numpy)
              Equivalent to np.isinf
              @end_compatibility</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_IsNan_" data-uid="TensorFlow.TFGraph.IsNan*"></a>
  <h4 id="TensorFlow_TFGraph_IsNan_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IsNan(TensorFlow.TFOutput,System.String)">IsNan(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns which elements of x are NaN.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IsNan (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IsNan&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IsNan_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>@compatibility(numpy)
              Equivalent to np.isnan
              @end_compatibility</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_IsVariableInitialized_" data-uid="TensorFlow.TFGraph.IsVariableInitialized*"></a>
  <h4 id="TensorFlow_TFGraph_IsVariableInitialized_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IsVariableInitialized(TensorFlow.TFOutput,System.String)">IsVariableInitialized(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Checks whether a tensor has been initialized.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IsVariableInitialized (TensorFlow.TFOutput reference, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>Should be from a <code>Variable</code> node. May be uninitialized.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IsVariableInitialized&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IsVariableInitialized_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Outputs boolean scalar indicating whether the tensor has been initialized.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Iterator_" data-uid="TensorFlow.TFGraph.Iterator*"></a>
  <h4 id="TensorFlow_TFGraph_Iterator_System_String_System_String_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.Iterator(System.String,System.String,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">Iterator(String, String, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>A container for an iterator resource.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Iterator (string shared_name, string container, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Iterator&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A handle to the iterator that can be passed to a &quot;MakeIterator&quot;
              or &quot;IteratorGetNext&quot; op.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_IteratorFromStringHandle_" data-uid="TensorFlow.TFGraph.IteratorFromStringHandle*"></a>
  <h4 id="TensorFlow_TFGraph_IteratorFromStringHandle_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.IteratorFromStringHandle(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">IteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Converts the given string representing a handle to an iterator to a resource.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IteratorFromStringHandle (TensorFlow.TFOutput string_handle, TensorFlow.TFDataType[] output_types = null, TensorFlow.TFShape[] output_shapes = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">string_handle</span></td>
        <td><p>A string representation of the given handle.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>Optional argument
              If specified, defines the type of each tuple component in an
              element produced by the resulting iterator.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>Optional argument
              If specified, defines the shape of each tuple component in an
              element produced by the resulting iterator.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IteratorFromStringHandle&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A handle to an iterator resource.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_IteratorGetNext_" data-uid="TensorFlow.TFGraph.IteratorGetNext*"></a>
  <h4 id="TensorFlow_TFGraph_IteratorGetNext_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.IteratorGetNext(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">IteratorGetNext(TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Gets the next output from the given iterator .</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] IteratorGetNext (TensorFlow.TFOutput iterator, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">iterator</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IteratorGetNext&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_IteratorGetNextAsOptional_" data-uid="TensorFlow.TFGraph.IteratorGetNextAsOptional*"></a>
  <h4 id="TensorFlow_TFGraph_IteratorGetNextAsOptional_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.IteratorGetNextAsOptional(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">IteratorGetNextAsOptional(TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Gets the next output from the given iterator as an Optional variant.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IteratorGetNextAsOptional (TensorFlow.TFOutput iterator, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">iterator</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IteratorGetNextAsOptional&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_IteratorGetNextSync_" data-uid="TensorFlow.TFGraph.IteratorGetNextSync*"></a>
  <h4 id="TensorFlow_TFGraph_IteratorGetNextSync_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.IteratorGetNextSync(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">IteratorGetNextSync(TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Gets the next output from the given iterator.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] IteratorGetNextSync (TensorFlow.TFOutput iterator, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">iterator</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IteratorGetNextSync&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_IteratorGetNextSync_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation is a synchronous version IteratorGetNext. It should only be used
              in situations where the iterator does not block the calling thread, or where
              the calling thread is not a member of the thread pool used to execute parallel
              operations (e.g. in eager mode).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_IteratorToStringHandle_" data-uid="TensorFlow.TFGraph.IteratorToStringHandle*"></a>
  <h4 id="TensorFlow_TFGraph_IteratorToStringHandle_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.IteratorToStringHandle(TensorFlow.TFOutput,System.String)">IteratorToStringHandle(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Converts the given <code>resource_handle</code> representing an iterator to a string.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput IteratorToStringHandle (TensorFlow.TFOutput resource_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource_handle</span></td>
        <td><p>A handle to an iterator resource.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;IteratorToStringHandle&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A string representation of the given handle.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_L2Loss_" data-uid="TensorFlow.TFGraph.L2Loss*"></a>
  <h4 id="TensorFlow_TFGraph_L2Loss_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.L2Loss(TensorFlow.TFOutput,System.String)">L2Loss(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>L2 Loss.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput L2Loss (TensorFlow.TFOutput t, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">t</span></td>
        <td><p>Typically 2-D, but may have any dimensions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;L2Loss&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>0-D.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_L2Loss_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes half the L2 norm of a tensor without the <code>sqrt</code>:</p>
<pre><code>          output = sum(t ** 2) / 2
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LearnedUnigramCandidateSampler_" data-uid="TensorFlow.TFGraph.LearnedUnigramCandidateSampler*"></a>
  <h4 id="TensorFlow_TFGraph_LearnedUnigramCandidateSampler_TensorFlow_TFOutput_System_Int64_System_Int64_System_Boolean_System_Int64_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.LearnedUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">LearnedUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Generates labels for candidate sampling with a learned unigram distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; LearnedUnigramCandidateSampler (TensorFlow.TFOutput true_classes, long num_true, long num_sampled, bool unique, long range_max, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">true_classes</span></td>
        <td><p>A batch_size * num_true matrix, in which each row contains the
              IDs of the num_true target_classes in the corresponding original label.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_true</span></td>
        <td><p>Number of true labels per context.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_sampled</span></td>
        <td><p>Number of candidates to randomly sample.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">unique</span></td>
        <td><p>If unique is true, we sample with rejection, so that all sampled
              candidates in a batch are unique. This requires some approximation to
              estimate the post-rejection sampling probabilities.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">range_max</span></td>
        <td><p>The sampler will sample integers from the interval [0, range_max).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              An second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LearnedUnigramCandidateSampler&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sampled_candidates: A vector of length num_sampled, in which each element is
              the ID of a sampled candidate.
              true_expected_count: A batch_size * num_true matrix, representing
              the number of times each candidate is expected to occur in a batch
              of sampled candidates. If unique=true, then this is a probability.
              sampled_expected_count: A vector of length num_sampled, for each sampled
              candidate representing the number of times the candidate is expected
              to occur in a batch of sampled candidates.  If unique=true, then this is a
              probability.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LearnedUnigramCandidateSampler_TensorFlow_TFOutput_System_Int64_System_Int64_System_Boolean_System_Int64_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>See explanations of candidate sampling and the data formats at
              go/candidate-sampling.</p>
<pre><code>          For each batch, this op picks a single set of sampled candidate labels.

          The advantages of sampling candidates per-batch are simplicity and the
          possibility of efficient dense matrix multiplication. The disadvantage is that
          the sampled candidates must be chosen independently of the context and of the
          true labels.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LeftShift_" data-uid="TensorFlow.TFGraph.LeftShift*"></a>
  <h4 id="TensorFlow_TFGraph_LeftShift_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LeftShift(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">LeftShift(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Elementwise computes the bitwise left-shift of <code>x</code> and <code>y</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LeftShift (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LeftShift&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LeftShift_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If <code>y</code> is negative, or greater than or equal to the width of <code>x</code> in bits the
              result is implementation defined.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Less_" data-uid="TensorFlow.TFGraph.Less*"></a>
  <h4 id="TensorFlow_TFGraph_Less_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Less(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Less(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the truth value of (x &lt; y) element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Less (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Less&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Less_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>Less</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_LessEqual_" data-uid="TensorFlow.TFGraph.LessEqual*"></a>
  <h4 id="TensorFlow_TFGraph_LessEqual_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LessEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">LessEqual(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the truth value of (x &lt;= y) element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LessEqual (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LessEqual&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LessEqual_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>LessEqual</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Lgamma_" data-uid="TensorFlow.TFGraph.Lgamma*"></a>
  <h4 id="TensorFlow_TFGraph_Lgamma_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Lgamma(TensorFlow.TFOutput,System.String)">Lgamma(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the log of the absolute value of <code>Gamma(x)</code> element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Lgamma (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Lgamma&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_LinSpace_" data-uid="TensorFlow.TFGraph.LinSpace*"></a>
  <h4 id="TensorFlow_TFGraph_LinSpace_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LinSpace(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">LinSpace(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Generates values in an interval.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LinSpace (TensorFlow.TFOutput start, TensorFlow.TFOutput stop, TensorFlow.TFOutput num, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">start</span></td>
        <td><p>0-D tensor. First entry in the range.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">stop</span></td>
        <td><p>0-D tensor. Last entry in the range.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num</span></td>
        <td><p>0-D tensor. Number of values to generate.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LinSpace&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>1-D. The generated values.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LinSpace_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>A sequence of <code>num</code> evenly-spaced values are generated beginning at <code>start</code>.
              If <code>num &gt; 1</code>, the values in the sequence increase by <code>stop - start / num - 1</code>,
              so that the last one is exactly <code>stop</code>.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          tf.linspace(10.0, 12.0, 3, name=&quot;linspace&quot;) =&amp;gt; [ 10.0  11.0  12.0]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ListDiff_" data-uid="TensorFlow.TFGraph.ListDiff*"></a>
  <h4 id="TensorFlow_TFGraph_ListDiff_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.ListDiff(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">ListDiff(TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the difference between two lists of numbers or strings.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; ListDiff (TensorFlow.TFOutput x, TensorFlow.TFOutput y, Nullable&lt;TensorFlow.TFDataType&gt; out_idx = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>1-D. Values to keep.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>1-D. Values to remove.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_idx</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ListDiff&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output: 1-D. Values present in <code>x</code> but not in <code>y</code>.
              idx: 1-D. Positions of <code>x</code> values preserved in <code>out</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ListDiff_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a list <code>x</code> and a list <code>y</code>, this operation returns a list <code>out</code> that
              represents all values that are in <code>x</code> but not in <code>y</code>. The returned list <code>out</code>
              is sorted in the same order that the numbers appear in <code>x</code> (duplicates are
              preserved). This operation also returns a list <code>idx</code> that represents the
              position of each <code>out</code> element in <code>x</code>. In other words:</p>
<pre><code>          &lt;code&gt;out[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]&lt;/code&gt;

          For example, given this input:

           &lt;pre&gt;&lt;code&gt;
          x = [1, 2, 3, 4, 5, 6]
          y = [1, 3, 5]
           &lt;/code&gt;&lt;/pre&gt;

          This operation would return:

           &lt;pre&gt;&lt;code&gt;
          out ==&amp;gt; [2, 4, 6]
          idx ==&amp;gt; [1, 3, 5]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LMDBReader_" data-uid="TensorFlow.TFGraph.LMDBReader*"></a>
  <h4 id="TensorFlow_TFGraph_LMDBReader_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.LMDBReader(System.String,System.String,System.String)">LMDBReader(String, String, String)</h4>
  <div class="markdown level1 summary"><p>A Reader that outputs the records from a LMDB file.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LMDBReader (string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LMDBReader&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_LoadAndRemapMatrix_" data-uid="TensorFlow.TFGraph.LoadAndRemapMatrix*"></a>
  <h4 id="TensorFlow_TFGraph_LoadAndRemapMatrix_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.LoadAndRemapMatrix(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String)">LoadAndRemapMatrix(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Loads a 2-D (matrix) <code>Tensor</code> with name <code>old_tensor_name</code> from the checkpoint</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LoadAndRemapMatrix (TensorFlow.TFOutput ckpt_path, TensorFlow.TFOutput old_tensor_name, TensorFlow.TFOutput row_remapping, TensorFlow.TFOutput col_remapping, TensorFlow.TFOutput initializing_values, long num_rows, long num_cols, Nullable&lt;long&gt; max_rows_in_memory = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ckpt_path</span></td>
        <td><p>Path to the TensorFlow checkpoint (version 2, <code>TensorBundle</code>) from
              which the old matrix <code>Tensor</code> will be loaded.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">old_tensor_name</span></td>
        <td><p>Name of the 2-D <code>Tensor</code> to load from checkpoint.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">row_remapping</span></td>
        <td><p>An int <code>Tensor</code> of row remappings (generally created by
              <code>generate_vocab_remapping</code>).  Even if no row remapping is needed, this must
              still be an index-valued Tensor (e.g. [0, 1, 2, ...]), or a shifted
              index-valued <code>Tensor</code> (e.g. [8, 9, 10, ...], for partitioned <code>Variables</code>).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">col_remapping</span></td>
        <td><p>An int <code>Tensor</code> of column remappings (generally created by
              <code>generate_vocab_remapping</code>).  May be a size-0 <code>Tensor</code> if only row remapping
              is to be done (e.g. column ordering is the same).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">initializing_values</span></td>
        <td><p>A float <code>Tensor</code> containing  values to fill in for cells
              in the output matrix that are not loaded from the checkpoint. Length must be
              exactly the same as the number of missing / new cells.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_rows</span></td>
        <td><p>Number of rows (length of the 1st dimension) in the output matrix.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_cols</span></td>
        <td><p>Number of columns (length of the 2nd dimension) in the output matrix.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">max_rows_in_memory</span></td>
        <td><p>Optional argument
              The maximum number of rows to load from the checkpoint at
              once. If less than or equal to 0, the entire matrix will be loaded into
              memory. Setting this arg trades increased disk reads for lower memory usage.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadAndRemapMatrix&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Output matrix containing existing values loaded from the
              checkpoint, and with any missing values filled in from initializing_values.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadAndRemapMatrix_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>at <code>ckpt_path</code> and potentially reorders its rows and columns using the
              specified remappings.</p>
<pre><code>          Most users should use one of the wrapper initializers (such as
          &lt;code&gt;tf.contrib.framework.load_and_remap_matrix_initializer&lt;/code&gt;) instead of this
          function directly.

          The remappings are 1-D tensors with the following properties:

          * &lt;code&gt;row_remapping&lt;/code&gt; must have exactly &lt;code&gt;num_rows&lt;/code&gt; entries. Row &lt;code&gt;i&lt;/code&gt; of the output
          matrix will be initialized from the row corresponding to index
          &lt;code&gt;row_remapping[i]&lt;/code&gt; in the old &lt;code&gt;Tensor&lt;/code&gt; from the checkpoint.
          * &lt;code&gt;col_remapping&lt;/code&gt; must have either 0 entries (indicating that no column
          reordering is needed) or &lt;code&gt;num_cols&lt;/code&gt; entries. If specified, column &lt;code&gt;j&lt;/code&gt; of the
          output matrix will be initialized from the column corresponding to index
          &lt;code&gt;col_remapping[j]&lt;/code&gt; in the old &lt;code&gt;Tensor&lt;/code&gt; from the checkpoint.
          * A value of -1 in either of the remappings signifies a &quot;missing&quot; entry. In that
          case, values from the &lt;code&gt;initializing_values&lt;/code&gt; tensor will be used to fill that
          missing row or column. If &lt;code&gt;row_remapping&lt;/code&gt; has &lt;code&gt;r&lt;/code&gt; missing entries and
          &lt;code&gt;col_remapping&lt;/code&gt; has &lt;code&gt;c&lt;/code&gt; missing entries, then the following condition must be
          true:

          &lt;code&gt;(r * num_cols) + (c * num_rows) - (r * c) == len(initializing_values)&lt;/code&gt;

          The remapping tensors can be generated using the GenerateVocabRemapping op.

          As an example, with row_remapping = [1, 0, -1], col_remapping = [0, 2, -1],
          initializing_values = [0.5, -0.5, 0.25, -0.25, 42], and w(i, j) representing
          the value from row i, column j of the old tensor in the checkpoint, the output
          matrix will look like the following:

          [[w(1, 0),  w(1, 2),  0.5],
          [w(0, 0),  w(0, 2), -0.5],
          [0.25,    -0.25,      42]]
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingAdadeltaParameters_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParameters*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingAdadeltaParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingAdadeltaParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingAdadeltaParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput updates, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the Adadelta optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accumulators</span></td>
        <td><p>Value of accumulators used in the Adadelta optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>Value of updates used in the Adadelta optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingAdadeltaParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingAdadeltaParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the Adadelta optimization algorithm.
          accumulators: A tensor containing the initial embedding table accumulators to use in embedding
          lookups using the Adadelta optimization algorithm.
          updates: A tensor containing the initial embedding table updates to use in embedding
          lookups using the Adadelta optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingAdadeltaParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingAdadeltaParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingAdadeltaParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingAdadeltaParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput updates, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the Adadelta optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accumulators</span></td>
        <td><p>Value of accumulators used in the Adadelta optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>Value of updates used in the Adadelta optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_accumulators</span></td>
        <td><p>Value of gradient_accumulators used in the Adadelta optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingAdadeltaParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingAdadeltaParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the Adadelta optimization algorithm.
          accumulators: A tensor containing the initial embedding table accumulators to use in embedding
          lookups using the Adadelta optimization algorithm.
          updates: A tensor containing the initial embedding table updates to use in embedding
          lookups using the Adadelta optimization algorithm.
          gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding
          lookups using the Adadelta optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingAdagradParameters_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParameters*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingAdagradParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingAdagradParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the Adagrad optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accumulators</span></td>
        <td><p>Value of accumulators used in the Adagrad optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingAdagradParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingAdagradParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the Adagrad optimization algorithm.
          accumulators: A tensor containing the initial embedding table accumulators to use in embedding
          lookups using the Adagrad optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingAdagradParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingAdagradParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingAdagradParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingAdagradParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the Adagrad optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accumulators</span></td>
        <td><p>Value of accumulators used in the Adagrad optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_accumulators</span></td>
        <td><p>Value of gradient_accumulators used in the Adagrad optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingAdagradParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingAdagradParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the Adagrad optimization algorithm.
          accumulators: A tensor containing the initial embedding table accumulators to use in embedding
          lookups using the Adagrad optimization algorithm.
          gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding
          lookups using the Adagrad optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingADAMParameters_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingADAMParameters*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingADAMParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingADAMParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingADAMParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingADAMParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput momenta, TensorFlow.TFOutput velocities, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the ADAM optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momenta</span></td>
        <td><p>Value of momenta used in the ADAM optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">velocities</span></td>
        <td><p>Value of velocities used in the ADAM optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingADAMParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingADAMParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the ADAM optimization algorithm.
          momenta: A tensor containing the initial embedding table momenta to use in embedding
          lookups using the ADAM optimization algorithm.
          velocities: A tensor containing the initial embedding table velocities to use in embedding
          lookups using the ADAM optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingADAMParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingADAMParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingADAMParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingADAMParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingADAMParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingADAMParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput momenta, TensorFlow.TFOutput velocities, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the ADAM optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momenta</span></td>
        <td><p>Value of momenta used in the ADAM optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">velocities</span></td>
        <td><p>Value of velocities used in the ADAM optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_accumulators</span></td>
        <td><p>Value of gradient_accumulators used in the ADAM optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingADAMParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingADAMParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the ADAM optimization algorithm.
          momenta: A tensor containing the initial embedding table momenta to use in embedding
          lookups using the ADAM optimization algorithm.
          velocities: A tensor containing the initial embedding table velocities to use in embedding
          lookups using the ADAM optimization algorithm.
          gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding
          lookups using the ADAM optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingCenteredRMSPropParameters_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingCenteredRMSPropParameters*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingCenteredRMSPropParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingCenteredRMSPropParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingCenteredRMSPropParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingCenteredRMSPropParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput mg, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the centered RMSProp optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ms</span></td>
        <td><p>Value of ms used in the centered RMSProp optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mom</span></td>
        <td><p>Value of mom used in the centered RMSProp optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mg</span></td>
        <td><p>Value of mg used in the centered RMSProp optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingCenteredRMSPropParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingCenteredRMSPropParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the centered RMSProp optimization algorithm.
          ms: A tensor containing the initial embedding table ms to use in embedding
          lookups using the centered RMSProp optimization algorithm.
          mom: A tensor containing the initial embedding table mom to use in embedding
          lookups using the centered RMSProp optimization algorithm.
          mg: A tensor containing the initial embedding table mg to use in embedding
          lookups using the centered RMSProp optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingFTRLParameters_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParameters*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingFTRLParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingFTRLParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingFTRLParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput linears, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the FTRL optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accumulators</span></td>
        <td><p>Value of accumulators used in the FTRL optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">linears</span></td>
        <td><p>Value of linears used in the FTRL optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingFTRLParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingFTRLParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the FTRL optimization algorithm.
          accumulators: A tensor containing the initial embedding table accumulators to use in embedding
          lookups using the FTRL optimization algorithm.
          linears: A tensor containing the initial embedding table linears to use in embedding
          lookups using the FTRL optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingFTRLParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingFTRLParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingFTRLParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingFTRLParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingFTRLParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput linears, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the FTRL optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accumulators</span></td>
        <td><p>Value of accumulators used in the FTRL optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">linears</span></td>
        <td><p>Value of linears used in the FTRL optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_accumulators</span></td>
        <td><p>Value of gradient_accumulators used in the FTRL optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingFTRLParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingFTRLParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the FTRL optimization algorithm.
          accumulators: A tensor containing the initial embedding table accumulators to use in embedding
          lookups using the FTRL optimization algorithm.
          linears: A tensor containing the initial embedding table linears to use in embedding
          lookups using the FTRL optimization algorithm.
          gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding
          lookups using the FTRL optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingMDLAdagradLightParameters_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingMDLAdagradLightParameters*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingMDLAdagradLightParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingMDLAdagradLightParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingMDLAdagradLightParameters(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingMDLAdagradLightParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput weights, TensorFlow.TFOutput benefits, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the MDL Adagrad Light optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accumulators</span></td>
        <td><p>Value of accumulators used in the MDL Adagrad Light optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">weights</span></td>
        <td><p>Value of weights used in the MDL Adagrad Light optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">benefits</span></td>
        <td><p>Value of benefits used in the MDL Adagrad Light optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingMDLAdagradLightParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingMDLAdagradLightParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the MDL Adagrad Light optimization algorithm.
          accumulators: A tensor containing the initial embedding table accumulators to use in embedding
          lookups using the MDL Adagrad Light optimization algorithm.
          weights: A tensor containing the initial embedding table weights to use in embedding
          lookups using the MDL Adagrad Light optimization algorithm.
          benefits: A tensor containing the initial embedding table benefits to use in embedding
          lookups using the MDL Adagrad Light optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingMomentumParameters_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParameters*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingMomentumParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingMomentumParameters(TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingMomentumParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput momenta, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the Momentum optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momenta</span></td>
        <td><p>Value of momenta used in the Momentum optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingMomentumParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingMomentumParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the Momentum optimization algorithm.
          momenta: A tensor containing the initial embedding table momenta to use in embedding
          lookups using the Momentum optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingMomentumParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingMomentumParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingMomentumParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingMomentumParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingMomentumParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput momenta, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the Momentum optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momenta</span></td>
        <td><p>Value of momenta used in the Momentum optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_accumulators</span></td>
        <td><p>Value of gradient_accumulators used in the Momentum optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingMomentumParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingMomentumParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the Momentum optimization algorithm.
          momenta: A tensor containing the initial embedding table momenta to use in embedding
          lookups using the Momentum optimization algorithm.
          gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding
          lookups using the Momentum optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingProximalAdagradParameters_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParameters*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingProximalAdagradParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingProximalAdagradParameters(TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingProximalAdagradParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the proximal Adagrad optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accumulators</span></td>
        <td><p>Value of accumulators used in the proximal Adagrad optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingProximalAdagradParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingProximalAdagradParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the proximal Adagrad optimization algorithm.
          accumulators: A tensor containing the initial embedding table accumulators to use in embedding
          lookups using the proximal Adagrad optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput accumulators, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the proximal Adagrad optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accumulators</span></td>
        <td><p>Value of accumulators used in the proximal Adagrad optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_accumulators</span></td>
        <td><p>Value of gradient_accumulators used in the proximal Adagrad optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the proximal Adagrad optimization algorithm.
          accumulators: A tensor containing the initial embedding table accumulators to use in embedding
          lookups using the proximal Adagrad optimization algorithm.
          gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding
          lookups using the proximal Adagrad optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingRMSPropParameters_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParameters*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingRMSPropParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParameters(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingRMSPropParameters(TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingRMSPropParameters (TensorFlow.TFOutput parameters, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the RMSProp optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ms</span></td>
        <td><p>Value of ms used in the RMSProp optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mom</span></td>
        <td><p>Value of mom used in the RMSProp optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingRMSPropParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingRMSPropParameters_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the RMSProp optimization algorithm.
          ms: A tensor containing the initial embedding table ms to use in embedding
          lookups using the RMSProp optimization algorithm.
          mom: A tensor containing the initial embedding table mom to use in embedding
          lookups using the RMSProp optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingRMSPropParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingRMSPropParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingRMSPropParametersGradAccumDebug(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingRMSPropParametersGradAccumDebug(TFOutput, TFOutput, TFOutput, TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingRMSPropParametersGradAccumDebug (TensorFlow.TFOutput parameters, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput gradient_accumulators, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the RMSProp optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ms</span></td>
        <td><p>Value of ms used in the RMSProp optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mom</span></td>
        <td><p>Value of mom used in the RMSProp optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_accumulators</span></td>
        <td><p>Value of gradient_accumulators used in the RMSProp optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingRMSPropParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingRMSPropParametersGradAccumDebug_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the RMSProp optimization algorithm.
          ms: A tensor containing the initial embedding table ms to use in embedding
          lookups using the RMSProp optimization algorithm.
          mom: A tensor containing the initial embedding table mom to use in embedding
          lookups using the RMSProp optimization algorithm.
          gradient_accumulators: A tensor containing the initial embedding table gradient_accumulators to use in embedding
          lookups using the RMSProp optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LoadTPUEmbeddingStochasticGradientDescentParameters_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingStochasticGradientDescentParameters*"></a>
  <h4 id="TensorFlow_TFGraph_LoadTPUEmbeddingStochasticGradientDescentParameters_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.LoadTPUEmbeddingStochasticGradientDescentParameters(TensorFlow.TFOutput,System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">LoadTPUEmbeddingStochasticGradientDescentParameters(TFOutput, Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Load embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LoadTPUEmbeddingStochasticGradientDescentParameters (TensorFlow.TFOutput parameters, long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">parameters</span></td>
        <td><p>Value of parameters used in the stochastic gradient descent optimization algorithm.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoadTPUEmbeddingStochasticGradientDescentParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoadTPUEmbeddingStochasticGradientDescentParameters_TensorFlow_TFOutput_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that loads optimization parameters into HBM for embedding. Must be
              preceded by a ConfigureTPUEmbeddingHost op that sets up the correct
              embedding table configuration. For example, this op is used to install
              parameters that are loaded from a checkpoint before a training loop is
              executed.</p>
<pre><code>          parameters: A tensor containing the initial embedding table parameters to use in embedding
          lookups using the stochastic gradient descent optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Log_" data-uid="TensorFlow.TFGraph.Log*"></a>
  <h4 id="TensorFlow_TFGraph_Log_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Log(TensorFlow.TFOutput,System.String)">Log(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes natural logarithm of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Log (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Log&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Log_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>I.e., \(y = \log_e x\).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Log1p_" data-uid="TensorFlow.TFGraph.Log1p*"></a>
  <h4 id="TensorFlow_TFGraph_Log1p_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Log1p(TensorFlow.TFOutput,System.String)">Log1p(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes natural logarithm of (1 + x) element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Log1p (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Log1p&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Log1p_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>I.e., \(y = \log_e (1 + x)\).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_LogicalAnd_" data-uid="TensorFlow.TFGraph.LogicalAnd*"></a>
  <h4 id="TensorFlow_TFGraph_LogicalAnd_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LogicalAnd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">LogicalAnd(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the truth value of x AND y element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LogicalAnd (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LogicalAnd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LogicalAnd_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>LogicalAnd</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_LogicalNot_" data-uid="TensorFlow.TFGraph.LogicalNot*"></a>
  <h4 id="TensorFlow_TFGraph_LogicalNot_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LogicalNot(TensorFlow.TFOutput,System.String)">LogicalNot(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the truth value of NOT x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LogicalNot (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LogicalNot&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_LogicalOr_" data-uid="TensorFlow.TFGraph.LogicalOr*"></a>
  <h4 id="TensorFlow_TFGraph_LogicalOr_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LogicalOr(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">LogicalOr(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the truth value of x OR y element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LogicalOr (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LogicalOr&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LogicalOr_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>LogicalOr</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_LogMatrixDeterminant_" data-uid="TensorFlow.TFGraph.LogMatrixDeterminant*"></a>
  <h4 id="TensorFlow_TFGraph_LogMatrixDeterminant_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LogMatrixDeterminant(TensorFlow.TFOutput,System.String)">LogMatrixDeterminant(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the sign and the log of the absolute value of the determinant of</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; LogMatrixDeterminant (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Shape is <code>[N, M, M]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LogMatrixDeterminant&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sign: The signs of the log determinants of the inputs. Shape is <code>[N]</code>.
              log_abs_determinant: The logs of the absolute values of the determinants
              of the N input matrices.  Shape is <code>[N]</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LogMatrixDeterminant_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>one or more square matrices.</p>
<pre><code>          The input is a tensor of shape &lt;code&gt;[N, M, M]&lt;/code&gt; whose inner-most 2 dimensions
          form square matrices. The outputs are two tensors containing the signs and
          absolute values of the log determinants for all N input submatrices
          &lt;code&gt;[..., :, :]&lt;/code&gt; such that the determinant = sign*exp(log_abs_determinant).
          The log_abs_determinant is computed as det(P)*sum(log(diag(LU))) where LU
          is the LU decomposition of the input and P is the corresponding
          permutation matrix.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LogSoftmax_" data-uid="TensorFlow.TFGraph.LogSoftmax*"></a>
  <h4 id="TensorFlow_TFGraph_LogSoftmax_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LogSoftmax(TensorFlow.TFOutput,System.String)">LogSoftmax(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes log softmax activations.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LogSoftmax (TensorFlow.TFOutput logits, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">logits</span></td>
        <td><p>2-D with shape <code>[batch_size, num_classes]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LogSoftmax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same shape as <code>logits</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LogSoftmax_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>For each batch <code>i</code> and class <code>j</code> we have</p>
<pre><code>          logsoftmax[i, j] = logits[i, j] - log(sum(exp(logits[i])))
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LogUniformCandidateSampler_" data-uid="TensorFlow.TFGraph.LogUniformCandidateSampler*"></a>
  <h4 id="TensorFlow_TFGraph_LogUniformCandidateSampler_TensorFlow_TFOutput_System_Int64_System_Int64_System_Boolean_System_Int64_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.LogUniformCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">LogUniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Generates labels for candidate sampling with a log-uniform distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; LogUniformCandidateSampler (TensorFlow.TFOutput true_classes, long num_true, long num_sampled, bool unique, long range_max, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">true_classes</span></td>
        <td><p>A batch_size * num_true matrix, in which each row contains the
              IDs of the num_true target_classes in the corresponding original label.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_true</span></td>
        <td><p>Number of true labels per context.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_sampled</span></td>
        <td><p>Number of candidates to randomly sample.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">unique</span></td>
        <td><p>If unique is true, we sample with rejection, so that all sampled
              candidates in a batch are unique. This requires some approximation to
              estimate the post-rejection sampling probabilities.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">range_max</span></td>
        <td><p>The sampler will sample integers from the interval [0, range_max).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              An second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LogUniformCandidateSampler&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sampled_candidates: A vector of length num_sampled, in which each element is
              the ID of a sampled candidate.
              true_expected_count: A batch_size * num_true matrix, representing
              the number of times each candidate is expected to occur in a batch
              of sampled candidates. If unique=true, then this is a probability.
              sampled_expected_count: A vector of length num_sampled, for each sampled
              candidate representing the number of times the candidate is expected
              to occur in a batch of sampled candidates.  If unique=true, then this is a
              probability.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LogUniformCandidateSampler_TensorFlow_TFOutput_System_Int64_System_Int64_System_Boolean_System_Int64_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>See explanations of candidate sampling and the data formats at
              go/candidate-sampling.</p>
<pre><code>          For each batch, this op picks a single set of sampled candidate labels.

          The advantages of sampling candidates per-batch are simplicity and the
          possibility of efficient dense matrix multiplication. The disadvantage is that
          the sampled candidates must be chosen independently of the context and of the
          true labels.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LookupTableExport_" data-uid="TensorFlow.TFGraph.LookupTableExport*"></a>
  <h4 id="TensorFlow_TFGraph_LookupTableExport_TensorFlow_TFOutput_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.LookupTableExport(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)">LookupTableExport(TFOutput, TFDataType, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Outputs all keys and values in the table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; LookupTableExport (TensorFlow.TFOutput table_handle, TensorFlow.TFDataType Tkeys, TensorFlow.TFDataType Tvalues, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to the table.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">Tkeys</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">Tvalues</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LookupTableExport&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              keys: Vector of all keys present in the table.
              values: Tensor of all values in the table. Indexed in parallel with <code>keys</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_LookupTableExportV2_" data-uid="TensorFlow.TFGraph.LookupTableExportV2*"></a>
  <h4 id="TensorFlow_TFGraph_LookupTableExportV2_TensorFlow_TFOutput_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.LookupTableExportV2(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)">LookupTableExportV2(TFOutput, TFDataType, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Outputs all keys and values in the table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; LookupTableExportV2 (TensorFlow.TFOutput table_handle, TensorFlow.TFDataType Tkeys, TensorFlow.TFDataType Tvalues, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to the table.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">Tkeys</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">Tvalues</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LookupTableExportV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              keys: Vector of all keys present in the table.
              values: Tensor of all values in the table. Indexed in parallel with <code>keys</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_LookupTableFind_" data-uid="TensorFlow.TFGraph.LookupTableFind*"></a>
  <h4 id="TensorFlow_TFGraph_LookupTableFind_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LookupTableFind(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">LookupTableFind(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Looks up keys in a table, outputs the corresponding values.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LookupTableFind (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput default_value, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to the table.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">keys</span></td>
        <td><p>Any shape.  Keys to look up.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">default_value</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LookupTableFind&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same shape as <code>keys</code>.  Values found in the table, or <code>default_values</code>
              for missing keys.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LookupTableFind_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The tensor <code>keys</code> must of the same type as the keys of the table.
              The output <code>values</code> is of the type of the table values.</p>
<pre><code>          The scalar &lt;code&gt;default_value&lt;/code&gt; is the value output for keys not present in the
          table. It must also be of the same type as the table values.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LookupTableFindV2_" data-uid="TensorFlow.TFGraph.LookupTableFindV2*"></a>
  <h4 id="TensorFlow_TFGraph_LookupTableFindV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LookupTableFindV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">LookupTableFindV2(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Looks up keys in a table, outputs the corresponding values.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LookupTableFindV2 (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput default_value, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to the table.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">keys</span></td>
        <td><p>Any shape.  Keys to look up.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">default_value</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LookupTableFindV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same shape as <code>keys</code>.  Values found in the table, or <code>default_values</code>
              for missing keys.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LookupTableFindV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The tensor <code>keys</code> must of the same type as the keys of the table.
              The output <code>values</code> is of the type of the table values.</p>
<pre><code>          The scalar &lt;code&gt;default_value&lt;/code&gt; is the value output for keys not present in the
          table. It must also be of the same type as the table values.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LookupTableImport_" data-uid="TensorFlow.TFGraph.LookupTableImport*"></a>
  <h4 id="TensorFlow_TFGraph_LookupTableImport_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LookupTableImport(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">LookupTableImport(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Replaces the contents of the table with the specified keys and values.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LookupTableImport (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to the table.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">keys</span></td>
        <td><p>Any shape.  Keys to look up.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>Values to associate with keys.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LookupTableImport&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LookupTableImport_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The tensor <code>keys</code> must be of the same type as the keys of the table.
              The tensor <code>values</code> must be of the type of the table values.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_LookupTableImportV2_" data-uid="TensorFlow.TFGraph.LookupTableImportV2*"></a>
  <h4 id="TensorFlow_TFGraph_LookupTableImportV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LookupTableImportV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">LookupTableImportV2(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Replaces the contents of the table with the specified keys and values.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LookupTableImportV2 (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to the table.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">keys</span></td>
        <td><p>Any shape.  Keys to look up.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>Values to associate with keys.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LookupTableImportV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LookupTableImportV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The tensor <code>keys</code> must be of the same type as the keys of the table.
              The tensor <code>values</code> must be of the type of the table values.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_LookupTableInsert_" data-uid="TensorFlow.TFGraph.LookupTableInsert*"></a>
  <h4 id="TensorFlow_TFGraph_LookupTableInsert_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LookupTableInsert(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">LookupTableInsert(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Updates the table to associates keys with values.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LookupTableInsert (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to the table.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">keys</span></td>
        <td><p>Any shape.  Keys to look up.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>Values to associate with keys.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LookupTableInsert&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LookupTableInsert_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The tensor <code>keys</code> must be of the same type as the keys of the table.
              The tensor <code>values</code> must be of the type of the table values.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_LookupTableInsertV2_" data-uid="TensorFlow.TFGraph.LookupTableInsertV2*"></a>
  <h4 id="TensorFlow_TFGraph_LookupTableInsertV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LookupTableInsertV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">LookupTableInsertV2(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Updates the table to associates keys with values.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation LookupTableInsertV2 (TensorFlow.TFOutput table_handle, TensorFlow.TFOutput keys, TensorFlow.TFOutput values, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to the table.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">keys</span></td>
        <td><p>Any shape.  Keys to look up.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>Values to associate with keys.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LookupTableInsertV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LookupTableInsertV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The tensor <code>keys</code> must be of the same type as the keys of the table.
              The tensor <code>values</code> must be of the type of the table values.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_LookupTableSize_" data-uid="TensorFlow.TFGraph.LookupTableSize*"></a>
  <h4 id="TensorFlow_TFGraph_LookupTableSize_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LookupTableSize(TensorFlow.TFOutput,System.String)">LookupTableSize(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the number of elements in the given table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LookupTableSize (TensorFlow.TFOutput table_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to the table.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LookupTableSize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Scalar that contains number of elements in the table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_LookupTableSizeV2_" data-uid="TensorFlow.TFGraph.LookupTableSizeV2*"></a>
  <h4 id="TensorFlow_TFGraph_LookupTableSizeV2_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LookupTableSizeV2(TensorFlow.TFOutput,System.String)">LookupTableSizeV2(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the number of elements in the given table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LookupTableSizeV2 (TensorFlow.TFOutput table_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">table_handle</span></td>
        <td><p>Handle to the table.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LookupTableSizeV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Scalar that contains number of elements in the table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_LoopCond_" data-uid="TensorFlow.TFGraph.LoopCond*"></a>
  <h4 id="TensorFlow_TFGraph_LoopCond_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.LoopCond(TensorFlow.TFOutput,System.String)">LoopCond(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Forwards the input to the output.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LoopCond (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A boolean scalar, representing the branch predicate of the Switch op.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LoopCond&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The same tensor as <code>input</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LoopCond_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operator represents the loop termination condition used by the
              &quot;pivot&quot; switches of a loop.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_LowerBound_" data-uid="TensorFlow.TFGraph.LowerBound*"></a>
  <h4 id="TensorFlow_TFGraph_LowerBound_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.LowerBound(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">LowerBound(TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Applies lower_bound(sorted_search_values, values) along each row.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LowerBound (TensorFlow.TFOutput sorted_inputs, TensorFlow.TFOutput values, Nullable&lt;TensorFlow.TFDataType&gt; out_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sorted_inputs</span></td>
        <td><p>2-D Tensor where each row is ordered.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>2-D Tensor with the same numbers of rows as <code>sorted_search_values</code>. Contains
              the values that will be searched for in <code>sorted_search_values</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LowerBound&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A <code>Tensor</code> with the same shape as <code>values</code>.  It contains the first scalar index
              into the last dimension where values can be inserted without changing the
              ordered property.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LowerBound_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Each set of rows with the same index in (sorted_inputs, values) is treated
              independently.  The resulting row is the equivalent of calling
              <code>np.searchsorted(sorted_inputs, values, side=&#39;left&#39;)</code>.</p>
<pre><code>          The result is not a global index to the entire
          &lt;code&gt;Tensor&lt;/code&gt;, but rather just the index in the last dimension.

          A 2-D example:
          sorted_sequence = [[0, 3, 9, 9, 10],
          [1, 2, 3, 4, 5]]
          values = [[2, 4, 9],
          [0, 2, 6]]

          result = LowerBound(sorted_sequence, values)

          result == [[1, 2, 2],
          [0, 1, 5]]
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LRN_" data-uid="TensorFlow.TFGraph.LRN*"></a>
  <h4 id="TensorFlow_TFGraph_LRN_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Single__System_Nullable_System_Single__System_Nullable_System_Single__System_String_" data-uid="TensorFlow.TFGraph.LRN(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)">LRN(TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Single&gt;, Nullable&lt;Single&gt;, Nullable&lt;Single&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Local Response Normalization.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LRN (TensorFlow.TFOutput input, Nullable&lt;long&gt; depth_radius = null, Nullable&lt;float&gt; bias = null, Nullable&lt;float&gt; alpha = null, Nullable&lt;float&gt; beta = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">depth_radius</span></td>
        <td><p>Optional argument
              0-D.  Half-width of the 1-D normalization window.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">bias</span></td>
        <td><p>Optional argument
              An offset (usually positive to avoid dividing by 0).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">alpha</span></td>
        <td><p>Optional argument
              A scale factor, usually positive.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">beta</span></td>
        <td><p>Optional argument
              An exponent.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LRN&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_LRN_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Single__System_Nullable_System_Single__System_Nullable_System_Single__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The 4-D <code>input</code> tensor is treated as a 3-D array of 1-D vectors (along the last
              dimension), and each vector is normalized independently.  Within a given vector,
              each component is divided by the weighted, squared sum of inputs within
              <code>depth_radius</code>.  In detail,</p>
<pre><code>          sqr_sum[a, b, c, d] =
          sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
          output = input / (bias + alpha * sqr_sum) ** beta

          For details, see [Krizhevsky et al., ImageNet classification with deep
          convolutional neural networks (NIPS 2012)](http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_LRNGrad_" data-uid="TensorFlow.TFGraph.LRNGrad*"></a>
  <h4 id="TensorFlow_TFGraph_LRNGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Single__System_Nullable_System_Single__System_Nullable_System_Single__System_String_" data-uid="TensorFlow.TFGraph.LRNGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)">LRNGrad(TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Single&gt;, Nullable&lt;Single&gt;, Nullable&lt;Single&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Gradients for Local Response Normalization.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput LRNGrad (TensorFlow.TFOutput input_grads, TensorFlow.TFOutput input_image, TensorFlow.TFOutput output_image, Nullable&lt;long&gt; depth_radius = null, Nullable&lt;float&gt; bias = null, Nullable&lt;float&gt; alpha = null, Nullable&lt;float&gt; beta = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_grads</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_image</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_image</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">depth_radius</span></td>
        <td><p>Optional argument
              A depth radius.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">bias</span></td>
        <td><p>Optional argument
              An offset (usually &gt; 0 to avoid dividing by 0).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">alpha</span></td>
        <td><p>Optional argument
              A scale factor, usually positive.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">beta</span></td>
        <td><p>Optional argument
              An exponent.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;LRNGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The gradients for LRN.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MakeIterator_" data-uid="TensorFlow.TFGraph.MakeIterator*"></a>
  <h4 id="TensorFlow_TFGraph_MakeIterator_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.MakeIterator(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">MakeIterator(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Makes a new iterator from the given <code>dataset</code> and stores it in <code>iterator</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation MakeIterator (TensorFlow.TFOutput dataset, TensorFlow.TFOutput iterator, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">iterator</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MakeIterator&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MakeIterator_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation may be executed multiple times. Each execution will reset the
              iterator in <code>iterator</code> to the first element of <code>dataset</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MapClear_" data-uid="TensorFlow.TFGraph.MapClear*"></a>
  <h4 id="TensorFlow_TFGraph_MapClear_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MapClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">MapClear(TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op removes all elements in the underlying container.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation MapClear (TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MapClear&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MapIncompleteSize_" data-uid="TensorFlow.TFGraph.MapIncompleteSize*"></a>
  <h4 id="TensorFlow_TFGraph_MapIncompleteSize_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MapIncompleteSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">MapIncompleteSize(TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op returns the number of incomplete elements in the underlying container.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MapIncompleteSize (TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MapIncompleteSize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MapPeek_" data-uid="TensorFlow.TFGraph.MapPeek*"></a>
  <h4 id="TensorFlow_TFGraph_MapPeek_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MapPeek(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">MapPeek(TFOutput, TFOutput, TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op peeks at the values at the specified key.  If the</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] MapPeek (TensorFlow.TFOutput key, TensorFlow.TFOutput indices, TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">key</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MapPeek&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MapPeek_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>underlying container does not contain this key
              this op will block until it does.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MapSize_" data-uid="TensorFlow.TFGraph.MapSize*"></a>
  <h4 id="TensorFlow_TFGraph_MapSize_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MapSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">MapSize(TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op returns the number of elements in the underlying container.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MapSize (TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MapSize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MapStage_" data-uid="TensorFlow.TFGraph.MapStage*"></a>
  <h4 id="TensorFlow_TFGraph_MapStage_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MapStage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">MapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Stage (key, values) in the underlying container which behaves like a hashtable.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation MapStage (TensorFlow.TFOutput key, TensorFlow.TFOutput indices, TensorFlow.TFOutput[] values, TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">key</span></td>
        <td><p>int64</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">values</span></td>
        <td><p>a list of tensors
              dtypes A list of data types that inserted values should adhere to.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument
              Maximum number of elements in the Staging Area. If &gt; 0, inserts
              on the container will block when the capacity is reached.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this queue is placed in the given container. Otherwise,
              a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              It is necessary to match this name to the matching Unstage Op.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MapStage&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MapUnstage_" data-uid="TensorFlow.TFGraph.MapUnstage*"></a>
  <h4 id="TensorFlow_TFGraph_MapUnstage_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MapUnstage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">MapUnstage(TFOutput, TFOutput, TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op removes and returns the values associated with the key</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] MapUnstage (TensorFlow.TFOutput key, TensorFlow.TFOutput indices, TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">key</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MapUnstage&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MapUnstage_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>from the underlying container.   If the underlying container
              does not contain this key, the op will block until it does.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MapUnstageNoKey_" data-uid="TensorFlow.TFGraph.MapUnstageNoKey*"></a>
  <h4 id="TensorFlow_TFGraph_MapUnstageNoKey_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MapUnstageNoKey(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">MapUnstageNoKey(TFOutput, TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op removes and returns a random (key, value)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput[]&gt; MapUnstageNoKey (TensorFlow.TFOutput indices, TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MapUnstageNoKey&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              key:
              values:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MapUnstageNoKey_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>from the underlying container.   If the underlying container
              does not contain elements, the op will block until it does.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MatchingFiles_" data-uid="TensorFlow.TFGraph.MatchingFiles*"></a>
  <h4 id="TensorFlow_TFGraph_MatchingFiles_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.MatchingFiles(TensorFlow.TFOutput,System.String)">MatchingFiles(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the set of files matching one or more glob patterns.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MatchingFiles (TensorFlow.TFOutput pattern, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">pattern</span></td>
        <td><p>Shell wildcard pattern(s). Scalar or vector of type string.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MatchingFiles&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A vector of matching filenames.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MatchingFiles_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that this routine only supports wildcard characters in the
              basename portion of the pattern, not in the directory portion.
              Note also that the order of filenames returned can be non-deterministic.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MatMul_" data-uid="TensorFlow.TFGraph.MatMul*"></a>
  <h4 id="TensorFlow_TFGraph_MatMul_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.MatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">MatMul(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Multiply the matrix &quot;a&quot; by the matrix &quot;b&quot;.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MatMul (TensorFlow.TFOutput a, TensorFlow.TFOutput b, Nullable&lt;bool&gt; transpose_a = null, Nullable&lt;bool&gt; transpose_b = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">transpose_a</span></td>
        <td><p>Optional argument
              If true, &quot;a&quot; is transposed before multiplication.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">transpose_b</span></td>
        <td><p>Optional argument
              If true, &quot;b&quot; is transposed before multiplication.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MatMul&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MatMul_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The inputs must be two-dimensional matrices and the inner dimension of
              &quot;a&quot; (after being transposed if transpose_a is true) must match the
              outer dimension of &quot;b&quot; (after being transposed if transposed_b is
              true).</p>
<pre><code>          *Note*: The default kernel implementation for MatMul on GPUs uses
          cublas.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_MatrixBandPart_" data-uid="TensorFlow.TFGraph.MatrixBandPart*"></a>
  <h4 id="TensorFlow_TFGraph_MatrixBandPart_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.MatrixBandPart(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">MatrixBandPart(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Copy a tensor setting everything outside a central band in each innermost matrix</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MatrixBandPart (TensorFlow.TFOutput input, TensorFlow.TFOutput num_lower, TensorFlow.TFOutput num_upper, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Rank <code>k</code> tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_lower</span></td>
        <td><p>0-D tensor. Number of subdiagonals to keep. If negative, keep entire
              lower triangle.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_upper</span></td>
        <td><p>0-D tensor. Number of superdiagonals to keep. If negative, keep
              entire upper triangle.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MatrixBandPart&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Rank <code>k</code> tensor of the same shape as input. The extracted banded tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MatrixBandPart_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>to zero.</p>
<pre><code>          The &lt;code&gt;band&lt;/code&gt; part is computed as follows:
          Assume &lt;code&gt;input&lt;/code&gt; has &lt;code&gt;k&lt;/code&gt; dimensions &lt;code&gt;[I, J, K, ..., M, N]&lt;/code&gt;, then the output is a
          tensor with the same shape where

          &lt;code&gt;band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]&lt;/code&gt;.

          The indicator function

          &lt;code&gt;in_band(m, n) = (num_lower &amp;lt; 0 || (m-n) &amp;lt;= num_lower)) &amp;&amp;
          (num_upper &amp;lt; 0 || (n-m) &amp;lt;= num_upper)&lt;/code&gt;.

          For example:

           &lt;pre&gt;&lt;code&gt;
          # if &#39;input&#39; is [[ 0,  1,  2, 3]
          [-1,  0,  1, 2]
          [-2, -1,  0, 1]
          [-3, -2, -1, 0]],

          tf.matrix_band_part(input, 1, -1) ==&amp;gt; [[ 0,  1,  2, 3]
          [-1,  0,  1, 2]
          [ 0, -1,  0, 1]
          [ 0,  0, -1, 0]],

          tf.matrix_band_part(input, 2, 1) ==&amp;gt; [[ 0,  1,  0, 0]
          [-1,  0,  1, 0]
          [-2, -1,  0, 1]
          [ 0, -2, -1, 0]]
           &lt;/code&gt;&lt;/pre&gt;

          Useful special cases:

           &lt;pre&gt;&lt;code&gt;
          tf.matrix_band_part(input, 0, -1) ==&amp;gt; Upper triangular part.
          tf.matrix_band_part(input, -1, 0) ==&amp;gt; Lower triangular part.
          tf.matrix_band_part(input, 0, 0) ==&amp;gt; Diagonal.
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_MatrixDeterminant_" data-uid="TensorFlow.TFGraph.MatrixDeterminant*"></a>
  <h4 id="TensorFlow_TFGraph_MatrixDeterminant_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.MatrixDeterminant(TensorFlow.TFOutput,System.String)">MatrixDeterminant(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the determinant of one or more square matrices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MatrixDeterminant (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Shape is <code>[..., M, M]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MatrixDeterminant&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Shape is <code>[...]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MatrixDeterminant_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
              form square matrices. The output is a tensor containing the determinants
              for all input submatrices <code>[..., :, :]</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MatrixDiag_" data-uid="TensorFlow.TFGraph.MatrixDiag*"></a>
  <h4 id="TensorFlow_TFGraph_MatrixDiag_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.MatrixDiag(TensorFlow.TFOutput,System.String)">MatrixDiag(TFOutput, String)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MatrixDiag (TensorFlow.TFOutput diagonal, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">diagonal</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MatrixDiagPart_" data-uid="TensorFlow.TFGraph.MatrixDiagPart*"></a>
  <h4 id="TensorFlow_TFGraph_MatrixDiagPart_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.MatrixDiagPart(TensorFlow.TFOutput,System.String)">MatrixDiagPart(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the batched diagonal part of a batched tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MatrixDiagPart (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Rank <code>k</code> tensor where <code>k &gt;= 2</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MatrixDiagPart&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The extracted diagonal(s) having shape
              <code>diagonal.shape = input.shape[:-2] + [min(input.shape[-2:])]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MatrixDiagPart_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation returns a tensor with the <code>diagonal</code> part
              of the batched <code>input</code>. The <code>diagonal</code> part is computed as follows:</p>
<pre><code>          Assume &lt;code&gt;input&lt;/code&gt; has &lt;code&gt;k&lt;/code&gt; dimensions &lt;code&gt;[I, J, K, ..., M, N]&lt;/code&gt;, then the output is a
          tensor of rank &lt;code&gt;k - 1&lt;/code&gt; with dimensions &lt;code&gt;[I, J, K, ..., min(M, N)]&lt;/code&gt; where:

          &lt;code&gt;diagonal[i, j, k, ..., n] = input[i, j, k, ..., n, n]&lt;/code&gt;.

          The input must be at least a matrix.

          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;input&#39; is [[[1, 0, 0, 0]
          [0, 2, 0, 0]
          [0, 0, 3, 0]
          [0, 0, 0, 4]],
          [[5, 0, 0, 0]
          [0, 6, 0, 0]
          [0, 0, 7, 0]
          [0, 0, 0, 8]]]

          and input.shape = (2, 4, 4)

          tf.matrix_diag_part(input) ==&amp;gt; [[1, 2, 3, 4], [5, 6, 7, 8]]

          which has shape (2, 4)
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_MatrixExponential_" data-uid="TensorFlow.TFGraph.MatrixExponential*"></a>
  <h4 id="TensorFlow_TFGraph_MatrixExponential_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.MatrixExponential(TensorFlow.TFOutput,System.String)">MatrixExponential(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated, use python implementation tf.linalg.matrix_exponential.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MatrixExponential (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MatrixExponential&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MatrixInverse_" data-uid="TensorFlow.TFGraph.MatrixInverse*"></a>
  <h4 id="TensorFlow_TFGraph_MatrixInverse_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.MatrixInverse(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">MatrixInverse(TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the inverse of one or more square invertible matrices or their</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MatrixInverse (TensorFlow.TFOutput input, Nullable&lt;bool&gt; adjoint = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Shape is <code>[..., M, M]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">adjoint</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MatrixInverse&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Shape is <code>[..., M, M]</code>.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.linalg.inv
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MatrixInverse_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>adjoints (conjugate transposes).</p>
<pre><code>          The input is a tensor of shape &lt;code&gt;[..., M, M]&lt;/code&gt; whose inner-most 2 dimensions
          form square matrices. The output is a tensor of the same shape as the input
          containing the inverse for all input submatrices &lt;code&gt;[..., :, :]&lt;/code&gt;.

          The op uses LU decomposition with partial pivoting to compute the inverses.

          If a matrix is not invertible there is no guarantee what the op does. It
          may detect the condition and raise an exception or it may simply return a
          garbage result.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_MatrixLogarithm_" data-uid="TensorFlow.TFGraph.MatrixLogarithm*"></a>
  <h4 id="TensorFlow_TFGraph_MatrixLogarithm_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.MatrixLogarithm(TensorFlow.TFOutput,System.String)">MatrixLogarithm(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the matrix logarithm of one or more square matrices:</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MatrixLogarithm (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Shape is <code>[..., M, M]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MatrixLogarithm&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Shape is <code>[..., M, M]</code>.</p>
<pre><code>          @compatibility(scipy)
          Equivalent to scipy.linalg.logm
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MatrixLogarithm_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>\(log(exp(A)) = A\)</p>
<pre><code>          This op is only defined for complex matrices. If A is positive-definite and
          real, then casting to a complex matrix, taking the logarithm and casting back
          to a real matrix will give the correct result.

          This function computes the matrix logarithm using the Schur-Parlett algorithm.
          Details of the algorithm can be found in Section 11.6.2 of:
          Nicholas J. Higham, Functions of Matrices: Theory and Computation, SIAM 2008.
          ISBN 978-0-898716-46-7.

          The input is a tensor of shape &lt;code&gt;[..., M, M]&lt;/code&gt; whose inner-most 2 dimensions
          form square matrices. The output is a tensor of the same shape as the input
          containing the exponential for all input submatrices &lt;code&gt;[..., :, :]&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_MatrixSetDiag_" data-uid="TensorFlow.TFGraph.MatrixSetDiag*"></a>
  <h4 id="TensorFlow_TFGraph_MatrixSetDiag_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.MatrixSetDiag(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">MatrixSetDiag(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns a batched matrix tensor with new batched diagonal values.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MatrixSetDiag (TensorFlow.TFOutput input, TensorFlow.TFOutput diagonal, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Rank <code>k+1</code>, where <code>k &gt;= 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">diagonal</span></td>
        <td><p>Rank <code>k</code>, where <code>k &gt;= 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MatrixSetDiag&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Rank <code>k+1</code>, with <code>output.shape = input.shape</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MatrixSetDiag_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given <code>input</code> and <code>diagonal</code>, this operation returns a tensor with the
              same shape and values as <code>input</code>, except for the main diagonal of the
              innermost matrices.  These will be overwritten by the values in <code>diagonal</code>.</p>
<pre><code>          The output is computed as follows:

          Assume &lt;code&gt;input&lt;/code&gt; has &lt;code&gt;k+1&lt;/code&gt; dimensions &lt;code&gt;[I, J, K, ..., M, N]&lt;/code&gt; and &lt;code&gt;diagonal&lt;/code&gt; has
          &lt;code&gt;k&lt;/code&gt; dimensions &lt;code&gt;[I, J, K, ..., min(M, N)]&lt;/code&gt;.  Then the output is a
          tensor of rank &lt;code&gt;k+1&lt;/code&gt; with dimensions &lt;code&gt;[I, J, K, ..., M, N]&lt;/code&gt; where:

          * &lt;code&gt;output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]&lt;/code&gt; for &lt;code&gt;m == n&lt;/code&gt;.
          * &lt;code&gt;output[i, j, k, ..., m, n] = input[i, j, k, ..., m, n]&lt;/code&gt; for &lt;code&gt;m != n&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_MatrixSolve_" data-uid="TensorFlow.TFGraph.MatrixSolve*"></a>
  <h4 id="TensorFlow_TFGraph_MatrixSolve_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.MatrixSolve(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">MatrixSolve(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Solves systems of linear equations.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MatrixSolve (TensorFlow.TFOutput matrix, TensorFlow.TFOutput rhs, Nullable&lt;bool&gt; adjoint = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">matrix</span></td>
        <td><p>Shape is <code>[..., M, M]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rhs</span></td>
        <td><p>Shape is <code>[..., M, K]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">adjoint</span></td>
        <td><p>Optional argument
              Boolean indicating whether to solve with <code>matrix</code> or its (block-wise)
              adjoint.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MatrixSolve&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Shape is <code>[..., M, K]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MatrixSolve_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>Matrix</code> is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
              form square matrices. <code>Rhs</code> is a tensor of shape <code>[..., M, K]</code>. The <code>output</code> is
              a tensor shape <code>[..., M, K]</code>.  If <code>adjoint</code> is <code>False</code> then each output matrix
              satisfies <code>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]</code>.
              If <code>adjoint</code> is <code>True</code> then each output matrix satisfies
              <code>adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MatrixSolveLs_" data-uid="TensorFlow.TFGraph.MatrixSolveLs*"></a>
  <h4 id="TensorFlow_TFGraph_MatrixSolveLs_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.MatrixSolveLs(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">MatrixSolveLs(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Solves one or more linear least-squares problems.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MatrixSolveLs (TensorFlow.TFOutput matrix, TensorFlow.TFOutput rhs, TensorFlow.TFOutput l2_regularizer, Nullable&lt;bool&gt; fast = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">matrix</span></td>
        <td><p>Shape is <code>[..., M, N]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rhs</span></td>
        <td><p>Shape is <code>[..., M, K]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2_regularizer</span></td>
        <td><p>Scalar tensor.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.linalg.lstsq
          @end_compatibility
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">fast</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MatrixSolveLs&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Shape is <code>[..., N, K]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MatrixSolveLs_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>matrix</code> is a tensor of shape <code>[..., M, N]</code> whose inner-most 2 dimensions
              form real or complex matrices of size <code>[M, N]</code>. <code>Rhs</code> is a tensor of the same
              type as <code>matrix</code> and shape <code>[..., M, K]</code>.
              The output is a tensor shape <code>[..., N, K]</code> where each output matrix solves
              each of the equations
              <code>matrix[..., :, :]</code> * <code>output[..., :, :]</code> = <code>rhs[..., :, :]</code>
              in the least squares sense.</p>
<pre><code>          We use the following notation for (complex) matrix and right-hand sides
          in the batch:

          &lt;code&gt;matrix&lt;/code&gt;=\\(A \in \mathbb{C}^{m \times n}\\),
          &lt;code&gt;rhs&lt;/code&gt;=\\(B  \in \mathbb{C}^{m \times k}\\),
          &lt;code&gt;output&lt;/code&gt;=\\(X  \in \mathbb{C}^{n \times k}\\),
          &lt;code&gt;l2_regularizer&lt;/code&gt;=\\(\lambda \in \mathbb{R}\\).

          If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then the solution is computed by solving the normal
          equations using Cholesky decomposition. Specifically, if \\(m \ge n\\) then
          \\(X = (A^H A + \lambda I)^{-1} A^H B\\), which solves the least-squares
          problem \\(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||A Z - B||_F^2 + \lambda ||Z||_F^2\\).
          If \\(m \lt n\\) then &lt;code&gt;output&lt;/code&gt; is computed as
          \\(X = A^H (A A^H + \lambda I)^{-1} B\\), which (for \\(\lambda = 0\\)) is the
          minimum-norm solution to the under-determined linear system, i.e.
          \\(X = \mathrm{argmin}_{Z \in \mathbb{C}^{n \times k} } ||Z||_F^2 \\),
          subject to \\(A Z = B\\). Notice that the fast path is only numerically stable
          when \\(A\\) is numerically full rank and has a condition number
          \\(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach} } }\\) or \\(\lambda\\) is
          sufficiently large.

          If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; an algorithm based on the numerically robust complete
          orthogonal decomposition is used. This computes the minimum-norm
          least-squares solution, even when \\(A\\) is rank deficient. This path is
          typically 6-7 times slower than the fast path. If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; then
          &lt;code&gt;l2_regularizer&lt;/code&gt; is ignored.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_MatrixTriangularSolve_" data-uid="TensorFlow.TFGraph.MatrixTriangularSolve*"></a>
  <h4 id="TensorFlow_TFGraph_MatrixTriangularSolve_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.MatrixTriangularSolve(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">MatrixTriangularSolve(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Solves systems of linear equations with upper or lower triangular matrices by</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MatrixTriangularSolve (TensorFlow.TFOutput matrix, TensorFlow.TFOutput rhs, Nullable&lt;bool&gt; lower = null, Nullable&lt;bool&gt; adjoint = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">matrix</span></td>
        <td><p>Shape is <code>[..., M, M]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rhs</span></td>
        <td><p>Shape is <code>[..., M, K]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">lower</span></td>
        <td><p>Optional argument
              Boolean indicating whether the innermost matrices in <code>matrix</code> are
              lower or upper triangular.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">adjoint</span></td>
        <td><p>Optional argument
              Boolean indicating whether to solve with <code>matrix</code> or its (block-wise)
              adjoint.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to scipy.linalg.solve_triangular
          @end_compatibility
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MatrixTriangularSolve&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Shape is <code>[..., M, K]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MatrixTriangularSolve_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>backsubstitution.</p>
<pre><code>          &lt;code&gt;matrix&lt;/code&gt; is a tensor of shape &lt;code&gt;[..., M, M]&lt;/code&gt; whose inner-most 2 dimensions form
          square matrices. If &lt;code&gt;lower&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; then the strictly upper triangular part
          of each inner-most matrix is assumed to be zero and not accessed.
          If &lt;code&gt;lower&lt;/code&gt; is False then the strictly lower triangular part of each inner-most
          matrix is assumed to be zero and not accessed.
          &lt;code&gt;rhs&lt;/code&gt; is a tensor of shape &lt;code&gt;[..., M, K]&lt;/code&gt;.

          The output is a tensor of shape &lt;code&gt;[..., M, K]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is
          &lt;code&gt;True&lt;/code&gt; then the innermost matrices in &lt;code&gt;output&lt;/code&gt; satisfy matrix equations
          &lt;code&gt;matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]&lt;/code&gt;.
          If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; then the strictly then the  innermost matrices in
          &lt;code&gt;output&lt;/code&gt; satisfy matrix equations
          &lt;code&gt;adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Max_" data-uid="TensorFlow.TFGraph.Max*"></a>
  <h4 id="TensorFlow_TFGraph_Max_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Max(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">Max(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the maximum of elements across dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Max (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable&lt;bool&gt; keep_dims = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The tensor to reduce.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reduction_indices</span></td>
        <td><p>The dimensions to reduce. Must be in the range
              <code>[-rank(input), rank(input))</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>Optional argument
              If true, retain reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Max&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Max_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
              <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
              <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
              retained with length 1.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Maximum_" data-uid="TensorFlow.TFGraph.Maximum*"></a>
  <h4 id="TensorFlow_TFGraph_Maximum_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Maximum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Maximum(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the max of x and y (i.e. x &gt; y ? x : y) element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Maximum (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Maximum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Maximum_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>Maximum</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MaxPool_" data-uid="TensorFlow.TFGraph.MaxPool*"></a>
  <h4 id="TensorFlow_TFGraph_MaxPool_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MaxPool(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">MaxPool(TFOutput, Int64[], Int64[], String, String, String)</h4>
  <div class="markdown level1 summary"><p>Performs max pooling on the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MaxPool (TensorFlow.TFOutput input, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D input to pool over.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>The size of the window for each dimension of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the
              input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, in_channels, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MaxPool&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The max pooled output tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MaxPool3D_" data-uid="TensorFlow.TFGraph.MaxPool3D*"></a>
  <h4 id="TensorFlow_TFGraph_MaxPool3D_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MaxPool3D(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">MaxPool3D(TFOutput, Int64[], Int64[], String, String, String)</h4>
  <div class="markdown level1 summary"><p>Performs 3D max pooling on the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MaxPool3D (TensorFlow.TFOutput input, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>1-D tensor of length 5. The size of the window for each dimension of
              the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D tensor of length 5. The stride of the sliding window for each
              dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              The data format of the input and output data. With the
              default format &quot;NDHWC&quot;, the data is stored in the order of:
              [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCDHW&quot;, the data storage order is:
              [batch, in_channels, in_depth, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MaxPool3D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The max pooled output tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MaxPool3DGrad_" data-uid="TensorFlow.TFGraph.MaxPool3DGrad*"></a>
  <h4 id="TensorFlow_TFGraph_MaxPool3DGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MaxPool3DGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">MaxPool3DGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)</h4>
  <div class="markdown level1 summary"><p>Computes gradients of max pooling function.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MaxPool3DGrad (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_input</span></td>
        <td><p>The original input tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_output</span></td>
        <td><p>The original output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>1-D tensor of length 5. The size of the window for each dimension of
              the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D tensor of length 5. The stride of the sliding window for each
              dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              The data format of the input and output data. With the
              default format &quot;NDHWC&quot;, the data is stored in the order of:
              [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCDHW&quot;, the data storage order is:
              [batch, in_channels, in_depth, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MaxPool3DGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MaxPool3DGradGrad_" data-uid="TensorFlow.TFGraph.MaxPool3DGradGrad*"></a>
  <h4 id="TensorFlow_TFGraph_MaxPool3DGradGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MaxPool3DGradGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">MaxPool3DGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)</h4>
  <div class="markdown level1 summary"><p>Computes second-order gradients of the maxpooling function.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MaxPool3DGradGrad (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_input</span></td>
        <td><p>The original input tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_output</span></td>
        <td><p>The original output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>1-D tensor of length 5. The size of the window for each dimension of
              the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>1-D tensor of length 5. The stride of the sliding window for each
              dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              The data format of the input and output data. With the
              default format &quot;NDHWC&quot;, the data is stored in the order of:
              [batch, in_depth, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCDHW&quot;, the data storage order is:
              [batch, in_channels, in_depth, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MaxPool3DGradGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Gradients of gradients w.r.t. the input to <code>max_pool</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MaxPoolGrad_" data-uid="TensorFlow.TFGraph.MaxPoolGrad*"></a>
  <h4 id="TensorFlow_TFGraph_MaxPoolGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MaxPoolGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">MaxPoolGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)</h4>
  <div class="markdown level1 summary"><p>Computes gradients of the maxpooling function.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MaxPoolGrad (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_input</span></td>
        <td><p>The original input tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_output</span></td>
        <td><p>The original output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>4-D.  Gradients w.r.t. the output of <code>max_pool</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>The size of the window for each dimension of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the
              input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, in_channels, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MaxPoolGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Gradients w.r.t. the input to <code>max_pool</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MaxPoolGradGrad_" data-uid="TensorFlow.TFGraph.MaxPoolGradGrad*"></a>
  <h4 id="TensorFlow_TFGraph_MaxPoolGradGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MaxPoolGradGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String,System.String)">MaxPoolGradGrad(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String, String)</h4>
  <div class="markdown level1 summary"><p>Computes second-order gradients of the maxpooling function.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MaxPoolGradGrad (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput grad, long[] ksize, long[] strides, string padding, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_input</span></td>
        <td><p>The original input tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_output</span></td>
        <td><p>The original output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>4-D.  Gradients of gradients w.r.t. the input of <code>max_pool</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>The size of the window for each dimension of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the
              input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, in_channels, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MaxPoolGradGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Gradients of gradients w.r.t. the input to <code>max_pool</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MaxPoolGradGradV2_" data-uid="TensorFlow.TFGraph.MaxPoolGradGradV2*"></a>
  <h4 id="TensorFlow_TFGraph_MaxPoolGradGradV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MaxPoolGradGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)">MaxPoolGradGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Computes second-order gradients of the maxpooling function.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MaxPoolGradGradV2 (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput grad, TensorFlow.TFOutput ksize, TensorFlow.TFOutput strides, string padding, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_input</span></td>
        <td><p>The original input tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_output</span></td>
        <td><p>The original output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>4-D.  Gradients of gradients w.r.t. the input of <code>max_pool</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ksize</span></td>
        <td><p>The size of the window for each dimension of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the
              input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, in_channels, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MaxPoolGradGradV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Gradients of gradients w.r.t. the input to <code>max_pool</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MaxPoolGradGradWithArgmax_" data-uid="TensorFlow.TFGraph.MaxPoolGradGradWithArgmax*"></a>
  <h4 id="TensorFlow_TFGraph_MaxPoolGradGradWithArgmax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_" data-uid="TensorFlow.TFGraph.MaxPoolGradGradWithArgmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">MaxPoolGradGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)</h4>
  <div class="markdown level1 summary"><p>Computes second-order gradients of the maxpooling function.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MaxPoolGradGradWithArgmax (TensorFlow.TFOutput input, TensorFlow.TFOutput grad, TensorFlow.TFOutput argmax, long[] ksize, long[] strides, string padding, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The original input.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.  Gradients w.r.t. the
              input of <code>max_pool</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">argmax</span></td>
        <td><p>The indices of the maximum values chosen for each output of <code>max_pool</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>The size of the window for each dimension of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the
              input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MaxPoolGradGradWithArgmax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Gradients of gradients w.r.t. the input of <code>max_pool</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MaxPoolGradV2_" data-uid="TensorFlow.TFGraph.MaxPoolGradV2*"></a>
  <h4 id="TensorFlow_TFGraph_MaxPoolGradV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MaxPoolGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)">MaxPoolGradV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Computes gradients of the maxpooling function.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MaxPoolGradV2 (TensorFlow.TFOutput orig_input, TensorFlow.TFOutput orig_output, TensorFlow.TFOutput grad, TensorFlow.TFOutput ksize, TensorFlow.TFOutput strides, string padding, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_input</span></td>
        <td><p>The original input tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">orig_output</span></td>
        <td><p>The original output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>4-D.  Gradients w.r.t. the output of <code>max_pool</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ksize</span></td>
        <td><p>The size of the window for each dimension of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the
              input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, in_channels, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MaxPoolGradV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Gradients w.r.t. the input to <code>max_pool</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MaxPoolGradWithArgmax_" data-uid="TensorFlow.TFGraph.MaxPoolGradWithArgmax*"></a>
  <h4 id="TensorFlow_TFGraph_MaxPoolGradWithArgmax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_" data-uid="TensorFlow.TFGraph.MaxPoolGradWithArgmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">MaxPoolGradWithArgmax(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)</h4>
  <div class="markdown level1 summary"><p>Computes gradients of the maxpooling function.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MaxPoolGradWithArgmax (TensorFlow.TFOutput input, TensorFlow.TFOutput grad, TensorFlow.TFOutput argmax, long[] ksize, long[] strides, string padding, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The original input.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.  Gradients w.r.t. the
              output of <code>max_pool</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">argmax</span></td>
        <td><p>The indices of the maximum values chosen for each output of <code>max_pool</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>The size of the window for each dimension of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the
              input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MaxPoolGradWithArgmax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Gradients w.r.t. the input of <code>max_pool</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MaxPoolV2_" data-uid="TensorFlow.TFGraph.MaxPoolV2*"></a>
  <h4 id="TensorFlow_TFGraph_MaxPoolV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MaxPoolV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)">MaxPoolV2(TFOutput, TFOutput, TFOutput, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Performs max pooling on the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MaxPoolV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput ksize, TensorFlow.TFOutput strides, string padding, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D input to pool over.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ksize</span></td>
        <td><p>The size of the window for each dimension of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the
              input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument
              Specify the data format of the input and output data. With the
              default format &quot;NHWC&quot;, the data is stored in the order of:
              [batch, in_height, in_width, in_channels].
              Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
              [batch, in_channels, in_height, in_width].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MaxPoolV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The max pooled output tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MaxPoolWithArgmax_" data-uid="TensorFlow.TFGraph.MaxPoolWithArgmax*"></a>
  <h4 id="TensorFlow_TFGraph_MaxPoolWithArgmax_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.MaxPoolWithArgmax(TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.Nullable{TensorFlow.TFDataType},System.String)">MaxPoolWithArgmax(TFOutput, Int64[], Int64[], String, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Performs max pooling on the input and outputs both max values and indices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; MaxPoolWithArgmax (TensorFlow.TFOutput input, long[] ksize, long[] strides, string padding, Nullable&lt;TensorFlow.TFDataType&gt; Targmax = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.  Input to pool over.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>The size of the window for each dimension of the input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the
              input tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">Targmax</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MaxPoolWithArgmax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output: The max pooled output tensor.
              argmax: 4-D.  The flattened indices of the max values chosen for each output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MaxPoolWithArgmax_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The indices in <code>argmax</code> are flattened, so that a maximum value at position
              <code>[b, y, x, c]</code> becomes flattened index
              <code>((b * height + y) * width + x) * channels + c</code>.</p>
<pre><code>          The indices returned are always in &lt;code&gt;[0, height) x [0, width)&lt;/code&gt; before flattening,
          even if padding is involved and the mathematically correct answer is outside
          (either negative or too large).  This is a bug, but fixing it is difficult to do
          in a safe backwards compatible way, especially due to flattening.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Mean_" data-uid="TensorFlow.TFGraph.Mean*"></a>
  <h4 id="TensorFlow_TFGraph_Mean_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Mean(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">Mean(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the mean of elements across dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Mean (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable&lt;bool&gt; keep_dims = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The tensor to reduce.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reduction_indices</span></td>
        <td><p>The dimensions to reduce. Must be in the range
              <code>[-rank(input), rank(input))</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>Optional argument
              If true, retain reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Mean&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Mean_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
              <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
              <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
              retained with length 1.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Merge_" data-uid="TensorFlow.TFGraph.Merge*"></a>
  <h4 id="TensorFlow_TFGraph_Merge_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.Merge(TensorFlow.TFOutput[],System.String)">Merge(TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Forwards the value of an available tensor from <code>inputs</code> to <code>output</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; Merge (TensorFlow.TFOutput[] inputs, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>The input tensors, exactly one of which will become available.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Merge&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output: Will be set to the available input tensor.
              value_index: The index of the chosen input tensor in <code>inputs</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Merge_TensorFlow_TFOutput___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>Merge</code> waits for at least one of the tensors in <code>inputs</code> to become available.
              It is usually combined with <code>Switch</code> to implement branching.</p>
<pre><code>          &lt;code&gt;Merge&lt;/code&gt; forwards the first tensor to become available to &lt;code&gt;output&lt;/code&gt;, and sets
          &lt;code&gt;value_index&lt;/code&gt; to its index in &lt;code&gt;inputs&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_MergeSummary_" data-uid="TensorFlow.TFGraph.MergeSummary*"></a>
  <h4 id="TensorFlow_TFGraph_MergeSummary_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.MergeSummary(TensorFlow.TFOutput[],System.String)">MergeSummary(TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Merges summaries.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MergeSummary (TensorFlow.TFOutput[] inputs, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>Can be of any shape.  Each must contain serialized <code>Summary</code> protocol
              buffers.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MergeSummary&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Scalar. Serialized <code>Summary</code> protocol buffer.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MergeSummary_TensorFlow_TFOutput___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op creates a
              <a href="https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto"><code>Summary</code></a>
              protocol buffer that contains the union of all the values in the input
              summaries.</p>
<pre><code>          When the Op is run, it reports an &lt;code&gt;InvalidArgument&lt;/code&gt; error if multiple values
          in the summaries to merge use the same tag.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_MergeV2Checkpoints_" data-uid="TensorFlow.TFGraph.MergeV2Checkpoints*"></a>
  <h4 id="TensorFlow_TFGraph_MergeV2Checkpoints_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.MergeV2Checkpoints(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">MergeV2Checkpoints(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>V2 format specific: merges the metadata files of sharded checkpoints.  The</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation MergeV2Checkpoints (TensorFlow.TFOutput checkpoint_prefixes, TensorFlow.TFOutput destination_prefix, Nullable&lt;bool&gt; delete_old_dirs = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">checkpoint_prefixes</span></td>
        <td><p>prefixes of V2 checkpoints to merge.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">destination_prefix</span></td>
        <td><p>scalar.  The desired final prefix.  Allowed to be the same
              as one of the checkpoint_prefixes.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">delete_old_dirs</span></td>
        <td><p>Optional argument
              see above.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MergeV2Checkpoints&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MergeV2Checkpoints_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>result is one logical checkpoint, with one physical metadata file and renamed
              data files.</p>
<pre><code>          Intended for &quot;grouping&quot; multiple checkpoints in a sharded checkpoint setup.

          If delete_old_dirs is true, attempts to delete recursively the dirname of each
          path in the input checkpoint_prefixes.  This is useful when those paths are non
          user-facing temporary locations.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Mfcc_" data-uid="TensorFlow.TFGraph.Mfcc*"></a>
  <h4 id="TensorFlow_TFGraph_Mfcc_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.Mfcc(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">Mfcc(TFOutput, TFOutput, Nullable&lt;Single&gt;, Nullable&lt;Single&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Transforms a spectrogram into a form that&#39;s useful for speech recognition.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Mfcc (TensorFlow.TFOutput spectrogram, TensorFlow.TFOutput sample_rate, Nullable&lt;float&gt; upper_frequency_limit = null, Nullable&lt;float&gt; lower_frequency_limit = null, Nullable&lt;long&gt; filterbank_channel_count = null, Nullable&lt;long&gt; dct_coefficient_count = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">spectrogram</span></td>
        <td><p>Typically produced by the Spectrogram op, with magnitude_squared
              set to true.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sample_rate</span></td>
        <td><p>How many samples per second the source audio used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">upper_frequency_limit</span></td>
        <td><p>Optional argument
              The highest frequency to use when calculating the
              ceptstrum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">lower_frequency_limit</span></td>
        <td><p>Optional argument
              The lowest frequency to use when calculating the
              ceptstrum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">filterbank_channel_count</span></td>
        <td><p>Optional argument
              Resolution of the Mel bank used internally.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">dct_coefficient_count</span></td>
        <td><p>Optional argument
              How many output channels to produce per time slice.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Mfcc&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Mfcc_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Mel Frequency Cepstral Coefficients are a way of representing audio data that&#39;s
              been effective as an input feature for machine learning. They are created by
              taking the spectrum of a spectrogram (a &#39;cepstrum&#39;), and discarding some of the
              higher frequencies that are less significant to the human ear. They have a long
              history in the speech recognition world, and <a href="https://en.wikipedia.org/wiki/Mel-frequency_cepstrum">https://en.wikipedia.org/wiki/Mel-frequency_cepstrum</a>
              is a good resource to learn more.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Min_" data-uid="TensorFlow.TFGraph.Min*"></a>
  <h4 id="TensorFlow_TFGraph_Min_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Min(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">Min(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the minimum of elements across dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Min (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable&lt;bool&gt; keep_dims = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The tensor to reduce.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reduction_indices</span></td>
        <td><p>The dimensions to reduce. Must be in the range
              <code>[-rank(input), rank(input))</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>Optional argument
              If true, retain reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Min&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Min_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
              <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
              <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
              retained with length 1.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Minimum_" data-uid="TensorFlow.TFGraph.Minimum*"></a>
  <h4 id="TensorFlow_TFGraph_Minimum_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Minimum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Minimum(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the min of x and y (i.e. x &lt; y ? x : y) element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Minimum (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Minimum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Minimum_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>Minimum</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MirrorPad_" data-uid="TensorFlow.TFGraph.MirrorPad*"></a>
  <h4 id="TensorFlow_TFGraph_MirrorPad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.MirrorPad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">MirrorPad(TFOutput, TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>Pads a tensor with mirrored values.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MirrorPad (TensorFlow.TFOutput input, TensorFlow.TFOutput paddings, string mode, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The input tensor to be padded.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">paddings</span></td>
        <td><p>A two-column matrix specifying the padding sizes. The number of
              rows must be the same as the rank of <code>input</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">mode</span></td>
        <td><p>Either <code>REFLECT</code> or <code>SYMMETRIC</code>. In reflect mode the padded regions
              do not include the borders, while in symmetric mode the padded regions
              do include the borders. For example, if <code>input</code> is <code>[1, 2, 3]</code> and <code>paddings</code>
              is <code>[0, 2]</code>, then the output is <code>[1, 2, 3, 2, 1]</code> in reflect mode, and
              it is <code>[1, 2, 3, 3, 2]</code> in symmetric mode.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MirrorPad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The padded tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MirrorPad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation pads a <code>input</code> with mirrored values according to the <code>paddings</code>
              you specify. <code>paddings</code> is an integer tensor with shape <code>[n, 2]</code>, where n is
              the rank of <code>input</code>. For each dimension D of <code>input</code>, <code>paddings[D, 0]</code> indicates
              how many values to add before the contents of <code>input</code> in that dimension, and
              <code>paddings[D, 1]</code> indicates how many values to add after the contents of <code>input</code>
              in that dimension. Both <code>paddings[D, 0]</code> and <code>paddings[D, 1]</code> must be no greater
              than <code>input.dim_size(D)</code> (or <code>input.dim_size(D) - 1</code>) if <code>copy_border</code> is true
              (if false, respectively).</p>
<pre><code>          The padded size of each dimension D of the output is:

          &lt;code&gt;paddings(D, 0) + input.dim_size(D) + paddings(D, 1)&lt;/code&gt;

          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;t&#39; is [[1, 2, 3], [4, 5, 6]].
          # &#39;paddings&#39; is [[1, 1]], [2, 2]].
          # &#39;mode&#39; is SYMMETRIC.
          # rank of &#39;t&#39; is 2.
          pad(t, paddings) ==&amp;gt; [[2, 1, 1, 2, 3, 3, 2]
          [2, 1, 1, 2, 3, 3, 2]
          [5, 4, 4, 5, 6, 6, 5]
          [5, 4, 4, 5, 6, 6, 5]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_MirrorPadGrad_" data-uid="TensorFlow.TFGraph.MirrorPadGrad*"></a>
  <h4 id="TensorFlow_TFGraph_MirrorPadGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.MirrorPadGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">MirrorPadGrad(TFOutput, TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>Gradient op for <code>MirrorPad</code> op. This op folds a mirror-padded tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MirrorPadGrad (TensorFlow.TFOutput input, TensorFlow.TFOutput paddings, string mode, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The input tensor to be folded.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">paddings</span></td>
        <td><p>A two-column matrix specifying the padding sizes. The number of
              rows must be the same as the rank of <code>input</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">mode</span></td>
        <td><p>The mode used in the <code>MirrorPad</code> op.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MirrorPadGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The folded tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MirrorPadGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation folds the padded areas of <code>input</code> by <code>MirrorPad</code> according to the
              <code>paddings</code> you specify. <code>paddings</code> must be the same as <code>paddings</code> argument
              given to the corresponding <code>MirrorPad</code> op.</p>
<pre><code>          The folded size of each dimension D of the output is:

          &lt;code&gt;input.dim_size(D) - paddings(D, 0) - paddings(D, 1)&lt;/code&gt;

          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;t&#39; is [[1, 2, 3], [4, 5, 6], [7, 8, 9]].
          # &#39;paddings&#39; is [[0, 1]], [0, 1]].
          # &#39;mode&#39; is SYMMETRIC.
          # rank of &#39;t&#39; is 2.
          pad(t, paddings) ==&amp;gt; [[ 1,  5]
          [11, 28]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Mod_" data-uid="TensorFlow.TFGraph.Mod*"></a>
  <h4 id="TensorFlow_TFGraph_Mod_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Mod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Mod(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns element-wise remainder of division. This emulates C semantics in that</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Mod (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Mod&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Mod_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>the result here is consistent with a truncating divide. E.g.
              <code>tf.truncatediv(x, y) * y + truncate_mod(x, y) = x</code>.</p>
<pre><code>          *NOTE*: &lt;code&gt;Mod&lt;/code&gt; supports broadcasting. More about broadcasting
          [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ModelDataset_" data-uid="TensorFlow.TFGraph.ModelDataset*"></a>
  <h4 id="TensorFlow_TFGraph_ModelDataset_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.ModelDataset(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">ModelDataset(TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Identity transformation that models performance.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ModelDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>A variant tensor representing the input dataset.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ModelDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ModelDataset_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Identity transformation that models performance.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Mul_" data-uid="TensorFlow.TFGraph.Mul*"></a>
  <h4 id="TensorFlow_TFGraph_Mul_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Mul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Mul(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns x * y element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Mul (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Mul&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Mul_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>Multiply</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MultiDeviceIterator_" data-uid="TensorFlow.TFGraph.MultiDeviceIterator*"></a>
  <h4 id="TensorFlow_TFGraph_MultiDeviceIterator_System_String___System_String_System_String_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.MultiDeviceIterator(System.String[],System.String,System.String,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">MultiDeviceIterator(String[], String, String, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a MultiDeviceIterator resource.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MultiDeviceIterator (string[] devices, string shared_name, string container, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">devices</span></td>
        <td><p>A list of devices the iterator works across.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>If non-empty, this resource will be shared under the given name
              across multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>If non-empty, this resource is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>The type list for the return values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>The list of shapes being produced.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MultiDeviceIterator&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Handle to the resource created.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MultiDeviceIteratorFromStringHandle_" data-uid="TensorFlow.TFGraph.MultiDeviceIteratorFromStringHandle*"></a>
  <h4 id="TensorFlow_TFGraph_MultiDeviceIteratorFromStringHandle_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.MultiDeviceIteratorFromStringHandle(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">MultiDeviceIteratorFromStringHandle(TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Generates a MultiDeviceIterator resource from its provided string handle.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MultiDeviceIteratorFromStringHandle (TensorFlow.TFOutput string_handle, TensorFlow.TFDataType[] output_types = null, TensorFlow.TFShape[] output_shapes = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">string_handle</span></td>
        <td><p>String representing the resource.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>Optional argument
              The type list for the return values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>Optional argument
              The list of shapes being produced.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MultiDeviceIteratorFromStringHandle&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A MultiDeviceIterator resource.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MultiDeviceIteratorGetNextFromShard_" data-uid="TensorFlow.TFGraph.MultiDeviceIteratorGetNextFromShard*"></a>
  <h4 id="TensorFlow_TFGraph_MultiDeviceIteratorGetNextFromShard_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.MultiDeviceIteratorGetNextFromShard(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">MultiDeviceIteratorGetNextFromShard(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Gets next element for the provided shard number.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] MultiDeviceIteratorGetNextFromShard (TensorFlow.TFOutput multi_device_iterator, TensorFlow.TFOutput shard_num, TensorFlow.TFOutput incarnation_id, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">multi_device_iterator</span></td>
        <td><p>A MultiDeviceIterator resource.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shard_num</span></td>
        <td><p>Integer representing which shard to fetch data for.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">incarnation_id</span></td>
        <td><p>Which incarnation of the MultiDeviceIterator is running.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>The type list for the return values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>The list of shapes being produced.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MultiDeviceIteratorGetNextFromShard&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>Result of the get_next on the dataset.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MultiDeviceIteratorInit_" data-uid="TensorFlow.TFGraph.MultiDeviceIteratorInit*"></a>
  <h4 id="TensorFlow_TFGraph_MultiDeviceIteratorInit_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.MultiDeviceIteratorInit(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">MultiDeviceIteratorInit(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Initializes the multi device iterator with the given dataset.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MultiDeviceIteratorInit (TensorFlow.TFOutput dataset, TensorFlow.TFOutput multi_device_iterator, TensorFlow.TFOutput max_buffer_size, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dataset</span></td>
        <td><p>Dataset to be iterated upon.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">multi_device_iterator</span></td>
        <td><p>A MultiDeviceIteratorResource.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_buffer_size</span></td>
        <td><p>The maximum size of the host side per device buffer to keep.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MultiDeviceIteratorInit&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>An int64 indicating which incarnation of the MultiDeviceIterator
              is running.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MultiDeviceIteratorToStringHandle_" data-uid="TensorFlow.TFGraph.MultiDeviceIteratorToStringHandle*"></a>
  <h4 id="TensorFlow_TFGraph_MultiDeviceIteratorToStringHandle_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.MultiDeviceIteratorToStringHandle(TensorFlow.TFOutput,System.String)">MultiDeviceIteratorToStringHandle(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Produces a string handle for the given MultiDeviceIterator.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MultiDeviceIteratorToStringHandle (TensorFlow.TFOutput multi_device_iterator, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">multi_device_iterator</span></td>
        <td><p>A MultiDeviceIterator resource.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MultiDeviceIteratorToStringHandle&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A string representing the resource.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Multinomial_" data-uid="TensorFlow.TFGraph.Multinomial*"></a>
  <h4 id="TensorFlow_TFGraph_Multinomial_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.Multinomial(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)">Multinomial(TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Draws samples from a multinomial distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Multinomial (TensorFlow.TFOutput logits, TensorFlow.TFOutput num_samples, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, Nullable&lt;TensorFlow.TFDataType&gt; output_dtype = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">logits</span></td>
        <td><p>2-D Tensor with shape <code>[batch_size, num_classes]</code>.  Each slice <code>[i, :]</code>
              represents the unnormalized log probabilities for all classes.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_samples</span></td>
        <td><p>0-D.  Number of independent samples to draw for each row slice.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either seed or seed2 is set to be non-zero, the internal random number
              generator is seeded by the given seed.  Otherwise, a random seed is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              A second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">output_dtype</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Multinomial&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>2-D Tensor with shape <code>[batch_size, num_samples]</code>.  Each slice <code>[i, :]</code>
              contains the drawn class labels with range <code>[0, num_classes)</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_MutableDenseHashTable_" data-uid="TensorFlow.TFGraph.MutableDenseHashTable*"></a>
  <h4 id="TensorFlow_TFGraph_MutableDenseHashTable_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__TensorFlow_TFShape_System_Nullable_System_Int64__System_Nullable_System_Single__System_String_" data-uid="TensorFlow.TFGraph.MutableDenseHashTable(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.Nullable{System.Int64},System.Nullable{System.Single},System.String)">MutableDenseHashTable(TFOutput, TFDataType, String, String, Nullable&lt;Boolean&gt;, TFShape, Nullable&lt;Int64&gt;, Nullable&lt;Single&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Creates an empty hash table that uses tensors as the backing store.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MutableDenseHashTable (TensorFlow.TFOutput empty_key, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable&lt;bool&gt; use_node_name_sharing = null, TensorFlow.TFShape value_shape = null, Nullable&lt;long&gt; initial_num_buckets = null, Nullable&lt;float&gt; max_load_factor = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">empty_key</span></td>
        <td><p>The key used to represent empty key buckets internally. Must not
              be used in insert or lookup operations.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">value_dtype</span></td>
        <td><p>Type of the table values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_node_name_sharing</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">value_shape</span></td>
        <td><p>Optional argument
              The shape of each value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">initial_num_buckets</span></td>
        <td><p>Optional argument
              The initial number of hash table buckets. Must be a power
              to 2.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">max_load_factor</span></td>
        <td><p>Optional argument
              The maximum ratio between number of entries and number of
              buckets before growing the table. Must be between 0 and 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MutableDenseHashTable&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MutableDenseHashTable_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__TensorFlow_TFShape_System_Nullable_System_Int64__System_Nullable_System_Single__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>It uses &quot;open addressing&quot; with quadratic reprobing to resolve
              collisions.</p>
<pre><code>          This op creates a mutable hash table, specifying the type of its keys and
          values. Each value must be a scalar. Data can be inserted into the table using
          the insert operations. It does not support the initialization operation.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_MutableDenseHashTableV2_" data-uid="TensorFlow.TFGraph.MutableDenseHashTableV2*"></a>
  <h4 id="TensorFlow_TFGraph_MutableDenseHashTableV2_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__TensorFlow_TFShape_System_Nullable_System_Int64__System_Nullable_System_Single__System_String_" data-uid="TensorFlow.TFGraph.MutableDenseHashTableV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.Nullable{System.Int64},System.Nullable{System.Single},System.String)">MutableDenseHashTableV2(TFOutput, TFDataType, String, String, Nullable&lt;Boolean&gt;, TFShape, Nullable&lt;Int64&gt;, Nullable&lt;Single&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Creates an empty hash table that uses tensors as the backing store.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MutableDenseHashTableV2 (TensorFlow.TFOutput empty_key, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable&lt;bool&gt; use_node_name_sharing = null, TensorFlow.TFShape value_shape = null, Nullable&lt;long&gt; initial_num_buckets = null, Nullable&lt;float&gt; max_load_factor = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">empty_key</span></td>
        <td><p>The key used to represent empty key buckets internally. Must not
              be used in insert or lookup operations.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">value_dtype</span></td>
        <td><p>Type of the table values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_node_name_sharing</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">value_shape</span></td>
        <td><p>Optional argument
              The shape of each value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">initial_num_buckets</span></td>
        <td><p>Optional argument
              The initial number of hash table buckets. Must be a power
              to 2.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">max_load_factor</span></td>
        <td><p>Optional argument
              The maximum ratio between number of entries and number of
              buckets before growing the table. Must be between 0 and 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MutableDenseHashTableV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MutableDenseHashTableV2_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__TensorFlow_TFShape_System_Nullable_System_Int64__System_Nullable_System_Single__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>It uses &quot;open addressing&quot; with quadratic reprobing to resolve
              collisions.</p>
<pre><code>          This op creates a mutable hash table, specifying the type of its keys and
          values. Each value must be a scalar. Data can be inserted into the table using
          the insert operations. It does not support the initialization operation.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_MutableHashTable_" data-uid="TensorFlow.TFGraph.MutableHashTable*"></a>
  <h4 id="TensorFlow_TFGraph_MutableHashTable_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.MutableHashTable(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)">MutableHashTable(TFDataType, TFDataType, String, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Creates an empty hash table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MutableHashTable (TensorFlow.TFDataType key_dtype, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable&lt;bool&gt; use_node_name_sharing = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">key_dtype</span></td>
        <td><p>Type of the table keys.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">value_dtype</span></td>
        <td><p>Type of the table values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_node_name_sharing</span></td>
        <td><p>Optional argument
              If true and shared_name is empty, the table is shared
              using the node name.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MutableHashTable&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MutableHashTable_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op creates a mutable hash table, specifying the type of its keys and
              values. Each value must be a scalar. Data can be inserted into the table using
              the insert operations. It does not support the initialization operation.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MutableHashTableOfTensors_" data-uid="TensorFlow.TFGraph.MutableHashTableOfTensors*"></a>
  <h4 id="TensorFlow_TFGraph_MutableHashTableOfTensors_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.MutableHashTableOfTensors(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.String)">MutableHashTableOfTensors(TFDataType, TFDataType, String, String, Nullable&lt;Boolean&gt;, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>Creates an empty hash table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MutableHashTableOfTensors (TensorFlow.TFDataType key_dtype, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable&lt;bool&gt; use_node_name_sharing = null, TensorFlow.TFShape value_shape = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">key_dtype</span></td>
        <td><p>Type of the table keys.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">value_dtype</span></td>
        <td><p>Type of the table values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_node_name_sharing</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">value_shape</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MutableHashTableOfTensors&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MutableHashTableOfTensors_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__TensorFlow_TFShape_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op creates a mutable hash table, specifying the type of its keys and
              values. Each value must be a vector. Data can be inserted into the table using
              the insert operations. It does not support the initialization operation.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MutableHashTableOfTensorsV2_" data-uid="TensorFlow.TFGraph.MutableHashTableOfTensorsV2*"></a>
  <h4 id="TensorFlow_TFGraph_MutableHashTableOfTensorsV2_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.MutableHashTableOfTensorsV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},TensorFlow.TFShape,System.String)">MutableHashTableOfTensorsV2(TFDataType, TFDataType, String, String, Nullable&lt;Boolean&gt;, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>Creates an empty hash table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MutableHashTableOfTensorsV2 (TensorFlow.TFDataType key_dtype, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable&lt;bool&gt; use_node_name_sharing = null, TensorFlow.TFShape value_shape = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">key_dtype</span></td>
        <td><p>Type of the table keys.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">value_dtype</span></td>
        <td><p>Type of the table values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_node_name_sharing</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">value_shape</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MutableHashTableOfTensorsV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MutableHashTableOfTensorsV2_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__TensorFlow_TFShape_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op creates a mutable hash table, specifying the type of its keys and
              values. Each value must be a vector. Data can be inserted into the table using
              the insert operations. It does not support the initialization operation.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MutableHashTableV2_" data-uid="TensorFlow.TFGraph.MutableHashTableV2*"></a>
  <h4 id="TensorFlow_TFGraph_MutableHashTableV2_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.MutableHashTableV2(TensorFlow.TFDataType,TensorFlow.TFDataType,System.String,System.String,System.Nullable{System.Boolean},System.String)">MutableHashTableV2(TFDataType, TFDataType, String, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Creates an empty hash table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MutableHashTableV2 (TensorFlow.TFDataType key_dtype, TensorFlow.TFDataType value_dtype, string container = null, string shared_name = null, Nullable&lt;bool&gt; use_node_name_sharing = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">key_dtype</span></td>
        <td><p>Type of the table keys.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">value_dtype</span></td>
        <td><p>Type of the table values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this table is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this table is shared under the given name across
              multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_node_name_sharing</span></td>
        <td><p>Optional argument
              If true and shared_name is empty, the table is shared
              using the node name.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MutableHashTableV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Handle to a table.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MutableHashTableV2_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op creates a mutable hash table, specifying the type of its keys and
              values. Each value must be a scalar. Data can be inserted into the table using
              the insert operations. It does not support the initialization operation.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_MutexLock_" data-uid="TensorFlow.TFGraph.MutexLock*"></a>
  <h4 id="TensorFlow_TFGraph_MutexLock_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.MutexLock(TensorFlow.TFOutput,System.String)">MutexLock(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Locks a mutex resource.  The output is the lock.  So long as the lock tensor</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MutexLock (TensorFlow.TFOutput mutex, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mutex</span></td>
        <td><p>The mutex resource to lock.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MutexLock&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor that keeps a shared pointer to a lock on the mutex;
              when the Tensor is destroyed, the use count on the shared pointer is decreased
              by 1.  When it reaches 0, the lock is released.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_MutexLock_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>is alive, any other request to use <code>MutexLock</code> with this mutex will wait.</p>
<pre><code>          This is particularly useful for creating a critical section when used in
          conjunction with &lt;code&gt;MutexLockIdentity&lt;/code&gt;:

           &lt;pre&gt;&lt;code&gt;

          mutex = mutex_v2(
          shared_name=handle_name, container=container, name=name)

          def execute_in_critical_section(fn, *args, **kwargs):
          lock = gen_resource_variable_ops.mutex_lock(mutex)

          with ops.control_dependencies([lock]):
          r = fn(*args, **kwargs)

          with ops.control_dependencies(nest.flatten(r)):
          with ops.colocate_with(mutex):
          ensure_lock_exists = mutex_lock_identity(lock)

          # Make sure that if any element of r is accessed, all of
          # them are executed together.
          r = nest.map_structure(tf.identity, r)

          with ops.control_dependencies([ensure_lock_exists]):
          return nest.map_structure(tf.identity, r)
           &lt;/code&gt;&lt;/pre&gt;

          While &lt;code&gt;fn&lt;/code&gt; is running in the critical section, no other functions which wish to
          use this critical section may run.

          Often the use case is that two executions of the same graph, in parallel,
          wish to run &lt;code&gt;fn&lt;/code&gt;; and we wish to ensure that only one of them executes
          at a time.  This is especially important if &lt;code&gt;fn&lt;/code&gt; modifies one or more
          variables at a time.

          It is also useful if two separate functions must share a resource, but we
          wish to ensure the usage is exclusive.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_MutexV2_" data-uid="TensorFlow.TFGraph.MutexV2*"></a>
  <h4 id="TensorFlow_TFGraph_MutexV2_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.MutexV2(System.String,System.String,System.String)">MutexV2(String, String, String)</h4>
  <div class="markdown level1 summary"><p>Creates a Mutex resource that can be locked by <code>MutexLock</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput MutexV2 (string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this variable is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this variable is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;MutexV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The mutex resource.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Neg_" data-uid="TensorFlow.TFGraph.Neg*"></a>
  <h4 id="TensorFlow_TFGraph_Neg_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Neg(TensorFlow.TFOutput,System.String)">Neg(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes numerical negative value element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Neg (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Neg&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Neg_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>I.e., \(y = -x\).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_NegTrain_" data-uid="TensorFlow.TFGraph.NegTrain*"></a>
  <h4 id="TensorFlow_TFGraph_NegTrain_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64_System_String_" data-uid="TensorFlow.TFGraph.NegTrain(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64,System.String)">NegTrain(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], Int64, String)</h4>
  <div class="markdown level1 summary"><p>Training via negative sampling.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation NegTrain (TensorFlow.TFOutput w_in, TensorFlow.TFOutput w_out, TensorFlow.TFOutput examples, TensorFlow.TFOutput labels, TensorFlow.TFOutput lr, long[] vocab_count, long num_negative_samples, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">w_in</span></td>
        <td><p>input word embedding.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">w_out</span></td>
        <td><p>output word embedding.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">examples</span></td>
        <td><p>A vector of word ids.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">labels</span></td>
        <td><p>A vector of word ids.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">vocab_count</span></td>
        <td><p>Count of words in the vocabulary.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_negative_samples</span></td>
        <td><p>Number of negative samples per example.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;NegTrain&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_NextIteration_" data-uid="TensorFlow.TFGraph.NextIteration*"></a>
  <h4 id="TensorFlow_TFGraph_NextIteration_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.NextIteration(TensorFlow.TFOutput,System.String)">NextIteration(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Makes its input available to the next iteration.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput NextIteration (TensorFlow.TFOutput data, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>The tensor to be made available to the next iteration.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;NextIteration&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The same tensor as <code>data</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_NonMaxSuppression_" data-uid="TensorFlow.TFGraph.NonMaxSuppression*"></a>
  <h4 id="TensorFlow_TFGraph_NonMaxSuppression_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_String_" data-uid="TensorFlow.TFGraph.NonMaxSuppression(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Single},System.String)">NonMaxSuppression(TFOutput, TFOutput, TFOutput, Nullable&lt;Single&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Greedily selects a subset of bounding boxes in descending order of score,</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput NonMaxSuppression (TensorFlow.TFOutput boxes, TensorFlow.TFOutput scores, TensorFlow.TFOutput max_output_size, Nullable&lt;float&gt; iou_threshold = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">boxes</span></td>
        <td><p>A 2-D float tensor of shape <code>[num_boxes, 4]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">scores</span></td>
        <td><p>A 1-D float tensor of shape <code>[num_boxes]</code> representing a single
              score corresponding to each box (each row of boxes).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_output_size</span></td>
        <td><p>A scalar integer tensor representing the maximum number of
              boxes to be selected by non max suppression.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">iou_threshold</span></td>
        <td><p>Optional argument
              A float representing the threshold for deciding whether boxes
              overlap too much with respect to IOU.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;NonMaxSuppression&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A 1-D integer tensor of shape <code>[M]</code> representing the selected
              indices from the boxes tensor, where <code>M &lt;= max_output_size</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_NonMaxSuppression_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Single__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>pruning away boxes that have high intersection-over-union (IOU) overlap
              with previously selected boxes.  Bounding boxes are supplied as
              [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
              diagonal pair of box corners and the coordinates can be provided as normalized
              (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
              is agnostic to where the origin is in the coordinate system.  Note that this
              algorithm is invariant to orthogonal transformations and translations
              of the coordinate system; thus translating or reflections of the coordinate
              system result in the same boxes being selected by the algorithm.
              The output of this operation is a set of integers indexing into the input
              collection of bounding boxes representing the selected boxes.  The bounding
              box coordinates corresponding to the selected indices can then be obtained
              using the <code>tf.gather operation</code>.  For example:
              selected_indices = tf.image.non_max_suppression(
              boxes, scores, max_output_size, iou_threshold)
              selected_boxes = tf.gather(boxes, selected_indices)</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_NonMaxSuppressionV2_" data-uid="TensorFlow.TFGraph.NonMaxSuppressionV2*"></a>
  <h4 id="TensorFlow_TFGraph_NonMaxSuppressionV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.NonMaxSuppressionV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">NonMaxSuppressionV2(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Greedily selects a subset of bounding boxes in descending order of score,</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput NonMaxSuppressionV2 (TensorFlow.TFOutput boxes, TensorFlow.TFOutput scores, TensorFlow.TFOutput max_output_size, TensorFlow.TFOutput iou_threshold, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">boxes</span></td>
        <td><p>A 2-D float tensor of shape <code>[num_boxes, 4]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">scores</span></td>
        <td><p>A 1-D float tensor of shape <code>[num_boxes]</code> representing a single
              score corresponding to each box (each row of boxes).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_output_size</span></td>
        <td><p>A scalar integer tensor representing the maximum number of
              boxes to be selected by non max suppression.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">iou_threshold</span></td>
        <td><p>A 0-D float tensor representing the threshold for deciding whether
              boxes overlap too much with respect to IOU.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;NonMaxSuppressionV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A 1-D integer tensor of shape <code>[M]</code> representing the selected
              indices from the boxes tensor, where <code>M &lt;= max_output_size</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_NonMaxSuppressionV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>pruning away boxes that have high intersection-over-union (IOU) overlap
              with previously selected boxes.  Bounding boxes are supplied as
              [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
              diagonal pair of box corners and the coordinates can be provided as normalized
              (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
              is agnostic to where the origin is in the coordinate system.  Note that this
              algorithm is invariant to orthogonal transformations and translations
              of the coordinate system; thus translating or reflections of the coordinate
              system result in the same boxes being selected by the algorithm.</p>
<pre><code>          The output of this operation is a set of integers indexing into the input
          collection of bounding boxes representing the selected boxes.  The bounding
          box coordinates corresponding to the selected indices can then be obtained
          using the &lt;code&gt;tf.gather operation&lt;/code&gt;.  For example:

          selected_indices = tf.image.non_max_suppression_v2(
          boxes, scores, max_output_size, iou_threshold)
          selected_boxes = tf.gather(boxes, selected_indices)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_NonMaxSuppressionV3_" data-uid="TensorFlow.TFGraph.NonMaxSuppressionV3*"></a>
  <h4 id="TensorFlow_TFGraph_NonMaxSuppressionV3_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.NonMaxSuppressionV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">NonMaxSuppressionV3(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Greedily selects a subset of bounding boxes in descending order of score,</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput NonMaxSuppressionV3 (TensorFlow.TFOutput boxes, TensorFlow.TFOutput scores, TensorFlow.TFOutput max_output_size, TensorFlow.TFOutput iou_threshold, TensorFlow.TFOutput score_threshold, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">boxes</span></td>
        <td><p>A 2-D float tensor of shape <code>[num_boxes, 4]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">scores</span></td>
        <td><p>A 1-D float tensor of shape <code>[num_boxes]</code> representing a single
              score corresponding to each box (each row of boxes).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_output_size</span></td>
        <td><p>A scalar integer tensor representing the maximum number of
              boxes to be selected by non max suppression.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">iou_threshold</span></td>
        <td><p>A 0-D float tensor representing the threshold for deciding whether
              boxes overlap too much with respect to IOU.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">score_threshold</span></td>
        <td><p>A 0-D float tensor representing the threshold for deciding when to remove
              boxes based on score.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;NonMaxSuppressionV3&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A 1-D integer tensor of shape <code>[M]</code> representing the selected
              indices from the boxes tensor, where <code>M &lt;= max_output_size</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_NonMaxSuppressionV3_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>pruning away boxes that have high intersection-over-union (IOU) overlap
              with previously selected boxes.  Bounding boxes with score less than
              <code>score_threshold</code> are removed.  Bounding boxes are supplied as
              [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
              diagonal pair of box corners and the coordinates can be provided as normalized
              (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
              is agnostic to where the origin is in the coordinate system and more
              generally is invariant to orthogonal transformations and translations
              of the coordinate system; thus translating or reflections of the coordinate
              system result in the same boxes being selected by the algorithm.
              The output of this operation is a set of integers indexing into the input
              collection of bounding boxes representing the selected boxes.  The bounding
              box coordinates corresponding to the selected indices can then be obtained
              using the <code>tf.gather operation</code>.  For example:
              selected_indices = tf.image.non_max_suppression_v2(
              boxes, scores, max_output_size, iou_threshold, score_threshold)
              selected_boxes = tf.gather(boxes, selected_indices)</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_NonMaxSuppressionV4_" data-uid="TensorFlow.TFGraph.NonMaxSuppressionV4*"></a>
  <h4 id="TensorFlow_TFGraph_NonMaxSuppressionV4_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.NonMaxSuppressionV4(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">NonMaxSuppressionV4(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Greedily selects a subset of bounding boxes in descending order of score,</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; NonMaxSuppressionV4 (TensorFlow.TFOutput boxes, TensorFlow.TFOutput scores, TensorFlow.TFOutput max_output_size, TensorFlow.TFOutput iou_threshold, TensorFlow.TFOutput score_threshold, Nullable&lt;bool&gt; pad_to_max_output_size = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">boxes</span></td>
        <td><p>A 2-D float tensor of shape <code>[num_boxes, 4]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">scores</span></td>
        <td><p>A 1-D float tensor of shape <code>[num_boxes]</code> representing a single
              score corresponding to each box (each row of boxes).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_output_size</span></td>
        <td><p>A scalar integer tensor representing the maximum number of
              boxes to be selected by non max suppression.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">iou_threshold</span></td>
        <td><p>A 0-D float tensor representing the threshold for deciding whether
              boxes overlap too much with respect to IOU.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">score_threshold</span></td>
        <td><p>A 0-D float tensor representing the threshold for deciding when to remove
              boxes based on score.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">pad_to_max_output_size</span></td>
        <td><p>Optional argument
              If true, the output <code>selected_indices</code> is padded to be of length
              <code>max_output_size</code>. Defaults to false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;NonMaxSuppressionV4&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              selected_indices: A 1-D integer tensor of shape <code>[M]</code> representing the selected
              indices from the boxes tensor, where <code>M &lt;= max_output_size</code>.
              valid_outputs: A 0-D integer tensor representing the number of valid elements in
              <code>selected_indices</code>, with the valid elements appearing first.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_NonMaxSuppressionV4_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>pruning away boxes that have high intersection-over-union (IOU) overlap
              with previously selected boxes.  Bounding boxes with score less than
              <code>score_threshold</code> are removed.  Bounding boxes are supplied as
              [y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
              diagonal pair of box corners and the coordinates can be provided as normalized
              (i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
              is agnostic to where the origin is in the coordinate system and more
              generally is invariant to orthogonal transformations and translations
              of the coordinate system; thus translating or reflections of the coordinate
              system result in the same boxes being selected by the algorithm.
              The output of this operation is a set of integers indexing into the input
              collection of bounding boxes representing the selected boxes.  The bounding
              box coordinates corresponding to the selected indices can then be obtained
              using the <code>tf.gather operation</code>.  For example:
              selected_indices = tf.image.non_max_suppression_v2(
              boxes, scores, max_output_size, iou_threshold, score_threshold)
              selected_boxes = tf.gather(boxes, selected_indices)</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_NonMaxSuppressionWithOverlaps_" data-uid="TensorFlow.TFGraph.NonMaxSuppressionWithOverlaps*"></a>
  <h4 id="TensorFlow_TFGraph_NonMaxSuppressionWithOverlaps_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.NonMaxSuppressionWithOverlaps(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">NonMaxSuppressionWithOverlaps(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Greedily selects a subset of bounding boxes in descending order of score,</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput NonMaxSuppressionWithOverlaps (TensorFlow.TFOutput overlaps, TensorFlow.TFOutput scores, TensorFlow.TFOutput max_output_size, TensorFlow.TFOutput overlap_threshold, TensorFlow.TFOutput score_threshold, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">overlaps</span></td>
        <td><p>A 2-D float tensor of shape <code>[num_boxes, num_boxes]</code> representing
              the n-by-n box overlap values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">scores</span></td>
        <td><p>A 1-D float tensor of shape <code>[num_boxes]</code> representing a single
              score corresponding to each box (each row of boxes).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_output_size</span></td>
        <td><p>A scalar integer tensor representing the maximum number of
              boxes to be selected by non max suppression.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">overlap_threshold</span></td>
        <td><p>A 0-D float tensor representing the threshold for deciding whether
              boxes overlap too.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">score_threshold</span></td>
        <td><p>A 0-D float tensor representing the threshold for deciding when to remove
              boxes based on score.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;NonMaxSuppressionWithOverlaps&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A 1-D integer tensor of shape <code>[M]</code> representing the selected
              indices from the boxes tensor, where <code>M &lt;= max_output_size</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_NonMaxSuppressionWithOverlaps_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>pruning away boxes that have high overlaps
              with previously selected boxes.  Bounding boxes with score less than
              <code>score_threshold</code> are removed. N-by-n overlap values are supplied as square matrix,
              which allows for defining a custom overlap criterium (eg. intersection over union,
              intersection over area, etc.).</p>
<pre><code>          The output of this operation is a set of integers indexing into the input
          collection of bounding boxes representing the selected boxes.  The bounding
          box coordinates corresponding to the selected indices can then be obtained
          using the &lt;code&gt;tf.gather operation&lt;/code&gt;.  For example:

          selected_indices = tf.image.non_max_suppression_with_overlaps(
          overlaps, scores, max_output_size, overlap_threshold, score_threshold)
          selected_boxes = tf.gather(boxes, selected_indices)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_NoOp_" data-uid="TensorFlow.TFGraph.NoOp*"></a>
  <h4 id="TensorFlow_TFGraph_NoOp_System_String_" data-uid="TensorFlow.TFGraph.NoOp(System.String)">NoOp(String)</h4>
  <div class="markdown level1 summary"><p>Does nothing. Only useful as a placeholder for control edges.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation NoOp (string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;NoOp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_NotEqual_" data-uid="TensorFlow.TFGraph.NotEqual*"></a>
  <h4 id="TensorFlow_TFGraph_NotEqual_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.NotEqual(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">NotEqual(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the truth value of (x != y) element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput NotEqual (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;NotEqual&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_NotEqual_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>NotEqual</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_NthElement_" data-uid="TensorFlow.TFGraph.NthElement*"></a>
  <h4 id="TensorFlow_TFGraph_NthElement_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.NthElement(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">NthElement(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Finds values of the <code>n</code>-th order statistic for the last dimension.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput NthElement (TensorFlow.TFOutput input, TensorFlow.TFOutput n, Nullable&lt;bool&gt; reverse = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>1-D or higher with last dimension at least <code>n+1</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">n</span></td>
        <td><p>0-D. Position of sorted vector to select along the last dimension (along
              each row for matrices). Valid range of n is <code>[0, input.shape[:-1])</code></p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">reverse</span></td>
        <td><p>Optional argument
              When set to True, find the nth-largest value in the vector and vice
              versa.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;NthElement&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The <code>n</code>-th order statistic along each last dimensional slice.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_NthElement_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If the input is a vector (rank-1), finds the entries which is the nth-smallest
              value in the vector and outputs their values as scalar tensor.</p>
<pre><code>          For matrices (resp. higher rank input), computes the entries which is the
          nth-smallest value in each row (resp. vector along the last dimension). Thus,

          values.shape = input.shape[:-1]
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_OneHot_" data-uid="TensorFlow.TFGraph.OneHot*"></a>
  <h4 id="TensorFlow_TFGraph_OneHot_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.OneHot(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)">OneHot(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput OneHot (TensorFlow.TFOutput indices, TensorFlow.TFOutput depth, TensorFlow.TFOutput on_value, TensorFlow.TFOutput off_value, Nullable&lt;long&gt; axis = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">depth</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">on_value</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">off_value</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">axis</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Ones_" data-uid="TensorFlow.TFGraph.Ones*"></a>
  <h4 id="TensorFlow_TFGraph_Ones_TensorFlow_TFShape_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.Ones(TensorFlow.TFShape,TensorFlow.TFDataType,System.String)">Ones(TFShape, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Outputs One values based on shape of tensor</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Ones (TensorFlow.TFShape shape, TensorFlow.TFDataType dtype = TensorFlow.TFDataType.Double, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>Shape of the output tensor</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>Optional Type of the Zero value. Default: Double</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Operation name, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_OnesLike_" data-uid="TensorFlow.TFGraph.OnesLike*"></a>
  <h4 id="TensorFlow_TFGraph_OnesLike_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.OnesLike(TensorFlow.TFOutput,System.String)">OnesLike(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns a tensor of ones with the same shape and type as x.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput OnesLike (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>a tensor of type T.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OnesLike&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>a tensor of the same shape and type as x but filled with ones.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_OptimizeDataset_" data-uid="TensorFlow.TFGraph.OptimizeDataset*"></a>
  <h4 id="TensorFlow_TFGraph_OptimizeDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.OptimizeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">OptimizeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset by applying optimizations to <code>input_dataset</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput OptimizeDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput optimizations, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>A variant tensor representing the input dataset.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">optimizations</span></td>
        <td><p>A <code>tf.string</code> vector <code>tf.Tensor</code> identifying optimizations to use.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OptimizeDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_OptimizeDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Creates a dataset by applying optimizations to <code>input_dataset</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_OptionalFromValue_" data-uid="TensorFlow.TFGraph.OptionalFromValue*"></a>
  <h4 id="TensorFlow_TFGraph_OptionalFromValue_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.OptionalFromValue(TensorFlow.TFOutput[],System.String)">OptionalFromValue(TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Constructs an Optional variant from a tuple of tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput OptionalFromValue (TensorFlow.TFOutput[] components, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">components</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OptionalFromValue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_OptionalGetValue_" data-uid="TensorFlow.TFGraph.OptionalGetValue*"></a>
  <h4 id="TensorFlow_TFGraph_OptionalGetValue_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.OptionalGetValue(TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">OptionalGetValue(TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Returns the value stored in an Optional variant or raises an error if none exists.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] OptionalGetValue (TensorFlow.TFOutput optional, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">optional</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OptionalGetValue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_OptionalHasValue_" data-uid="TensorFlow.TFGraph.OptionalHasValue*"></a>
  <h4 id="TensorFlow_TFGraph_OptionalHasValue_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.OptionalHasValue(TensorFlow.TFOutput,System.String)">OptionalHasValue(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns true if and only if the given Optional variant has a value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput OptionalHasValue (TensorFlow.TFOutput optional, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">optional</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OptionalHasValue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_OptionalNone_" data-uid="TensorFlow.TFGraph.OptionalNone*"></a>
  <h4 id="TensorFlow_TFGraph_OptionalNone_System_String_" data-uid="TensorFlow.TFGraph.OptionalNone(System.String)">OptionalNone(String)</h4>
  <div class="markdown level1 summary"><p>Creates an Optional variant with no value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput OptionalNone (string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OptionalNone&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_OrderedMapClear_" data-uid="TensorFlow.TFGraph.OrderedMapClear*"></a>
  <h4 id="TensorFlow_TFGraph_OrderedMapClear_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.OrderedMapClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">OrderedMapClear(TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op removes all elements in the underlying container.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation OrderedMapClear (TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OrderedMapClear&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_OrderedMapIncompleteSize_" data-uid="TensorFlow.TFGraph.OrderedMapIncompleteSize*"></a>
  <h4 id="TensorFlow_TFGraph_OrderedMapIncompleteSize_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.OrderedMapIncompleteSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">OrderedMapIncompleteSize(TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op returns the number of incomplete elements in the underlying container.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput OrderedMapIncompleteSize (TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OrderedMapIncompleteSize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_OrderedMapPeek_" data-uid="TensorFlow.TFGraph.OrderedMapPeek*"></a>
  <h4 id="TensorFlow_TFGraph_OrderedMapPeek_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.OrderedMapPeek(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">OrderedMapPeek(TFOutput, TFOutput, TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op peeks at the values at the specified key.  If the</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] OrderedMapPeek (TensorFlow.TFOutput key, TensorFlow.TFOutput indices, TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">key</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OrderedMapPeek&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_OrderedMapPeek_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>underlying container does not contain this key
              this op will block until it does.   This Op is optimized for
              performance.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_OrderedMapSize_" data-uid="TensorFlow.TFGraph.OrderedMapSize*"></a>
  <h4 id="TensorFlow_TFGraph_OrderedMapSize_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.OrderedMapSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">OrderedMapSize(TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op returns the number of elements in the underlying container.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput OrderedMapSize (TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OrderedMapSize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_OrderedMapStage_" data-uid="TensorFlow.TFGraph.OrderedMapStage*"></a>
  <h4 id="TensorFlow_TFGraph_OrderedMapStage_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.OrderedMapStage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">OrderedMapStage(TFOutput, TFOutput, TFOutput[], TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Stage (key, values) in the underlying container which behaves like a ordered</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation OrderedMapStage (TensorFlow.TFOutput key, TensorFlow.TFOutput indices, TensorFlow.TFOutput[] values, TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">key</span></td>
        <td><p>int64</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">values</span></td>
        <td><p>a list of tensors
              dtypes A list of data types that inserted values should adhere to.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument
              Maximum number of elements in the Staging Area. If &gt; 0, inserts
              on the container will block when the capacity is reached.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this queue is placed in the given container. Otherwise,
              a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              It is necessary to match this name to the matching Unstage Op.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OrderedMapStage&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_OrderedMapStage_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>associative container.   Elements are ordered by key.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_OrderedMapUnstage_" data-uid="TensorFlow.TFGraph.OrderedMapUnstage*"></a>
  <h4 id="TensorFlow_TFGraph_OrderedMapUnstage_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.OrderedMapUnstage(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">OrderedMapUnstage(TFOutput, TFOutput, TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op removes and returns the values associated with the key</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] OrderedMapUnstage (TensorFlow.TFOutput key, TensorFlow.TFOutput indices, TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">key</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OrderedMapUnstage&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_OrderedMapUnstage_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>from the underlying container.   If the underlying container
              does not contain this key, the op will block until it does.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_OrderedMapUnstageNoKey_" data-uid="TensorFlow.TFGraph.OrderedMapUnstageNoKey*"></a>
  <h4 id="TensorFlow_TFGraph_OrderedMapUnstageNoKey_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.OrderedMapUnstageNoKey(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">OrderedMapUnstageNoKey(TFOutput, TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op removes and returns the (key, value) element with the smallest</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput[]&gt; OrderedMapUnstageNoKey (TensorFlow.TFOutput indices, TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OrderedMapUnstageNoKey&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              key:
              values:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_OrderedMapUnstageNoKey_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>key from the underlying container.   If the underlying container
              does not contain elements, the op will block until it does.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_OutfeedDequeue_" data-uid="TensorFlow.TFGraph.OutfeedDequeue*"></a>
  <h4 id="TensorFlow_TFGraph_OutfeedDequeue_TensorFlow_TFDataType_TensorFlow_TFShape_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.OutfeedDequeue(TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Int64},System.String)">OutfeedDequeue(TFDataType, TFShape, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Retrieves a single tensor from the computation outfeed.  This operation will</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput OutfeedDequeue (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, Nullable&lt;long&gt; device_ordinal = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of elements in the tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">device_ordinal</span></td>
        <td><p>Optional argument
              The TPU device to use. This should be -1 when the Op
              is running on a TPU device, and &gt;= 0 when the Op is running on the CPU
              device.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OutfeedDequeue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor that will be read from the device outfeed.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_OutfeedDequeue_TensorFlow_TFDataType_TensorFlow_TFShape_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>block indefinitely until data is available.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_OutfeedDequeueTuple_" data-uid="TensorFlow.TFGraph.OutfeedDequeueTuple*"></a>
  <h4 id="TensorFlow_TFGraph_OutfeedDequeueTuple_TensorFlow_TFDataType___TensorFlow_TFShape___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.OutfeedDequeueTuple(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String)">OutfeedDequeueTuple(TFDataType[], TFShape[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve multiple values that will be emitted by the computation as an XLA</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] OutfeedDequeueTuple (TensorFlow.TFDataType[] dtypes, TensorFlow.TFShape[] shapes, Nullable&lt;long&gt; device_ordinal = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>The element types of each element in <code>outputs</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>The shapes of each tensor in <code>outputs</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">device_ordinal</span></td>
        <td><p>Optional argument
              The TPU device to use. This should be -1 when the Op
              is running on a TPU device, and &gt;= 0 when the Op is running on the CPU
              device.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OutfeedDequeueTuple&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>A list of tensors that will be read from the outfeed.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_OutfeedDequeueTuple_TensorFlow_TFDataType___TensorFlow_TFShape___System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>tuple.  This operations will block indefinitely until data is available.
              Output <code>i</code> corresponds to XLA tuple element <code>i</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_OutfeedEnqueue_" data-uid="TensorFlow.TFGraph.OutfeedEnqueue*"></a>
  <h4 id="TensorFlow_TFGraph_OutfeedEnqueue_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.OutfeedEnqueue(TensorFlow.TFOutput,System.String)">OutfeedEnqueue(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>An op which emits a single Tensor value from an XLA computation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation OutfeedEnqueue (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A tensor that will be inserted into the outfeed queue.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OutfeedEnqueue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_OutfeedEnqueueTuple_" data-uid="TensorFlow.TFGraph.OutfeedEnqueueTuple*"></a>
  <h4 id="TensorFlow_TFGraph_OutfeedEnqueueTuple_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.OutfeedEnqueueTuple(TensorFlow.TFOutput[],System.String)">OutfeedEnqueueTuple(TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>An op which emits multiple Tensor values from an XLA computation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation OutfeedEnqueueTuple (TensorFlow.TFOutput[] inputs, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>A list of tensors that will be inserted into the outfeed queue as an
              XLA tuple.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;OutfeedEnqueueTuple&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Pack_" data-uid="TensorFlow.TFGraph.Pack*"></a>
  <h4 id="TensorFlow_TFGraph_Pack_TensorFlow_TFOutput___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.Pack(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">Pack(TFOutput[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Packs a list of <code>N</code> rank-<code>R</code> tensors into one rank-<code>(R+1)</code> tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Pack (TensorFlow.TFOutput[] values, Nullable&lt;long&gt; axis = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">values</span></td>
        <td><p>Must be of same shape and type.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">axis</span></td>
        <td><p>Optional argument
              Dimension along which to pack.  Negative values wrap around, so the
              valid range is <code>[-(R+1), R+1)</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Pack&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The packed tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Pack_TensorFlow_TFOutput___System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Packs the <code>N</code> tensors in <code>values</code> into a tensor with rank one higher than each
              tensor in <code>values</code>, by packing them along the <code>axis</code> dimension.
              Given a list of tensors of shape <code>(A, B, C)</code>;</p>
<pre><code>          if &lt;code&gt;axis == 0&lt;/code&gt; then the &lt;code&gt;output&lt;/code&gt; tensor will have the shape &lt;code&gt;(N, A, B, C)&lt;/code&gt;.
          if &lt;code&gt;axis == 1&lt;/code&gt; then the &lt;code&gt;output&lt;/code&gt; tensor will have the shape &lt;code&gt;(A, N, B, C)&lt;/code&gt;.
          Etc.

          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;x&#39; is [1, 4]
          # &#39;y&#39; is [2, 5]
          # &#39;z&#39; is [3, 6]
          pack([x, y, z]) =&amp;gt; [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.
          pack([x, y, z], axis=1) =&amp;gt; [[1, 2, 3], [4, 5, 6]]
           &lt;/code&gt;&lt;/pre&gt;

          This is the opposite of &lt;code&gt;unpack&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Pad_" data-uid="TensorFlow.TFGraph.Pad*"></a>
  <h4 id="TensorFlow_TFGraph_Pad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Pad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Pad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Pads a tensor with zeros.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Pad (TensorFlow.TFOutput input, TensorFlow.TFOutput paddings, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">paddings</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Pad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Pad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation pads a <code>input</code> with zeros according to the <code>paddings</code> you
              specify. <code>paddings</code> is an integer tensor with shape <code>[Dn, 2]</code>, where n is the
              rank of <code>input</code>. For each dimension D of <code>input</code>, <code>paddings[D, 0]</code> indicates
              how many zeros to add before the contents of <code>input</code> in that dimension, and
              <code>paddings[D, 1]</code> indicates how many zeros to add after the contents of <code>input</code>
              in that dimension.</p>
<pre><code>          The padded size of each dimension D of the output is:

          &lt;code&gt;paddings(D, 0) + input.dim_size(D) + paddings(D, 1)&lt;/code&gt;

          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;t&#39; is [[1, 1], [2, 2]]
          # &#39;paddings&#39; is [[1, 1], [2, 2]]
          # rank of &#39;t&#39; is 2
          pad(t, paddings) ==&amp;gt; [[0, 0, 0, 0, 0, 0]
          [0, 0, 1, 1, 0, 0]
          [0, 0, 2, 2, 0, 0]
          [0, 0, 0, 0, 0, 0]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_PaddedBatchDataset_" data-uid="TensorFlow.TFGraph.PaddedBatchDataset*"></a>
  <h4 id="TensorFlow_TFGraph_PaddedBatchDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.PaddedBatchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)">PaddedBatchDataset(TFOutput, TFOutput, TFOutput[], TFOutput[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that batches and pads <code>batch_size</code> elements from the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput PaddedBatchDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput batch_size, TensorFlow.TFOutput[] padded_shapes, TensorFlow.TFOutput[] padding_values, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">batch_size</span></td>
        <td><p>A scalar representing the number of elements to accumulate in a
              batch.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">padded_shapes</span></td>
        <td><p>A list of int64 tensors representing the desired padded shapes
              of the corresponding output components. These shapes may be partially
              specified, using <code>-1</code> to indicate that a particular dimension should be
              padded to the maximum size of all batch elements.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">padding_values</span></td>
        <td><p>A list of scalars containing the padding value to use for
              each of the outputs.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;PaddedBatchDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_PaddedBatchDatasetV2_" data-uid="TensorFlow.TFGraph.PaddedBatchDatasetV2*"></a>
  <h4 id="TensorFlow_TFGraph_PaddedBatchDatasetV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput_TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.PaddedBatchDatasetV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFShape[],System.String)">PaddedBatchDatasetV2(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput, TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that batches and pads <code>batch_size</code> elements from the input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput PaddedBatchDatasetV2 (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput batch_size, TensorFlow.TFOutput[] padded_shapes, TensorFlow.TFOutput[] padding_values, TensorFlow.TFOutput drop_remainder, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">batch_size</span></td>
        <td><p>A scalar representing the number of elements to accumulate in a
              batch.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">padded_shapes</span></td>
        <td><p>A list of int64 tensors representing the desired padded shapes
              of the corresponding output components. These shapes may be partially
              specified, using <code>-1</code> to indicate that a particular dimension should be
              padded to the maximum size of all batch elements.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">padding_values</span></td>
        <td><p>A list of scalars containing the padding value to use for
              each of the outputs.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">drop_remainder</span></td>
        <td><p>A scalar representing whether the last batch should be dropped in case its size
              is smaller than desired.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;PaddedBatchDatasetV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_PaddingFIFOQueue_" data-uid="TensorFlow.TFGraph.PaddingFIFOQueue*"></a>
  <h4 id="TensorFlow_TFGraph_PaddingFIFOQueue_TensorFlow_TFDataType___TensorFlow_TFShape___System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.PaddingFIFOQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)">PaddingFIFOQueue(TFDataType[], TFShape[], Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A queue that produces elements in first-in first-out order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput PaddingFIFOQueue (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable&lt;long&gt; capacity = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a value.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>Optional argument
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types.
              Shapes of fixed rank but variable size are allowed by setting
              any shape dimension to -1.  In this case, the inputs&#39; shape may vary along
              the given dimension, and DequeueMany will pad the given dimension with
              zeros up to the maximum shape of all elements in the given batch.
              If the length of this attr is 0, different queue elements may have
              different ranks and shapes, but only one element may be dequeued at a time.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;PaddingFIFOQueue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_PaddingFIFOQueue_TensorFlow_TFDataType___TensorFlow_TFShape___System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Variable-size shapes are allowed by setting the corresponding shape dimensions
              to 0 in the shape attr.  In this case DequeueMany will pad up to the maximum
              size of any given element in the minibatch.  See below for details.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_PaddingFIFOQueueV2_" data-uid="TensorFlow.TFGraph.PaddingFIFOQueueV2*"></a>
  <h4 id="TensorFlow_TFGraph_PaddingFIFOQueueV2_TensorFlow_TFDataType___TensorFlow_TFShape___System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.PaddingFIFOQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.String,System.String,System.String)">PaddingFIFOQueueV2(TFDataType[], TFShape[], Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A queue that produces elements in first-in first-out order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput PaddingFIFOQueueV2 (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable&lt;long&gt; capacity = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a value.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>Optional argument
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types.
              Shapes of fixed rank but variable size are allowed by setting
              any shape dimension to -1.  In this case, the inputs&#39; shape may vary along
              the given dimension, and DequeueMany will pad the given dimension with
              zeros up to the maximum shape of all elements in the given batch.
              If the length of this attr is 0, different queue elements may have
              different ranks and shapes, but only one element may be dequeued at a time.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;PaddingFIFOQueueV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_PaddingFIFOQueueV2_TensorFlow_TFDataType___TensorFlow_TFShape___System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Variable-size shapes are allowed by setting the corresponding shape dimensions
              to 0 in the shape attr.  In this case DequeueMany will pad up to the maximum
              size of any given element in the minibatch.  See below for details.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_PadV2_" data-uid="TensorFlow.TFGraph.PadV2*"></a>
  <h4 id="TensorFlow_TFGraph_PadV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.PadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">PadV2(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Pads a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput PadV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput paddings, TensorFlow.TFOutput constant_values, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">paddings</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">constant_values</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;PadV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_PadV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation pads <code>input</code> according to the <code>paddings</code> and <code>constant_values</code>
              you specify. <code>paddings</code> is an integer tensor with shape <code>[Dn, 2]</code>, where n is
              the rank of <code>input</code>. For each dimension D of <code>input</code>, <code>paddings[D, 0]</code> indicates
              how many padding values to add before the contents of <code>input</code> in that dimension,
              and <code>paddings[D, 1]</code> indicates how many padding values to add after the contents
              of <code>input</code> in that dimension. <code>constant_values</code> is a scalar tensor of the same
              type as <code>input</code> that indicates the value to use for padding <code>input</code>.</p>
<pre><code>          The padded size of each dimension D of the output is:

          &lt;code&gt;paddings(D, 0) + input.dim_size(D) + paddings(D, 1)&lt;/code&gt;

          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;t&#39; is [[1, 1], [2, 2]]
          # &#39;paddings&#39; is [[1, 1], [2, 2]]
          # &#39;constant_values&#39; is 0
          # rank of &#39;t&#39; is 2
          pad(t, paddings) ==&amp;gt; [[0, 0, 0, 0, 0, 0]
          [0, 0, 1, 1, 0, 0]
          [0, 0, 2, 2, 0, 0]
          [0, 0, 0, 0, 0, 0]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ParallelConcat_" data-uid="TensorFlow.TFGraph.ParallelConcat*"></a>
  <h4 id="TensorFlow_TFGraph_ParallelConcat_TensorFlow_TFOutput___TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.ParallelConcat(TensorFlow.TFOutput[],TensorFlow.TFShape,System.String)">ParallelConcat(TFOutput[], TFShape, String)</h4>
  <div class="markdown level1 summary"><p>Concatenates a list of <code>N</code> tensors along the first dimension.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ParallelConcat (TensorFlow.TFOutput[] values, TensorFlow.TFShape shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">values</span></td>
        <td><p>Tensors to be concatenated. All must have size 1 in the first dimension
              and same shape.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>the final shape of the result; should be equal to the shapes of any input
              but with the number of input values in the first dimension.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ParallelConcat&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The concatenated tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ParallelConcat_TensorFlow_TFOutput___TensorFlow_TFShape_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The input tensors are all required to have size 1 in the first dimension.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;x&#39; is [[1, 4]]
          # &#39;y&#39; is [[2, 5]]
          # &#39;z&#39; is [[3, 6]]
          parallel_concat([x, y, z]) =&amp;gt; [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.
           &lt;/code&gt;&lt;/pre&gt;

          The difference between concat and parallel_concat is that concat requires all
          of the inputs be computed before the operation will begin but doesn&#39;t require
          that the input shapes be known during graph construction.  Parallel concat
          will copy pieces of the input into the output as they become available, in
          some situations this can provide a performance benefit.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ParallelDynamicStitch_" data-uid="TensorFlow.TFGraph.ParallelDynamicStitch*"></a>
  <h4 id="TensorFlow_TFGraph_ParallelDynamicStitch_TensorFlow_TFOutput___TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.ParallelDynamicStitch(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)">ParallelDynamicStitch(TFOutput[], TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Interleave the values from the <code>data</code> tensors into a single tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ParallelDynamicStitch (TensorFlow.TFOutput[] indices, TensorFlow.TFOutput[] data, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ParallelDynamicStitch&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ParallelDynamicStitch_TensorFlow_TFOutput___TensorFlow_TFOutput___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Builds a merged tensor such that</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]
           &lt;/code&gt;&lt;/pre&gt;

          For example, if each &lt;code&gt;indices[m]&lt;/code&gt; is scalar or vector, we have

           &lt;pre&gt;&lt;code&gt;
          # Scalar indices:
          merged[indices[m], ...] = data[m][...]

          # Vector indices:
          merged[indices[m][i], ...] = data[m][i, ...]
           &lt;/code&gt;&lt;/pre&gt;

          Each &lt;code&gt;data[i].shape&lt;/code&gt; must start with the corresponding &lt;code&gt;indices[i].shape&lt;/code&gt;,
          and the rest of &lt;code&gt;data[i].shape&lt;/code&gt; must be constant w.r.t. &lt;code&gt;i&lt;/code&gt;.  That is, we
          must have &lt;code&gt;data[i].shape = indices[i].shape + constant&lt;/code&gt;.  In terms of this
          &lt;code&gt;constant&lt;/code&gt;, the output shape is

          merged.shape = [max(indices)] + constant

          Values may be merged in parallel, so if an index appears in both &lt;code&gt;indices[m][i]&lt;/code&gt;
          and &lt;code&gt;indices[n][j]&lt;/code&gt;, the result may be invalid. This differs from the normal
          DynamicStitch operator that defines the behavior in that case.

          For example:

           &lt;pre&gt;&lt;code&gt;
          indices[0] = 6
          indices[1] = [4, 1]
          indices[2] = [[5, 2], [0, 3]]
          data[0] = [61, 62]
          data[1] = [[41, 42], [11, 12]]
          data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]
          merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],
          [51, 52], [61, 62]]
           &lt;/code&gt;&lt;/pre&gt;

          This method can be used to merge partitions created by &lt;code&gt;dynamic_partition&lt;/code&gt;
          as illustrated on the following example:

           &lt;pre&gt;&lt;code&gt;
          # Apply function (increments x_i) on elements for which a certain condition
          # apply (x_i != -1 in this example).
          x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])
          condition_mask=tf.not_equal(x,tf.constant(-1.))
          partitioned_data = tf.dynamic_partition(
          x, tf.cast(condition_mask, tf.int32) , 2)
          partitioned_data[1] = partitioned_data[1] + 1.0
          condition_indices = tf.dynamic_partition(
          tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)
          x = tf.dynamic_stitch(condition_indices, partitioned_data)
          # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain
          # unchanged.
           &lt;/code&gt;&lt;/pre&gt;

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/DynamicStitch.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ParameterizedTruncatedNormal_" data-uid="TensorFlow.TFGraph.ParameterizedTruncatedNormal*"></a>
  <h4 id="TensorFlow_TFGraph_ParameterizedTruncatedNormal_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.ParameterizedTruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">ParameterizedTruncatedNormal(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Outputs random values from a normal distribution. The parameters may each be a</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ParameterizedTruncatedNormal (TensorFlow.TFOutput shape, TensorFlow.TFOutput means, TensorFlow.TFOutput stdevs, TensorFlow.TFOutput minvals, TensorFlow.TFOutput maxvals, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the output tensor. Batches are indexed by the 0th dimension.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">means</span></td>
        <td><p>The mean parameter of each batch.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">stdevs</span></td>
        <td><p>The standard deviation parameter of each batch. Must be greater than 0.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">minvals</span></td>
        <td><p>The minimum cutoff. May be -infinity.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">maxvals</span></td>
        <td><p>The maximum cutoff. May be +infinity, and must be more than the minval
              for each batch.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              A second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ParameterizedTruncatedNormal&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A matrix of shape num_batches x samples_per_batch, filled with random
              truncated normal values using the parameters for each row.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ParameterizedTruncatedNormal_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>scalar which applies to the entire output, or a vector of length shape[0] which
              stores the parameters for each batch.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ParseExample_" data-uid="TensorFlow.TFGraph.ParseExample*"></a>
  <h4 id="TensorFlow_TFGraph_ParseExample_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.ParseExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">ParseExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Transforms a vector of brain.Example protos (as strings) into typed tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]&gt; ParseExample (TensorFlow.TFOutput serialized, TensorFlow.TFOutput names, TensorFlow.TFOutput[] sparse_keys, TensorFlow.TFOutput[] dense_keys, TensorFlow.TFOutput[] dense_defaults, TensorFlow.TFDataType[] sparse_types, TensorFlow.TFShape[] dense_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">serialized</span></td>
        <td><p>A vector containing a batch of binary serialized Example protos.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">names</span></td>
        <td><p>A vector containing the names of the serialized protos.
              May contain, for example, table key (descriptive) names for the
              corresponding serialized protos.  These are purely useful for debugging
              purposes, and the presence of values here has no effect on the output.
              May also be an empty vector if no names are available.
              If non-empty, this vector must be the same length as &quot;serialized&quot;.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">sparse_keys</span></td>
        <td><p>A list of Nsparse string Tensors (scalars).
              The keys expected in the Examples&#39; features associated with sparse values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">dense_keys</span></td>
        <td><p>A list of Ndense string Tensors (scalars).
              The keys expected in the Examples&#39; features associated with dense values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">dense_defaults</span></td>
        <td><p>A list of Ndense Tensors (some may be empty).
              dense_defaults[j] provides default values
              when the example&#39;s feature_map lacks dense_key[j].  If an empty Tensor is
              provided for dense_defaults[j], then the Feature dense_keys[j] is required.
              The input type is inferred from dense_defaults[j], even when it&#39;s empty.
              If dense_defaults[j] is not empty, and dense_shapes[j] is fully defined,
              then the shape of dense_defaults[j] must match that of dense_shapes[j].
              If dense_shapes[j] has an undefined major dimension (variable strides dense
              feature), dense_defaults[j] must contain a single element:
              the padding element.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">sparse_types</span></td>
        <td><p>A list of Nsparse types; the data types of data in each Feature
              given in sparse_keys.
              Currently the ParseExample supports DT_FLOAT (FloatList),
              DT_INT64 (Int64List), and DT_STRING (BytesList).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">dense_shapes</span></td>
        <td><p>A list of Ndense shapes; the shapes of data in each Feature
              given in dense_keys.
              The number of elements in the Feature corresponding to dense_key[j]
              must always equal dense_shapes[j].NumEntries().
              If dense_shapes[j] == (D0, D1, ..., DN) then the shape of output
              Tensor dense_values[j] will be (|serialized|, D0, D1, ..., DN):
              The dense outputs are just the inputs row-stacked by batch.
              This works for dense_shapes[j] = (-1, D1, ..., DN).  In this case
              the shape of the output Tensor dense_values[j] will be
              (|serialized|, M, D1, .., DN), where M is the maximum number of blocks
              of elements of length D1 * .... * DN, across all minibatch entries
              in the input.  Any minibatch entry with less than M blocks of elements of
              length D1 * ... * DN will be padded with the corresponding default_value
              scalar element along the second dimension.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ParseExample&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sparse_indices:
              sparse_values:
              sparse_shapes:
              dense_values:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ParseSequenceExample_" data-uid="TensorFlow.TFGraph.ParseSequenceExample*"></a>
  <h4 id="TensorFlow_TFGraph_ParseSequenceExample_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String___System_String___System_String___System_String___System_String___System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__TensorFlow_TFDataType___TensorFlow_TFDataType___TensorFlow_TFShape___TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.ParseSequenceExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String[],System.String[],System.String[],System.String[],System.String[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},TensorFlow.TFDataType[],TensorFlow.TFDataType[],TensorFlow.TFShape[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">ParseSequenceExample(TFOutput, TFOutput, TFOutput[], String[], String[], String[], String[], String[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Transforms a vector of brain.SequenceExample protos (as strings) into typed tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],ValueTuple&lt;TensorFlow.TFOutput[],TensorFlow.TFOutput[]&gt;&gt; ParseSequenceExample (TensorFlow.TFOutput serialized, TensorFlow.TFOutput debug_name, TensorFlow.TFOutput[] context_dense_defaults, string[] feature_list_dense_missing_assumed_empty, string[] context_sparse_keys, string[] context_dense_keys, string[] feature_list_sparse_keys, string[] feature_list_dense_keys, Nullable&lt;long&gt; Ncontext_sparse = null, Nullable&lt;long&gt; Ncontext_dense = null, Nullable&lt;long&gt; Nfeature_list_sparse = null, Nullable&lt;long&gt; Nfeature_list_dense = null, TensorFlow.TFDataType[] context_sparse_types = null, TensorFlow.TFDataType[] feature_list_dense_types = null, TensorFlow.TFShape[] context_dense_shapes = null, TensorFlow.TFDataType[] feature_list_sparse_types = null, TensorFlow.TFShape[] feature_list_dense_shapes = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">serialized</span></td>
        <td><p>A vector containing binary serialized SequenceExample protos.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">debug_name</span></td>
        <td><p>A vector containing the names of the serialized protos.
              May contain, for example, table key (descriptive) name for the
              corresponding serialized proto.  This is purely useful for debugging
              purposes, and the presence of values here has no effect on the output.
              May also be an empty vector if no name is available.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">context_dense_defaults</span></td>
        <td><p>A list of Ncontext_dense Tensors (some may be empty).
              context_dense_defaults[j] provides default values
              when the SequenceExample&#39;s context map lacks context_dense_key[j].
              If an empty Tensor is provided for context_dense_defaults[j],
              then the Feature context_dense_keys[j] is required.
              The input type is inferred from context_dense_defaults[j], even when it&#39;s
              empty.  If context_dense_defaults[j] is not empty, its shape must match
              context_dense_shapes[j].</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">feature_list_dense_missing_assumed_empty</span></td>
        <td><p>A vector listing the
              FeatureList keys which may be missing from the SequenceExamples.  If the
              associated FeatureList is missing, it is treated as empty.  By default,
              any FeatureList not listed in this vector must exist in the SequenceExamples.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">context_sparse_keys</span></td>
        <td><p>A list of Ncontext_sparse string Tensors (scalars).
              The keys expected in the Examples&#39; features associated with context_sparse
              values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">context_dense_keys</span></td>
        <td><p>A list of Ncontext_dense string Tensors (scalars).
              The keys expected in the SequenceExamples&#39; context features associated with
              dense values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">feature_list_sparse_keys</span></td>
        <td><p>A list of Nfeature_list_sparse string Tensors
              (scalars).  The keys expected in the FeatureLists associated with sparse
              values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">feature_list_dense_keys</span></td>
        <td><p>A list of Nfeature_list_dense string Tensors (scalars).
              The keys expected in the SequenceExamples&#39; feature_lists associated
              with lists of dense values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">Ncontext_sparse</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">Ncontext_dense</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">Nfeature_list_sparse</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">Nfeature_list_dense</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">context_sparse_types</span></td>
        <td><p>Optional argument
              A list of Ncontext_sparse types; the data types of data in
              each context Feature given in context_sparse_keys.
              Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
              DT_INT64 (Int64List), and DT_STRING (BytesList).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">feature_list_dense_types</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">context_dense_shapes</span></td>
        <td><p>Optional argument
              A list of Ncontext_dense shapes; the shapes of data in
              each context Feature given in context_dense_keys.
              The number of elements in the Feature corresponding to context_dense_key[j]
              must always equal context_dense_shapes[j].NumEntries().
              The shape of context_dense_values[j] will match context_dense_shapes[j].</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">feature_list_sparse_types</span></td>
        <td><p>Optional argument
              A list of Nfeature_list_sparse types; the data types
              of data in each FeatureList given in feature_list_sparse_keys.
              Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
              DT_INT64 (Int64List), and DT_STRING (BytesList).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">feature_list_dense_shapes</span></td>
        <td><p>Optional argument
              A list of Nfeature_list_dense shapes; the shapes of
              data in each FeatureList given in feature_list_dense_keys.
              The shape of each Feature in the FeatureList corresponding to
              feature_list_dense_key[j] must always equal
              feature_list_dense_shapes[j].NumEntries().</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ParseSequenceExample&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]&gt;&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              context_sparse_indices:
              context_sparse_values:
              context_sparse_shapes:
              context_dense_values:
              feature_list_sparse_indices:
              feature_list_sparse_values:
              feature_list_sparse_shapes:
              feature_list_dense_values:
              feature_list_dense_lengths:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ParseSingleExample_" data-uid="TensorFlow.TFGraph.ParseSingleExample*"></a>
  <h4 id="TensorFlow_TFGraph_ParseSingleExample_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Int64_System_String___System_String___TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.ParseSingleExample(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Int64,System.String[],System.String[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">ParseSingleExample(TFOutput, TFOutput[], Int64, String[], String[], TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Transforms a tf.Example proto (as a string) into typed tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]&gt; ParseSingleExample (TensorFlow.TFOutput serialized, TensorFlow.TFOutput[] dense_defaults, long num_sparse, string[] sparse_keys, string[] dense_keys, TensorFlow.TFDataType[] sparse_types, TensorFlow.TFShape[] dense_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">serialized</span></td>
        <td><p>A vector containing a batch of binary serialized Example protos.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">dense_defaults</span></td>
        <td><p>A list of Tensors (some may be empty), whose length matches
              the length of <code>dense_keys</code>. dense_defaults[j] provides default values
              when the example&#39;s feature_map lacks dense_key[j].  If an empty Tensor is
              provided for dense_defaults[j], then the Feature dense_keys[j] is required.
              The input type is inferred from dense_defaults[j], even when it&#39;s empty.
              If dense_defaults[j] is not empty, and dense_shapes[j] is fully defined,
              then the shape of dense_defaults[j] must match that of dense_shapes[j].
              If dense_shapes[j] has an undefined major dimension (variable strides dense
              feature), dense_defaults[j] must contain a single element:
              the padding element.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_sparse</span></td>
        <td><p>The number of sparse features to be parsed from the example. This
              must match the lengths of <code>sparse_keys</code> and <code>sparse_types</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">sparse_keys</span></td>
        <td><p>A list of <code>num_sparse</code> strings.
              The keys expected in the Examples&#39; features associated with sparse values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">dense_keys</span></td>
        <td><p>The keys expected in the Examples&#39; features associated with dense
              values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">sparse_types</span></td>
        <td><p>A list of <code>num_sparse</code> types; the data types of data in each
              Feature given in sparse_keys.
              Currently the ParseSingleExample op supports DT_FLOAT (FloatList),
              DT_INT64 (Int64List), and DT_STRING (BytesList).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">dense_shapes</span></td>
        <td><p>The shapes of data in each Feature given in dense_keys.
              The length of this list must match the length of <code>dense_keys</code>.  The
              number of elements in the Feature corresponding to dense_key[j] must
              always equal dense_shapes[j].NumEntries().  If dense_shapes[j] ==
              (D0, D1, ..., DN) then the shape of output Tensor dense_values[j]
              will be (D0, D1, ..., DN): In the case dense_shapes[j] = (-1, D1,
              ..., DN), the shape of the output Tensor dense_values[j] will be (M,
              D1, .., DN), where M is the number of blocks of elements of length
              D1 * .... * DN, in the input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ParseSingleExample&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sparse_indices:
              sparse_values:
              sparse_shapes:
              dense_values:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ParseSingleSequenceExample_" data-uid="TensorFlow.TFGraph.ParseSingleSequenceExample*"></a>
  <h4 id="TensorFlow_TFGraph_ParseSingleSequenceExample_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFDataType___TensorFlow_TFShape___TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.ParseSingleSequenceExample(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFDataType[],TensorFlow.TFShape[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">ParseSingleSequenceExample(TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFDataType[], TFDataType[], TFShape[], TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Transforms a scalar brain.SequenceExample proto (as strings) into typed tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],ValueTuple&lt;TensorFlow.TFOutput[]&gt;&gt; ParseSingleSequenceExample (TensorFlow.TFOutput serialized, TensorFlow.TFOutput feature_list_dense_missing_assumed_empty, TensorFlow.TFOutput[] context_sparse_keys, TensorFlow.TFOutput[] context_dense_keys, TensorFlow.TFOutput[] feature_list_sparse_keys, TensorFlow.TFOutput[] feature_list_dense_keys, TensorFlow.TFOutput[] context_dense_defaults, TensorFlow.TFOutput debug_name, TensorFlow.TFDataType[] context_sparse_types = null, TensorFlow.TFDataType[] feature_list_dense_types = null, TensorFlow.TFShape[] context_dense_shapes = null, TensorFlow.TFDataType[] feature_list_sparse_types = null, TensorFlow.TFShape[] feature_list_dense_shapes = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">serialized</span></td>
        <td><p>A scalar containing a binary serialized SequenceExample proto.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">feature_list_dense_missing_assumed_empty</span></td>
        <td><p>A vector listing the
              FeatureList keys which may be missing from the SequenceExample.  If the
              associated FeatureList is missing, it is treated as empty.  By default,
              any FeatureList not listed in this vector must exist in the SequenceExample.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">context_sparse_keys</span></td>
        <td><p>A list of Ncontext_sparse string Tensors (scalars).
              The keys expected in the Examples&#39; features associated with context_sparse
              values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">context_dense_keys</span></td>
        <td><p>A list of Ncontext_dense string Tensors (scalars).
              The keys expected in the SequenceExamples&#39; context features associated with
              dense values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">feature_list_sparse_keys</span></td>
        <td><p>A list of Nfeature_list_sparse string Tensors
              (scalars).  The keys expected in the FeatureLists associated with sparse
              values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">feature_list_dense_keys</span></td>
        <td><p>A list of Nfeature_list_dense string Tensors (scalars).
              The keys expected in the SequenceExamples&#39; feature_lists associated
              with lists of dense values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">context_dense_defaults</span></td>
        <td><p>A list of Ncontext_dense Tensors (some may be empty).
              context_dense_defaults[j] provides default values
              when the SequenceExample&#39;s context map lacks context_dense_key[j].
              If an empty Tensor is provided for context_dense_defaults[j],
              then the Feature context_dense_keys[j] is required.
              The input type is inferred from context_dense_defaults[j], even when it&#39;s
              empty.  If context_dense_defaults[j] is not empty, its shape must match
              context_dense_shapes[j].</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">debug_name</span></td>
        <td><p>A scalar containing the name of the serialized proto.
              May contain, for example, table key (descriptive) name for the
              corresponding serialized proto.  This is purely useful for debugging
              purposes, and the presence of values here has no effect on the output.
              May also be an empty scalar if no name is available.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">context_sparse_types</span></td>
        <td><p>Optional argument
              A list of Ncontext_sparse types; the data types of data in
              each context Feature given in context_sparse_keys.
              Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
              DT_INT64 (Int64List), and DT_STRING (BytesList).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">feature_list_dense_types</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">context_dense_shapes</span></td>
        <td><p>Optional argument
              A list of Ncontext_dense shapes; the shapes of data in
              each context Feature given in context_dense_keys.
              The number of elements in the Feature corresponding to context_dense_key[j]
              must always equal context_dense_shapes[j].NumEntries().
              The shape of context_dense_values[j] will match context_dense_shapes[j].</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">feature_list_sparse_types</span></td>
        <td><p>Optional argument
              A list of Nfeature_list_sparse types; the data types
              of data in each FeatureList given in feature_list_sparse_keys.
              Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),
              DT_INT64 (Int64List), and DT_STRING (BytesList).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">feature_list_dense_shapes</span></td>
        <td><p>Optional argument
              A list of Nfeature_list_dense shapes; the shapes of
              data in each FeatureList given in feature_list_dense_keys.
              The shape of each Feature in the FeatureList corresponding to
              feature_list_dense_key[j] must always equal
              feature_list_dense_shapes[j].NumEntries().</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ParseSingleSequenceExample&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]&gt;&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              context_sparse_indices:
              context_sparse_values:
              context_sparse_shapes:
              context_dense_values:
              feature_list_sparse_indices:
              feature_list_sparse_values:
              feature_list_sparse_shapes:
              feature_list_dense_values:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ParseTensor_" data-uid="TensorFlow.TFGraph.ParseTensor*"></a>
  <h4 id="TensorFlow_TFGraph_ParseTensor_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.ParseTensor(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">ParseTensor(TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Transforms a serialized tensorflow.TensorProto proto into a Tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ParseTensor (TensorFlow.TFOutput serialized, TensorFlow.TFDataType out_type, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">serialized</span></td>
        <td><p>A scalar string containing a serialized TensorProto proto.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">out_type</span></td>
        <td><p>The type of the serialized tensor.  The provided type must match the
              type of the serialized tensor and no implicit conversion will take place.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ParseTensor&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A Tensor of type <code>out_type</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Placeholder_" data-uid="TensorFlow.TFGraph.Placeholder*"></a>
  <h4 id="TensorFlow_TFGraph_Placeholder_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.Placeholder(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">Placeholder(TFDataType, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>A placeholder op for a value that will be fed into the computation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Placeholder (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of elements in the tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>Optional argument
              (Optional) The shape of the tensor. If the shape has 0 dimensions, the
              shape is unconstrained.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Placeholder&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A placeholder tensor that must be replaced using the feed mechanism.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Placeholder_TensorFlow_TFDataType_TensorFlow_TFShape_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>N.B. This operation will fail with an error if it is executed. It is
              intended as a way to represent a value that will always be fed, and to
              provide attrs that enable the fed value to be checked at runtime.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_PlaceholderV2_" data-uid="TensorFlow.TFGraph.PlaceholderV2*"></a>
  <h4 id="TensorFlow_TFGraph_PlaceholderV2_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.PlaceholderV2(TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">PlaceholderV2(TFDataType, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>A placeholder op for a value that will be fed into the computation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput PlaceholderV2 (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of elements in the tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the tensor. The shape can be any partially-specified
              shape.  To be unconstrained, pass in a shape with unknown rank.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;PlaceholderV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A placeholder tensor that must be replaced using the feed mechanism.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_PlaceholderV2_TensorFlow_TFDataType_TensorFlow_TFShape_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>N.B. This operation will fail with an error if it is executed. It is
              intended as a way to represent a value that will always be fed, and to
              provide attrs that enable the fed value to be checked at runtime.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_PlaceholderWithDefault_" data-uid="TensorFlow.TFGraph.PlaceholderWithDefault*"></a>
  <h4 id="TensorFlow_TFGraph_PlaceholderWithDefault_TensorFlow_TFOutput_TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.PlaceholderWithDefault(TensorFlow.TFOutput,TensorFlow.TFShape,System.String)">PlaceholderWithDefault(TFOutput, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>A placeholder op that passes through <code>input</code> when its output is not fed.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput PlaceholderWithDefault (TensorFlow.TFOutput input, TensorFlow.TFShape shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The default value to produce when <code>output</code> is not fed.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The (possibly partial) shape of the tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;PlaceholderWithDefault&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A placeholder tensor that defaults to <code>input</code> if it is not fed.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Polygamma_" data-uid="TensorFlow.TFGraph.Polygamma*"></a>
  <h4 id="TensorFlow_TFGraph_Polygamma_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Polygamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Polygamma(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Compute the polygamma function \(\psi^{(n)}(x)\).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Polygamma (TensorFlow.TFOutput a, TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Polygamma&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Polygamma_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The polygamma function is defined as:</p>
<pre><code>          \\(\psi^{(n)}(x) = \frac{d^n}{dx^n} \psi(x)\\)

          where \\(\psi(x)\\) is the digamma function.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_PopulationCount_" data-uid="TensorFlow.TFGraph.PopulationCount*"></a>
  <h4 id="TensorFlow_TFGraph_PopulationCount_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.PopulationCount(TensorFlow.TFOutput,System.String)">PopulationCount(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes element-wise population count (a.k.a. popcount, bitsum, bitcount).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput PopulationCount (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;PopulationCount&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_PopulationCount_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>For each entry in <code>x</code>, calculates the number of <code>1</code> (on) bits in the binary
              representation of that entry.</p>
<pre><code>          **NOTE**: It is more efficient to first &lt;code&gt;tf.bitcast&lt;/code&gt; your tensors into
          &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt; and perform the bitcount on the result, than to feed in
          8- or 16-bit inputs and then aggregate the resulting counts.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Pow_" data-uid="TensorFlow.TFGraph.Pow*"></a>
  <h4 id="TensorFlow_TFGraph_Pow_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Pow(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Pow(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the power of one value to another.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Pow (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Pow&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Pow_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a tensor <code>x</code> and a tensor <code>y</code>, this operation computes \(x^y\) for
              corresponding elements in <code>x</code> and <code>y</code>. For example:</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          # tensor &#39;x&#39; is [[2, 2]], [3, 3]]
          # tensor &#39;y&#39; is [[8, 16], [2, 3]]
          tf.pow(x, y) ==&amp;gt; [[256, 65536], [9, 27]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_PrefetchDataset_" data-uid="TensorFlow.TFGraph.PrefetchDataset*"></a>
  <h4 id="TensorFlow_TFGraph_PrefetchDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.PrefetchDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">PrefetchDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that asynchronously prefetches elements from <code>input_dataset</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput PrefetchDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput buffer_size, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">buffer_size</span></td>
        <td><p>The maximum number of elements to buffer in an iterator over
              this dataset.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;PrefetchDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_PreventGradient_" data-uid="TensorFlow.TFGraph.PreventGradient*"></a>
  <h4 id="TensorFlow_TFGraph_PreventGradient_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.PreventGradient(TensorFlow.TFOutput,System.String,System.String)">PreventGradient(TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>An identity op that triggers an error if a gradient is requested.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput PreventGradient (TensorFlow.TFOutput input, string message = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>any tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">message</span></td>
        <td><p>Optional argument
              Will be printed in the error when anyone tries to differentiate
              this operation.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;PreventGradient&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>the same input tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_PreventGradient_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>When executed in a graph, this op outputs its input tensor as-is.</p>
<pre><code>          When building ops to compute gradients, the TensorFlow gradient system
          will return an error when trying to lookup the gradient of this op,
          because no gradient must ever be registered for this function.  This
          op exists to prevent subtle bugs from silently returning unimplemented
          gradients in some corner cases.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Print_" data-uid="TensorFlow.TFGraph.Print*"></a>
  <h4 id="TensorFlow_TFGraph_Print_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.Print(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">Print(TFOutput, TFOutput[], String, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Prints a list of tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Print (TensorFlow.TFOutput input, TensorFlow.TFOutput[] data, string message = null, Nullable&lt;long&gt; first_n = null, Nullable&lt;long&gt; summarize = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The tensor passed to <code>output</code></p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">data</span></td>
        <td><p>A list of tensors to print out when op is evaluated.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">message</span></td>
        <td><p>Optional argument
              A string, prefix of the error message.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">first_n</span></td>
        <td><p>Optional argument
              Only log <code>first_n</code> number of times. -1 disables logging.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">summarize</span></td>
        <td><p>Optional argument
              Only print this many entries of each tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Print&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>= The unmodified <code>input</code> tensor
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Print_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Passes <code>input</code> through to <code>output</code> and prints <code>data</code> when evaluating.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_PrintV2_" data-uid="TensorFlow.TFGraph.PrintV2*"></a>
  <h4 id="TensorFlow_TFGraph_PrintV2_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.PrintV2(TensorFlow.TFOutput,System.String,System.String)">PrintV2(TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>Prints a string scalar.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation PrintV2 (TensorFlow.TFOutput input, string output_stream = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The string scalar to print.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">output_stream</span></td>
        <td><p>Optional argument
              A string specifying the output stream or logging level to print to.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;PrintV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_PrintV2_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Prints a string scalar to the desired output_stream.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_PriorityQueue_" data-uid="TensorFlow.TFGraph.PriorityQueue*"></a>
  <h4 id="TensorFlow_TFGraph_PriorityQueue_TensorFlow_TFShape___TensorFlow_TFDataType___System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.PriorityQueue(TensorFlow.TFShape[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String,System.String,System.String)">PriorityQueue(TFShape[], TFDataType[], Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A queue that produces elements sorted by the first component value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput PriorityQueue (TensorFlow.TFShape[] shapes, TensorFlow.TFDataType[] component_types = null, Nullable&lt;long&gt; capacity = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types. If the length of
              this attr is 0, the shapes of queue elements are not constrained, and
              only one element may be dequeued at a time.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>Optional argument
              The type of each component in a value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;PriorityQueue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_PriorityQueue_TensorFlow_TFShape___TensorFlow_TFDataType___System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that the PriorityQueue requires the first component of any element
              to be a scalar int64, in addition to the other elements declared by
              component_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue
              and DequeueMany) on a PriorityQueue will all require (resp. output) one extra
              entry in their input (resp. output) lists.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_PriorityQueueV2_" data-uid="TensorFlow.TFGraph.PriorityQueueV2*"></a>
  <h4 id="TensorFlow_TFGraph_PriorityQueueV2_TensorFlow_TFShape___TensorFlow_TFDataType___System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.PriorityQueueV2(TensorFlow.TFShape[],TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String,System.String,System.String)">PriorityQueueV2(TFShape[], TFDataType[], Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A queue that produces elements sorted by the first component value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput PriorityQueueV2 (TensorFlow.TFShape[] shapes, TensorFlow.TFDataType[] component_types = null, Nullable&lt;long&gt; capacity = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types. If the length of
              this attr is 0, the shapes of queue elements are not constrained, and
              only one element may be dequeued at a time.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>Optional argument
              The type of each component in a value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;PriorityQueueV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_PriorityQueueV2_TensorFlow_TFShape___TensorFlow_TFDataType___System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that the PriorityQueue requires the first component of any element
              to be a scalar int64, in addition to the other elements declared by
              component_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue
              and DequeueMany) on a PriorityQueue will all require (resp. output) one extra
              entry in their input (resp. output) lists.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Prod_" data-uid="TensorFlow.TFGraph.Prod*"></a>
  <h4 id="TensorFlow_TFGraph_Prod_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Prod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">Prod(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the product of elements across dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Prod (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable&lt;bool&gt; keep_dims = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The tensor to reduce.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reduction_indices</span></td>
        <td><p>The dimensions to reduce. Must be in the range
              <code>[-rank(input), rank(input))</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>Optional argument
              If true, retain reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Prod&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Prod_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
              <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
              <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
              retained with length 1.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Qr_" data-uid="TensorFlow.TFGraph.Qr*"></a>
  <h4 id="TensorFlow_TFGraph_Qr_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Qr(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">Qr(TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the QR decompositions of one or more matrices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; Qr (TensorFlow.TFOutput input, Nullable&lt;bool&gt; full_matrices = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A tensor of shape <code>[..., M, N]</code> whose inner-most 2 dimensions
              form matrices of size <code>[M, N]</code>. Let <code>P</code> be the minimum of <code>M</code> and <code>N</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">full_matrices</span></td>
        <td><p>Optional argument
              If true, compute full-sized <code>q</code> and <code>r</code>. If false
              (the default), compute only the leading <code>P</code> columns of <code>q</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Qr&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              q: Orthonormal basis for range of <code>a</code>. If <code>full_matrices</code> is <code>False</code> then
              shape is <code>[..., M, P]</code>; if <code>full_matrices</code> is <code>True</code> then shape is
              <code>[..., M, M]</code>.
              r: Triangular factor. If <code>full_matrices</code> is <code>False</code> then shape is
              <code>[..., P, N]</code>. If <code>full_matrices</code> is <code>True</code> then shape is <code>[..., M, N]</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Qr_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the QR decomposition of each inner matrix in <code>tensor</code> such that
              <code>tensor[..., :, :] = q[..., :, :] * r[..., :,:])</code><pre><code><p>
<h1 id="a-is-a-tensor">a is a tensor.</h1>
<pre><code>          # q is a tensor of orthonormal matrices.
          # r is a tensor of upper triangular matrices.
          q, r = qr(a)
          q_full, r_full = qr(a, full_matrices=True)
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_QuantizeAndDequantize_" data-uid="TensorFlow.TFGraph.QuantizeAndDequantize*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizeAndDequantize_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Int64__System_Nullable_System_Boolean__System_Nullable_System_Single__System_Nullable_System_Single__System_String_" data-uid="TensorFlow.TFGraph.QuantizeAndDequantize(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.Nullable{System.Boolean},System.Nullable{System.Single},System.Nullable{System.Single},System.String)">QuantizeAndDequantize(TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Single&gt;, Nullable&lt;Single&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Use QuantizeAndDequantizeV2 instead.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput QuantizeAndDequantize (TensorFlow.TFOutput input, Nullable&lt;bool&gt; signed_input = null, Nullable&lt;long&gt; num_bits = null, Nullable&lt;bool&gt; range_given = null, Nullable&lt;float&gt; input_min = null, Nullable&lt;float&gt; input_max = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">signed_input</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">num_bits</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">range_given</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">input_min</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">input_max</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizeAndDequantize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_QuantizeAndDequantizeV3_" data-uid="TensorFlow.TFGraph.QuantizeAndDequantizeV3*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizeAndDequantizeV3_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.QuantizeAndDequantizeV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">QuantizeAndDequantizeV3(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Quantizes then dequantizes a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput QuantizeAndDequantizeV3 (TensorFlow.TFOutput input, TensorFlow.TFOutput input_min, TensorFlow.TFOutput input_max, TensorFlow.TFOutput num_bits, Nullable&lt;bool&gt; signed_input = null, Nullable&lt;bool&gt; range_given = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_min</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_max</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_bits</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">signed_input</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">range_given</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizeAndDequantizeV3&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QuantizeAndDequantizeV3_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This is almost identical to QuantizeAndDequantizeV2, except that num_bits is a
              tensor, so its value can change during training.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_QuantizedAdd_" data-uid="TensorFlow.TFGraph.QuantizedAdd*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.QuantizedAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">QuantizedAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns x + y element-wise, working on quantized buffers.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedAdd (TensorFlow.TFOutput x, TensorFlow.TFOutput y, TensorFlow.TFOutput min_x, TensorFlow.TFOutput max_x, TensorFlow.TFOutput min_y, TensorFlow.TFOutput max_y, Nullable&lt;TensorFlow.TFDataType&gt; Toutput = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_x</span></td>
        <td><p>The float value that the lowest quantized <code>x</code> value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_x</span></td>
        <td><p>The float value that the highest quantized <code>x</code> value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_y</span></td>
        <td><p>The float value that the lowest quantized <code>y</code> value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_y</span></td>
        <td><p>The float value that the highest quantized <code>y</code> value represents.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">Toutput</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedAdd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              z:
              min_z: The float value that the lowest quantized output value represents.
              max_z: The float value that the highest quantized output value represents.</p>
<pre><code>          *NOTE*: &lt;code&gt;QuantizedAdd&lt;/code&gt; supports limited forms of broadcasting. More about
          broadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
          The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_QuantizedAvgPool_" data-uid="TensorFlow.TFGraph.QuantizedAvgPool*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedAvgPool_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_" data-uid="TensorFlow.TFGraph.QuantizedAvgPool(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">QuantizedAvgPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)</h4>
  <div class="markdown level1 summary"><p>Produces the average pool of the input tensor for quantized types.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedAvgPool (TensorFlow.TFOutput input, TensorFlow.TFOutput min_input, TensorFlow.TFOutput max_input, long[] ksize, long[] strides, string padding, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_input</span></td>
        <td><p>The float value that the lowest quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_input</span></td>
        <td><p>The float value that the highest quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>The size of the window for each dimension of the input tensor.
              The length must be 4 to match the number of dimensions of the input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the input
              tensor.  The length must be 4 to match the number of dimensions of the input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedAvgPool&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output:
              min_output: The float value that the lowest quantized output value represents.
              max_output: The float value that the highest quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_QuantizedBatchNormWithGlobalNormalization_" data-uid="TensorFlow.TFGraph.QuantizedBatchNormWithGlobalNormalization*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedBatchNormWithGlobalNormalization_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Single_System_Boolean_System_String_" data-uid="TensorFlow.TFGraph.QuantizedBatchNormWithGlobalNormalization(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Single,System.Boolean,System.String)">QuantizedBatchNormWithGlobalNormalization(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, Single, Boolean, String)</h4>
  <div class="markdown level1 summary"><p>Quantized Batch normalization.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedBatchNormWithGlobalNormalization (TensorFlow.TFOutput t, TensorFlow.TFOutput t_min, TensorFlow.TFOutput t_max, TensorFlow.TFOutput m, TensorFlow.TFOutput m_min, TensorFlow.TFOutput m_max, TensorFlow.TFOutput v, TensorFlow.TFOutput v_min, TensorFlow.TFOutput v_max, TensorFlow.TFOutput beta, TensorFlow.TFOutput beta_min, TensorFlow.TFOutput beta_max, TensorFlow.TFOutput gamma, TensorFlow.TFOutput gamma_min, TensorFlow.TFOutput gamma_max, TensorFlow.TFDataType out_type, float variance_epsilon, bool scale_after_normalization, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">t</span></td>
        <td><p>A 4D input Tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">t_min</span></td>
        <td><p>The value represented by the lowest quantized input.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">t_max</span></td>
        <td><p>The value represented by the highest quantized input.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">m</span></td>
        <td><p>A 1D mean Tensor with size matching the last dimension of t.
              This is the first output from tf.nn.moments,
              or a saved moving average thereof.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">m_min</span></td>
        <td><p>The value represented by the lowest quantized mean.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">m_max</span></td>
        <td><p>The value represented by the highest quantized mean.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">v</span></td>
        <td><p>A 1D variance Tensor with size matching the last dimension of t.
              This is the second output from tf.nn.moments,
              or a saved moving average thereof.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">v_min</span></td>
        <td><p>The value represented by the lowest quantized variance.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">v_max</span></td>
        <td><p>The value represented by the highest quantized variance.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta</span></td>
        <td><p>A 1D beta Tensor with size matching the last dimension of t.
              An offset to be added to the normalized tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta_min</span></td>
        <td><p>The value represented by the lowest quantized offset.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta_max</span></td>
        <td><p>The value represented by the highest quantized offset.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gamma</span></td>
        <td><p>A 1D gamma Tensor with size matching the last dimension of t.
              If &quot;scale_after_normalization&quot; is true, this tensor will be multiplied
              with the normalized tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gamma_min</span></td>
        <td><p>The value represented by the lowest quantized gamma.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gamma_max</span></td>
        <td><p>The value represented by the highest quantized gamma.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">out_type</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span></td>
        <td><span class="parametername">variance_epsilon</span></td>
        <td><p>A small float number to avoid dividing by 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">scale_after_normalization</span></td>
        <td><p>A bool indicating whether the resulted tensor
              needs to be multiplied with gamma.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedBatchNormWithGlobalNormalization&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              result:
              result_min:
              result_max:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QuantizedBatchNormWithGlobalNormalization_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Single_System_Boolean_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op is deprecated and will be removed in the future. Prefer
              <code>tf.nn.batch_normalization</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_QuantizedBiasAdd_" data-uid="TensorFlow.TFGraph.QuantizedBiasAdd*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedBiasAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.QuantizedBiasAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">QuantizedBiasAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Adds Tensor &#39;bias&#39; to Tensor &#39;input&#39; for Quantized types.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedBiasAdd (TensorFlow.TFOutput input, TensorFlow.TFOutput bias, TensorFlow.TFOutput min_input, TensorFlow.TFOutput max_input, TensorFlow.TFOutput min_bias, TensorFlow.TFOutput max_bias, TensorFlow.TFDataType out_type, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">bias</span></td>
        <td><p>A 1D bias Tensor with size matching the last dimension of &#39;input&#39;.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_input</span></td>
        <td><p>The float value that the lowest quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_input</span></td>
        <td><p>The float value that the highest quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_bias</span></td>
        <td><p>The float value that the lowest quantized bias value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_bias</span></td>
        <td><p>The float value that the highest quantized bias value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">out_type</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedBiasAdd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output:
              min_out: The float value that the lowest quantized output value represents.
              max_out: The float value that the highest quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QuantizedBiasAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Broadcasts the values of bias on dimensions 0..N-2 of &#39;input&#39;.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_QuantizedConcat_" data-uid="TensorFlow.TFGraph.QuantizedConcat*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedConcat_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.QuantizedConcat(TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String)">QuantizedConcat(TFOutput, TFOutput[], TFOutput[], TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Concatenates quantized tensors along one dimension.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedConcat (TensorFlow.TFOutput concat_dim, TensorFlow.TFOutput[] values, TensorFlow.TFOutput[] input_mins, TensorFlow.TFOutput[] input_maxes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">concat_dim</span></td>
        <td><p>0-D.  The dimension along which to concatenate.  Must be in the
              range [0, rank(values)).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">values</span></td>
        <td><p>The <code>N</code> Tensors to concatenate. Their ranks and types must match,
              and their sizes must match in all dimensions except <code>concat_dim</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">input_mins</span></td>
        <td><p>The minimum scalar values for each of the input tensors.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">input_maxes</span></td>
        <td><p>The maximum scalar values for each of the input tensors.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedConcat&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output: A <code>Tensor</code> with the concatenation of values stacked along the
              <code>concat_dim</code> dimension.  This tensor&#39;s shape matches that of <code>values</code> except
              in <code>concat_dim</code> where it has the sum of the sizes.
              output_min: The float value that the minimum quantized output value represents.
              output_max: The float value that the maximum quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_QuantizedConv2D_" data-uid="TensorFlow.TFGraph.QuantizedConv2D*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedConv2D_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_Nullable_TensorFlow_TFDataType__System_Int64___System_String_" data-uid="TensorFlow.TFGraph.QuantizedConv2D(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.String,System.Nullable{TensorFlow.TFDataType},System.Int64[],System.String)">QuantizedConv2D(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Int64[], String, Nullable&lt;TFDataType&gt;, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Computes a 2D convolution given quantized 4D input and filter tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedConv2D (TensorFlow.TFOutput input, TensorFlow.TFOutput filter, TensorFlow.TFOutput min_input, TensorFlow.TFOutput max_input, TensorFlow.TFOutput min_filter, TensorFlow.TFOutput max_filter, long[] strides, string padding, Nullable&lt;TensorFlow.TFDataType&gt; out_type = null, long[] dilations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filter</span></td>
        <td><p>filter&#39;s input_depth dimension must match input&#39;s depth dimensions.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_input</span></td>
        <td><p>The float value that the lowest quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_input</span></td>
        <td><p>The float value that the highest quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_filter</span></td>
        <td><p>The float value that the lowest quantized filter value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_filter</span></td>
        <td><p>The float value that the highest quantized filter value represents.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the input
              tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">dilations</span></td>
        <td><p>Optional argument
              1-D tensor of length 4.  The dilation factor for each dimension of
              <code>input</code>. If set to k &gt; 1, there will be k-1 skipped cells between each
              filter element on that dimension. The dimension order is determined by the
              value of <code>data_format</code>, see above for details. Dilations in the batch and
              depth dimensions must be 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedConv2D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output:
              min_output: The float value that the lowest quantized output value represents.
              max_output: The float value that the highest quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QuantizedConv2D_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_String_System_Nullable_TensorFlow_TFDataType__System_Int64___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The inputs are quantized tensors where the lowest value represents the real
              number of the associated minimum, and the highest represents the maximum.
              This means that you can only interpret the quantized output in the same way, by
              taking the returned minimum and maximum values into account.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_QuantizedInstanceNorm_" data-uid="TensorFlow.TFGraph.QuantizedInstanceNorm*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedInstanceNorm_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Single__System_Nullable_System_Single__System_Nullable_System_Single__System_Nullable_System_Single__System_String_" data-uid="TensorFlow.TFGraph.QuantizedInstanceNorm(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.Nullable{System.Single},System.String)">QuantizedInstanceNorm(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Single&gt;, Nullable&lt;Single&gt;, Nullable&lt;Single&gt;, Nullable&lt;Single&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Quantized Instance normalization.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedInstanceNorm (TensorFlow.TFOutput x, TensorFlow.TFOutput x_min, TensorFlow.TFOutput x_max, Nullable&lt;bool&gt; output_range_given = null, Nullable&lt;float&gt; given_y_min = null, Nullable&lt;float&gt; given_y_max = null, Nullable&lt;float&gt; variance_epsilon = null, Nullable&lt;float&gt; min_separation = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>A 4D input Tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x_min</span></td>
        <td><p>The value represented by the lowest quantized input.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x_max</span></td>
        <td><p>The value represented by the highest quantized input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">output_range_given</span></td>
        <td><p>Optional argument
              If True, <code>given_y_min</code> and <code>given_y_min</code>
              and <code>given_y_max</code> are used as the output range. Otherwise,
              the implementation computes the output range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">given_y_min</span></td>
        <td><p>Optional argument
              Output in <code>y_min</code> if <code>output_range_given</code> is True.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">given_y_max</span></td>
        <td><p>Optional argument
              Output in <code>y_max</code> if <code>output_range_given</code> is True.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">variance_epsilon</span></td>
        <td><p>Optional argument
              A small float number to avoid dividing by 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">min_separation</span></td>
        <td><p>Optional argument
              Minimum value of <code>y_max - y_min</code></p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedInstanceNorm&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              y: A 4D Tensor.
              y_min: The value represented by the lowest quantized output.
              y_max: The value represented by the highest quantized output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_QuantizedMatMul_" data-uid="TensorFlow.TFGraph.QuantizedMatMul*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedMatMul_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.QuantizedMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{TensorFlow.TFDataType},System.String)">QuantizedMatMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Perform a quantized matrix multiplication of  <code>a</code> by the matrix <code>b</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedMatMul (TensorFlow.TFOutput a, TensorFlow.TFOutput b, TensorFlow.TFOutput min_a, TensorFlow.TFOutput max_a, TensorFlow.TFOutput min_b, TensorFlow.TFOutput max_b, Nullable&lt;TensorFlow.TFDataType&gt; Toutput = null, Nullable&lt;bool&gt; transpose_a = null, Nullable&lt;bool&gt; transpose_b = null, Nullable&lt;TensorFlow.TFDataType&gt; Tactivation = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a</span></td>
        <td><p>Must be a two-dimensional tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b</span></td>
        <td><p>Must be a two-dimensional tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_a</span></td>
        <td><p>The float value that the lowest quantized <code>a</code> value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_a</span></td>
        <td><p>The float value that the highest quantized <code>a</code> value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_b</span></td>
        <td><p>The float value that the lowest quantized <code>b</code> value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_b</span></td>
        <td><p>The float value that the highest quantized <code>b</code> value represents.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">Toutput</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">transpose_a</span></td>
        <td><p>Optional argument
              If true, <code>a</code> is transposed before multiplication.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">transpose_b</span></td>
        <td><p>Optional argument
              If true, <code>b</code> is transposed before multiplication.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">Tactivation</span></td>
        <td><p>Optional argument
              The type of output produced by activation function
              following this operation.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedMatMul&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output:
              min_out: The float value that the lowest quantized output value represents.
              max_out: The float value that the highest quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QuantizedMatMul_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The inputs must be two-dimensional matrices and the inner dimension of
              <code>a</code> (after being transposed if <code>transpose_a</code> is non-zero) must match the
              outer dimension of <code>b</code> (after being transposed if <code>transposed_b</code> is
              non-zero).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_QuantizedMaxPool_" data-uid="TensorFlow.TFGraph.QuantizedMaxPool*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedMaxPool_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64___System_Int64___System_String_System_String_" data-uid="TensorFlow.TFGraph.QuantizedMaxPool(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64[],System.Int64[],System.String,System.String)">QuantizedMaxPool(TFOutput, TFOutput, TFOutput, Int64[], Int64[], String, String)</h4>
  <div class="markdown level1 summary"><p>Produces the max pool of the input tensor for quantized types.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedMaxPool (TensorFlow.TFOutput input, TensorFlow.TFOutput min_input, TensorFlow.TFOutput max_input, long[] ksize, long[] strides, string padding, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The 4D (batch x rows x cols x depth) Tensor to MaxReduce over.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_input</span></td>
        <td><p>The float value that the lowest quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_input</span></td>
        <td><p>The float value that the highest quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">ksize</span></td>
        <td><p>The size of the window for each dimension of the input tensor.
              The length must be 4 to match the number of dimensions of the input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">strides</span></td>
        <td><p>The stride of the sliding window for each dimension of the input
              tensor. The length must be 4 to match the number of dimensions of the input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">padding</span></td>
        <td><p>The type of padding algorithm to use.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedMaxPool&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output:
              min_output: The float value that the lowest quantized output value represents.
              max_output: The float value that the highest quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_QuantizedMul_" data-uid="TensorFlow.TFGraph.QuantizedMul*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedMul_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.QuantizedMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">QuantizedMul(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns x * y element-wise, working on quantized buffers.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedMul (TensorFlow.TFOutput x, TensorFlow.TFOutput y, TensorFlow.TFOutput min_x, TensorFlow.TFOutput max_x, TensorFlow.TFOutput min_y, TensorFlow.TFOutput max_y, Nullable&lt;TensorFlow.TFDataType&gt; Toutput = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_x</span></td>
        <td><p>The float value that the lowest quantized <code>x</code> value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_x</span></td>
        <td><p>The float value that the highest quantized <code>x</code> value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_y</span></td>
        <td><p>The float value that the lowest quantized <code>y</code> value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_y</span></td>
        <td><p>The float value that the highest quantized <code>y</code> value represents.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">Toutput</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedMul&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              z:
              min_z: The float value that the lowest quantized output value represents.
              max_z: The float value that the highest quantized output value represents.</p>
<pre><code>          *NOTE*: &lt;code&gt;QuantizedMul&lt;/code&gt; supports limited forms of broadcasting. More about
          broadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
          The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_QuantizeDownAndShrinkRange_" data-uid="TensorFlow.TFGraph.QuantizeDownAndShrinkRange*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizeDownAndShrinkRange_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.QuantizeDownAndShrinkRange(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">QuantizeDownAndShrinkRange(TFOutput, TFOutput, TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Convert the quantized &#39;input&#39; tensor into a lower-precision &#39;output&#39;, using the</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizeDownAndShrinkRange (TensorFlow.TFOutput input, TensorFlow.TFOutput input_min, TensorFlow.TFOutput input_max, TensorFlow.TFDataType out_type, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_min</span></td>
        <td><p>The float value that the minimum quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_max</span></td>
        <td><p>The float value that the maximum quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">out_type</span></td>
        <td><p>The type of the output. Should be a lower bit depth than Tinput.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizeDownAndShrinkRange&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output:
              output_min: The float value that the minimum quantized output value represents.
              output_max: The float value that the maximum quantized output value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QuantizeDownAndShrinkRange_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>actual distribution of the values to maximize the usage of the lower bit depth
              and adjusting the output min and max ranges accordingly.</p>
<pre><code>          [input_min, input_max] are scalar floats that specify the range for the float
          interpretation of the &#39;input&#39; data. For example, if input_min is -1.0f and
          input_max is 1.0f, and we are dealing with quint16 quantized data, then a 0
          value in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.

          This operator tries to squeeze as much precision as possible into an output with
          a lower bit depth by calculating the actual min and max values found in the
          data. For example, maybe that quint16 input has no values lower than 16,384 and
          none higher than 49,152. That means only half the range is actually needed, all
          the float interpretations are between -0.5f and 0.5f, so if we want to compress
          the data into a quint8 output, we can use that range rather than the theoretical
          -1.0f to 1.0f that is suggested by the input min and max.

          In practice, this is most useful for taking output from operations like
          QuantizedMatMul that can produce higher bit-depth outputs than their inputs and
          may have large potential output ranges, but in practice have a distribution of
          input values that only uses a small fraction of the possible range. By feeding
          that output into this operator, we can reduce it from 32 bits down to 8 with
          minimal loss of accuracy.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_QuantizedRelu_" data-uid="TensorFlow.TFGraph.QuantizedRelu*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedRelu_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.QuantizedRelu(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">QuantizedRelu(TFOutput, TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes Quantized Rectified Linear: <code>max(features, 0)</code></p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedRelu (TensorFlow.TFOutput features, TensorFlow.TFOutput min_features, TensorFlow.TFOutput max_features, Nullable&lt;TensorFlow.TFDataType&gt; out_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_features</span></td>
        <td><p>The float value that the lowest quantized value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_features</span></td>
        <td><p>The float value that the highest quantized value represents.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedRelu&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              activations: Has the same output shape as &quot;features&quot;.
              min_activations: The float value that the lowest quantized value represents.
              max_activations: The float value that the highest quantized value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_QuantizedRelu6_" data-uid="TensorFlow.TFGraph.QuantizedRelu6*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedRelu6_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.QuantizedRelu6(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">QuantizedRelu6(TFOutput, TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes Quantized Rectified Linear 6: <code>min(max(features, 0), 6)</code></p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedRelu6 (TensorFlow.TFOutput features, TensorFlow.TFOutput min_features, TensorFlow.TFOutput max_features, Nullable&lt;TensorFlow.TFDataType&gt; out_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_features</span></td>
        <td><p>The float value that the lowest quantized value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_features</span></td>
        <td><p>The float value that the highest quantized value represents.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedRelu6&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              activations: Has the same output shape as &quot;features&quot;.
              min_activations: The float value that the lowest quantized value represents.
              max_activations: The float value that the highest quantized value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_QuantizedReluX_" data-uid="TensorFlow.TFGraph.QuantizedReluX*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedReluX_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.QuantizedReluX(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">QuantizedReluX(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes Quantized Rectified Linear X: <code>min(max(features, 0), max_value)</code></p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedReluX (TensorFlow.TFOutput features, TensorFlow.TFOutput max_value, TensorFlow.TFOutput min_features, TensorFlow.TFOutput max_features, Nullable&lt;TensorFlow.TFDataType&gt; out_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_value</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_features</span></td>
        <td><p>The float value that the lowest quantized value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_features</span></td>
        <td><p>The float value that the highest quantized value represents.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedReluX&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              activations: Has the same output shape as &quot;features&quot;.
              min_activations: The float value that the lowest quantized value represents.
              max_activations: The float value that the highest quantized value represents.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_QuantizedReshape_" data-uid="TensorFlow.TFGraph.QuantizedReshape*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedReshape_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.QuantizedReshape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">QuantizedReshape(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedReshape (TensorFlow.TFOutput tensor, TensorFlow.TFOutput shape, TensorFlow.TFOutput input_min, TensorFlow.TFOutput input_max, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_min</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_max</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_QuantizedResizeBilinear_" data-uid="TensorFlow.TFGraph.QuantizedResizeBilinear*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizedResizeBilinear_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.QuantizedResizeBilinear(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">QuantizedResizeBilinear(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Resize quantized <code>images</code> to <code>size</code> using quantized bilinear interpolation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizedResizeBilinear (TensorFlow.TFOutput images, TensorFlow.TFOutput size, TensorFlow.TFOutput min, TensorFlow.TFOutput max, Nullable&lt;bool&gt; align_corners = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">images</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>= A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
              new size for the images.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">align_corners</span></td>
        <td><p>Optional argument
              If true, the centers of the 4 corner pixels of the input and output tensors are
              aligned, preserving the values at the corner pixels. Defaults to false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizedResizeBilinear&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              resized_images: 4-D with shape
              <code>[batch, new_height, new_width, channels]</code>.
              out_min:
              out_max:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QuantizedResizeBilinear_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Input images and output images must be quantized types.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_QuantizeV2_" data-uid="TensorFlow.TFGraph.QuantizeV2*"></a>
  <h4 id="TensorFlow_TFGraph_QuantizeV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.QuantizeV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.String)">QuantizeV2(TFOutput, TFOutput, TFOutput, TFDataType, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Quantize the &#39;input&#39; tensor of type float to &#39;output&#39; tensor of type &#39;T&#39;.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; QuantizeV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput min_range, TensorFlow.TFOutput max_range, TensorFlow.TFDataType T, string mode = null, string round_mode = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_range</span></td>
        <td><p>The minimum scalar value possibly produced for the input.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_range</span></td>
        <td><p>The maximum scalar value possibly produced for the input.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">T</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">round_mode</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QuantizeV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output: The quantized data produced from the float input.
              output_min: The actual minimum scalar value used for the output.
              output_max: The actual maximum scalar value used for the output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QuantizeV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>[min_range, max_range] are scalar floats that specify the range for
              the &#39;input&#39; data. The &#39;mode&#39; attribute controls exactly which calculations are
              used to convert the float values to their quantized equivalents.  The
              &#39;round_mode&#39; attribute controls which rounding tie-breaking algorithm is used
              when rounding float values to their quantized equivalents.</p>
<pre><code>          In &#39;MIN_COMBINED&#39; mode, each value of the tensor will undergo the following:

           &lt;pre&gt;&lt;code&gt;
          out[i] = (in[i] - min_range) * range(T) / (max_range - min_range)
          if T == qint8: out[i] -= (range(T) + 1) / 2.0
           &lt;/code&gt;&lt;/pre&gt;

          here &lt;code&gt;range(T) = numeric_limits&amp;lt;T&amp;gt;::max() - numeric_limits&amp;lt;T&amp;gt;::min()&lt;/code&gt;

          *MIN_COMBINED Mode Example*

          Assume the input is type float and has a possible range of [0.0, 6.0] and the
          output type is quint8 ([0, 255]). The min_range and max_range values should be
          specified as 0.0 and 6.0. Quantizing from float to quint8 will multiply each
          value of the input by 255/6 and cast to quint8.

          If the output type was qint8 ([-128, 127]), the operation will additionally
          subtract each value by 128 prior to casting, so that the range of values aligns
          with the range of qint8.

          If the mode is &#39;MIN_FIRST&#39;, then this approach is used:

           &lt;pre&gt;&lt;code&gt;
          num_discrete_values = 1 &amp;lt;&amp;lt; (# of bits in T)
          range_adjust = num_discrete_values / (num_discrete_values - 1)
          range = (range_max - range_min) * range_adjust
          range_scale = num_discrete_values / range
          quantized = round(input * range_scale) - round(range_min * range_scale) +
          numeric_limits&amp;lt;T&amp;gt;::min()
          quantized = max(quantized, numeric_limits&amp;lt;T&amp;gt;::min())
          quantized = min(quantized, numeric_limits&amp;lt;T&amp;gt;::max())
           &lt;/code&gt;&lt;/pre&gt;

          The biggest difference between this and MIN_COMBINED is that the minimum range
          is rounded first, before it&#39;s subtracted from the rounded value. With
          MIN_COMBINED, a small bias is introduced where repeated iterations of quantizing
          and dequantizing will introduce a larger and larger error.

          *SCALED mode Example*

          &lt;code&gt;SCALED&lt;/code&gt; mode matches the quantization approach used in
          &lt;code&gt;QuantizeAndDequantize{V2|V3}&lt;/code&gt;.

          If the mode is &lt;code&gt;SCALED&lt;/code&gt;, we do not use the full range of the output type,
          choosing to elide the lowest possible value for symmetry (e.g., output range is
          -127 to 127, not -128 to 127 for signed 8 bit quantization), so that 0.0 maps to
          0.

          We first find the range of values in our tensor. The
          range we use is always centered on 0, so we find m such that

           &lt;pre&gt;&lt;code&gt;
          m = max(abs(input_min), abs(input_max))
           &lt;/code&gt;&lt;/pre&gt;

          Our input tensor range is then &lt;code&gt;[-m, m]&lt;/code&gt;.

          Next, we choose our fixed-point quantization buckets, &lt;code&gt;[min_fixed, max_fixed]&lt;/code&gt;.
          If T is signed, this is

           &lt;pre&gt;&lt;code&gt;
          num_bits = sizeof(T) * 8
          [min_fixed, max_fixed] =
          [-(1 &amp;lt;&amp;lt; (num_bits - 1) - 1), (1 &amp;lt;&amp;lt; (num_bits - 1)) - 1]
           &lt;/code&gt;&lt;/pre&gt;

          Otherwise, if T is unsigned, the fixed-point range is

           &lt;pre&gt;&lt;code&gt;
          [min_fixed, max_fixed] = [0, (1 &amp;lt;&amp;lt; num_bits) - 1]
           &lt;/code&gt;&lt;/pre&gt;

          From this we compute our scaling factor, s:

           &lt;pre&gt;&lt;code&gt;
          s = (max_fixed - min_fixed) / (2 * m)
           &lt;/code&gt;&lt;/pre&gt;

          Now we can quantize the elements of our tensor:

           &lt;pre&gt;&lt;code&gt;
          result = round(input * s)
           &lt;/code&gt;&lt;/pre&gt;

          One thing to watch out for is that the operator may choose to adjust the
          requested minimum and maximum values slightly during the quantization process,
          so you should always use the output ports as the range for further calculations.
          For example, if the requested minimum and maximum values are close to equal,
          they will be separated by a small epsilon value to prevent ill-formed quantized
          buffers from being created. Otherwise, you can end up with buffers where all the
          quantized values map to the same float value, which causes problems for
          operations that have to perform further calculations on them.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_QueueClose_" data-uid="TensorFlow.TFGraph.QueueClose*"></a>
  <h4 id="TensorFlow_TFGraph_QueueClose_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.QueueClose(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">QueueClose(TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Closes the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation QueueClose (TensorFlow.TFOutput handle, Nullable&lt;bool&gt; cancel_pending_enqueues = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">cancel_pending_enqueues</span></td>
        <td><p>Optional argument
              If true, all pending enqueue requests that are
              blocked on the given queue will be canceled.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueClose&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueClose_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation signals that no more elements will be enqueued in the
              given queue. Subsequent Enqueue(Many) operations will fail.
              Subsequent Dequeue(Many) operations will continue to succeed if
              sufficient elements remain in the queue. Subsequent Dequeue(Many)
              operations that would block will fail immediately.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_QueueCloseV2_" data-uid="TensorFlow.TFGraph.QueueCloseV2*"></a>
  <h4 id="TensorFlow_TFGraph_QueueCloseV2_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.QueueCloseV2(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">QueueCloseV2(TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Closes the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation QueueCloseV2 (TensorFlow.TFOutput handle, Nullable&lt;bool&gt; cancel_pending_enqueues = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">cancel_pending_enqueues</span></td>
        <td><p>Optional argument
              If true, all pending enqueue requests that are
              blocked on the given queue will be canceled.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueCloseV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueCloseV2_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation signals that no more elements will be enqueued in the
              given queue. Subsequent Enqueue(Many) operations will fail.
              Subsequent Dequeue(Many) operations will continue to succeed if
              sufficient elements remain in the queue. Subsequent Dequeue(Many)
              operations that would block will fail immediately.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_QueueDequeue_" data-uid="TensorFlow.TFGraph.QueueDequeue*"></a>
  <h4 id="TensorFlow_TFGraph_QueueDequeue_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.QueueDequeue(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)">QueueDequeue(TFOutput, TFDataType[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Dequeues a tuple of one or more tensors from the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] QueueDequeue (TensorFlow.TFOutput handle, TensorFlow.TFDataType[] component_types, Nullable&lt;long&gt; timeout_ms = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a tuple.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">timeout_ms</span></td>
        <td><p>Optional argument
              If the queue is empty, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueDequeue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueDequeue_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation has k outputs, where k is the number of components
              in the tuples stored in the given queue, and output i is the ith
              component of the dequeued tuple.</p>
<pre><code>          N.B. If the queue is empty, this operation will block until an element
          has been dequeued (or &#39;timeout_ms&#39; elapses, if specified).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_QueueDequeueMany_" data-uid="TensorFlow.TFGraph.QueueDequeueMany*"></a>
  <h4 id="TensorFlow_TFGraph_QueueDequeueMany_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.QueueDequeueMany(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)">QueueDequeueMany(TFOutput, TFOutput, TFDataType[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Dequeues <code>n</code> tuples of one or more tensors from the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] QueueDequeueMany (TensorFlow.TFOutput handle, TensorFlow.TFOutput n, TensorFlow.TFDataType[] component_types, Nullable&lt;long&gt; timeout_ms = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">n</span></td>
        <td><p>The number of tuples to dequeue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a tuple.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">timeout_ms</span></td>
        <td><p>Optional argument
              If the queue has fewer than n elements, this operation
              will block for up to timeout_ms milliseconds.
              Note: This option is not supported yet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueDequeueMany&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueDequeueMany_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If the queue is closed and there are fewer than <code>n</code> elements, then an
              OutOfRange error is returned.</p>
<pre><code>          This operation concatenates queue-element component tensors along the
          0th dimension to make a single component tensor.  All of the components
          in the dequeued tuple will have size &lt;code&gt;n&lt;/code&gt; in the 0th dimension.

          This operation has &lt;code&gt;k&lt;/code&gt; outputs, where &lt;code&gt;k&lt;/code&gt; is the number of components in
          the tuples stored in the given queue, and output &lt;code&gt;i&lt;/code&gt; is the ith
          component of the dequeued tuple.

          N.B. If the queue is empty, this operation will block until &lt;code&gt;n&lt;/code&gt; elements
          have been dequeued (or &#39;timeout_ms&#39; elapses, if specified).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_QueueDequeueManyV2_" data-uid="TensorFlow.TFGraph.QueueDequeueManyV2*"></a>
  <h4 id="TensorFlow_TFGraph_QueueDequeueManyV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.QueueDequeueManyV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)">QueueDequeueManyV2(TFOutput, TFOutput, TFDataType[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Dequeues <code>n</code> tuples of one or more tensors from the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] QueueDequeueManyV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput n, TensorFlow.TFDataType[] component_types, Nullable&lt;long&gt; timeout_ms = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">n</span></td>
        <td><p>The number of tuples to dequeue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a tuple.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">timeout_ms</span></td>
        <td><p>Optional argument
              If the queue has fewer than n elements, this operation
              will block for up to timeout_ms milliseconds.
              Note: This option is not supported yet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueDequeueManyV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueDequeueManyV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If the queue is closed and there are fewer than <code>n</code> elements, then an
              OutOfRange error is returned.</p>
<pre><code>          This operation concatenates queue-element component tensors along the
          0th dimension to make a single component tensor.  All of the components
          in the dequeued tuple will have size &lt;code&gt;n&lt;/code&gt; in the 0th dimension.

          This operation has &lt;code&gt;k&lt;/code&gt; outputs, where &lt;code&gt;k&lt;/code&gt; is the number of components in
          the tuples stored in the given queue, and output &lt;code&gt;i&lt;/code&gt; is the ith
          component of the dequeued tuple.

          N.B. If the queue is empty, this operation will block until &lt;code&gt;n&lt;/code&gt; elements
          have been dequeued (or &#39;timeout_ms&#39; elapses, if specified).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_QueueDequeueUpTo_" data-uid="TensorFlow.TFGraph.QueueDequeueUpTo*"></a>
  <h4 id="TensorFlow_TFGraph_QueueDequeueUpTo_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.QueueDequeueUpTo(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)">QueueDequeueUpTo(TFOutput, TFOutput, TFDataType[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Dequeues <code>n</code> tuples of one or more tensors from the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] QueueDequeueUpTo (TensorFlow.TFOutput handle, TensorFlow.TFOutput n, TensorFlow.TFDataType[] component_types, Nullable&lt;long&gt; timeout_ms = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">n</span></td>
        <td><p>The number of tuples to dequeue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a tuple.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">timeout_ms</span></td>
        <td><p>Optional argument
              If the queue has fewer than n elements, this operation
              will block for up to timeout_ms milliseconds.
              Note: This option is not supported yet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueDequeueUpTo&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueDequeueUpTo_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation is not supported by all queues.  If a queue does not support
              DequeueUpTo, then an Unimplemented error is returned.</p>
<pre><code>          If the queue is closed and there are more than 0 but less than &lt;code&gt;n&lt;/code&gt;
          elements remaining, then instead of returning an OutOfRange error like
          QueueDequeueMany, less than &lt;code&gt;n&lt;/code&gt; elements are returned immediately.  If
          the queue is closed and there are 0 elements left in the queue, then
          an OutOfRange error is returned just like in QueueDequeueMany.
          Otherwise the behavior is identical to QueueDequeueMany:

          This operation concatenates queue-element component tensors along the
          0th dimension to make a single component tensor.  All of the components
          in the dequeued tuple will have size &lt;code&gt;n&lt;/code&gt; in the 0th dimension.

          This operation has k outputs, where &lt;code&gt;k&lt;/code&gt; is the number of components in
          the tuples stored in the given queue, and output &lt;code&gt;i&lt;/code&gt; is the ith
          component of the dequeued tuple.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_QueueDequeueUpToV2_" data-uid="TensorFlow.TFGraph.QueueDequeueUpToV2*"></a>
  <h4 id="TensorFlow_TFGraph_QueueDequeueUpToV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.QueueDequeueUpToV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)">QueueDequeueUpToV2(TFOutput, TFOutput, TFDataType[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Dequeues <code>n</code> tuples of one or more tensors from the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] QueueDequeueUpToV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput n, TensorFlow.TFDataType[] component_types, Nullable&lt;long&gt; timeout_ms = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">n</span></td>
        <td><p>The number of tuples to dequeue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a tuple.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">timeout_ms</span></td>
        <td><p>Optional argument
              If the queue has fewer than n elements, this operation
              will block for up to timeout_ms milliseconds.
              Note: This option is not supported yet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueDequeueUpToV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueDequeueUpToV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation is not supported by all queues.  If a queue does not support
              DequeueUpTo, then an Unimplemented error is returned.</p>
<pre><code>          If the queue is closed and there are more than 0 but less than &lt;code&gt;n&lt;/code&gt;
          elements remaining, then instead of returning an OutOfRange error like
          QueueDequeueMany, less than &lt;code&gt;n&lt;/code&gt; elements are returned immediately.  If
          the queue is closed and there are 0 elements left in the queue, then
          an OutOfRange error is returned just like in QueueDequeueMany.
          Otherwise the behavior is identical to QueueDequeueMany:

          This operation concatenates queue-element component tensors along the
          0th dimension to make a single component tensor.  All of the components
          in the dequeued tuple will have size n in the 0th dimension.

          This operation has &lt;code&gt;k&lt;/code&gt; outputs, where &lt;code&gt;k&lt;/code&gt; is the number of components in
          the tuples stored in the given queue, and output &lt;code&gt;i&lt;/code&gt; is the ith
          component of the dequeued tuple.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_QueueDequeueV2_" data-uid="TensorFlow.TFGraph.QueueDequeueV2*"></a>
  <h4 id="TensorFlow_TFGraph_QueueDequeueV2_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.QueueDequeueV2(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.String)">QueueDequeueV2(TFOutput, TFDataType[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Dequeues a tuple of one or more tensors from the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] QueueDequeueV2 (TensorFlow.TFOutput handle, TensorFlow.TFDataType[] component_types, Nullable&lt;long&gt; timeout_ms = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a tuple.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">timeout_ms</span></td>
        <td><p>Optional argument
              If the queue is empty, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueDequeueV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>One or more tensors that were dequeued as a tuple.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueDequeueV2_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation has k outputs, where k is the number of components
              in the tuples stored in the given queue, and output i is the ith
              component of the dequeued tuple.</p>
<pre><code>          N.B. If the queue is empty, this operation will block until an element
          has been dequeued (or &#39;timeout_ms&#39; elapses, if specified).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_QueueEnqueue_" data-uid="TensorFlow.TFGraph.QueueEnqueue*"></a>
  <h4 id="TensorFlow_TFGraph_QueueEnqueue_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.QueueEnqueue(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">QueueEnqueue(TFOutput, TFOutput[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Enqueues a tuple of one or more tensors in the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation QueueEnqueue (TensorFlow.TFOutput handle, TensorFlow.TFOutput[] components, Nullable&lt;long&gt; timeout_ms = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">components</span></td>
        <td><p>One or more tensors from which the enqueued tensors should be taken.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">timeout_ms</span></td>
        <td><p>Optional argument
              If the queue is full, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueEnqueue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueEnqueue_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The components input has k elements, which correspond to the components of
              tuples stored in the given queue.</p>
<pre><code>          N.B. If the queue is full, this operation will block until the given
          element has been enqueued (or &#39;timeout_ms&#39; elapses, if specified).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_QueueEnqueueMany_" data-uid="TensorFlow.TFGraph.QueueEnqueueMany*"></a>
  <h4 id="TensorFlow_TFGraph_QueueEnqueueMany_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.QueueEnqueueMany(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">QueueEnqueueMany(TFOutput, TFOutput[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Enqueues zero or more tuples of one or more tensors in the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation QueueEnqueueMany (TensorFlow.TFOutput handle, TensorFlow.TFOutput[] components, Nullable&lt;long&gt; timeout_ms = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">components</span></td>
        <td><p>One or more tensors from which the enqueued tensors should
              be taken.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">timeout_ms</span></td>
        <td><p>Optional argument
              If the queue is too full, this operation will block for up
              to timeout_ms milliseconds.
              Note: This option is not supported yet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueEnqueueMany&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueEnqueueMany_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation slices each component tensor along the 0th dimension to
              make multiple queue elements. All of the tuple components must have the
              same size in the 0th dimension.</p>
<pre><code>          The components input has k elements, which correspond to the components of
          tuples stored in the given queue.

          N.B. If the queue is full, this operation will block until the given
          elements have been enqueued (or &#39;timeout_ms&#39; elapses, if specified).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_QueueEnqueueManyV2_" data-uid="TensorFlow.TFGraph.QueueEnqueueManyV2*"></a>
  <h4 id="TensorFlow_TFGraph_QueueEnqueueManyV2_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.QueueEnqueueManyV2(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">QueueEnqueueManyV2(TFOutput, TFOutput[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Enqueues zero or more tuples of one or more tensors in the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation QueueEnqueueManyV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput[] components, Nullable&lt;long&gt; timeout_ms = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">components</span></td>
        <td><p>One or more tensors from which the enqueued tensors should
              be taken.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">timeout_ms</span></td>
        <td><p>Optional argument
              If the queue is too full, this operation will block for up
              to timeout_ms milliseconds.
              Note: This option is not supported yet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueEnqueueManyV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueEnqueueManyV2_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation slices each component tensor along the 0th dimension to
              make multiple queue elements. All of the tuple components must have the
              same size in the 0th dimension.</p>
<pre><code>          The components input has k elements, which correspond to the components of
          tuples stored in the given queue.

          N.B. If the queue is full, this operation will block until the given
          elements have been enqueued (or &#39;timeout_ms&#39; elapses, if specified).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_QueueEnqueueV2_" data-uid="TensorFlow.TFGraph.QueueEnqueueV2*"></a>
  <h4 id="TensorFlow_TFGraph_QueueEnqueueV2_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.QueueEnqueueV2(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.Nullable{System.Int64},System.String)">QueueEnqueueV2(TFOutput, TFOutput[], Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Enqueues a tuple of one or more tensors in the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation QueueEnqueueV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput[] components, Nullable&lt;long&gt; timeout_ms = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">components</span></td>
        <td><p>One or more tensors from which the enqueued tensors should be taken.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">timeout_ms</span></td>
        <td><p>Optional argument
              If the queue is full, this operation will block for up to
              timeout_ms milliseconds.
              Note: This option is not supported yet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueEnqueueV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueEnqueueV2_TensorFlow_TFOutput_TensorFlow_TFOutput___System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The components input has k elements, which correspond to the components of
              tuples stored in the given queue.</p>
<pre><code>          N.B. If the queue is full, this operation will block until the given
          element has been enqueued (or &#39;timeout_ms&#39; elapses, if specified).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_QueueIsClosed_" data-uid="TensorFlow.TFGraph.QueueIsClosed*"></a>
  <h4 id="TensorFlow_TFGraph_QueueIsClosed_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.QueueIsClosed(TensorFlow.TFOutput,System.String)">QueueIsClosed(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns true if queue is closed.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput QueueIsClosed (TensorFlow.TFOutput handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueIsClosed&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueIsClosed_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation returns true if the queue is closed and false if the queue
              is open.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_QueueIsClosedV2_" data-uid="TensorFlow.TFGraph.QueueIsClosedV2*"></a>
  <h4 id="TensorFlow_TFGraph_QueueIsClosedV2_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.QueueIsClosedV2(TensorFlow.TFOutput,System.String)">QueueIsClosedV2(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns true if queue is closed.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput QueueIsClosedV2 (TensorFlow.TFOutput handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueIsClosedV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_QueueIsClosedV2_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation returns true if the queue is closed and false if the queue
              is open.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_QueueSize_" data-uid="TensorFlow.TFGraph.QueueSize*"></a>
  <h4 id="TensorFlow_TFGraph_QueueSize_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.QueueSize(TensorFlow.TFOutput,System.String)">QueueSize(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the number of elements in the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput QueueSize (TensorFlow.TFOutput handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueSize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The number of elements in the given queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_QueueSizeV2_" data-uid="TensorFlow.TFGraph.QueueSizeV2*"></a>
  <h4 id="TensorFlow_TFGraph_QueueSizeV2_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.QueueSizeV2(TensorFlow.TFOutput,System.String)">QueueSizeV2(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the number of elements in the given queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput QueueSizeV2 (TensorFlow.TFOutput handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a queue.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;QueueSizeV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The number of elements in the given queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_RandomCrop_" data-uid="TensorFlow.TFGraph.RandomCrop*"></a>
  <h4 id="TensorFlow_TFGraph_RandomCrop_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.RandomCrop(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">RandomCrop(TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Randomly crop <code>image</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RandomCrop (TensorFlow.TFOutput image, TensorFlow.TFOutput size, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">image</span></td>
        <td><p>3-D of shape <code>[height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>1-D of length 2 containing: <code>crop_height</code>, <code>crop_width</code>..</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              An second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RandomCrop&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>3-D of shape <code>[crop_height, crop_width, channels].</code>
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RandomCrop_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>size</code> is a 1-D int64 tensor with 2 elements representing the crop height and
              width.  The values must be non negative.</p>
<pre><code>          This Op picks a random location in &lt;code&gt;image&lt;/code&gt; and crops a &lt;code&gt;height&lt;/code&gt; by &lt;code&gt;width&lt;/code&gt;
          rectangle from that location.  The random location is picked so the cropped
          area will fit inside the original image.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RandomGamma_" data-uid="TensorFlow.TFGraph.RandomGamma*"></a>
  <h4 id="TensorFlow_TFGraph_RandomGamma_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.RandomGamma(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">RandomGamma(TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Outputs random values from the Gamma distribution(s) described by alpha.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RandomGamma (TensorFlow.TFOutput shape, TensorFlow.TFOutput alpha, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>1-D integer tensor. Shape of independent samples to draw from each
              distribution described by the shape parameters given in alpha.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">alpha</span></td>
        <td><p>A tensor in which each scalar is a &quot;shape&quot; parameter describing the
              associated gamma distribution.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              A second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RandomGamma&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor with shape <code>shape + shape(alpha)</code>. Each slice
              <code>[:, ..., :, i0, i1, ...iN]</code> contains the samples drawn for
              <code>alpha[i0, i1, ...iN]</code>. The dtype of the output matches the dtype of alpha.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RandomGamma_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op uses the algorithm by Marsaglia et al. to acquire samples via
              transformation-rejection from pairs of uniform and normal random variables.
              See <a href="http://dl.acm.org/citation.cfm?id=358414">http://dl.acm.org/citation.cfm?id=358414</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_RandomGammaGrad_" data-uid="TensorFlow.TFGraph.RandomGammaGrad*"></a>
  <h4 id="TensorFlow_TFGraph_RandomGammaGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RandomGammaGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">RandomGammaGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the derivative of a Gamma random sample w.r.t. <code>alpha</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RandomGammaGrad (TensorFlow.TFOutput alpha, TensorFlow.TFOutput sample, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">alpha</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sample</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RandomGammaGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_RandomNormal_" data-uid="TensorFlow.TFGraph.RandomNormal*"></a>
  <h4 id="TensorFlow_TFGraph_RandomNormal_TensorFlow_TFShape_System_Double_System_Double_System_Nullable_System_Int32__System_String_" data-uid="TensorFlow.TFGraph.RandomNormal(TensorFlow.TFShape,System.Double,System.Double,System.Nullable{System.Int32},System.String)">RandomNormal(TFShape, Double, Double, Nullable&lt;Int32&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Outputs random values from a normal distribution</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RandomNormal (TensorFlow.TFShape shape, double mean = 0, double stddev = 1, Nullable&lt;int&gt; seed = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>Shape of the output tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">mean</span></td>
        <td><p>The mean of the standard distribution.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">stddev</span></td>
        <td><p>The standard deviation of the normal distribution.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int32</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Integer seed used for the random distribution, using the TensorFlow SetRandomSeed .</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Operation name, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor of the specified shape filled with random normal values.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_RandomPoisson_" data-uid="TensorFlow.TFGraph.RandomPoisson*"></a>
  <h4 id="TensorFlow_TFGraph_RandomPoisson_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.RandomPoisson(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">RandomPoisson(TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Use RandomPoissonV2 instead.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RandomPoisson (TensorFlow.TFOutput shape, TensorFlow.TFOutput rate, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rate</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RandomPoisson&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_RandomPoissonV2_" data-uid="TensorFlow.TFGraph.RandomPoissonV2*"></a>
  <h4 id="TensorFlow_TFGraph_RandomPoissonV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.RandomPoissonV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{TensorFlow.TFDataType},System.String)">RandomPoissonV2(TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Outputs random values from the Poisson distribution(s) described by rate.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RandomPoissonV2 (TensorFlow.TFOutput shape, TensorFlow.TFOutput rate, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, Nullable&lt;TensorFlow.TFDataType&gt; dtype = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>1-D integer tensor. Shape of independent samples to draw from each
              distribution described by the shape parameters given in rate.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rate</span></td>
        <td><p>A tensor in which each scalar is a &quot;rate&quot; parameter describing the
              associated poisson distribution.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              A second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">dtype</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RandomPoissonV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor with shape <code>shape + shape(rate)</code>. Each slice
              <code>[:, ..., :, i0, i1, ...iN]</code> contains the samples drawn for
              <code>rate[i0, i1, ...iN]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RandomPoissonV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op uses two algorithms, depending on rate. If rate &gt;= 10, then
              the algorithm by Hormann is used to acquire samples via
              transformation-rejection.
              See <a href="http://www.sciencedirect.com/science/article/pii/0167668793909974">http://www.sciencedirect.com/science/article/pii/0167668793909974</a>.</p>
<pre><code>          Otherwise, Knuth&#39;s algorithm is used to acquire samples via multiplying uniform
          random variables.
          See Donald E. Knuth (1969). Seminumerical Algorithms. The Art of Computer
          Programming, Volume 2. Addison Wesley
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RandomShuffle_" data-uid="TensorFlow.TFGraph.RandomShuffle*"></a>
  <h4 id="TensorFlow_TFGraph_RandomShuffle_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.RandomShuffle(TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">RandomShuffle(TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Randomly shuffles a tensor along its first dimension.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RandomShuffle (TensorFlow.TFOutput value, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>The tensor to be shuffled.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              A second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RandomShuffle&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor of same shape and type as <code>value</code>, shuffled along its first
              dimension.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RandomShuffle_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The tensor is shuffled along dimension 0, such that each <code>value[j]</code> is mapped
              to one and only one <code>output[i]</code>. For example, a mapping that might occur for a
              3x2 tensor is:</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          [[1, 2],       [[5, 6],
          [3, 4],  ==&amp;gt;   [1, 2],
          [5, 6]]        [3, 4]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RandomShuffleQueue_" data-uid="TensorFlow.TFGraph.RandomShuffleQueue*"></a>
  <h4 id="TensorFlow_TFGraph_RandomShuffleQueue_TensorFlow_TFDataType___TensorFlow_TFShape___System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.RandomShuffleQueue(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">RandomShuffleQueue(TFDataType[], TFShape[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A queue that randomizes the order of elements.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RandomShuffleQueue (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; min_after_dequeue = null, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a value.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>Optional argument
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types. If the length of
              this attr is 0, the shapes of queue elements are not constrained, and
              only one element may be dequeued at a time.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">min_after_dequeue</span></td>
        <td><p>Optional argument
              Dequeue will block unless there would be this
              many elements after the dequeue or the queue is closed. This
              ensures a minimum level of mixing of elements.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either seed or seed2 is set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, a random seed is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              A second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RandomShuffleQueue&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_RandomShuffleQueueV2_" data-uid="TensorFlow.TFGraph.RandomShuffleQueueV2*"></a>
  <h4 id="TensorFlow_TFGraph_RandomShuffleQueueV2_TensorFlow_TFDataType___TensorFlow_TFShape___System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.RandomShuffleQueueV2(TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">RandomShuffleQueueV2(TFDataType[], TFShape[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A queue that randomizes the order of elements.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RandomShuffleQueueV2 (TensorFlow.TFDataType[] component_types, TensorFlow.TFShape[] shapes = null, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; min_after_dequeue = null, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">component_types</span></td>
        <td><p>The type of each component in a value.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>Optional argument
              The shape of each component in a value. The length of this attr must
              be either 0 or the same as the length of component_types. If the length of
              this attr is 0, the shapes of queue elements are not constrained, and
              only one element may be dequeued at a time.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument
              The upper bound on the number of elements in this queue.
              Negative numbers mean no limit.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">min_after_dequeue</span></td>
        <td><p>Optional argument
              Dequeue will block unless there would be this
              many elements after the dequeue or the queue is closed. This
              ensures a minimum level of mixing of elements.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either seed or seed2 is set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, a random seed is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              A second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this queue is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this queue will be shared under the given name
              across multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RandomShuffleQueueV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to the queue.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_RandomStandardNormal_" data-uid="TensorFlow.TFGraph.RandomStandardNormal*"></a>
  <h4 id="TensorFlow_TFGraph_RandomStandardNormal_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.RandomStandardNormal(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">RandomStandardNormal(TFOutput, TFDataType, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Outputs random values from a normal distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RandomStandardNormal (TensorFlow.TFOutput shape, TensorFlow.TFDataType dtype, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of the output.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              A second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RandomStandardNormal&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor of the specified shape filled with random normal values.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RandomStandardNormal_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The generated values will have mean 0 and standard deviation 1.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_RandomUniform_" data-uid="TensorFlow.TFGraph.RandomUniform*"></a>
  <h4 id="TensorFlow_TFGraph_RandomUniform_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.RandomUniform(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">RandomUniform(TFOutput, TFDataType, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Outputs random values from a uniform distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RandomUniform (TensorFlow.TFOutput shape, TensorFlow.TFDataType dtype, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of the output.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              A second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RandomUniform&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor of the specified shape filled with uniform random values.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RandomUniform_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The generated values follow a uniform distribution in the range <code>[0, 1)</code>. The
              lower bound 0 is included in the range, while the upper bound 1 is excluded.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_RandomUniform_" data-uid="TensorFlow.TFGraph.RandomUniform*"></a>
  <h4 id="TensorFlow_TFGraph_RandomUniform_TensorFlow_TFShape_System_Double_System_Double_System_Nullable_System_Int32__System_String_" data-uid="TensorFlow.TFGraph.RandomUniform(TensorFlow.TFShape,System.Double,System.Double,System.Nullable{System.Int32},System.String)">RandomUniform(TFShape, Double, Double, Nullable&lt;Int32&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Randoms the uniform.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RandomUniform (TensorFlow.TFShape shape, double minval = 0, double maxval = 1, Nullable&lt;int&gt; seed = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>Shape.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">minval</span></td>
        <td><p>Minval.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Double</span></td>
        <td><span class="parametername">maxval</span></td>
        <td><p>Maxval.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int32</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Oper name.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The uniform.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_RandomUniformInt_" data-uid="TensorFlow.TFGraph.RandomUniformInt*"></a>
  <h4 id="TensorFlow_TFGraph_RandomUniformInt_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.RandomUniformInt(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">RandomUniformInt(TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Outputs random integers from a uniform distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RandomUniformInt (TensorFlow.TFOutput shape, TensorFlow.TFOutput minval, TensorFlow.TFOutput maxval, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">minval</span></td>
        <td><p>0-D.  Inclusive lower bound on the generated integers.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">maxval</span></td>
        <td><p>0-D.  Exclusive upper bound on the generated integers.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              A second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RandomUniformInt&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor of the specified shape filled with uniform random integers.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RandomUniformInt_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The generated values are uniform integers in the range <code>[minval, maxval)</code>.
              The lower bound <code>minval</code> is included in the range, while the upper bound
              <code>maxval</code> is excluded.</p>
<pre><code>          The random integers are slightly biased unless &lt;code&gt;maxval - minval&lt;/code&gt; is an exact
          power of two.  The bias is small for values of &lt;code&gt;maxval - minval&lt;/code&gt; significantly
          smaller than the range of the output (either &lt;code&gt;2^32&lt;/code&gt; or &lt;code&gt;2^64&lt;/code&gt;).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Range_" data-uid="TensorFlow.TFGraph.Range*"></a>
  <h4 id="TensorFlow_TFGraph_Range_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Range(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Range(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Creates a sequence of numbers.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Range (TensorFlow.TFOutput start, TensorFlow.TFOutput limit, TensorFlow.TFOutput delta, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">start</span></td>
        <td><p>0-D (scalar). First entry in the sequence.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">limit</span></td>
        <td><p>0-D (scalar). Upper limit of sequence, exclusive.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">delta</span></td>
        <td><p>0-D (scalar). Optional. Default is 1. Number that increments <code>start</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Range&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>1-D.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Range_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation creates a sequence of numbers that begins at <code>start</code> and
              extends by increments of <code>delta</code> up to but not including <code>limit</code>.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;start&#39; is 3
          # &#39;limit&#39; is 18
          # &#39;delta&#39; is 3
          tf.range(start, limit, delta) ==&amp;gt; [3, 6, 9, 12, 15]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Range_" data-uid="TensorFlow.TFGraph.Range*"></a>
  <h4 id="TensorFlow_TFGraph_Range_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFOutput__System_Nullable_TensorFlow_TFOutput__System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.Range(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFDataType},System.String)">Range(TFOutput, Nullable&lt;TFOutput&gt;, Nullable&lt;TFOutput&gt;, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Creates a sequence of numbers.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Range (TensorFlow.TFOutput start, Nullable&lt;TensorFlow.TFOutput&gt; limit = null, Nullable&lt;TensorFlow.TFOutput&gt; delta = null, Nullable&lt;TensorFlow.TFDataType&gt; dataType = null, string operName = &quot;range&quot;);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">start</span></td>
        <td><p>A 0 - D <code>Tensor</code> (scalar).Acts as first entry in the range if <code>limit</code> is not None; otherwise, acts as range limit and first entry defaults to 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><span class="parametername">limit</span></td>
        <td><p>A 0 - D <code>Tensor</code> (scalar).Upper limit of sequence, exclusive. If None, defaults to the value of <code>start</code> while the first entry of the range defaults to 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><span class="parametername">delta</span></td>
        <td><p>A 0 - D <code>Tensor</code> (scalar).Number that increments <code>start</code>. Defaults to 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">dataType</span></td>
        <td><p>The type of the elements of the resulting tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>A name for the operation.Defaults to &quot;range&quot;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Range_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFOutput__System_Nullable_TensorFlow_TFOutput__System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Creates a sequence of numbers that begins at <code>start</code> and extends by increments of <code>delta</code> up to but not including 
            <code>limit</code>. The dtype of the resulting tensor is inferred from the inputs unless it is provided explicitly.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_RangeDataset_" data-uid="TensorFlow.TFGraph.RangeDataset*"></a>
  <h4 id="TensorFlow_TFGraph_RangeDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.RangeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">RangeDataset(TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset with a range of values. Corresponds to python&#39;s xrange.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RangeDataset (TensorFlow.TFOutput start, TensorFlow.TFOutput stop, TensorFlow.TFOutput step, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">start</span></td>
        <td><p>corresponds to start in python&#39;s xrange().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">stop</span></td>
        <td><p>corresponds to stop in python&#39;s xrange().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">step</span></td>
        <td><p>corresponds to step in python&#39;s xrange().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RangeDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Rank_" data-uid="TensorFlow.TFGraph.Rank*"></a>
  <h4 id="TensorFlow_TFGraph_Rank_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Rank(TensorFlow.TFOutput,System.String)">Rank(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the rank of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Rank (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Rank&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Rank_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation returns an integer representing the rank of <code>input</code>.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;t&#39; is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
          # shape of tensor &#39;t&#39; is [2, 2, 3]
          rank(t) ==&amp;gt; 3
           &lt;/code&gt;&lt;/pre&gt;

          **Note**: The rank of a tensor is not the same as the rank of a matrix. The rank
          of a tensor is the number of indices required to uniquely select each element
          of the tensor. Rank is also known as &quot;order&quot;, &quot;degree&quot;, or &quot;ndims.&quot;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ReaderNumRecordsProduced_" data-uid="TensorFlow.TFGraph.ReaderNumRecordsProduced*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderNumRecordsProduced_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderNumRecordsProduced(TensorFlow.TFOutput,System.String)">ReaderNumRecordsProduced(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the number of records this Reader has produced.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReaderNumRecordsProduced (TensorFlow.TFOutput reader_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a Reader.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderNumRecordsProduced&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReaderNumRecordsProduced_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This is the same as the number of ReaderRead executions that have
              succeeded.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ReaderNumRecordsProducedV2_" data-uid="TensorFlow.TFGraph.ReaderNumRecordsProducedV2*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderNumRecordsProducedV2_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderNumRecordsProducedV2(TensorFlow.TFOutput,System.String)">ReaderNumRecordsProducedV2(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the number of records this Reader has produced.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReaderNumRecordsProducedV2 (TensorFlow.TFOutput reader_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a Reader.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderNumRecordsProducedV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReaderNumRecordsProducedV2_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This is the same as the number of ReaderRead executions that have
              succeeded.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ReaderNumWorkUnitsCompleted_" data-uid="TensorFlow.TFGraph.ReaderNumWorkUnitsCompleted*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderNumWorkUnitsCompleted_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderNumWorkUnitsCompleted(TensorFlow.TFOutput,System.String)">ReaderNumWorkUnitsCompleted(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the number of work units this Reader has finished processing.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReaderNumWorkUnitsCompleted (TensorFlow.TFOutput reader_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a Reader.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderNumWorkUnitsCompleted&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ReaderNumWorkUnitsCompletedV2_" data-uid="TensorFlow.TFGraph.ReaderNumWorkUnitsCompletedV2*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderNumWorkUnitsCompletedV2_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderNumWorkUnitsCompletedV2(TensorFlow.TFOutput,System.String)">ReaderNumWorkUnitsCompletedV2(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the number of work units this Reader has finished processing.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReaderNumWorkUnitsCompletedV2 (TensorFlow.TFOutput reader_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a Reader.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderNumWorkUnitsCompletedV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ReaderRead_" data-uid="TensorFlow.TFGraph.ReaderRead*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderRead_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderRead(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ReaderRead(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the next record (key, value pair) produced by a Reader.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; ReaderRead (TensorFlow.TFOutput reader_handle, TensorFlow.TFOutput queue_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a Reader.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">queue_handle</span></td>
        <td><p>Handle to a Queue, with string work items.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderRead&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              key: A scalar.
              value: A scalar.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReaderRead_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Will dequeue from the input queue if necessary (e.g. when the
              Reader needs to start reading from a new file since it has finished
              with the previous file).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ReaderReadUpTo_" data-uid="TensorFlow.TFGraph.ReaderReadUpTo*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderReadUpTo_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderReadUpTo(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ReaderReadUpTo(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns up to <code>num_records</code> (key, value) pairs produced by a Reader.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; ReaderReadUpTo (TensorFlow.TFOutput reader_handle, TensorFlow.TFOutput queue_handle, TensorFlow.TFOutput num_records, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a <code>Reader</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">queue_handle</span></td>
        <td><p>Handle to a <code>Queue</code>, with string work items.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_records</span></td>
        <td><p>number of records to read from <code>Reader</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderReadUpTo&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              keys: A 1-D tensor.
              values: A 1-D tensor.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReaderReadUpTo_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Will dequeue from the input queue if necessary (e.g. when the
              Reader needs to start reading from a new file since it has finished
              with the previous file).
              It may return less than <code>num_records</code> even before the last batch.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ReaderReadUpToV2_" data-uid="TensorFlow.TFGraph.ReaderReadUpToV2*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderReadUpToV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderReadUpToV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ReaderReadUpToV2(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns up to <code>num_records</code> (key, value) pairs produced by a Reader.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; ReaderReadUpToV2 (TensorFlow.TFOutput reader_handle, TensorFlow.TFOutput queue_handle, TensorFlow.TFOutput num_records, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a <code>Reader</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">queue_handle</span></td>
        <td><p>Handle to a <code>Queue</code>, with string work items.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_records</span></td>
        <td><p>number of records to read from <code>Reader</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderReadUpToV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              keys: A 1-D tensor.
              values: A 1-D tensor.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReaderReadUpToV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Will dequeue from the input queue if necessary (e.g. when the
              Reader needs to start reading from a new file since it has finished
              with the previous file).
              It may return less than <code>num_records</code> even before the last batch.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ReaderReadV2_" data-uid="TensorFlow.TFGraph.ReaderReadV2*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderReadV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderReadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ReaderReadV2(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the next record (key, value pair) produced by a Reader.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; ReaderReadV2 (TensorFlow.TFOutput reader_handle, TensorFlow.TFOutput queue_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a Reader.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">queue_handle</span></td>
        <td><p>Handle to a Queue, with string work items.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderReadV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              key: A scalar.
              value: A scalar.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReaderReadV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Will dequeue from the input queue if necessary (e.g. when the
              Reader needs to start reading from a new file since it has finished
              with the previous file).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ReaderReset_" data-uid="TensorFlow.TFGraph.ReaderReset*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderReset_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderReset(TensorFlow.TFOutput,System.String)">ReaderReset(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Restore a Reader to its initial clean state.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ReaderReset (TensorFlow.TFOutput reader_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a Reader.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderReset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ReaderResetV2_" data-uid="TensorFlow.TFGraph.ReaderResetV2*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderResetV2_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderResetV2(TensorFlow.TFOutput,System.String)">ReaderResetV2(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Restore a Reader to its initial clean state.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ReaderResetV2 (TensorFlow.TFOutput reader_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a Reader.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderResetV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ReaderRestoreState_" data-uid="TensorFlow.TFGraph.ReaderRestoreState*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderRestoreState_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderRestoreState(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ReaderRestoreState(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Restore a reader to a previously saved state.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ReaderRestoreState (TensorFlow.TFOutput reader_handle, TensorFlow.TFOutput state, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a Reader.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">state</span></td>
        <td><p>Result of a ReaderSerializeState of a Reader with type
              matching reader_handle.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderRestoreState&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReaderRestoreState_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Not all Readers support being restored, so this can produce an
              Unimplemented error.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ReaderRestoreStateV2_" data-uid="TensorFlow.TFGraph.ReaderRestoreStateV2*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderRestoreStateV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderRestoreStateV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ReaderRestoreStateV2(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Restore a reader to a previously saved state.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ReaderRestoreStateV2 (TensorFlow.TFOutput reader_handle, TensorFlow.TFOutput state, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a Reader.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">state</span></td>
        <td><p>Result of a ReaderSerializeState of a Reader with type
              matching reader_handle.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderRestoreStateV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReaderRestoreStateV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Not all Readers support being restored, so this can produce an
              Unimplemented error.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ReaderSerializeState_" data-uid="TensorFlow.TFGraph.ReaderSerializeState*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderSerializeState_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderSerializeState(TensorFlow.TFOutput,System.String)">ReaderSerializeState(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Produce a string tensor that encodes the state of a Reader.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReaderSerializeState (TensorFlow.TFOutput reader_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a Reader.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderSerializeState&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReaderSerializeState_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Not all Readers support being serialized, so this can produce an
              Unimplemented error.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ReaderSerializeStateV2_" data-uid="TensorFlow.TFGraph.ReaderSerializeStateV2*"></a>
  <h4 id="TensorFlow_TFGraph_ReaderSerializeStateV2_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReaderSerializeStateV2(TensorFlow.TFOutput,System.String)">ReaderSerializeStateV2(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Produce a string tensor that encodes the state of a Reader.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReaderSerializeStateV2 (TensorFlow.TFOutput reader_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reader_handle</span></td>
        <td><p>Handle to a Reader.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReaderSerializeStateV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReaderSerializeStateV2_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Not all Readers support being serialized, so this can produce an
              Unimplemented error.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ReadFile_" data-uid="TensorFlow.TFGraph.ReadFile*"></a>
  <h4 id="TensorFlow_TFGraph_ReadFile_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReadFile(TensorFlow.TFOutput,System.String)">ReadFile(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Reads and outputs the entire contents of the input filename.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReadFile (TensorFlow.TFOutput filename, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filename</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReadFile&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ReadVariableOp_" data-uid="TensorFlow.TFGraph.ReadVariableOp*"></a>
  <h4 id="TensorFlow_TFGraph_ReadVariableOp_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.ReadVariableOp(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">ReadVariableOp(TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Reads the value of a variable.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReadVariableOp (TensorFlow.TFOutput resource, TensorFlow.TFDataType dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>handle to the resource in which to store the variable.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>the dtype of the value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReadVariableOp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReadVariableOp_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The tensor returned by this operation is immutable.</p>
<pre><code>          The value returned by this operation is guaranteed to be influenced by all the
          writes on which this operation depends directly or indirectly, and to not be
          influenced by any of the writes which depend directly or indirectly on this
          operation.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Real_" data-uid="TensorFlow.TFGraph.Real*"></a>
  <h4 id="TensorFlow_TFGraph_Real_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.Real(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">Real(TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns the real part of a complex number.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Real (TensorFlow.TFOutput input, Nullable&lt;TensorFlow.TFDataType&gt; Tout = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">Tout</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Real&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Real_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of
              type <code>float</code> that is the real part of each element in <code>input</code>. All elements in
              <code>input</code> must be complex numbers of the form \(a + bj\), where <em>a</em> is the real
              part returned by this operation and <em>b</em> is the imaginary part.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          # tensor &#39;input&#39; is [-2.25 + 4.75j, 3.25 + 5.75j]
          tf.real(input) ==&amp;gt; [-2.25, 3.25]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RealDiv_" data-uid="TensorFlow.TFGraph.RealDiv*"></a>
  <h4 id="TensorFlow_TFGraph_RealDiv_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RealDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">RealDiv(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns x / y element-wise for real types.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RealDiv (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RealDiv&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RealDiv_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If <code>x</code> and <code>y</code> are reals, this will return the floating-point division.</p>
<pre><code>          *NOTE*: &lt;code&gt;Div&lt;/code&gt; supports broadcasting. More about broadcasting
          [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Reciprocal_" data-uid="TensorFlow.TFGraph.Reciprocal*"></a>
  <h4 id="TensorFlow_TFGraph_Reciprocal_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Reciprocal(TensorFlow.TFOutput,System.String)">Reciprocal(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the reciprocal of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Reciprocal (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Reciprocal&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Reciprocal_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>I.e., \(y = 1 / x\).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ReciprocalGrad_" data-uid="TensorFlow.TFGraph.ReciprocalGrad*"></a>
  <h4 id="TensorFlow_TFGraph_ReciprocalGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReciprocalGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ReciprocalGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradient for the inverse of <code>x</code> wrt its input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReciprocalGrad (TensorFlow.TFOutput y, TensorFlow.TFOutput dy, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dy</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReciprocalGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReciprocalGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Specifically, <code>grad = -dy * y*y</code>, where <code>y = 1/x</code>, and <code>dy</code>
              is the corresponding input gradient.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_RecordInput_" data-uid="TensorFlow.TFGraph.RecordInput*"></a>
  <h4 id="TensorFlow_TFGraph_RecordInput_System_String_System_Nullable_System_Int64__System_Nullable_System_Single__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RecordInput(System.String,System.Nullable{System.Int64},System.Nullable{System.Single},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String)">RecordInput(String, Nullable&lt;Int64&gt;, Nullable&lt;Single&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Emits randomized records.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RecordInput (string file_pattern, Nullable&lt;long&gt; file_random_seed = null, Nullable&lt;float&gt; file_shuffle_shift_ratio = null, Nullable&lt;long&gt; file_buffer_size = null, Nullable&lt;long&gt; file_parallelism = null, Nullable&lt;long&gt; batch_size = null, string compression_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">file_pattern</span></td>
        <td><p>Glob pattern for the data files.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">file_random_seed</span></td>
        <td><p>Optional argument
              Random seeds used to produce randomized records.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">file_shuffle_shift_ratio</span></td>
        <td><p>Optional argument
              Shifts the list of files after the list is randomly
              shuffled.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">file_buffer_size</span></td>
        <td><p>Optional argument
              The randomization shuffling buffer.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">file_parallelism</span></td>
        <td><p>Optional argument
              How many sstables are opened and concurrently iterated over.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">batch_size</span></td>
        <td><p>Optional argument
              The batch size.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">compression_type</span></td>
        <td><p>Optional argument
              The type of compression for the file. Currently ZLIB and
              GZIP are supported. Defaults to none.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RecordInput&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor of shape [batch_size].
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_RecvTPUEmbeddingActivations_" data-uid="TensorFlow.TFGraph.RecvTPUEmbeddingActivations*"></a>
  <h4 id="TensorFlow_TFGraph_RecvTPUEmbeddingActivations_System_Int64_System_String_System_String_" data-uid="TensorFlow.TFGraph.RecvTPUEmbeddingActivations(System.Int64,System.String,System.String)">RecvTPUEmbeddingActivations(Int64, String, String)</h4>
  <div class="markdown level1 summary"><p>An op that receives embedding activations on the TPU.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] RecvTPUEmbeddingActivations (long num_outputs, string config, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_outputs</span></td>
        <td><p>The number of output activation tensors, equal to the number of
              embedding tables in the model.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">config</span></td>
        <td><p>Serialized TPUEmbeddingConfiguration proto.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RecvTPUEmbeddingActivations&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>A TensorList of embedding activations containing one Tensor per
              embedding table in the model.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RecvTPUEmbeddingActivations_System_Int64_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The TPU system performs the embedding lookups and aggregations specified by
              the arguments to TPUEmbeddingEnqueue(Integer/Sparse/SparseTensor)Batch. The
              results of these aggregations are visible to the Tensorflow Graph as the
              outputs of a RecvTPUEmbeddingActivations op. This op returns a list containing
              one Tensor of activations per table specified in the model. There can be at
              most one RecvTPUEmbeddingActivations op in the TPU graph.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ReduceJoin_" data-uid="TensorFlow.TFGraph.ReduceJoin*"></a>
  <h4 id="TensorFlow_TFGraph_ReduceJoin_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_System_String_" data-uid="TensorFlow.TFGraph.ReduceJoin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String,System.String)">ReduceJoin(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Joins a string Tensor across the given dimensions.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReduceJoin (TensorFlow.TFOutput inputs, TensorFlow.TFOutput reduction_indices, Nullable&lt;bool&gt; keep_dims = null, string separator = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">inputs</span></td>
        <td><p>The input to be joined.  All reduced indices must have non-zero size.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reduction_indices</span></td>
        <td><p>The dimensions to reduce over.  Dimensions are reduced in the
              order specified.  Omitting <code>reduction_indices</code> is equivalent to passing
              <code>[n-1, n-2, ..., 0]</code>.  Negative indices from <code>-n</code> to <code>-1</code> are supported.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>Optional argument
              If <code>True</code>, retain reduced dimensions with length <code>1</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">separator</span></td>
        <td><p>Optional argument
              The separator to use when joining.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReduceJoin&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has shape equal to that of the input with reduced dimensions removed or
              set to <code>1</code> depending on <code>keep_dims</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReduceJoin_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the string join across dimensions in the given string Tensor of shape
              <code>[\(d_0, d_1, ..., d_{n-1}\)]</code>.  Returns a new Tensor created by joining the input
              strings with the given separator (default: empty string).  Negative indices are
              counted backwards from the end, with <code>-1</code> being equivalent to <code>n - 1</code>.  If
              indices are not specified, joins across all dimensions beginning from <code>n - 1</code>
              through <code>0</code>.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          # tensor &lt;code&gt;a&lt;/code&gt; is [[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]]
          tf.reduce_join(a, 0) ==&amp;gt; [&quot;ac&quot;, &quot;bd&quot;]
          tf.reduce_join(a, 1) ==&amp;gt; [&quot;ab&quot;, &quot;cd&quot;]
          tf.reduce_join(a, -2) = tf.reduce_join(a, 0) ==&amp;gt; [&quot;ac&quot;, &quot;bd&quot;]
          tf.reduce_join(a, -1) = tf.reduce_join(a, 1) ==&amp;gt; [&quot;ab&quot;, &quot;cd&quot;]
          tf.reduce_join(a, 0, keep_dims=True) ==&amp;gt; [[&quot;ac&quot;, &quot;bd&quot;]]
          tf.reduce_join(a, 1, keep_dims=True) ==&amp;gt; [[&quot;ab&quot;], [&quot;cd&quot;]]
          tf.reduce_join(a, 0, separator=&quot;.&quot;) ==&amp;gt; [&quot;a.c&quot;, &quot;b.d&quot;]
          tf.reduce_join(a, [0, 1]) ==&amp;gt; &quot;acbd&quot;
          tf.reduce_join(a, [1, 0]) ==&amp;gt; &quot;abcd&quot;
          tf.reduce_join(a, []) ==&amp;gt; [[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]]
          tf.reduce_join(a) = tf.reduce_join(a, [1, 0]) ==&amp;gt; &quot;abcd&quot;
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ReduceMean_" data-uid="TensorFlow.TFGraph.ReduceMean*"></a>
  <h4 id="TensorFlow_TFGraph_ReduceMean_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFOutput__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ReduceMean(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)">ReduceMean(TFOutput, Nullable&lt;TFOutput&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the mean of elements across dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReduceMean (TensorFlow.TFOutput input, Nullable&lt;TensorFlow.TFOutput&gt; axis = null, Nullable&lt;bool&gt; keep_dims = false, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The tensor to reduce. Should have numeric type.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><span class="parametername">axis</span></td>
        <td><p>The dimensions to reduce. If not set (the default), reduces all dimensions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>If set to <code>true</code> retains reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>A name for the operation, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The reduced tensor.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReduceMean_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFOutput__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>
              Reduces input_tensor along the dimensions given in axis.
            Unless keep_dims is true, the rank of the tensor is reduced by 1 for each
            entry in axis. If keep_dims is true, the reduced dimensions
            are retained with length 1.</p>
    <p>
            If axis has no entries, all dimensions are reduced, and a
            tensor with a single element is returned.</p></div>
  
  
  <a id="TensorFlow_TFGraph_ReduceProd_" data-uid="TensorFlow.TFGraph.ReduceProd*"></a>
  <h4 id="TensorFlow_TFGraph_ReduceProd_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFOutput__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ReduceProd(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)">ReduceProd(TFOutput, Nullable&lt;TFOutput&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the product of elements across dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReduceProd (TensorFlow.TFOutput input, Nullable&lt;TensorFlow.TFOutput&gt; axis = null, Nullable&lt;bool&gt; keep_dims = false, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The tensor to reduce. Should have numeric type.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><span class="parametername">axis</span></td>
        <td><p>The dimensions to reduce. If not se (the default), reduces all dimensions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>If set to <code>true</code> retains reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>A name for the operation, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The reduced tensor.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReduceProd_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFOutput__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Reduces input_tensor along the dimensions given in axis.
            Unless keep_dims is true, the rank of the tensor is reduced by 1 for each
            entry in axis. If keep_dims is true, the reduced dimensions
            are retained with length 1.</p>
<pre><code>        If axis has no entries, all dimensions are reduced, and a
        tensor with a single element is returned.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ReduceSum_" data-uid="TensorFlow.TFGraph.ReduceSum*"></a>
  <h4 id="TensorFlow_TFGraph_ReduceSum_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFOutput__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ReduceSum(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{System.Boolean},System.String)">ReduceSum(TFOutput, Nullable&lt;TFOutput&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the sum of elements across dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReduceSum (TensorFlow.TFOutput input, Nullable&lt;TensorFlow.TFOutput&gt; axis = null, Nullable&lt;bool&gt; keep_dims = false, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The tensor to reduce. Should have numeric type.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><span class="parametername">axis</span></td>
        <td><p>The dimensions to reduce. If not se (the default), reduces all dimensions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>If set to <code>true</code> retains reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>A name for the operation, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The reduced tensor.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReduceSum_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFOutput__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Reduces input_tensor along the dimensions given in axis.
            Unless keep_dims is true, the rank of the tensor is reduced by 1 for each
            entry in axis. If keep_dims is true, the reduced dimensions
            are retained with length 1.</p>
<pre><code>        If axis has no entries, all dimensions are reduced, and a
        tensor with a single element is returned.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RefEnter_" data-uid="TensorFlow.TFGraph.RefEnter*"></a>
  <h4 id="TensorFlow_TFGraph_RefEnter_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.RefEnter(TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)">RefEnter(TFOutput, String, Nullable&lt;Boolean&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Creates or finds a child frame, and makes <code>data</code> available to the child frame.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RefEnter (TensorFlow.TFOutput data, string frame_name, Nullable&lt;bool&gt; is_constant = null, Nullable&lt;long&gt; parallel_iterations = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>The tensor to be made available to the child frame.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">frame_name</span></td>
        <td><p>The name of the child frame.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">is_constant</span></td>
        <td><p>Optional argument
              If true, the output is constant within the child frame.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">parallel_iterations</span></td>
        <td><p>Optional argument
              The number of iterations allowed to run in parallel.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RefEnter&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The same tensor as <code>data</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RefEnter_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The unique <code>frame_name</code> is used by the <code>Executor</code> to identify frames. If
              <code>is_constant</code> is true, <code>output</code> is a constant in the child frame; otherwise
              it may be changed in the child frame. At most <code>parallel_iterations</code> iterations
              are run in parallel in the child frame.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_RefExit_" data-uid="TensorFlow.TFGraph.RefExit*"></a>
  <h4 id="TensorFlow_TFGraph_RefExit_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RefExit(TensorFlow.TFOutput,System.String)">RefExit(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Exits the current frame to its parent frame.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RefExit (TensorFlow.TFOutput data, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>The tensor to be made available to the parent frame.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RefExit&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The same tensor as <code>data</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RefExit_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Exit makes its input <code>data</code> available to the parent frame.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_RefIdentity_" data-uid="TensorFlow.TFGraph.RefIdentity*"></a>
  <h4 id="TensorFlow_TFGraph_RefIdentity_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RefIdentity(TensorFlow.TFOutput,System.String)">RefIdentity(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Return the same ref tensor as the input ref tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RefIdentity (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RefIdentity&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_RefMerge_" data-uid="TensorFlow.TFGraph.RefMerge*"></a>
  <h4 id="TensorFlow_TFGraph_RefMerge_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.RefMerge(TensorFlow.TFOutput[],System.String)">RefMerge(TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Forwards the value of an available tensor from <code>inputs</code> to <code>output</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RefMerge (TensorFlow.TFOutput[] inputs, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>The input tensors, exactly one of which will become available.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RefMerge&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output: Will be set to the available input tensor.
              value_index: The index of the chosen input tensor in <code>inputs</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RefMerge_TensorFlow_TFOutput___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>Merge</code> waits for at least one of the tensors in <code>inputs</code> to become available.
              It is usually combined with <code>Switch</code> to implement branching.</p>
<pre><code>          &lt;code&gt;Merge&lt;/code&gt; forwards the first tensor for become available to &lt;code&gt;output&lt;/code&gt;, and sets
          &lt;code&gt;value_index&lt;/code&gt; to its index in &lt;code&gt;inputs&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RefNextIteration_" data-uid="TensorFlow.TFGraph.RefNextIteration*"></a>
  <h4 id="TensorFlow_TFGraph_RefNextIteration_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RefNextIteration(TensorFlow.TFOutput,System.String)">RefNextIteration(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Makes its input available to the next iteration.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RefNextIteration (TensorFlow.TFOutput data, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>The tensor to be made available to the next iteration.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RefNextIteration&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The same tensor as <code>data</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_RefSelect_" data-uid="TensorFlow.TFGraph.RefSelect*"></a>
  <h4 id="TensorFlow_TFGraph_RefSelect_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.RefSelect(TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)">RefSelect(TFOutput, TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Forwards the <code>index</code>th element of <code>inputs</code> to <code>output</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RefSelect (TensorFlow.TFOutput index, TensorFlow.TFOutput[] inputs, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">index</span></td>
        <td><p>A scalar that determines the input that gets selected.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>A list of ref tensors, one of which will be forwarded to <code>output</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RefSelect&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The forwarded tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_RefSwitch_" data-uid="TensorFlow.TFGraph.RefSwitch*"></a>
  <h4 id="TensorFlow_TFGraph_RefSwitch_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RefSwitch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">RefSwitch(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Forwards the ref tensor <code>data</code> to the output port determined by <code>pred</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RefSwitch (TensorFlow.TFOutput data, TensorFlow.TFOutput pred, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>The ref tensor to be forwarded to the appropriate output.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">pred</span></td>
        <td><p>A scalar that specifies which output port will receive data.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RefSwitch&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_false: If <code>pred</code> is false, data will be forwarded to this output.
              output_true: If <code>pred</code> is true, data will be forwarded to this output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RefSwitch_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If <code>pred</code> is true, the <code>data</code> input is forwarded to <code>output_true</code>. Otherwise,
              the data goes to <code>output_false</code>.</p>
<pre><code>          See also &lt;code&gt;Switch&lt;/code&gt; and &lt;code&gt;Merge&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RegexFullMatch_" data-uid="TensorFlow.TFGraph.RegexFullMatch*"></a>
  <h4 id="TensorFlow_TFGraph_RegexFullMatch_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RegexFullMatch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">RegexFullMatch(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Check if the input matches the regex pattern.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RegexFullMatch (TensorFlow.TFOutput input, TensorFlow.TFOutput pattern, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A string tensor of the text to be processed.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">pattern</span></td>
        <td><p>A scalar string tensor containing the regular expression to match the input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RegexFullMatch&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A bool tensor with the same shape as <code>input</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RegexFullMatch_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The input is a string tensor of any shape. The pattern is a scalar
              string tensor which is applied to every element of the input tensor.
              The boolean values (True or False) of the output tensor indicate
              if the input matches the regex pattern provided.</p>
<pre><code>          The pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RegexReplace_" data-uid="TensorFlow.TFGraph.RegexReplace*"></a>
  <h4 id="TensorFlow_TFGraph_RegexReplace_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.RegexReplace(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">RegexReplace(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Replaces the match of pattern in input with rewrite.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RegexReplace (TensorFlow.TFOutput input, TensorFlow.TFOutput pattern, TensorFlow.TFOutput rewrite, Nullable&lt;bool&gt; replace_global = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The text to be processed.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">pattern</span></td>
        <td><p>The regular expression to match the input.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rewrite</span></td>
        <td><p>The rewrite to be applied to the matched expresion.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">replace_global</span></td>
        <td><p>Optional argument
              If True, the replacement is global, otherwise the replacement
              is done only on the first match.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RegexReplace&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The text after applying pattern and rewrite.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RegexReplace_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>It follows the re2 syntax (<a href="https://github.com/google/re2/wiki/Syntax">https://github.com/google/re2/wiki/Syntax</a>)</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Relu_" data-uid="TensorFlow.TFGraph.Relu*"></a>
  <h4 id="TensorFlow_TFGraph_Relu_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Relu(TensorFlow.TFOutput,System.String)">Relu(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes rectified linear: <code>max(features, 0)</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Relu (TensorFlow.TFOutput features, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Relu&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Relu6_" data-uid="TensorFlow.TFGraph.Relu6*"></a>
  <h4 id="TensorFlow_TFGraph_Relu6_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Relu6(TensorFlow.TFOutput,System.String)">Relu6(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes rectified linear 6: <code>min(max(features, 0), 6)</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Relu6 (TensorFlow.TFOutput features, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Relu6&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Relu6Grad_" data-uid="TensorFlow.TFGraph.Relu6Grad*"></a>
  <h4 id="TensorFlow_TFGraph_Relu6Grad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Relu6Grad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Relu6Grad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes rectified linear 6 gradients for a Relu6 operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Relu6Grad (TensorFlow.TFOutput gradients, TensorFlow.TFOutput features, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradients</span></td>
        <td><p>The backpropagated gradients to the corresponding Relu6 operation.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>The features passed as input to the corresponding Relu6 operation, or
              its output; using either one produces the same result.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Relu6Grad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The gradients:
              <code>gradients * (features &gt; 0) * (features &lt; 6)</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ReluGrad_" data-uid="TensorFlow.TFGraph.ReluGrad*"></a>
  <h4 id="TensorFlow_TFGraph_ReluGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ReluGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes rectified linear gradients for a Relu operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReluGrad (TensorFlow.TFOutput gradients, TensorFlow.TFOutput features, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradients</span></td>
        <td><p>The backpropagated gradients to the corresponding Relu operation.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>The features passed as input to the corresponding Relu operation, OR
              the outputs of that operation (both work equivalently).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReluGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p><code>gradients * (features &gt; 0)</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_RemoteFusedGraphExecute_" data-uid="TensorFlow.TFGraph.RemoteFusedGraphExecute*"></a>
  <h4 id="TensorFlow_TFGraph_RemoteFusedGraphExecute_TensorFlow_TFOutput___TensorFlow_TFDataType___System_String_System_String_" data-uid="TensorFlow.TFGraph.RemoteFusedGraphExecute(TensorFlow.TFOutput[],TensorFlow.TFDataType[],System.String,System.String)">RemoteFusedGraphExecute(TFOutput[], TFDataType[], String, String)</h4>
  <div class="markdown level1 summary"><p>Execute a sub graph on a remote processor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] RemoteFusedGraphExecute (TensorFlow.TFOutput[] inputs, TensorFlow.TFDataType[] Toutputs, string serialized_remote_fused_graph_execute_info, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>Arbitrary number of tensors with arbitrary data types</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">Toutputs</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">serialized_remote_fused_graph_execute_info</span></td>
        <td><p>Serialized protocol buffer
              of RemoteFusedGraphExecuteInfo which contains graph specifications.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RemoteFusedGraphExecute&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>Arbitrary number of tensors with arbitrary data types
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RemoteFusedGraphExecute_TensorFlow_TFOutput___TensorFlow_TFDataType___System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The graph specifications(such as graph itself, input tensors and output names)
              are stored as a serialized protocol buffer of RemoteFusedGraphExecuteInfo
              as serialized_remote_fused_graph_execute_info.
              The specifications will be passed to a dedicated registered
              remote fused graph executor.  The executor will send the graph specifications
              to a remote processor and execute that graph.  The execution results
              will be passed to consumer nodes as outputs of this node.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_RepeatDataset_" data-uid="TensorFlow.TFGraph.RepeatDataset*"></a>
  <h4 id="TensorFlow_TFGraph_RepeatDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.RepeatDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">RepeatDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that emits the outputs of <code>input_dataset</code><code>count</code> times.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RepeatDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput count, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">count</span></td>
        <td><p>A scalar representing the number of times that <code>input_dataset</code> should
              be repeated. A value of <code>-1</code> indicates that it should be repeated infinitely.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RepeatDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_RequantizationRange_" data-uid="TensorFlow.TFGraph.RequantizationRange*"></a>
  <h4 id="TensorFlow_TFGraph_RequantizationRange_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RequantizationRange(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">RequantizationRange(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Given a quantized tensor described by (input, input_min, input_max), outputs a</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RequantizationRange (TensorFlow.TFOutput input, TensorFlow.TFOutput input_min, TensorFlow.TFOutput input_max, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_min</span></td>
        <td><p>The float value that the minimum quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_max</span></td>
        <td><p>The float value that the maximum quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RequantizationRange&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_min: The computed min output.
              output_max: the computed max output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RequantizationRange_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>range that covers the actual values present in that tensor.  This op is
              typically used to produce the requested_output_min and requested_output_max for
              Requantize.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Requantize_" data-uid="TensorFlow.TFGraph.Requantize*"></a>
  <h4 id="TensorFlow_TFGraph_Requantize_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.Requantize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">Requantize(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Convert the quantized &#39;input&#39; tensor into a lower-precision &#39;output&#39;, using the</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; Requantize (TensorFlow.TFOutput input, TensorFlow.TFOutput input_min, TensorFlow.TFOutput input_max, TensorFlow.TFOutput requested_output_min, TensorFlow.TFOutput requested_output_max, TensorFlow.TFDataType out_type, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_min</span></td>
        <td><p>The float value that the minimum quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_max</span></td>
        <td><p>The float value that the maximum quantized input value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">requested_output_min</span></td>
        <td><p>The float value that the minimum quantized output value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">requested_output_max</span></td>
        <td><p>The float value that the maximum quantized output value represents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">out_type</span></td>
        <td><p>The type of the output. Should be a lower bit depth than Tinput.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Requantize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output:
              output_min: The requested_output_min value is copied into this output.
              output_max: The requested_output_max value is copied into this output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Requantize_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>output range specified with &#39;requested_output_min&#39; and &#39;requested_output_max&#39;.</p>
<pre><code>          [input_min, input_max] are scalar floats that specify the range for the float
          interpretation of the &#39;input&#39; data. For example, if input_min is -1.0f and
          input_max is 1.0f, and we are dealing with quint16 quantized data, then a 0
          value in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Reshape_" data-uid="TensorFlow.TFGraph.Reshape*"></a>
  <h4 id="TensorFlow_TFGraph_Reshape_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Reshape(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Reshape(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Reshapes a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Reshape (TensorFlow.TFOutput tensor, TensorFlow.TFOutput shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>Defines the shape of the output tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Reshape&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Reshape_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given <code>tensor</code>, this operation returns a tensor that has the same values
              as <code>tensor</code> with shape <code>shape</code>.</p>
<pre><code>          If one component of &lt;code&gt;shape&lt;/code&gt; is the special value -1, the size of that dimension
          is computed so that the total size remains constant.  In particular, a &lt;code&gt;shape&lt;/code&gt;
          of &lt;code&gt;[-1]&lt;/code&gt; flattens into 1-D.  At most one component of &lt;code&gt;shape&lt;/code&gt; can be -1.

          If &lt;code&gt;shape&lt;/code&gt; is 1-D or higher, then the operation returns a tensor with shape
          &lt;code&gt;shape&lt;/code&gt; filled with the values of &lt;code&gt;tensor&lt;/code&gt;. In this case, the number of elements
          implied by &lt;code&gt;shape&lt;/code&gt; must be the same as the number of elements in &lt;code&gt;tensor&lt;/code&gt;.

          For example:

           &lt;pre&gt;&lt;code&gt;
          # tensor &#39;t&#39; is [1, 2, 3, 4, 5, 6, 7, 8, 9]
          # tensor &#39;t&#39; has shape [9]
          reshape(t, [3, 3]) ==&amp;gt; [[1, 2, 3],
          [4, 5, 6],
          [7, 8, 9]]

          # tensor &#39;t&#39; is [[[1, 1], [2, 2]],
          #                [[3, 3], [4, 4]]]
          # tensor &#39;t&#39; has shape [2, 2, 2]
          reshape(t, [2, 4]) ==&amp;gt; [[1, 1, 2, 2],
          [3, 3, 4, 4]]

          # tensor &#39;t&#39; is [[[1, 1, 1],
          #                 [2, 2, 2]],
          #                [[3, 3, 3],
          #                 [4, 4, 4]],
          #                [[5, 5, 5],
          #                 [6, 6, 6]]]
          # tensor &#39;t&#39; has shape [3, 2, 3]
          # pass &#39;[-1]&#39; to flatten &#39;t&#39;
          reshape(t, [-1]) ==&amp;gt; [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]

          # -1 can also be used to infer the shape

          # -1 is inferred to be 9:
          reshape(t, [2, -1]) ==&amp;gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],
          [4, 4, 4, 5, 5, 5, 6, 6, 6]]
          # -1 is inferred to be 2:
          reshape(t, [-1, 9]) ==&amp;gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],
          [4, 4, 4, 5, 5, 5, 6, 6, 6]]
          # -1 is inferred to be 3:
          reshape(t, [ 2, -1, 3]) ==&amp;gt; [[[1, 1, 1],
          [2, 2, 2],
          [3, 3, 3]],
          [[4, 4, 4],
          [5, 5, 5],
          [6, 6, 6]]]

          # tensor &#39;t&#39; is [7]
          # shape &lt;code&gt;[]&lt;/code&gt; reshapes to a scalar
          reshape(t, []) ==&amp;gt; 7
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResizeArea_" data-uid="TensorFlow.TFGraph.ResizeArea*"></a>
  <h4 id="TensorFlow_TFGraph_ResizeArea_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResizeArea(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResizeArea(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Resize <code>images</code> to <code>size</code> using area interpolation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ResizeArea (TensorFlow.TFOutput images, TensorFlow.TFOutput size, Nullable&lt;bool&gt; align_corners = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">images</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>= A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
              new size for the images.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">align_corners</span></td>
        <td><p>Optional argument
              If true, the centers of the 4 corner pixels of the input and output tensors are
              aligned, preserving the values at the corner pixels. Defaults to false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResizeArea&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape
              <code>[batch, new_height, new_width, channels]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResizeArea_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Input images can be of different types but output images are always float.</p>
<pre><code>          The range of pixel values for the output image might be slightly different
          from the range for the input image because of limited numerical precision.
          To guarantee an output range, for example &lt;code&gt;[0.0, 1.0]&lt;/code&gt;, apply
          &lt;code&gt;tf.clip_by_value&lt;/code&gt; to the output.

          Each output pixel is computed by first transforming the pixel&#39;s footprint into
          the input tensor and then averaging the pixels that intersect the footprint. An
          input pixel&#39;s contribution to the average is weighted by the fraction of its
          area that intersects the footprint.  This is the same as OpenCV&#39;s INTER_AREA.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResizeBicubic_" data-uid="TensorFlow.TFGraph.ResizeBicubic*"></a>
  <h4 id="TensorFlow_TFGraph_ResizeBicubic_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResizeBicubic(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResizeBicubic(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Resize <code>images</code> to <code>size</code> using bicubic interpolation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ResizeBicubic (TensorFlow.TFOutput images, TensorFlow.TFOutput size, Nullable&lt;bool&gt; align_corners = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">images</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>= A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
              new size for the images.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">align_corners</span></td>
        <td><p>Optional argument
              If true, the centers of the 4 corner pixels of the input and output tensors are
              aligned, preserving the values at the corner pixels. Defaults to false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResizeBicubic&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape
              <code>[batch, new_height, new_width, channels]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResizeBicubic_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Input images can be of different types but output images are always float.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResizeBicubicGrad_" data-uid="TensorFlow.TFGraph.ResizeBicubicGrad*"></a>
  <h4 id="TensorFlow_TFGraph_ResizeBicubicGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResizeBicubicGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResizeBicubicGrad(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradient of bicubic interpolation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ResizeBicubicGrad (TensorFlow.TFOutput grads, TensorFlow.TFOutput original_image, Nullable&lt;bool&gt; align_corners = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grads</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">original_image</span></td>
        <td><p>4-D with shape <code>[batch, orig_height, orig_width, channels]</code>,
              The image tensor that was resized.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">align_corners</span></td>
        <td><p>Optional argument
              If true, the centers of the 4 corner pixels of the input and grad tensors are
              aligned. Defaults to false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResizeBicubicGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape <code>[batch, orig_height, orig_width, channels]</code>.
              Gradients with respect to the input image. Input image must have been
              float or double.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ResizeBilinear_" data-uid="TensorFlow.TFGraph.ResizeBilinear*"></a>
  <h4 id="TensorFlow_TFGraph_ResizeBilinear_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResizeBilinear(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResizeBilinear(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Resize <code>images</code> to <code>size</code> using bilinear interpolation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ResizeBilinear (TensorFlow.TFOutput images, TensorFlow.TFOutput size, Nullable&lt;bool&gt; align_corners = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">images</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>= A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
              new size for the images.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">align_corners</span></td>
        <td><p>Optional argument
              If true, the centers of the 4 corner pixels of the input and output tensors are
              aligned, preserving the values at the corner pixels. Defaults to false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResizeBilinear&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape
              <code>[batch, new_height, new_width, channels]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResizeBilinear_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Input images can be of different types but output images are always float.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResizeBilinearGrad_" data-uid="TensorFlow.TFGraph.ResizeBilinearGrad*"></a>
  <h4 id="TensorFlow_TFGraph_ResizeBilinearGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResizeBilinearGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResizeBilinearGrad(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradient of bilinear interpolation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ResizeBilinearGrad (TensorFlow.TFOutput grads, TensorFlow.TFOutput original_image, Nullable&lt;bool&gt; align_corners = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grads</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">original_image</span></td>
        <td><p>4-D with shape <code>[batch, orig_height, orig_width, channels]</code>,
              The image tensor that was resized.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">align_corners</span></td>
        <td><p>Optional argument
              If true, the centers of the 4 corner pixels of the input and grad tensors are
              aligned. Defaults to false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResizeBilinearGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape <code>[batch, orig_height, orig_width, channels]</code>.
              Gradients with respect to the input image. Input image must have been
              float or double.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ResizeNearestNeighbor_" data-uid="TensorFlow.TFGraph.ResizeNearestNeighbor*"></a>
  <h4 id="TensorFlow_TFGraph_ResizeNearestNeighbor_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResizeNearestNeighbor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResizeNearestNeighbor(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Resize <code>images</code> to <code>size</code> using nearest neighbor interpolation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ResizeNearestNeighbor (TensorFlow.TFOutput images, TensorFlow.TFOutput size, Nullable&lt;bool&gt; align_corners = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">images</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>= A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
              new size for the images.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">align_corners</span></td>
        <td><p>Optional argument
              If true, the centers of the 4 corner pixels of the input and output tensors are
              aligned, preserving the values at the corner pixels. Defaults to false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResizeNearestNeighbor&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape
              <code>[batch, new_height, new_width, channels]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ResizeNearestNeighborGrad_" data-uid="TensorFlow.TFGraph.ResizeNearestNeighborGrad*"></a>
  <h4 id="TensorFlow_TFGraph_ResizeNearestNeighborGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResizeNearestNeighborGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResizeNearestNeighborGrad(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradient of nearest neighbor interpolation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ResizeNearestNeighborGrad (TensorFlow.TFOutput grads, TensorFlow.TFOutput size, Nullable&lt;bool&gt; align_corners = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grads</span></td>
        <td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>= A 1-D int32 Tensor of 2 elements: <code>orig_height, orig_width</code>. The
              original input size.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">align_corners</span></td>
        <td><p>Optional argument
              If true, the centers of the 4 corner pixels of the input and grad tensors are
              aligned. Defaults to false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResizeNearestNeighborGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>4-D with shape <code>[batch, orig_height, orig_width, channels]</code>. Gradients
              with respect to the input image.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyAdadelta_" data-uid="TensorFlow.TFGraph.ResourceApplyAdadelta*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyAdadelta_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the adadelta scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyAdadelta (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput accum_update, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum_update</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rho</span></td>
        <td><p>Decay factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Constant factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, updating of the var, accum and update_accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyAdadelta&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceApplyAdadelta_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>accum = rho() * accum + (1 - rho()) * grad.square();
              update = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;
              update_accum = rho() * update_accum + (1 - rho()) * update.square();
              var -= update;</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyAdagrad_" data-uid="TensorFlow.TFGraph.ResourceApplyAdagrad*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">ResourceApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the adagrad scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, Nullable&lt;bool&gt; update_slots = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">update_slots</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyAdagrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceApplyAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>accum += grad * grad
              var -= lr * grad * (1 / sqrt(accum))</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyAdagradDA_" data-uid="TensorFlow.TFGraph.ResourceApplyAdagradDA*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyAdagradDA_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the proximal adagrad scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyAdagradDA (TensorFlow.TFOutput var, TensorFlow.TFOutput gradient_accumulator, TensorFlow.TFOutput gradient_squared_accumulator, TensorFlow.TFOutput grad, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput global_step, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_accumulator</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_squared_accumulator</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">global_step</span></td>
        <td><p>Training step number. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyAdagradDA&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyAdam_" data-uid="TensorFlow.TFGraph.ResourceApplyAdam*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyAdam_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyAdam(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">ResourceApplyAdam(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the Adam algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyAdam (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput v, TensorFlow.TFOutput beta1_power, TensorFlow.TFOutput beta2_power, TensorFlow.TFOutput lr, TensorFlow.TFOutput beta1, TensorFlow.TFOutput beta2, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, Nullable&lt;bool&gt; use_nesterov = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">m</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">v</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta1_power</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta2_power</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta1</span></td>
        <td><p>Momentum factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta2</span></td>
        <td><p>Momentum factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Ridge term. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var, m, and v tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_nesterov</span></td>
        <td><p>Optional argument
              If <code>True</code>, uses the nesterov update.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyAdam&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceApplyAdam_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>$$lr_t := \text{learning_rate} * \sqrt{1 - beta_2^t} / (1 - beta_1^t)$$
              $$m_t := beta_1 * m_{t-1} + (1 - beta_1) * g$$
              $$v_t := beta_2 * v_{t-1} + (1 - beta_2) * g * g$$
              $$variable := variable - lr_t * m_t / (\sqrt{v_t} + \epsilon)$$</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyAdaMax_" data-uid="TensorFlow.TFGraph.ResourceApplyAdaMax*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyAdaMax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyAdaMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceApplyAdaMax(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the AdaMax algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyAdaMax (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput v, TensorFlow.TFOutput beta1_power, TensorFlow.TFOutput lr, TensorFlow.TFOutput beta1, TensorFlow.TFOutput beta2, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">m</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">v</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta1_power</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta1</span></td>
        <td><p>Momentum factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta2</span></td>
        <td><p>Momentum factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Ridge term. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var, m, and v tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyAdaMax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceApplyAdaMax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>m_t &lt;- beta1 * m_{t-1} + (1 - beta1) * g
              v_t &lt;- max(beta2 * v_{t-1}, abs(g))
              variable &lt;- variable - learning_rate / (1 - beta1^t) * m_t / (v_t + epsilon)</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyAddSign_" data-uid="TensorFlow.TFGraph.ResourceApplyAddSign*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyAddSign_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyAddSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceApplyAddSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the AddSign update.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyAddSign (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput lr, TensorFlow.TFOutput alpha, TensorFlow.TFOutput sign_decay, TensorFlow.TFOutput beta, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">m</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">alpha</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sign_decay</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and m tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyAddSign&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceApplyAddSign_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>m_t &lt;- beta1 * m_{t-1} + (1 - beta1) * g
              update &lt;- (alpha + sign_decay * sign(g) *sign(m)) * g
              variable &lt;- variable - lr_t * update</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyCenteredRMSProp_" data-uid="TensorFlow.TFGraph.ResourceApplyCenteredRMSProp*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyCenteredRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the centered RMSProp algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyCenteredRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput mg, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mg</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ms</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mom</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rho</span></td>
        <td><p>Decay rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momentum</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Ridge term. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var, mg, ms, and mom tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyCenteredRMSProp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceApplyCenteredRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The centered RMSProp algorithm uses an estimate of the centered second moment
              (i.e., the variance) for normalization, as opposed to regular RMSProp, which
              uses the (uncentered) second moment. This often helps with training, but is
              slightly more expensive in terms of computation and memory.</p>
<pre><code>          Note that in dense implementation of this algorithm, mg, ms, and mom will
          update even if the grad is zero, but in this sparse implementation, mg, ms,
          and mom will not update in iterations during which the grad is zero.

          mean_square = decay * mean_square + (1-decay) * gradient ** 2
          mean_grad = decay * mean_grad + (1-decay) * gradient

          Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)

          mg &amp;lt;- rho * mg_{t-1} + (1-rho) * grad
          ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
          mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)
          var &amp;lt;- var - mom
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyFtrl_" data-uid="TensorFlow.TFGraph.ResourceApplyFtrl*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyFtrl_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the Ftrl-proximal scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyFtrl (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput lr_power, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">linear</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regulariation. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regulariation. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr_power</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyFtrl&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceApplyFtrl_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>accum_new = accum + grad * grad
              linear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
              accum = accum_new</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyFtrlV2_" data-uid="TensorFlow.TFGraph.ResourceApplyFtrlV2*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyFtrlV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the Ftrl-proximal scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyFtrlV2 (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput l2_shrinkage, TensorFlow.TFOutput lr_power, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">linear</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regulariation. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 shrinkage regulariation. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2_shrinkage</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr_power</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyFtrlV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceApplyFtrlV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>grad_with_shrinkage = grad + 2 * l2_shrinkage * var
              accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
              linear += grad_with_shrinkage +
              (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
              accum = accum_new</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyGradientDescent_" data-uid="TensorFlow.TFGraph.ResourceApplyGradientDescent*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyGradientDescent_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceApplyGradientDescent(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; by subtracting &#39;alpha&#39; * &#39;delta&#39; from it.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyGradientDescent (TensorFlow.TFOutput var, TensorFlow.TFOutput alpha, TensorFlow.TFOutput delta, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">alpha</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">delta</span></td>
        <td><p>The change.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyGradientDescent&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyMomentum_" data-uid="TensorFlow.TFGraph.ResourceApplyMomentum*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyMomentum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">ResourceApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the momentum scheme. Set use_nesterov = True if you</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyMomentum (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, TensorFlow.TFOutput momentum, Nullable&lt;bool&gt; use_locking = null, Nullable&lt;bool&gt; use_nesterov = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momentum</span></td>
        <td><p>Momentum. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_nesterov</span></td>
        <td><p>Optional argument
              If <code>True</code>, the tensor passed to compute grad will be
              var - lr * momentum * accum, so in the end, the var you get is actually
              var - lr * momentum * accum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyMomentum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceApplyMomentum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>want to use Nesterov momentum.</p>
<pre><code>          accum = accum * momentum + grad
          var -= lr * accum
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyPowerSign_" data-uid="TensorFlow.TFGraph.ResourceApplyPowerSign*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyPowerSign_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyPowerSign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceApplyPowerSign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the AddSign update.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyPowerSign (TensorFlow.TFOutput var, TensorFlow.TFOutput m, TensorFlow.TFOutput lr, TensorFlow.TFOutput logbase, TensorFlow.TFOutput sign_decay, TensorFlow.TFOutput beta, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">m</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">logbase</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sign_decay</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">beta</span></td>
        <td><p>Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and m tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyPowerSign&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceApplyPowerSign_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>m_t &lt;- beta1 * m_{t-1} + (1 - beta1) * g
              update &lt;- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g
              variable &lt;- variable - lr_t * update</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyProximalAdagrad_" data-uid="TensorFlow.TFGraph.ResourceApplyProximalAdagrad*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyProximalAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;<em>var&#39; and &#39;</em>accum&#39; according to FOBOS with Adagrad learning rate.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyProximalAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyProximalAdagrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceApplyProximalAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>accum += grad * grad
              prox_v = var - lr * grad * (1 / sqrt(accum))
              var = sign(prox_v)/(1+lr<em>l2) * max{|prox_v|-lr</em>l1,0}</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyProximalGradientDescent_" data-uid="TensorFlow.TFGraph.ResourceApplyProximalGradientDescent*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyProximalGradientDescent_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; as FOBOS algorithm with fixed learning rate.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyProximalGradientDescent (TensorFlow.TFOutput var, TensorFlow.TFOutput alpha, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput delta, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">alpha</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">delta</span></td>
        <td><p>The change.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyProximalGradientDescent&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceApplyProximalGradientDescent_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>prox_v = var - alpha * delta
              var = sign(prox_v)/(1+alpha<em>l2) * max{|prox_v|-alpha</em>l1,0}</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceApplyRMSProp_" data-uid="TensorFlow.TFGraph.ResourceApplyRMSProp*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceApplyRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the RMSProp algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceApplyRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ms</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mom</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rho</span></td>
        <td><p>Decay rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momentum</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Ridge term. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var, ms, and mom tensors is protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceApplyRMSProp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceApplyRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that in dense implementation of this algorithm, ms and mom will
              update even if the grad is zero, but in this sparse implementation, ms
              and mom will not update in iterations during which the grad is zero.</p>
<pre><code>          mean_square = decay * mean_square + (1-decay) * gradient ** 2
          Delta = learning_rate * gradient / sqrt(mean_square + epsilon)

          ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
          mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
          var &amp;lt;- var - mom
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceCountUpTo_" data-uid="TensorFlow.TFGraph.ResourceCountUpTo*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceCountUpTo_TensorFlow_TFOutput_System_Int64_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.ResourceCountUpTo(TensorFlow.TFOutput,System.Int64,TensorFlow.TFDataType,System.String)">ResourceCountUpTo(TFOutput, Int64, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Increments variable pointed to by &#39;resource&#39; until it reaches &#39;limit&#39;.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ResourceCountUpTo (TensorFlow.TFOutput resource, long limit, TensorFlow.TFDataType T, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>Should be from a scalar <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">limit</span></td>
        <td><p>If incrementing ref would bring it above limit, instead generates an
              &#39;OutOfRange&#39; error.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">T</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceCountUpTo&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A copy of the input before increment. If nothing else modifies the
              input, the values produced will all be distinct.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ResourceGather_" data-uid="TensorFlow.TFGraph.ResourceGather*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceGather_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceGather(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Boolean},System.String)">ResourceGather(TFOutput, TFOutput, TFDataType, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Gather slices from the variable pointed to by <code>resource</code> according to <code>indices</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ResourceGather (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFDataType dtype, Nullable&lt;bool&gt; validate_indices = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">validate_indices</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceGather&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceGather_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>indices</code> must be an integer tensor of any dimension (usually 0-D or 1-D).
              Produces an output tensor with shape <code>indices.shape + params.shape[1:]</code> where:</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          # Scalar indices
          output[:, ..., :] = params[indices, :, ... :]

          # Vector indices
          output[i, :, ..., :] = params[indices[i], :, ... :]

          # Higher rank indices
          output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceScatterAdd_" data-uid="TensorFlow.TFGraph.ResourceScatterAdd*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceScatterAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ResourceScatterAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ResourceScatterAdd(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Adds sparse updates to the variable referenced by <code>resource</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceScatterAdd (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of updated values to add to <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceScatterAdd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceScatterAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes</p>
<pre><code>          # Scalar indices
          ref[indices, ...] += updates[...]

          # Vector indices (for each i)
          ref[indices[i], ...] += updates[i, ...]

          # High rank indices (for each i, ..., j)
          ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]

          Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference
          the same location, their contributions add.

          Requires &lt;code&gt;updates.shape = indices.shape + ref.shape[1:]&lt;/code&gt; or &lt;code&gt;updates.shape = []&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&#39;https://www.tensorflow.org/images/ScatterAdd.png&#39; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceScatterDiv_" data-uid="TensorFlow.TFGraph.ResourceScatterDiv*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceScatterDiv_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ResourceScatterDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ResourceScatterDiv(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Divides sparse updates into the variable referenced by <code>resource</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceScatterDiv (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of updated values to add to <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceScatterDiv&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceScatterDiv_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes</p>
<pre><code>          # Scalar indices
          ref[indices, ...] /= updates[...]

          # Vector indices (for each i)
          ref[indices[i], ...] /= updates[i, ...]

          # High rank indices (for each i, ..., j)
          ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]

          Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference
          the same location, their contributions multiply.

          Requires &lt;code&gt;updates.shape = indices.shape + ref.shape[1:]&lt;/code&gt; or &lt;code&gt;updates.shape = []&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&#39;https://www.tensorflow.org/images/ScatterAdd.png&#39; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceScatterMax_" data-uid="TensorFlow.TFGraph.ResourceScatterMax*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceScatterMax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ResourceScatterMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ResourceScatterMax(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Reduces sparse updates into the variable referenced by <code>resource</code> using the <code>max</code> operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceScatterMax (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of updated values to add to <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceScatterMax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceScatterMax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes</p>
<pre><code>          # Scalar indices
          ref[indices, ...] = max(ref[indices, ...], updates[...])

          # Vector indices (for each i)
          ref[indices[i], ...] = max(ref[indices[i], ...], updates[i, ...])

          # High rank indices (for each i, ..., j)
          ref[indices[i, ..., j], ...] = max(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])

          Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference
          the same location, their contributions are combined.

          Requires &lt;code&gt;updates.shape = indices.shape + ref.shape[1:]&lt;/code&gt; or &lt;code&gt;updates.shape = []&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&#39;https://www.tensorflow.org/images/ScatterAdd.png&#39; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceScatterMin_" data-uid="TensorFlow.TFGraph.ResourceScatterMin*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceScatterMin_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ResourceScatterMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ResourceScatterMin(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Reduces sparse updates into the variable referenced by <code>resource</code> using the <code>min</code> operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceScatterMin (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of updated values to add to <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceScatterMin&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceScatterMin_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes</p>
<pre><code>          # Scalar indices
          ref[indices, ...] = min(ref[indices, ...], updates[...])

          # Vector indices (for each i)
          ref[indices[i], ...] = min(ref[indices[i], ...], updates[i, ...])

          # High rank indices (for each i, ..., j)
          ref[indices[i, ..., j], ...] = min(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])

          Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference
          the same location, their contributions are combined.

          Requires &lt;code&gt;updates.shape = indices.shape + ref.shape[1:]&lt;/code&gt; or &lt;code&gt;updates.shape = []&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&#39;https://www.tensorflow.org/images/ScatterAdd.png&#39; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceScatterMul_" data-uid="TensorFlow.TFGraph.ResourceScatterMul*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceScatterMul_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ResourceScatterMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ResourceScatterMul(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Multiplies sparse updates into the variable referenced by <code>resource</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceScatterMul (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of updated values to add to <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceScatterMul&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceScatterMul_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes</p>
<pre><code>          # Scalar indices
          ref[indices, ...] *= updates[...]

          # Vector indices (for each i)
          ref[indices[i], ...] *= updates[i, ...]

          # High rank indices (for each i, ..., j)
          ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]

          Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference
          the same location, their contributions multiply.

          Requires &lt;code&gt;updates.shape = indices.shape + ref.shape[1:]&lt;/code&gt; or &lt;code&gt;updates.shape = []&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&#39;https://www.tensorflow.org/images/ScatterAdd.png&#39; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceScatterNdAdd_" data-uid="TensorFlow.TFGraph.ResourceScatterNdAdd*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceScatterNdAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceScatterNdAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Adds sparse <code>updates</code> to individual values or slices within a given</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceScatterNdAdd (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>A resource handle. Must be from a VarHandleOp.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A Tensor. Must be one of the following types: int32, int64.
              A tensor of indices into ref.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A Tensor. Must have the same type as ref. A tensor of
              values to add to ref.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              An optional bool. Defaults to True. If True, the assignment will
              be protected by a lock; otherwise the behavior is undefined,
              but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceScatterNdAdd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceScatterNdAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>variable according to <code>indices</code>.</p>
<pre><code>          &lt;code&gt;ref&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; with rank &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q&lt;/code&gt;.

          &lt;code&gt;indices&lt;/code&gt; must be integer tensor, containing indices into &lt;code&gt;ref&lt;/code&gt;.
          It must be shape &lt;code&gt;[d_0, ..., d_{Q-2}, K]&lt;/code&gt; where &lt;code&gt;0 &amp;lt; K &amp;lt;= P&lt;/code&gt;.

          The innermost dimension of &lt;code&gt;indices&lt;/code&gt; (with length &lt;code&gt;K&lt;/code&gt;) corresponds to
          indices into elements (if &lt;code&gt;K = P&lt;/code&gt;) or slices (if &lt;code&gt;K &amp;lt; P&lt;/code&gt;) along the &lt;code&gt;K&lt;/code&gt;th
          dimension of &lt;code&gt;ref&lt;/code&gt;.

          &lt;code&gt;updates&lt;/code&gt; is &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q-1+P-K&lt;/code&gt; with shape:

           &lt;pre&gt;&lt;code&gt;
          [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].
           &lt;/code&gt;&lt;/pre&gt;

          For example, say we want to update 4 scattered elements to a rank-1 tensor to
          8 elements. In Python, that update would look like this:

           &lt;pre&gt;&lt;code&gt;
          ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8], use_resource=True)
          indices = tf.constant([[4], [3], [1] ,[7]])
          updates = tf.constant([9, 10, 11, 12])
          update = tf.scatter_nd_add(ref, indices, updates)
          with tf.Session() as sess:
          print sess.run(update)
           &lt;/code&gt;&lt;/pre&gt;

          The resulting update to ref would look like this:

          [1, 12, 3, 14, 14, 6, 7, 20]

          See &lt;code&gt;tf.scatter_nd&lt;/code&gt; for more details about how to make updates to
          slices.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceScatterNdUpdate_" data-uid="TensorFlow.TFGraph.ResourceScatterNdUpdate*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceScatterNdUpdate_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceScatterNdUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Applies sparse <code>updates</code> to individual values or slices within a given</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceScatterNdUpdate (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>A resource handle. Must be from a VarHandleOp.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A Tensor. Must be one of the following types: int32, int64.
              A tensor of indices into ref.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A Tensor. Must have the same type as ref. A tensor of updated
              values to add to ref.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              An optional bool. Defaults to True. If True, the assignment will
              be protected by a lock; otherwise the behavior is undefined,
              but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceScatterNdUpdate&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceScatterNdUpdate_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>variable according to <code>indices</code>.</p>
<pre><code>          &lt;code&gt;ref&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; with rank &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q&lt;/code&gt;.

          &lt;code&gt;indices&lt;/code&gt; must be integer tensor, containing indices into &lt;code&gt;ref&lt;/code&gt;.
          It must be shape &lt;code&gt;[d_0, ..., d_{Q-2}, K]&lt;/code&gt; where &lt;code&gt;0 &amp;lt; K &amp;lt;= P&lt;/code&gt;.

          The innermost dimension of &lt;code&gt;indices&lt;/code&gt; (with length &lt;code&gt;K&lt;/code&gt;) corresponds to
          indices into elements (if &lt;code&gt;K = P&lt;/code&gt;) or slices (if &lt;code&gt;K &amp;lt; P&lt;/code&gt;) along the &lt;code&gt;K&lt;/code&gt;th
          dimension of &lt;code&gt;ref&lt;/code&gt;.

          &lt;code&gt;updates&lt;/code&gt; is &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q-1+P-K&lt;/code&gt; with shape:

           &lt;pre&gt;&lt;code&gt;
          [d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].
           &lt;/code&gt;&lt;/pre&gt;

          For example, say we want to update 4 scattered elements to a rank-1 tensor to
          8 elements. In Python, that update would look like this:

           &lt;pre&gt;&lt;code&gt;
          ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
          indices = tf.constant([[4], [3], [1] ,[7]])
          updates = tf.constant([9, 10, 11, 12])
          update = tf.scatter_nd_update(ref, indices, updates)
          with tf.Session() as sess:
          print sess.run(update)
           &lt;/code&gt;&lt;/pre&gt;

          The resulting update to ref would look like this:

          [1, 11, 3, 10, 9, 6, 7, 12]

          See &lt;code&gt;tf.scatter_nd&lt;/code&gt; for more details about how to make updates to
          slices.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceScatterSub_" data-uid="TensorFlow.TFGraph.ResourceScatterSub*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceScatterSub_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ResourceScatterSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ResourceScatterSub(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Subtracts sparse updates from the variable referenced by <code>resource</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceScatterSub (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of updated values to add to <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceScatterSub&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceScatterSub_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes</p>
<pre><code>          # Scalar indices
          ref[indices, ...] -= updates[...]

          # Vector indices (for each i)
          ref[indices[i], ...] -= updates[i, ...]

          # High rank indices (for each i, ..., j)
          ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]

          Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference
          the same location, their contributions add.

          Requires &lt;code&gt;updates.shape = indices.shape + ref.shape[1:]&lt;/code&gt; or &lt;code&gt;updates.shape = []&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&#39;https://www.tensorflow.org/images/ScatterAdd.png&#39; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceScatterUpdate_" data-uid="TensorFlow.TFGraph.ResourceScatterUpdate*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceScatterUpdate_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ResourceScatterUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ResourceScatterUpdate(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Assigns sparse updates to the variable referenced by <code>resource</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceScatterUpdate (TensorFlow.TFOutput resource, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of updated values to add to <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceScatterUpdate&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceScatterUpdate_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes</p>
<pre><code>          # Scalar indices
          ref[indices, ...] = updates[...]

          # Vector indices (for each i)
          ref[indices[i], ...] = updates[i, ...]

          # High rank indices (for each i, ..., j)
          ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceSparseApplyAdadelta_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyAdadelta*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceSparseApplyAdadelta_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceSparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>var: Should be from a Variable().</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceSparseApplyAdadelta (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput accum_update, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum_update</span></td>
        <td><p>: Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Learning rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rho</span></td>
        <td><p>Decay factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Constant factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceSparseApplyAdadelta&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ResourceSparseApplyAdagrad_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyAdagrad*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceSparseApplyAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">ResourceSparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update relevant entries in &#39;<em>var&#39; and &#39;</em>accum&#39; according to the adagrad scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceSparseApplyAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable&lt;bool&gt; use_locking = null, Nullable&lt;bool&gt; update_slots = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Learning rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">update_slots</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceSparseApplyAdagrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceSparseApplyAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>That is for rows we have grad for, we update var and accum as follows:
              accum += grad * grad
              var -= lr * grad * (1 / sqrt(accum))</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceSparseApplyAdagradDA_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyAdagradDA*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceSparseApplyAdagradDA_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceSparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update entries in &#39;<em>var&#39; and &#39;</em>accum&#39; according to the proximal adagrad scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceSparseApplyAdagradDA (TensorFlow.TFOutput var, TensorFlow.TFOutput gradient_accumulator, TensorFlow.TFOutput gradient_squared_accumulator, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput global_step, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_accumulator</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_squared_accumulator</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Learning rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">global_step</span></td>
        <td><p>Training step number. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceSparseApplyAdagradDA&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ResourceSparseApplyCenteredRMSProp_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyCenteredRMSProp*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceSparseApplyCenteredRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceSparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the centered RMSProp algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceSparseApplyCenteredRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput mg, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mg</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ms</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mom</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rho</span></td>
        <td><p>Decay rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momentum</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Ridge term. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var, ms and mom.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var, mg, ms, and mom tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceSparseApplyCenteredRMSProp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceSparseApplyCenteredRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The centered RMSProp algorithm uses an estimate of the centered second moment
              (i.e., the variance) for normalization, as opposed to regular RMSProp, which
              uses the (uncentered) second moment. This often helps with training, but is
              slightly more expensive in terms of computation and memory.</p>
<pre><code>          Note that in dense implementation of this algorithm, mg, ms, and mom will
          update even if the grad is zero, but in this sparse implementation, mg, ms,
          and mom will not update in iterations during which the grad is zero.

          mean_square = decay * mean_square + (1-decay) * gradient ** 2
          mean_grad = decay * mean_grad + (1-decay) * gradient
          Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)

          ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
          mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
          var &amp;lt;- var - mom
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceSparseApplyFtrl_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyFtrl*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceSparseApplyFtrl_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceSparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update relevant entries in &#39;*var&#39; according to the Ftrl-proximal scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceSparseApplyFtrl (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput lr_power, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">linear</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr_power</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceSparseApplyFtrl&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceSparseApplyFtrl_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>That is for rows we have grad for, we update var, accum and linear as follows:
              accum_new = accum + grad * grad
              linear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
              accum = accum_new</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceSparseApplyFtrlV2_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyFtrlV2*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceSparseApplyFtrlV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceSparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update relevant entries in &#39;*var&#39; according to the Ftrl-proximal scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceSparseApplyFtrlV2 (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput l2_shrinkage, TensorFlow.TFOutput lr_power, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">linear</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 shrinkage regulariation. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2_shrinkage</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr_power</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceSparseApplyFtrlV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceSparseApplyFtrlV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>That is for rows we have grad for, we update var, accum and linear as follows:
              grad_with_shrinkage = grad + 2 * l2_shrinkage * var
              accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
              linear += grad_with_shrinkage +
              (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
              accum = accum_new</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceSparseApplyMomentum_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyMomentum*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceSparseApplyMomentum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">ResourceSparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update relevant entries in &#39;<em>var&#39; and &#39;</em>accum&#39; according to the momentum scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceSparseApplyMomentum (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput momentum, Nullable&lt;bool&gt; use_locking = null, Nullable&lt;bool&gt; use_nesterov = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Learning rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momentum</span></td>
        <td><p>Momentum. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_nesterov</span></td>
        <td><p>Optional argument
              If <code>True</code>, the tensor passed to compute grad will be
              var - lr * momentum * accum, so in the end, the var you get is actually
              var - lr * momentum * accum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceSparseApplyMomentum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceSparseApplyMomentum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Set use_nesterov = True if you want to use Nesterov momentum.</p>
<pre><code>          That is for rows we have grad for, we update var and accum as follows:

          accum = accum * momentum + grad
          var -= lr * accum
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceSparseApplyProximalAdagrad_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyProximalAdagrad*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceSparseApplyProximalAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceSparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Sparse update entries in &#39;<em>var&#39; and &#39;</em>accum&#39; according to FOBOS algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceSparseApplyProximalAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Learning rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceSparseApplyProximalAdagrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceSparseApplyProximalAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>That is for rows we have grad for, we update var and accum as follows:
              accum += grad * grad
              prox_v = var
              prox_v -= lr * grad * (1 / sqrt(accum))
              var = sign(prox_v)/(1+lr<em>l2) * max{|prox_v|-lr</em>l1,0}</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceSparseApplyProximalGradientDescent_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyProximalGradientDescent*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceSparseApplyProximalGradientDescent_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceSparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Sparse update &#39;*var&#39; as FOBOS algorithm with fixed learning rate.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceSparseApplyProximalGradientDescent (TensorFlow.TFOutput var, TensorFlow.TFOutput alpha, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">alpha</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceSparseApplyProximalGradientDescent&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceSparseApplyProximalGradientDescent_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>That is for rows we have grad for, we update var as follows:
              prox_v = var - alpha * grad
              var = sign(prox_v)/(1+alpha<em>l2) * max{|prox_v|-alpha</em>l1,0}</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ResourceSparseApplyRMSProp_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyRMSProp*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceSparseApplyRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ResourceSparseApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ResourceSparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the RMSProp algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceSparseApplyRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ms</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mom</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rho</span></td>
        <td><p>Decay rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momentum</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Ridge term. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var, ms and mom.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var, ms, and mom tensors is protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ResourceSparseApplyRMSProp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ResourceSparseApplyRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that in dense implementation of this algorithm, ms and mom will
              update even if the grad is zero, but in this sparse implementation, ms
              and mom will not update in iterations during which the grad is zero.</p>
<pre><code>          mean_square = decay * mean_square + (1-decay) * gradient ** 2
          Delta = learning_rate * gradient / sqrt(mean_square + epsilon)

          ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad
          mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)
          var &amp;lt;- var - mom
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ResourceStridedSliceAssign_" data-uid="TensorFlow.TFGraph.ResourceStridedSliceAssign*"></a>
  <h4 id="TensorFlow_TFGraph_ResourceStridedSliceAssign_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.ResourceStridedSliceAssign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">ResourceStridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ResourceStridedSliceAssign (TensorFlow.TFOutput reference, TensorFlow.TFOutput begin, TensorFlow.TFOutput end, TensorFlow.TFOutput strides, TensorFlow.TFOutput value, Nullable&lt;long&gt; begin_mask = null, Nullable&lt;long&gt; end_mask = null, Nullable&lt;long&gt; ellipsis_mask = null, Nullable&lt;long&gt; new_axis_mask = null, Nullable&lt;long&gt; shrink_axis_mask = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">begin</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">end</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">strides</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">begin_mask</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">end_mask</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">ellipsis_mask</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">new_axis_mask</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">shrink_axis_mask</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Restore_" data-uid="TensorFlow.TFGraph.Restore*"></a>
  <h4 id="TensorFlow_TFGraph_Restore_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.Restore(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)">Restore(TFOutput, TFOutput, TFDataType, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Restores a tensor from checkpoint files.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Restore (TensorFlow.TFOutput file_pattern, TensorFlow.TFOutput tensor_name, TensorFlow.TFDataType dt, Nullable&lt;long&gt; preferred_shard = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">file_pattern</span></td>
        <td><p>Must have a single element. The pattern of the files from
              which we read the tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor_name</span></td>
        <td><p>Must have a single element. The name of the tensor to be
              restored.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dt</span></td>
        <td><p>The type of the tensor to be restored.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">preferred_shard</span></td>
        <td><p>Optional argument
              Index of file to open first if multiple files match
              <code>file_pattern</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Restore&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The restored tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Restore_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Reads a tensor stored in one or several files. If there are several files (for
              instance because a tensor was saved as slices), <code>file_pattern</code> may contain
              wildcard symbols (<code>*</code> and <code>?</code>) in the filename portion only, not in the
              directory portion.</p>
<pre><code>          If a &lt;code&gt;file_pattern&lt;/code&gt; matches several files, &lt;code&gt;preferred_shard&lt;/code&gt; can be used to hint
          in which file the requested tensor is likely to be found. This op will first
          open the file at index &lt;code&gt;preferred_shard&lt;/code&gt; in the list of matching files and try
          to restore tensors from that file.  Only if some tensors or tensor slices are
          not found in that first file, then the Op opens all the files. Setting
          &lt;code&gt;preferred_shard&lt;/code&gt; to match the value passed as the &lt;code&gt;shard&lt;/code&gt; input
          of a matching &lt;code&gt;Save&lt;/code&gt; Op may speed up Restore.  This attribute only affects
          performance, not correctness.  The default value -1 means files are processed in
          order.

          See also &lt;code&gt;RestoreSlice&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RestoreSlice_" data-uid="TensorFlow.TFGraph.RestoreSlice*"></a>
  <h4 id="TensorFlow_TFGraph_RestoreSlice_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.RestoreSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)">RestoreSlice(TFOutput, TFOutput, TFOutput, TFDataType, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Restores a tensor from checkpoint files.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RestoreSlice (TensorFlow.TFOutput file_pattern, TensorFlow.TFOutput tensor_name, TensorFlow.TFOutput shape_and_slice, TensorFlow.TFDataType dt, Nullable&lt;long&gt; preferred_shard = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">file_pattern</span></td>
        <td><p>Must have a single element. The pattern of the files from
              which we read the tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor_name</span></td>
        <td><p>Must have a single element. The name of the tensor to be
              restored.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape_and_slice</span></td>
        <td><p>Scalar. The shapes and slice specifications to use when
              restoring a tensors.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dt</span></td>
        <td><p>The type of the tensor to be restored.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">preferred_shard</span></td>
        <td><p>Optional argument
              Index of file to open first if multiple files match
              <code>file_pattern</code>. See the documentation for <code>Restore</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RestoreSlice&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The restored tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RestoreSlice_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This is like <code>Restore</code> except that restored tensor can be listed as filling
              only a slice of a larger tensor.  <code>shape_and_slice</code> specifies the shape of the
              larger tensor and the slice that the restored tensor covers.</p>
<pre><code>          The &lt;code&gt;shape_and_slice&lt;/code&gt; input has the same format as the
          elements of the &lt;code&gt;shapes_and_slices&lt;/code&gt; input of the &lt;code&gt;SaveSlices&lt;/code&gt; op.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RestoreV2_" data-uid="TensorFlow.TFGraph.RestoreV2*"></a>
  <h4 id="TensorFlow_TFGraph_RestoreV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_String_" data-uid="TensorFlow.TFGraph.RestoreV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],System.String)">RestoreV2(TFOutput, TFOutput, TFOutput, TFDataType[], String)</h4>
  <div class="markdown level1 summary"><p>Restores tensors from a V2 checkpoint.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] RestoreV2 (TensorFlow.TFOutput prefix, TensorFlow.TFOutput tensor_names, TensorFlow.TFOutput shape_and_slices, TensorFlow.TFDataType[] dtypes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">prefix</span></td>
        <td><p>Must have a single element.  The prefix of a V2 checkpoint.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor_names</span></td>
        <td><p>shape {N}.  The names of the tensors to be restored.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape_and_slices</span></td>
        <td><p>shape {N}.  The slice specs of the tensors to be restored.
              Empty strings indicate that they are non-partitioned tensors.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>shape {N}.  The list of expected dtype for the tensors.  Must match
              those stored in the checkpoint.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RestoreV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>shape {N}.  The restored tensors, whose shapes are read from the
              checkpoint directly.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RestoreV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>For backward compatibility with the V1 format, this Op currently allows
              restoring from a V1 checkpoint as well:</p>
<ul>
<li>This Op first attempts to find the V2 index file pointed to by &quot;prefix&quot;, and
if found proceed to read it as a V2 checkpoint;</li>
<li><p>Otherwise the V1 read path is invoked.
Relying on this behavior is not recommended, as the ability to fall back to read
V1 might be deprecated and eventually removed.</p>
<p>By default, restores the named tensors in full.  If the caller wishes to restore
specific slices of stored tensors, &quot;shape_and_slices&quot; should be non-empty
strings and correspondingly well-formed.</p>
<p>Callers must ensure all the named tensors are indeed stored in the checkpoint.</p>
</li>
</ul>
</div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingAdadeltaParameters_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParameters*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingAdadeltaParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingAdadeltaParameters(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingAdadeltaParameters (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingAdadeltaParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the Adadelta optimization algorithm.
              accumulators: Parameter accumulators updated by the Adadelta optimization algorithm.
              updates: Parameter updates updated by the Adadelta optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingAdadeltaParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the Adadelta optimization algorithm.
          accumulators: A tensor containing the embedding table accumulators to store with the
          parameters from embedding updates using the Adadelta optimization algorithm.
          updates: A tensor containing the embedding table updates to store with the
          parameters from embedding updates using the Adadelta optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the Adadelta optimization algorithm.
              accumulators: Parameter accumulators updated by the Adadelta optimization algorithm.
              updates: Parameter updates updated by the Adadelta optimization algorithm.
              gradient_accumulators: Parameter gradient_accumulators updated by the Adadelta optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the Adadelta optimization algorithm.
          accumulators: A tensor containing the embedding table accumulators to store with the
          parameters from embedding updates using the Adadelta optimization algorithm.
          updates: A tensor containing the embedding table updates to store with the
          parameters from embedding updates using the Adadelta optimization algorithm.
          gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the
          parameters from embedding updates using the Adadelta optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingAdagradParameters_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParameters*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingAdagradParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingAdagradParameters(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingAdagradParameters (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingAdagradParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the Adagrad optimization algorithm.
              accumulators: Parameter accumulators updated by the Adagrad optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingAdagradParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the Adagrad optimization algorithm.
          accumulators: A tensor containing the embedding table accumulators to store with the
          parameters from embedding updates using the Adagrad optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingAdagradParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingAdagradParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingAdagradParametersGradAccumDebug(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingAdagradParametersGradAccumDebug (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingAdagradParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the Adagrad optimization algorithm.
              accumulators: Parameter accumulators updated by the Adagrad optimization algorithm.
              gradient_accumulators: Parameter gradient_accumulators updated by the Adagrad optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingAdagradParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the Adagrad optimization algorithm.
          accumulators: A tensor containing the embedding table accumulators to store with the
          parameters from embedding updates using the Adagrad optimization algorithm.
          gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the
          parameters from embedding updates using the Adagrad optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingADAMParameters_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParameters*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingADAMParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingADAMParameters(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingADAMParameters (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingADAMParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the ADAM optimization algorithm.
              momenta: Parameter momenta updated by the ADAM optimization algorithm.
              velocities: Parameter velocities updated by the ADAM optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingADAMParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the ADAM optimization algorithm.
          momenta: A tensor containing the embedding table momenta to store with the
          parameters from embedding updates using the ADAM optimization algorithm.
          velocities: A tensor containing the embedding table velocities to store with the
          parameters from embedding updates using the ADAM optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingADAMParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingADAMParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingADAMParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingADAMParametersGradAccumDebug(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingADAMParametersGradAccumDebug (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingADAMParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the ADAM optimization algorithm.
              momenta: Parameter momenta updated by the ADAM optimization algorithm.
              velocities: Parameter velocities updated by the ADAM optimization algorithm.
              gradient_accumulators: Parameter gradient_accumulators updated by the ADAM optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingADAMParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the ADAM optimization algorithm.
          momenta: A tensor containing the embedding table momenta to store with the
          parameters from embedding updates using the ADAM optimization algorithm.
          velocities: A tensor containing the embedding table velocities to store with the
          parameters from embedding updates using the ADAM optimization algorithm.
          gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the
          parameters from embedding updates using the ADAM optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingCenteredRMSPropParameters_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingCenteredRMSPropParameters*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingCenteredRMSPropParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingCenteredRMSPropParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingCenteredRMSPropParameters(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingCenteredRMSPropParameters (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingCenteredRMSPropParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the centered RMSProp optimization algorithm.
              ms: Parameter ms updated by the centered RMSProp optimization algorithm.
              mom: Parameter mom updated by the centered RMSProp optimization algorithm.
              mg: Parameter mg updated by the centered RMSProp optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingCenteredRMSPropParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the centered RMSProp optimization algorithm.
          ms: A tensor containing the embedding table ms to store with the
          parameters from embedding updates using the centered RMSProp optimization algorithm.
          mom: A tensor containing the embedding table mom to store with the
          parameters from embedding updates using the centered RMSProp optimization algorithm.
          mg: A tensor containing the embedding table mg to store with the
          parameters from embedding updates using the centered RMSProp optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingFTRLParameters_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParameters*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingFTRLParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingFTRLParameters(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingFTRLParameters (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingFTRLParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the FTRL optimization algorithm.
              accumulators: Parameter accumulators updated by the FTRL optimization algorithm.
              linears: Parameter linears updated by the FTRL optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingFTRLParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the FTRL optimization algorithm.
          accumulators: A tensor containing the embedding table accumulators to store with the
          parameters from embedding updates using the FTRL optimization algorithm.
          linears: A tensor containing the embedding table linears to store with the
          parameters from embedding updates using the FTRL optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingFTRLParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingFTRLParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingFTRLParametersGradAccumDebug(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingFTRLParametersGradAccumDebug (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingFTRLParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the FTRL optimization algorithm.
              accumulators: Parameter accumulators updated by the FTRL optimization algorithm.
              linears: Parameter linears updated by the FTRL optimization algorithm.
              gradient_accumulators: Parameter gradient_accumulators updated by the FTRL optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingFTRLParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the FTRL optimization algorithm.
          accumulators: A tensor containing the embedding table accumulators to store with the
          parameters from embedding updates using the FTRL optimization algorithm.
          linears: A tensor containing the embedding table linears to store with the
          parameters from embedding updates using the FTRL optimization algorithm.
          gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the
          parameters from embedding updates using the FTRL optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingMDLAdagradLightParameters_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingMDLAdagradLightParameters*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingMDLAdagradLightParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingMDLAdagradLightParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingMDLAdagradLightParameters(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingMDLAdagradLightParameters (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingMDLAdagradLightParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the MDL Adagrad Light optimization algorithm.
              accumulators: Parameter accumulators updated by the MDL Adagrad Light optimization algorithm.
              weights: Parameter weights updated by the MDL Adagrad Light optimization algorithm.
              benefits: Parameter benefits updated by the MDL Adagrad Light optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingMDLAdagradLightParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the MDL Adagrad Light optimization algorithm.
          accumulators: A tensor containing the embedding table accumulators to store with the
          parameters from embedding updates using the MDL Adagrad Light optimization algorithm.
          weights: A tensor containing the embedding table weights to store with the
          parameters from embedding updates using the MDL Adagrad Light optimization algorithm.
          benefits: A tensor containing the embedding table benefits to store with the
          parameters from embedding updates using the MDL Adagrad Light optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingMomentumParameters_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParameters*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingMomentumParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingMomentumParameters(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingMomentumParameters (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingMomentumParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the Momentum optimization algorithm.
              momenta: Parameter momenta updated by the Momentum optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingMomentumParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the Momentum optimization algorithm.
          momenta: A tensor containing the embedding table momenta to store with the
          parameters from embedding updates using the Momentum optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingMomentumParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingMomentumParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingMomentumParametersGradAccumDebug(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingMomentumParametersGradAccumDebug (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingMomentumParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the Momentum optimization algorithm.
              momenta: Parameter momenta updated by the Momentum optimization algorithm.
              gradient_accumulators: Parameter gradient_accumulators updated by the Momentum optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingMomentumParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the Momentum optimization algorithm.
          momenta: A tensor containing the embedding table momenta to store with the
          parameters from embedding updates using the Momentum optimization algorithm.
          gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the
          parameters from embedding updates using the Momentum optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingProximalAdagradParameters_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParameters*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingProximalAdagradParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingProximalAdagradParameters(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingProximalAdagradParameters (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingProximalAdagradParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the proximal Adagrad optimization algorithm.
              accumulators: Parameter accumulators updated by the proximal Adagrad optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingProximalAdagradParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the proximal Adagrad optimization algorithm.
          accumulators: A tensor containing the embedding table accumulators to store with the
          parameters from embedding updates using the proximal Adagrad optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the proximal Adagrad optimization algorithm.
              accumulators: Parameter accumulators updated by the proximal Adagrad optimization algorithm.
              gradient_accumulators: Parameter gradient_accumulators updated by the proximal Adagrad optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the proximal Adagrad optimization algorithm.
          accumulators: A tensor containing the embedding table accumulators to store with the
          parameters from embedding updates using the proximal Adagrad optimization algorithm.
          gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the
          parameters from embedding updates using the proximal Adagrad optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingRMSPropParameters_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParameters*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingRMSPropParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingRMSPropParameters(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingRMSPropParameters (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingRMSPropParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the RMSProp optimization algorithm.
              ms: Parameter ms updated by the RMSProp optimization algorithm.
              mom: Parameter mom updated by the RMSProp optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingRMSPropParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the RMSProp optimization algorithm.
          ms: A tensor containing the embedding table ms to store with the
          parameters from embedding updates using the RMSProp optimization algorithm.
          mom: A tensor containing the embedding table mom to store with the
          parameters from embedding updates using the RMSProp optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              parameters: Parameter parameters updated by the RMSProp optimization algorithm.
              ms: Parameter ms updated by the RMSProp optimization algorithm.
              mom: Parameter mom updated by the RMSProp optimization algorithm.
              gradient_accumulators: Parameter gradient_accumulators updated by the RMSProp optimization algorithm.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the RMSProp optimization algorithm.
          ms: A tensor containing the embedding table ms to store with the
          parameters from embedding updates using the RMSProp optimization algorithm.
          mom: A tensor containing the embedding table mom to store with the
          parameters from embedding updates using the RMSProp optimization algorithm.
          gradient_accumulators: A tensor containing the embedding table gradient_accumulators to store with the
          parameters from embedding updates using the RMSProp optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RetrieveTPUEmbeddingStochasticGradientDescentParameters_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingStochasticGradientDescentParameters*"></a>
  <h4 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingStochasticGradientDescentParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String_" data-uid="TensorFlow.TFGraph.RetrieveTPUEmbeddingStochasticGradientDescentParameters(System.Int64,System.Int64,System.Nullable{System.Int64},System.String,System.String)">RetrieveTPUEmbeddingStochasticGradientDescentParameters(Int64, Int64, Nullable&lt;Int64&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Retrieve embedding parameters for a single table.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RetrieveTPUEmbeddingStochasticGradientDescentParameters (long num_shards, long shard_id, Nullable&lt;long&gt; table_id = null, string table_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">shard_id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">table_id</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">table_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RetrieveTPUEmbeddingStochasticGradientDescentParameters&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Parameter parameters updated by the stochastic gradient descent optimization algorithm.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RetrieveTPUEmbeddingStochasticGradientDescentParameters_System_Int64_System_Int64_System_Nullable_System_Int64__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An op that retrieves optimization parameters from embedding to host
              memory. Must be preceded by a ConfigureTPUEmbeddingHost op that sets up
              the correct embedding table configuration. For example, this op is
              used to retrieve updated parameters before saving a checkpoint.</p>
<pre><code>          parameters: A tensor containing the embedding table parameters to store with the
          parameters from embedding updates using the stochastic gradient descent optimization algorithm.
          table_name: Name of this table; must match a name in the
          TPUEmbeddingConfiguration proto (overrides table_id).
          num_shards: Number of shards into which the embedding tables are divided.
          shard_id: Identifier of shard for this operation.
          table_id: Index of this table in the EmbeddingLayerConfiguration proto
          (deprecated).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Reverse_" data-uid="TensorFlow.TFGraph.Reverse*"></a>
  <h4 id="TensorFlow_TFGraph_Reverse_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Reverse(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Reverse(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Reverses specific dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Reverse (TensorFlow.TFOutput tensor, TensorFlow.TFOutput dims, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>Up to 8-D.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dims</span></td>
        <td><p>1-D. The dimensions to reverse.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Reverse&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The same shape as <code>tensor</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Reverse_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a <code>tensor</code>, and a <code>bool</code> tensor <code>dims</code> representing the dimensions
              of <code>tensor</code>, this operation reverses each dimension i of <code>tensor</code> where
              <code>dims[i]</code> is <code>True</code>.</p>
<pre><code>          &lt;code&gt;tensor&lt;/code&gt; can have up to 8 dimensions. The number of dimensions
          of &lt;code&gt;tensor&lt;/code&gt; must equal the number of elements in &lt;code&gt;dims&lt;/code&gt;. In other words:

          &lt;code&gt;rank(tensor) = size(dims)&lt;/code&gt;

          For example:

           &lt;pre&gt;&lt;code&gt;
          # tensor &#39;t&#39; is [[[[ 0,  1,  2,  3],
          #                  [ 4,  5,  6,  7],
          #                  [ 8,  9, 10, 11]],
          #                 [[12, 13, 14, 15],
          #                  [16, 17, 18, 19],
          #                  [20, 21, 22, 23]]]]
          # tensor &#39;t&#39; shape is [1, 2, 3, 4]

          # &#39;dims&#39; is [False, False, False, True]
          reverse(t, dims) ==&amp;gt; [[[[ 3,  2,  1,  0],
          [ 7,  6,  5,  4],
          [ 11, 10, 9, 8]],
          [[15, 14, 13, 12],
          [19, 18, 17, 16],
          [23, 22, 21, 20]]]]

          # &#39;dims&#39; is [False, True, False, False]
          reverse(t, dims) ==&amp;gt; [[[[12, 13, 14, 15],
          [16, 17, 18, 19],
          [20, 21, 22, 23]
          [[ 0,  1,  2,  3],
          [ 4,  5,  6,  7],
          [ 8,  9, 10, 11]]]]

          # &#39;dims&#39; is [False, False, True, False]
          reverse(t, dims) ==&amp;gt; [[[[8, 9, 10, 11],
          [4, 5, 6, 7],
          [0, 1, 2, 3]]
          [[20, 21, 22, 23],
          [16, 17, 18, 19],
          [12, 13, 14, 15]]]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ReverseSequence_" data-uid="TensorFlow.TFGraph.ReverseSequence*"></a>
  <h4 id="TensorFlow_TFGraph_ReverseSequence_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.ReverseSequence(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.String)">ReverseSequence(TFOutput, TFOutput, Int64, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Reverses variable length slices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReverseSequence (TensorFlow.TFOutput input, TensorFlow.TFOutput seq_lengths, long seq_dim, Nullable&lt;long&gt; batch_dim = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The input to reverse.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">seq_lengths</span></td>
        <td><p>1-D with length <code>input.dims(batch_dim)</code> and
              <code>max(seq_lengths) &lt;= input.dims(seq_dim)</code></p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">seq_dim</span></td>
        <td><p>The dimension which is partially reversed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">batch_dim</span></td>
        <td><p>Optional argument
              The dimension along which reversal is performed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReverseSequence&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The partially reversed input. It has the same shape as <code>input</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReverseSequence_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op first slices <code>input</code> along the dimension <code>batch_dim</code>, and for each
              slice <code>i</code>, reverses the first <code>seq_lengths[i]</code> elements along
              the dimension <code>seq_dim</code>.</p>
<pre><code>          The elements of &lt;code&gt;seq_lengths&lt;/code&gt; must obey &lt;code&gt;seq_lengths[i] &amp;lt;= input.dims[seq_dim]&lt;/code&gt;,
          and &lt;code&gt;seq_lengths&lt;/code&gt; must be a vector of length &lt;code&gt;input.dims[batch_dim]&lt;/code&gt;.

          The output slice &lt;code&gt;i&lt;/code&gt; along dimension &lt;code&gt;batch_dim&lt;/code&gt; is then given by input
          slice &lt;code&gt;i&lt;/code&gt;, with the first &lt;code&gt;seq_lengths[i]&lt;/code&gt; slices along dimension
          &lt;code&gt;seq_dim&lt;/code&gt; reversed.

          For example:

           &lt;pre&gt;&lt;code&gt;
          # Given this:
          batch_dim = 0
          seq_dim = 1
          input.dims = (4, 8, ...)
          seq_lengths = [7, 2, 3, 5]

          # then slices of input are reversed on seq_dim, but only up to seq_lengths:
          output[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]
          output[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]
          output[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]
          output[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]

          # while entries past seq_lens are copied through:
          output[0, 7:, :, ...] = input[0, 7:, :, ...]
          output[1, 2:, :, ...] = input[1, 2:, :, ...]
          output[2, 3:, :, ...] = input[2, 3:, :, ...]
          output[3, 2:, :, ...] = input[3, 2:, :, ...]
           &lt;/code&gt;&lt;/pre&gt;

          In contrast, if:

           &lt;pre&gt;&lt;code&gt;
          # Given this:
          batch_dim = 2
          seq_dim = 0
          input.dims = (8, ?, 4, ...)
          seq_lengths = [7, 2, 3, 5]

          # then slices of input are reversed on seq_dim, but only up to seq_lengths:
          output[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...]
          output[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...]
          output[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...]
          output[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]

          # while entries past seq_lens are copied through:
          output[7:, :, 0, :, ...] = input[7:, :, 0, :, ...]
          output[2:, :, 1, :, ...] = input[2:, :, 1, :, ...]
          output[3:, :, 2, :, ...] = input[3:, :, 2, :, ...]
          output[2:, :, 3, :, ...] = input[2:, :, 3, :, ...]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ReverseV2_" data-uid="TensorFlow.TFGraph.ReverseV2*"></a>
  <h4 id="TensorFlow_TFGraph_ReverseV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ReverseV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ReverseV2(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Reverses specific dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ReverseV2 (TensorFlow.TFOutput tensor, TensorFlow.TFOutput axis, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>Up to 8-D.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">axis</span></td>
        <td><p>1-D. The indices of the dimensions to reverse. Must be in the range
              <code>[-rank(tensor), rank(tensor))</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ReverseV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The same shape as <code>tensor</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ReverseV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>NOTE <code>tf.reverse</code> has now changed behavior in preparation for 1.0.
              <code>tf.reverse_v2</code> is currently an alias that will be deprecated before TF 1.0.</p>
<pre><code>          Given a &lt;code&gt;tensor&lt;/code&gt;, and a &lt;code&gt;int32&lt;/code&gt; tensor &lt;code&gt;axis&lt;/code&gt; representing the set of
          dimensions of &lt;code&gt;tensor&lt;/code&gt; to reverse. This operation reverses each dimension
          &lt;code&gt;i&lt;/code&gt; for which there exists &lt;code&gt;j&lt;/code&gt; s.t. &lt;code&gt;axis[j] == i&lt;/code&gt;.

          &lt;code&gt;tensor&lt;/code&gt; can have up to 8 dimensions. The number of dimensions specified
          in &lt;code&gt;axis&lt;/code&gt; may be 0 or more entries. If an index is specified more than
          once, a InvalidArgument error is raised.

          For example:

           &lt;pre&gt;&lt;code&gt;
          # tensor &#39;t&#39; is [[[[ 0,  1,  2,  3],
          #                  [ 4,  5,  6,  7],
          #                  [ 8,  9, 10, 11]],
          #                 [[12, 13, 14, 15],
          #                  [16, 17, 18, 19],
          #                  [20, 21, 22, 23]]]]
          # tensor &#39;t&#39; shape is [1, 2, 3, 4]

          # &#39;dims&#39; is [3] or &#39;dims&#39; is [-1]
          reverse(t, dims) ==&amp;gt; [[[[ 3,  2,  1,  0],
          [ 7,  6,  5,  4],
          [ 11, 10, 9, 8]],
          [[15, 14, 13, 12],
          [19, 18, 17, 16],
          [23, 22, 21, 20]]]]

          # &#39;dims&#39; is &#39;[1]&#39; (or &#39;dims&#39; is &#39;[-3]&#39;)
          reverse(t, dims) ==&amp;gt; [[[[12, 13, 14, 15],
          [16, 17, 18, 19],
          [20, 21, 22, 23]
          [[ 0,  1,  2,  3],
          [ 4,  5,  6,  7],
          [ 8,  9, 10, 11]]]]

          # &#39;dims&#39; is &#39;[2]&#39; (or &#39;dims&#39; is &#39;[-2]&#39;)
          reverse(t, dims) ==&amp;gt; [[[[8, 9, 10, 11],
          [4, 5, 6, 7],
          [0, 1, 2, 3]]
          [[20, 21, 22, 23],
          [16, 17, 18, 19],
          [12, 13, 14, 15]]]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RFFT_" data-uid="TensorFlow.TFGraph.RFFT*"></a>
  <h4 id="TensorFlow_TFGraph_RFFT_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RFFT(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">RFFT(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Real-valued fast Fourier transform.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RFFT (TensorFlow.TFOutput input, TensorFlow.TFOutput fft_length, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A float32 tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">fft_length</span></td>
        <td><p>An int32 tensor of shape [1]. The FFT length.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RFFT&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A complex64 tensor of the same rank as <code>input</code>. The inner-most
              dimension of <code>input</code> is replaced with the <code>fft_length / 2 + 1</code> unique
              frequency components of its 1D Fourier transform.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.fft.rfft
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RFFT_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the 1-dimensional discrete Fourier transform of a real-valued signal
              over the inner-most dimension of <code>input</code>.</p>
<pre><code>          Since the DFT of a real signal is Hermitian-symmetric, &lt;code&gt;RFFT&lt;/code&gt; only returns the
          &lt;code&gt;fft_length / 2 + 1&lt;/code&gt; unique components of the FFT: the zero-frequency term,
          followed by the &lt;code&gt;fft_length / 2&lt;/code&gt; positive-frequency terms.

          Along the axis &lt;code&gt;RFFT&lt;/code&gt; is computed on, if &lt;code&gt;fft_length&lt;/code&gt; is smaller than the
          corresponding dimension of &lt;code&gt;input&lt;/code&gt;, the dimension is cropped. If it is larger,
          the dimension is padded with zeros.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RFFT2D_" data-uid="TensorFlow.TFGraph.RFFT2D*"></a>
  <h4 id="TensorFlow_TFGraph_RFFT2D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RFFT2D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">RFFT2D(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>2D real-valued fast Fourier transform.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RFFT2D (TensorFlow.TFOutput input, TensorFlow.TFOutput fft_length, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A float32 tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">fft_length</span></td>
        <td><p>An int32 tensor of shape [2]. The FFT length for each dimension.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RFFT2D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A complex64 tensor of the same rank as <code>input</code>. The inner-most 2
              dimensions of <code>input</code> are replaced with their 2D Fourier transform. The
              inner-most dimension contains <code>fft_length / 2 + 1</code> unique frequency
              components.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.fft.rfft2
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RFFT2D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the 2-dimensional discrete Fourier transform of a real-valued signal
              over the inner-most 2 dimensions of <code>input</code>.</p>
<pre><code>          Since the DFT of a real signal is Hermitian-symmetric, &lt;code&gt;RFFT2D&lt;/code&gt; only returns the
          &lt;code&gt;fft_length / 2 + 1&lt;/code&gt; unique components of the FFT for the inner-most dimension
          of &lt;code&gt;output&lt;/code&gt;: the zero-frequency term, followed by the &lt;code&gt;fft_length / 2&lt;/code&gt;
          positive-frequency terms.

          Along each axis &lt;code&gt;RFFT2D&lt;/code&gt; is computed on, if &lt;code&gt;fft_length&lt;/code&gt; is smaller than the
          corresponding dimension of &lt;code&gt;input&lt;/code&gt;, the dimension is cropped. If it is larger,
          the dimension is padded with zeros.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RFFT3D_" data-uid="TensorFlow.TFGraph.RFFT3D*"></a>
  <h4 id="TensorFlow_TFGraph_RFFT3D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RFFT3D(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">RFFT3D(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>3D real-valued fast Fourier transform.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RFFT3D (TensorFlow.TFOutput input, TensorFlow.TFOutput fft_length, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A float32 tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">fft_length</span></td>
        <td><p>An int32 tensor of shape [3]. The FFT length for each dimension.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RFFT3D&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A complex64 tensor of the same rank as <code>input</code>. The inner-most 3
              dimensions of <code>input</code> are replaced with the their 3D Fourier transform. The
              inner-most dimension contains <code>fft_length / 2 + 1</code> unique frequency
              components.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.fft.rfftn with 3 dimensions.
          @end_compatibility
          The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.
</code></pre></td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RFFT3D_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the 3-dimensional discrete Fourier transform of a real-valued signal
              over the inner-most 3 dimensions of <code>input</code>.</p>
<pre><code>          Since the DFT of a real signal is Hermitian-symmetric, &lt;code&gt;RFFT3D&lt;/code&gt; only returns the
          &lt;code&gt;fft_length / 2 + 1&lt;/code&gt; unique components of the FFT for the inner-most dimension
          of &lt;code&gt;output&lt;/code&gt;: the zero-frequency term, followed by the &lt;code&gt;fft_length / 2&lt;/code&gt;
          positive-frequency terms.

          Along each axis &lt;code&gt;RFFT3D&lt;/code&gt; is computed on, if &lt;code&gt;fft_length&lt;/code&gt; is smaller than the
          corresponding dimension of &lt;code&gt;input&lt;/code&gt;, the dimension is cropped. If it is larger,
          the dimension is padded with zeros.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RGBToHSV_" data-uid="TensorFlow.TFGraph.RGBToHSV*"></a>
  <h4 id="TensorFlow_TFGraph_RGBToHSV_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RGBToHSV(TensorFlow.TFOutput,System.String)">RGBToHSV(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Converts one or more images from RGB to HSV.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RGBToHSV (TensorFlow.TFOutput images, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">images</span></td>
        <td><p>1-D or higher rank. RGB data to convert. Last dimension must be size 3.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RGBToHSV&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p><code>images</code> converted to HSV.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RGBToHSV_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Outputs a tensor of the same shape as the <code>images</code> tensor, containing the HSV
              value of the pixels. The output is only well defined if the value in <code>images</code>
              are in <code>[0,1]</code>.</p>
<pre><code>          &lt;code&gt;output[..., 0]&lt;/code&gt; contains hue, &lt;code&gt;output[..., 1]&lt;/code&gt; contains saturation, and
          &lt;code&gt;output[..., 2]&lt;/code&gt; contains value. All HSV values are in &lt;code&gt;[0,1]&lt;/code&gt;. A hue of 0
          corresponds to pure red, hue 1/3 is pure green, and 2/3 is pure blue.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_RightShift_" data-uid="TensorFlow.TFGraph.RightShift*"></a>
  <h4 id="TensorFlow_TFGraph_RightShift_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RightShift(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">RightShift(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Elementwise computes the bitwise right-shift of <code>x</code> and <code>y</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RightShift (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RightShift&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RightShift_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Performs a logical shift for unsigned integer types, and an arithmetic shift
              for signed integer types.</p>
<pre><code>          If &lt;code&gt;y&lt;/code&gt; is negative, or greater than or equal to than the width of &lt;code&gt;x&lt;/code&gt; in bits
          the result is implementation defined.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Rint_" data-uid="TensorFlow.TFGraph.Rint*"></a>
  <h4 id="TensorFlow_TFGraph_Rint_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Rint(TensorFlow.TFOutput,System.String)">Rint(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns element-wise integer closest to x.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Rint (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Rint&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Rint_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If the result is midway between two representable values,
              the even representable is chosen.
              For example:</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          rint(-1.5) ==&amp;gt; -2.0
          rint(0.5000001) ==&amp;gt; 1.0
          rint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) ==&amp;gt; [-2., -2., -0., 0., 2., 2., 2.]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Roll_" data-uid="TensorFlow.TFGraph.Roll*"></a>
  <h4 id="TensorFlow_TFGraph_Roll_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Roll(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Roll(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Rolls the elements of a tensor along an axis.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Roll (TensorFlow.TFOutput input, TensorFlow.TFOutput shift, TensorFlow.TFOutput axis, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shift</span></td>
        <td><p>Dimension must be 0-D or 1-D. <code>shift[i]</code> specifies the number of places by which
              elements are shifted positively (towards larger indices) along the dimension
              specified by <code>axis[i]</code>. Negative shifts will roll the elements in the opposite
              direction.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">axis</span></td>
        <td><p>Dimension must be 0-D or 1-D. <code>axis[i]</code> specifies the dimension that the shift
              <code>shift[i]</code> should occur. If the same axis is referenced more than once, the
              total shift for that axis will be the sum of all the shifts that belong to that
              axis.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Roll&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has the same shape and size as the input. The elements are shifted
              positively (towards larger indices) by the offsets of <code>shift</code> along the
              dimensions of <code>axis</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Roll_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The elements are shifted positively (towards larger indices) by the offset of
              <code>shift</code> along the dimension of <code>axis</code>. Negative <code>shift</code> values will shift
              elements in the opposite direction. Elements that roll passed the last position
              will wrap around to the first and vice versa. Multiple shifts along multiple
              axes may be specified.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;t&#39; is [0, 1, 2, 3, 4]
          roll(t, shift=2, axis=0) ==&amp;gt; [3, 4, 0, 1, 2]

          # shifting along multiple dimensions
          # &#39;t&#39; is [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]
          roll(t, shift=[1, -2], axis=[0, 1]) ==&amp;gt; [[7, 8, 9, 5, 6], [2, 3, 4, 0, 1]]

          # shifting along the same axis multiple times
          # &#39;t&#39; is [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]
          roll(t, shift=[2, -3], axis=[1, 1]) ==&amp;gt; [[1, 2, 3, 4, 0], [6, 7, 8, 9, 5]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Round_" data-uid="TensorFlow.TFGraph.Round*"></a>
  <h4 id="TensorFlow_TFGraph_Round_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Round(TensorFlow.TFOutput,System.String)">Round(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Rounds the values of a tensor to the nearest integer, element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Round (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Round&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Round_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Rounds half to even.  Also known as bankers rounding. If you want to round
              according to the current system rounding mode use std::cint.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Rpc_" data-uid="TensorFlow.TFGraph.Rpc*"></a>
  <h4 id="TensorFlow_TFGraph_Rpc_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.Rpc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)">Rpc(TFOutput, TFOutput, TFOutput, String, Nullable&lt;Boolean&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Perform batches of RPC requests.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Rpc (TensorFlow.TFOutput address, TensorFlow.TFOutput method, TensorFlow.TFOutput request, string protocol = null, Nullable&lt;bool&gt; fail_fast = null, Nullable&lt;long&gt; timeout_in_ms = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">address</span></td>
        <td><p><code>0-D</code> or <code>1-D</code>.  The address (i.e. host_name:port) of the RPC server.
              If this tensor has more than 1 element, then multiple parallel rpc requests
              are sent.  This argument broadcasts with <code>method</code> and <code>request</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">method</span></td>
        <td><p><code>0-D</code> or <code>1-D</code>.  The method address on the RPC server.
              If this tensor has more than 1 element, then multiple parallel rpc requests
              are sent.  This argument broadcasts with <code>address</code> and <code>request</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">request</span></td>
        <td><p><code>0-D</code> or <code>1-D</code>.  Serialized proto strings: the rpc request argument.
              If this tensor has more than 1 element, then multiple parallel rpc requests
              are sent.  This argument broadcasts with <code>address</code> and <code>method</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">protocol</span></td>
        <td><p>Optional argument
              RPC protocol to use.  Empty string means use the default protocol.
              Options include &#39;grpc&#39;.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">fail_fast</span></td>
        <td><p>Optional argument
              <code>boolean</code>. If <code>true</code> (default), then failures to connect
              (i.e., the server does not immediately respond) cause an RPC failure.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">timeout_in_ms</span></td>
        <td><p>Optional argument
              <code>int</code>. If <code>0</code> (default), then the kernel will run the RPC
              request and only time out if the RPC deadline passes or the session times out.
              If this value is greater than <code>0</code>, then the op will raise an exception if
              the RPC takes longer than <code>timeout_in_ms</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Rpc&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same shape as <code>request</code>. Serialized proto strings: the rpc responses.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Rpc_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op asynchronously performs either a single RPC request, or a batch
              of requests.  RPC requests are defined by three main parameters:</p>
<pre><code>          - &lt;code&gt;address&lt;/code&gt; (the host+port or BNS address of the request)
          - &lt;code&gt;method&lt;/code&gt; (the RPC method name for the request)
          - &lt;code&gt;request&lt;/code&gt; (the serialized proto string, or vector of strings,
          of the RPC request argument).

          For example, if you have an RPC service running on port localhost:2345,
          and its interface is configured with the following proto declaration:

           &lt;pre&gt;&lt;code&gt;
          service MyService {
          rpc MyMethod(MyRequestProto) returns (MyResponseProto) {
          }
          };
           &lt;/code&gt;&lt;/pre&gt;

          then call this op with arguments:

           &lt;pre&gt;&lt;code&gt;
          address = &quot;localhost:2345&quot;
          method = &quot;MyService/MyMethod&quot;
           &lt;/code&gt;&lt;/pre&gt;

          The &lt;code&gt;request&lt;/code&gt; tensor is a string tensor representing serialized &lt;code&gt;MyRequestProto&lt;/code&gt;
          strings; and the output string tensor &lt;code&gt;response&lt;/code&gt; will have the same shape
          and contain (upon successful completion) corresponding serialized
          &lt;code&gt;MyResponseProto&lt;/code&gt; strings.

          For example, to send a single, empty, &lt;code&gt;MyRequestProto&lt;/code&gt;, call
          this op with &lt;code&gt;request = &quot;&quot;&lt;/code&gt;.  To send 5 **parallel** empty requests,
          call this op with &lt;code&gt;request = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]&lt;/code&gt;.

          More generally, one can create a batch of &lt;code&gt;MyRequestProto&lt;/code&gt; serialized protos
          from regular batched tensors using the &lt;code&gt;encode_proto&lt;/code&gt; op, and convert
          the response &lt;code&gt;MyResponseProto&lt;/code&gt; serialized protos to batched tensors
          using the &lt;code&gt;decode_proto&lt;/code&gt; op.

          **NOTE** Working with serialized proto strings is faster than instantiating
          actual proto objects in memory, so no performance degradation is expected
          compared to writing custom kernels for this workflow.

          If the connection fails or the remote worker returns an error
          status, the op reraises this exception locally.

          See the &lt;code&gt;TryRpc&lt;/code&gt; op if you prefer to handle RPC failures manually in the graph.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Rsqrt_" data-uid="TensorFlow.TFGraph.Rsqrt*"></a>
  <h4 id="TensorFlow_TFGraph_Rsqrt_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Rsqrt(TensorFlow.TFOutput,System.String)">Rsqrt(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes reciprocal of square root of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Rsqrt (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Rsqrt&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Rsqrt_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>I.e., \(y = 1 / \sqrt{x}\).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_RsqrtGrad_" data-uid="TensorFlow.TFGraph.RsqrtGrad*"></a>
  <h4 id="TensorFlow_TFGraph_RsqrtGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.RsqrtGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">RsqrtGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradient for the rsqrt of <code>x</code> wrt its input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput RsqrtGrad (TensorFlow.TFOutput y, TensorFlow.TFOutput dy, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dy</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;RsqrtGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_RsqrtGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Specifically, <code>grad = dy * -0.5 * y^3</code>, where <code>y = rsqrt(x)</code>, and <code>dy</code>
              is the corresponding input gradient.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SampleDistortedBoundingBox_" data-uid="TensorFlow.TFGraph.SampleDistortedBoundingBox*"></a>
  <h4 id="TensorFlow_TFGraph_SampleDistortedBoundingBox_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Single__System_Single___System_Single___System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SampleDistortedBoundingBox(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Single},System.Single[],System.Single[],System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">SampleDistortedBoundingBox(TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Single&gt;, Single[], Single[], Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Generate a single randomly distorted bounding box for an image.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SampleDistortedBoundingBox (TensorFlow.TFOutput image_size, TensorFlow.TFOutput bounding_boxes, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, Nullable&lt;float&gt; min_object_covered = null, float[] aspect_ratio_range = null, float[] area_range = null, Nullable&lt;long&gt; max_attempts = null, Nullable&lt;bool&gt; use_image_if_no_bounding_boxes = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">image_size</span></td>
        <td><p>1-D, containing <code>[height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">bounding_boxes</span></td>
        <td><p>3-D with shape <code>[batch, N, 4]</code> describing the N bounding boxes
              associated with the image.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either <code>seed</code> or <code>seed2</code> are set to non-zero, the random number
              generator is seeded by the given <code>seed</code>.  Otherwise, it is seeded by a random
              seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              A second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">min_object_covered</span></td>
        <td><p>Optional argument
              The cropped area of the image must contain at least this
              fraction of any bounding box supplied. The value of this parameter should be
              non-negative. In the case of 0, the cropped area does not need to overlap
              any of the bounding boxes supplied.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span>[]</td>
        <td><span class="parametername">aspect_ratio_range</span></td>
        <td><p>Optional argument
              The cropped area of the image must have an aspect ratio =
              width / height within this range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span>[]</td>
        <td><span class="parametername">area_range</span></td>
        <td><p>Optional argument
              The cropped area of the image must contain a fraction of the
              supplied image within this range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">max_attempts</span></td>
        <td><p>Optional argument
              Number of attempts at generating a cropped region of the image
              of the specified constraints. After <code>max_attempts</code> failures, return the entire
              image.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_image_if_no_bounding_boxes</span></td>
        <td><p>Optional argument
              Controls behavior if no bounding boxes supplied.
              If true, assume an implicit bounding box covering the whole input. If false,
              raise an error.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SampleDistortedBoundingBox&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              begin: 1-D, containing <code>[offset_height, offset_width, 0]</code>. Provide as input to
              <code>tf.slice</code>.
              size: 1-D, containing <code>[target_height, target_width, -1]</code>. Provide as input to
              <code>tf.slice</code>.
              bboxes: 3-D with shape <code>[1, 1, 4]</code> containing the distorted bounding box.
              Provide as input to <code>tf.image.draw_bounding_boxes</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SampleDistortedBoundingBox_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Single__System_Single___System_Single___System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Bounding box annotations are often supplied in addition to ground-truth labels
              in image recognition or object localization tasks. A common technique for
              training such a system is to randomly distort an image while preserving
              its content, i.e. <em>data augmentation</em>. This Op outputs a randomly distorted
              localization of an object, i.e. bounding box, given an <code>image_size</code>,
              <code>bounding_boxes</code> and a series of constraints.</p>
<pre><code>          The output of this Op is a single bounding box that may be used to crop the
          original image. The output is returned as 3 tensors: &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt; and
          &lt;code&gt;bboxes&lt;/code&gt;. The first 2 tensors can be fed directly into &lt;code&gt;tf.slice&lt;/code&gt; to crop the
          image. The latter may be supplied to &lt;code&gt;tf.image.draw_bounding_boxes&lt;/code&gt; to visualize
          what the bounding box looks like.

          Bounding boxes are supplied and returned as &lt;code&gt;[y_min, x_min, y_max, x_max]&lt;/code&gt;. The
          bounding box coordinates are floats in &lt;code&gt;[0.0, 1.0]&lt;/code&gt; relative to the width and
          height of the underlying image.

          For example,

           &lt;pre&gt;&lt;code&gt;
          # Generate a single distorted bounding box.
          begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(
          tf.shape(image),
          bounding_boxes=bounding_boxes)

          # Draw the bounding box in an image summary.
          image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),
          bbox_for_draw)
          tf.summary.image(&#39;images_with_box&#39;, image_with_box)

          # Employ the bounding box to distort the image.
          distorted_image = tf.slice(image, begin, size)
           &lt;/code&gt;&lt;/pre&gt;

          Note that if no bounding box information is available, setting
          &lt;code&gt;use_image_if_no_bounding_boxes = true&lt;/code&gt; will assume there is a single implicit
          bounding box covering the whole image. If &lt;code&gt;use_image_if_no_bounding_boxes&lt;/code&gt; is
          false and no bounding boxes are supplied, an error is raised.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SampleDistortedBoundingBoxV2_" data-uid="TensorFlow.TFGraph.SampleDistortedBoundingBoxV2*"></a>
  <h4 id="TensorFlow_TFGraph_SampleDistortedBoundingBoxV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Single___System_Single___System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SampleDistortedBoundingBoxV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Single[],System.Single[],System.Nullable{System.Int64},System.Nullable{System.Boolean},System.String)">SampleDistortedBoundingBoxV2(TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Single[], Single[], Nullable&lt;Int64&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Generate a single randomly distorted bounding box for an image.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SampleDistortedBoundingBoxV2 (TensorFlow.TFOutput image_size, TensorFlow.TFOutput bounding_boxes, TensorFlow.TFOutput min_object_covered, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, float[] aspect_ratio_range = null, float[] area_range = null, Nullable&lt;long&gt; max_attempts = null, Nullable&lt;bool&gt; use_image_if_no_bounding_boxes = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">image_size</span></td>
        <td><p>1-D, containing <code>[height, width, channels]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">bounding_boxes</span></td>
        <td><p>3-D with shape <code>[batch, N, 4]</code> describing the N bounding boxes
              associated with the image.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">min_object_covered</span></td>
        <td><p>The cropped area of the image must contain at least this
              fraction of any bounding box supplied. The value of this parameter should be
              non-negative. In the case of 0, the cropped area does not need to overlap
              any of the bounding boxes supplied.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either <code>seed</code> or <code>seed2</code> are set to non-zero, the random number
              generator is seeded by the given <code>seed</code>.  Otherwise, it is seeded by a random
              seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              A second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span>[]</td>
        <td><span class="parametername">aspect_ratio_range</span></td>
        <td><p>Optional argument
              The cropped area of the image must have an aspect ratio =
              width / height within this range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span>[]</td>
        <td><span class="parametername">area_range</span></td>
        <td><p>Optional argument
              The cropped area of the image must contain a fraction of the
              supplied image within this range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">max_attempts</span></td>
        <td><p>Optional argument
              Number of attempts at generating a cropped region of the image
              of the specified constraints. After <code>max_attempts</code> failures, return the entire
              image.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_image_if_no_bounding_boxes</span></td>
        <td><p>Optional argument
              Controls behavior if no bounding boxes supplied.
              If true, assume an implicit bounding box covering the whole input. If false,
              raise an error.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SampleDistortedBoundingBoxV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              begin: 1-D, containing <code>[offset_height, offset_width, 0]</code>. Provide as input to
              <code>tf.slice</code>.
              size: 1-D, containing <code>[target_height, target_width, -1]</code>. Provide as input to
              <code>tf.slice</code>.
              bboxes: 3-D with shape <code>[1, 1, 4]</code> containing the distorted bounding box.
              Provide as input to <code>tf.image.draw_bounding_boxes</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SampleDistortedBoundingBoxV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Single___System_Single___System_Nullable_System_Int64__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Bounding box annotations are often supplied in addition to ground-truth labels
              in image recognition or object localization tasks. A common technique for
              training such a system is to randomly distort an image while preserving
              its content, i.e. <em>data augmentation</em>. This Op outputs a randomly distorted
              localization of an object, i.e. bounding box, given an <code>image_size</code>,
              <code>bounding_boxes</code> and a series of constraints.</p>
<pre><code>          The output of this Op is a single bounding box that may be used to crop the
          original image. The output is returned as 3 tensors: &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt; and
          &lt;code&gt;bboxes&lt;/code&gt;. The first 2 tensors can be fed directly into &lt;code&gt;tf.slice&lt;/code&gt; to crop the
          image. The latter may be supplied to &lt;code&gt;tf.image.draw_bounding_boxes&lt;/code&gt; to visualize
          what the bounding box looks like.

          Bounding boxes are supplied and returned as &lt;code&gt;[y_min, x_min, y_max, x_max]&lt;/code&gt;. The
          bounding box coordinates are floats in &lt;code&gt;[0.0, 1.0]&lt;/code&gt; relative to the width and
          height of the underlying image.

          For example,

           &lt;pre&gt;&lt;code&gt;
          # Generate a single distorted bounding box.
          begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(
          tf.shape(image),
          bounding_boxes=bounding_boxes)

          # Draw the bounding box in an image summary.
          image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),
          bbox_for_draw)
          tf.summary.image(&#39;images_with_box&#39;, image_with_box)

          # Employ the bounding box to distort the image.
          distorted_image = tf.slice(image, begin, size)
           &lt;/code&gt;&lt;/pre&gt;

          Note that if no bounding box information is available, setting
          &lt;code&gt;use_image_if_no_bounding_boxes = true&lt;/code&gt; will assume there is a single implicit
          bounding box covering the whole image. If &lt;code&gt;use_image_if_no_bounding_boxes&lt;/code&gt; is
          false and no bounding boxes are supplied, an error is raised.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Save_" data-uid="TensorFlow.TFGraph.Save*"></a>
  <h4 id="TensorFlow_TFGraph_Save_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.Save(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)">Save(TFOutput, TFOutput, TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Saves the input tensors to disk.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation Save (TensorFlow.TFOutput filename, TensorFlow.TFOutput tensor_names, TensorFlow.TFOutput[] data, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filename</span></td>
        <td><p>Must have a single element. The name of the file to which we write
              the tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor_names</span></td>
        <td><p>Shape <code>[N]</code>. The names of the tensors to be saved.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">data</span></td>
        <td><p><code>N</code> tensors to save.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Save&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Save_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The size of <code>tensor_names</code> must match the number of tensors in <code>data</code>. <code>data[i]</code>
              is written to <code>filename</code> with name <code>tensor_names[i]</code>.</p>
<pre><code>          See also &lt;code&gt;SaveSlices&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SaveSlices_" data-uid="TensorFlow.TFGraph.SaveSlices*"></a>
  <h4 id="TensorFlow_TFGraph_SaveSlices_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.SaveSlices(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)">SaveSlices(TFOutput, TFOutput, TFOutput, TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Saves input tensors slices to disk.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation SaveSlices (TensorFlow.TFOutput filename, TensorFlow.TFOutput tensor_names, TensorFlow.TFOutput shapes_and_slices, TensorFlow.TFOutput[] data, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filename</span></td>
        <td><p>Must have a single element. The name of the file to which we write the
              tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor_names</span></td>
        <td><p>Shape <code>[N]</code>. The names of the tensors to be saved.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shapes_and_slices</span></td>
        <td><p>Shape <code>[N]</code>.  The shapes and slice specifications to use when
              saving the tensors.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">data</span></td>
        <td><p><code>N</code> tensors to save.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SaveSlices&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SaveSlices_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This is like <code>Save</code> except that tensors can be listed in the saved file as being
              a slice of a larger tensor.  <code>shapes_and_slices</code> specifies the shape of the
              larger tensor and the slice that this tensor covers. <code>shapes_and_slices</code> must
              have as many elements as <code>tensor_names</code>.</p>
<pre><code>          Elements of the &lt;code&gt;shapes_and_slices&lt;/code&gt; input must either be:

          *  The empty string, in which case the corresponding tensor is
          saved normally.
          *  A string of the form &lt;code&gt;dim0 dim1 ... dimN-1 slice-spec&lt;/code&gt; where the
          &lt;code&gt;dimI&lt;/code&gt; are the dimensions of the larger tensor and &lt;code&gt;slice-spec&lt;/code&gt;
          specifies what part is covered by the tensor to save.

          &lt;code&gt;slice-spec&lt;/code&gt; itself is a &lt;code&gt;:&lt;/code&gt;-separated list: &lt;code&gt;slice0:slice1:...:sliceN-1&lt;/code&gt;
          where each &lt;code&gt;sliceI&lt;/code&gt; is either:

          *  The string &lt;code&gt;-&lt;/code&gt; meaning that the slice covers all indices of this dimension
          *  &lt;code&gt;start,length&lt;/code&gt; where &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are integers.  In that
          case the slice covers &lt;code&gt;length&lt;/code&gt; indices starting at &lt;code&gt;start&lt;/code&gt;.

          See also &lt;code&gt;Save&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SaveV2_" data-uid="TensorFlow.TFGraph.SaveV2*"></a>
  <h4 id="TensorFlow_TFGraph_SaveV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.SaveV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],System.String)">SaveV2(TFOutput, TFOutput, TFOutput, TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Saves tensors in V2 checkpoint format.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation SaveV2 (TensorFlow.TFOutput prefix, TensorFlow.TFOutput tensor_names, TensorFlow.TFOutput shape_and_slices, TensorFlow.TFOutput[] tensors, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">prefix</span></td>
        <td><p>Must have a single element. The prefix of the V2 checkpoint to which we
              write the tensors.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor_names</span></td>
        <td><p>shape {N}. The names of the tensors to be saved.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape_and_slices</span></td>
        <td><p>shape {N}.  The slice specs of the tensors to be saved.
              Empty strings indicate that they are non-partitioned tensors.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">tensors</span></td>
        <td><p><code>N</code> tensors to save.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SaveV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SaveV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>By default, saves the named tensors in full.  If the caller wishes to save
              specific slices of full tensors, &quot;shape_and_slices&quot; should be non-empty strings
              and correspondingly well-formed.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ScalarSummary_" data-uid="TensorFlow.TFGraph.ScalarSummary*"></a>
  <h4 id="TensorFlow_TFGraph_ScalarSummary_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ScalarSummary(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ScalarSummary(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ScalarSummary (TensorFlow.TFOutput tags, TensorFlow.TFOutput values, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tags</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ScatterAdd_" data-uid="TensorFlow.TFGraph.ScatterAdd*"></a>
  <h4 id="TensorFlow_TFGraph_ScatterAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ScatterAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ScatterAdd(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Adds sparse updates to a variable reference.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ScatterAdd (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of updated values to add to <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the addition will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ScatterAdd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>= Same as <code>ref</code>.  Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ScatterAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes</p>
<pre><code>          # Scalar indices
          ref[indices, ...] += updates[...]

          # Vector indices (for each i)
          ref[indices[i], ...] += updates[i, ...]

          # High rank indices (for each i, ..., j)
          ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]

          This operation outputs &lt;code&gt;ref&lt;/code&gt; after the update is done.
          This makes it easier to chain operations that need to use the reset value.

          Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference
          the same location, their contributions add.

          Requires &lt;code&gt;updates.shape = indices.shape + ref.shape[1:]&lt;/code&gt; or &lt;code&gt;updates.shape = []&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/ScatterAdd.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ScatterDiv_" data-uid="TensorFlow.TFGraph.ScatterDiv*"></a>
  <h4 id="TensorFlow_TFGraph_ScatterDiv_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ScatterDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ScatterDiv(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Divides a variable reference by sparse updates.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ScatterDiv (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of values that <code>ref</code> is divided by.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the operation will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ScatterDiv&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>= Same as <code>ref</code>.  Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ScatterDiv_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          # Scalar indices
          ref[indices, ...] /= updates[...]

          # Vector indices (for each i)
          ref[indices[i], ...] /= updates[i, ...]

          # High rank indices (for each i, ..., j)
          ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]
           &lt;/code&gt;&lt;/pre&gt;

          This operation outputs &lt;code&gt;ref&lt;/code&gt; after the update is done.
          This makes it easier to chain operations that need to use the reset value.

          Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference
          the same location, their contributions divide.

          Requires &lt;code&gt;updates.shape = indices.shape + ref.shape[1:]&lt;/code&gt; or &lt;code&gt;updates.shape = []&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ScatterMax_" data-uid="TensorFlow.TFGraph.ScatterMax*"></a>
  <h4 id="TensorFlow_TFGraph_ScatterMax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ScatterMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ScatterMax(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Reduces sparse updates into a variable reference using the <code>max</code> operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ScatterMax (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of updated values to reduce into <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the update will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ScatterMax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>= Same as <code>ref</code>.  Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ScatterMax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes</p>
<pre><code>          # Scalar indices
          ref[indices, ...] = max(ref[indices, ...], updates[...])

          # Vector indices (for each i)
          ref[indices[i], ...] = max(ref[indices[i], ...], updates[i, ...])

          # High rank indices (for each i, ..., j)
          ref[indices[i, ..., j], ...] = max(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])

          This operation outputs &lt;code&gt;ref&lt;/code&gt; after the update is done.
          This makes it easier to chain operations that need to use the reset value.

          Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference
          the same location, their contributions combine.

          Requires &lt;code&gt;updates.shape = indices.shape + ref.shape[1:]&lt;/code&gt; or &lt;code&gt;updates.shape = []&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/ScatterAdd.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ScatterMin_" data-uid="TensorFlow.TFGraph.ScatterMin*"></a>
  <h4 id="TensorFlow_TFGraph_ScatterMin_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ScatterMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ScatterMin(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Reduces sparse updates into a variable reference using the <code>min</code> operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ScatterMin (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of updated values to reduce into <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the update will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ScatterMin&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>= Same as <code>ref</code>.  Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ScatterMin_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes</p>
<pre><code>          # Scalar indices
          ref[indices, ...] = min(ref[indices, ...], updates[...])

          # Vector indices (for each i)
          ref[indices[i], ...] = min(ref[indices[i], ...], updates[i, ...])

          # High rank indices (for each i, ..., j)
          ref[indices[i, ..., j], ...] = min(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])

          This operation outputs &lt;code&gt;ref&lt;/code&gt; after the update is done.
          This makes it easier to chain operations that need to use the reset value.

          Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference
          the same location, their contributions combine.

          Requires &lt;code&gt;updates.shape = indices.shape + ref.shape[1:]&lt;/code&gt; or &lt;code&gt;updates.shape = []&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/ScatterAdd.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ScatterMul_" data-uid="TensorFlow.TFGraph.ScatterMul*"></a>
  <h4 id="TensorFlow_TFGraph_ScatterMul_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ScatterMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ScatterMul(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Multiplies sparse updates into a variable reference.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ScatterMul (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of updated values to multiply to <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the operation will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ScatterMul&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>= Same as <code>ref</code>.  Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ScatterMul_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          # Scalar indices
          ref[indices, ...] *= updates[...]

          # Vector indices (for each i)
          ref[indices[i], ...] *= updates[i, ...]

          # High rank indices (for each i, ..., j)
          ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]
           &lt;/code&gt;&lt;/pre&gt;

          This operation outputs &lt;code&gt;ref&lt;/code&gt; after the update is done.
          This makes it easier to chain operations that need to use the reset value.

          Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference
          the same location, their contributions multiply.

          Requires &lt;code&gt;updates.shape = indices.shape + ref.shape[1:]&lt;/code&gt; or &lt;code&gt;updates.shape = []&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ScatterNd_" data-uid="TensorFlow.TFGraph.ScatterNd*"></a>
  <h4 id="TensorFlow_TFGraph_ScatterNd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ScatterNd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ScatterNd(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Scatter <code>updates</code> into a new tensor according to <code>indices</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ScatterNd (TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, TensorFlow.TFOutput shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>Index tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>Updates to scatter into output.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>1-D. The shape of the resulting tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ScatterNd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A new tensor with the given shape and updates applied according
              to the indices.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ScatterNd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Creates a new tensor by applying sparse <code>updates</code> to individual values or
              slices within a tensor (initially zero for numeric, empty for string) of
              the given <code>shape</code> according to indices.  This operator is the inverse of the
              <code>tf.gather_nd</code> operator which extracts values or slices from a given tensor.</p>
<pre><code>          This operation is similar to tensor_scatter_add, except that the tensor is
          zero-initialized. Calling &lt;code&gt;tf.scatter_nd(indices, values, shape)&lt;/code&gt; is identical
          to &lt;code&gt;tensor_scatter_add(tf.zeros(shape, values.dtype), indices, values)&lt;/code&gt;

          If &lt;code&gt;indices&lt;/code&gt; contains duplicates, then their updates are accumulated (summed).

          **WARNING**: The order in which updates are applied is nondeterministic, so the
          output will be nondeterministic if &lt;code&gt;indices&lt;/code&gt; contains duplicates -- because
          of some numerical approximation issues, numbers summed in different order
          may yield different results.

          &lt;code&gt;indices&lt;/code&gt; is an integer tensor containing indices into a new tensor of shape
          &lt;code&gt;shape&lt;/code&gt;.  The last dimension of &lt;code&gt;indices&lt;/code&gt; can be at most the rank of &lt;code&gt;shape&lt;/code&gt;:

          indices.shape[-1] &amp;lt;= shape.rank

          The last dimension of &lt;code&gt;indices&lt;/code&gt; corresponds to indices into elements
          (if &lt;code&gt;indices.shape[-1] = shape.rank&lt;/code&gt;) or slices
          (if &lt;code&gt;indices.shape[-1] &amp;lt; shape.rank&lt;/code&gt;) along dimension &lt;code&gt;indices.shape[-1]&lt;/code&gt; of
          &lt;code&gt;shape&lt;/code&gt;.  &lt;code&gt;updates&lt;/code&gt; is a tensor with shape

          indices.shape[:-1] + shape[indices.shape[-1]:]

          The simplest form of scatter is to insert individual elements in a tensor by
          index. For example, say we want to insert 4 scattered elements in a rank-1
          tensor with 8 elements.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/ScatterNd1.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;

          In Python, this scatter operation would look like this:

           &lt;pre&gt;&lt;code&gt;
          indices = tf.constant([[4], [3], [1], [7]])
          updates = tf.constant([9, 10, 11, 12])
          shape = tf.constant([8])
          scatter = tf.scatter_nd(indices, updates, shape)
          with tf.Session() as sess:
          print(sess.run(scatter))
           &lt;/code&gt;&lt;/pre&gt;

          The resulting tensor would look like this:

          [0, 11, 0, 10, 9, 0, 0, 12]

          We can also, insert entire slices of a higher rank tensor all at once. For
          example, if we wanted to insert two slices in the first dimension of a
          rank-3 tensor with two matrices of new values.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/ScatterNd2.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;

          In Python, this scatter operation would look like this:

           &lt;pre&gt;&lt;code&gt;
          indices = tf.constant([[0], [2]])
          updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],
          [7, 7, 7, 7], [8, 8, 8, 8]],
          [[5, 5, 5, 5], [6, 6, 6, 6],
          [7, 7, 7, 7], [8, 8, 8, 8]]])
          shape = tf.constant([4, 4, 4])
          scatter = tf.scatter_nd(indices, updates, shape)
          with tf.Session() as sess:
          print(sess.run(scatter))
           &lt;/code&gt;&lt;/pre&gt;

          The resulting tensor would look like this:

          [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
          [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
          [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
          [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]]

          Note that on CPU, if an out of bound index is found, an error is returned.
          On GPU, if an out of bound index is found, the index is ignored.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ScatterNdAdd_" data-uid="TensorFlow.TFGraph.ScatterNdAdd*"></a>
  <h4 id="TensorFlow_TFGraph_ScatterNdAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ScatterNdAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ScatterNdAdd(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Applies sparse addition between <code>updates</code> and individual values or slices</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ScatterNdAdd (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>A mutable Tensor. Should be from a Variable node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A Tensor. Must be one of the following types: int32, int64.
              A tensor of indices into ref.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A Tensor. Must have the same type as ref. A tensor of updated values
              to add to ref.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              An optional bool. Defaults to True. If True, the assignment will
              be protected by a lock; otherwise the behavior is undefined,
              but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ScatterNdAdd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as ref. Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ScatterNdAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>within a given variable according to <code>indices</code>.</p>
<pre><code>          &lt;code&gt;ref&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; with rank &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q&lt;/code&gt;.

          &lt;code&gt;indices&lt;/code&gt; must be integer tensor, containing indices into &lt;code&gt;ref&lt;/code&gt;.
          It must be shape &lt;code&gt;\\([d_0, ..., d_{Q-2}, K]\\)&lt;/code&gt; where &lt;code&gt;0 &amp;lt; K &amp;lt;= P&lt;/code&gt;.

          The innermost dimension of &lt;code&gt;indices&lt;/code&gt; (with length &lt;code&gt;K&lt;/code&gt;) corresponds to
          indices into elements (if &lt;code&gt;K = P&lt;/code&gt;) or slices (if &lt;code&gt;K &amp;lt; P&lt;/code&gt;) along the &lt;code&gt;K&lt;/code&gt;th
          dimension of &lt;code&gt;ref&lt;/code&gt;.

          &lt;code&gt;updates&lt;/code&gt; is &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q-1+P-K&lt;/code&gt; with shape:

          $$[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].$$

          For example, say we want to add 4 scattered elements to a rank-1 tensor to 8
          elements. In Python, that addition would look like this:

          ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
          indices = tf.constant([[4], [3], [1], [7]])
          updates = tf.constant([9, 10, 11, 12])
          add = tf.scatter_nd_add(ref, indices, updates)
          with tf.Session() as sess:
          print sess.run(add)

          The resulting update to ref would look like this:

          [1, 13, 3, 14, 14, 6, 7, 20]

          See &lt;code&gt;tf.scatter_nd&lt;/code&gt; for more details about how to make updates to
          slices.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ScatterNdNonAliasingAdd_" data-uid="TensorFlow.TFGraph.ScatterNdNonAliasingAdd*"></a>
  <h4 id="TensorFlow_TFGraph_ScatterNdNonAliasingAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ScatterNdNonAliasingAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ScatterNdNonAliasingAdd(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Applies sparse addition to <code>input</code> using individual values or slices</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ScatterNdNonAliasingAdd (TensorFlow.TFOutput input, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A Tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A Tensor. Must be one of the following types: <code>int32</code>, <code>int64</code>.
              A tensor of indices into <code>input</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A Tensor. Must have the same type as ref. A tensor of updated values
              to add to <code>input</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ScatterNdNonAliasingAdd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A <code>Tensor</code> with the same shape as <code>input</code>, containing values of <code>input</code>
              updated with <code>updates</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ScatterNdNonAliasingAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>from <code>updates</code> according to indices <code>indices</code>.  The updates are non-aliasing:
              <code>input</code> is only modified in-place if no other operations will use it.
              Otherwise, a copy of <code>input</code> is made.  This operation has a gradient with
              respect to both <code>input</code> and <code>updates</code>.</p>
<pre><code>          &lt;code&gt;input&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; with rank &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q&lt;/code&gt;.

          &lt;code&gt;indices&lt;/code&gt; must be integer tensor, containing indices into &lt;code&gt;input&lt;/code&gt;.
          It must be shape \\([d_0, ..., d_{Q-2}, K]\\) where &lt;code&gt;0 &amp;lt; K &amp;lt;= P&lt;/code&gt;.

          The innermost dimension of &lt;code&gt;indices&lt;/code&gt; (with length &lt;code&gt;K&lt;/code&gt;) corresponds to
          indices into elements (if &lt;code&gt;K = P&lt;/code&gt;) or &lt;code&gt;(P-K)&lt;/code&gt;-dimensional slices
          (if &lt;code&gt;K &amp;lt; P&lt;/code&gt;) along the &lt;code&gt;K&lt;/code&gt;th dimension of &lt;code&gt;input&lt;/code&gt;.

          &lt;code&gt;updates&lt;/code&gt; is &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q-1+P-K&lt;/code&gt; with shape:

          $$[d_0, ..., d_{Q-2}, input.shape[K], ..., input.shape[P-1]].$$

          For example, say we want to add 4 scattered elements to a rank-1 tensor to 8
          elements. In Python, that addition would look like this:

          input = tf.constant([1, 2, 3, 4, 5, 6, 7, 8])
          indices = tf.constant([[4], [3], [1], [7]])
          updates = tf.constant([9, 10, 11, 12])
          output = tf.scatter_nd_non_aliasing_add(input, indices, updates)
          with tf.Session() as sess:
          print(sess.run(output))

          The resulting value &lt;code&gt;output&lt;/code&gt; would look like this:

          [1, 13, 3, 14, 14, 6, 7, 20]

          See &lt;code&gt;tf.scatter_nd&lt;/code&gt; for more details about how to make updates to slices.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ScatterNdSub_" data-uid="TensorFlow.TFGraph.ScatterNdSub*"></a>
  <h4 id="TensorFlow_TFGraph_ScatterNdSub_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ScatterNdSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ScatterNdSub(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Applies sparse subtraction between <code>updates</code> and individual values or slices</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ScatterNdSub (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>A mutable Tensor. Should be from a Variable node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A Tensor. Must be one of the following types: int32, int64.
              A tensor of indices into ref.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A Tensor. Must have the same type as ref. A tensor of updated values
              to subtract from ref.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              An optional bool. Defaults to True. If True, the assignment will
              be protected by a lock; otherwise the behavior is undefined,
              but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ScatterNdSub&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as ref. Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ScatterNdSub_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>within a given variable according to <code>indices</code>.</p>
<pre><code>          &lt;code&gt;ref&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; with rank &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q&lt;/code&gt;.

          &lt;code&gt;indices&lt;/code&gt; must be integer tensor, containing indices into &lt;code&gt;ref&lt;/code&gt;.
          It must be shape \\([d_0, ..., d_{Q-2}, K]\\) where &lt;code&gt;0 &amp;lt; K &amp;lt;= P&lt;/code&gt;.

          The innermost dimension of &lt;code&gt;indices&lt;/code&gt; (with length &lt;code&gt;K&lt;/code&gt;) corresponds to
          indices into elements (if &lt;code&gt;K = P&lt;/code&gt;) or slices (if &lt;code&gt;K &amp;lt; P&lt;/code&gt;) along the &lt;code&gt;K&lt;/code&gt;th
          dimension of &lt;code&gt;ref&lt;/code&gt;.

          &lt;code&gt;updates&lt;/code&gt; is &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q-1+P-K&lt;/code&gt; with shape:

          $$[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].$$

          For example, say we want to subtract 4 scattered elements from a rank-1 tensor
          with 8 elements. In Python, that subtraction would look like this:

          ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
          indices = tf.constant([[4], [3], [1], [7]])
          updates = tf.constant([9, 10, 11, 12])
          sub = tf.scatter_nd_sub(ref, indices, updates)
          with tf.Session() as sess:
          print sess.run(sub)

          The resulting update to ref would look like this:

          [1, -9, 3, -6, -4, 6, 7, -4]

          See &lt;code&gt;tf.scatter_nd&lt;/code&gt; for more details about how to make updates to
          slices.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ScatterNdUpdate_" data-uid="TensorFlow.TFGraph.ScatterNdUpdate*"></a>
  <h4 id="TensorFlow_TFGraph_ScatterNdUpdate_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ScatterNdUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ScatterNdUpdate(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Applies sparse <code>updates</code> to individual values or slices within a given</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ScatterNdUpdate (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>A mutable Tensor. Should be from a Variable node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A Tensor. Must be one of the following types: int32, int64.
              A tensor of indices into ref.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A Tensor. Must have the same type as ref. A tensor of updated
              values to add to ref.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              An optional bool. Defaults to True. If True, the assignment will
              be protected by a lock; otherwise the behavior is undefined,
              but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ScatterNdUpdate&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as ref. Returned as a convenience for operations that want to
              use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ScatterNdUpdate_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>variable according to <code>indices</code>.</p>
<pre><code>          &lt;code&gt;ref&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; with rank &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q&lt;/code&gt;.

          &lt;code&gt;indices&lt;/code&gt; must be integer tensor, containing indices into &lt;code&gt;ref&lt;/code&gt;.
          It must be shape \\([d_0, ..., d_{Q-2}, K]\\) where &lt;code&gt;0 &amp;lt; K &amp;lt;= P&lt;/code&gt;.

          The innermost dimension of &lt;code&gt;indices&lt;/code&gt; (with length &lt;code&gt;K&lt;/code&gt;) corresponds to
          indices into elements (if &lt;code&gt;K = P&lt;/code&gt;) or slices (if &lt;code&gt;K &amp;lt; P&lt;/code&gt;) along the &lt;code&gt;K&lt;/code&gt;th
          dimension of &lt;code&gt;ref&lt;/code&gt;.

          &lt;code&gt;updates&lt;/code&gt; is &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q-1+P-K&lt;/code&gt; with shape:

          $$[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].$$

          For example, say we want to update 4 scattered elements to a rank-1 tensor to
          8 elements. In Python, that update would look like this:

           &lt;pre&gt;&lt;code&gt;
          ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])
          indices = tf.constant([[4], [3], [1] ,[7]])
          updates = tf.constant([9, 10, 11, 12])
          update = tf.scatter_nd_update(ref, indices, updates)
          with tf.Session() as sess:
          print sess.run(update)
           &lt;/code&gt;&lt;/pre&gt;

          The resulting update to ref would look like this:

          [1, 11, 3, 10, 9, 6, 7, 12]

          See &lt;code&gt;tf.scatter_nd&lt;/code&gt; for more details about how to make updates to
          slices.

          See also &lt;code&gt;tf.scatter_update&lt;/code&gt; and &lt;code&gt;tf.batch_scatter_update&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ScatterSub_" data-uid="TensorFlow.TFGraph.ScatterSub*"></a>
  <h4 id="TensorFlow_TFGraph_ScatterSub_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ScatterSub(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ScatterSub(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Subtracts sparse updates to a variable reference.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ScatterSub (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of updated values to subtract from <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ScatterSub&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>= Same as <code>ref</code>.  Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ScatterSub_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><pre><code>
              # Scalar indices
              ref[indices, ...] -= updates[...]

              # Vector indices (for each i)
              ref[indices[i], ...] -= updates[i, ...]

              # High rank indices (for each i, ..., j)
              ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]
               </code></pre>

<pre><code>          This operation outputs &lt;code&gt;ref&lt;/code&gt; after the update is done.
          This makes it easier to chain operations that need to use the reset value.

          Duplicate entries are handled correctly: if multiple &lt;code&gt;indices&lt;/code&gt; reference
          the same location, their (negated) contributions add.

          Requires &lt;code&gt;updates.shape = indices.shape + ref.shape[1:]&lt;/code&gt; or &lt;code&gt;updates.shape = []&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/ScatterSub.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ScatterUpdate_" data-uid="TensorFlow.TFGraph.ScatterUpdate*"></a>
  <h4 id="TensorFlow_TFGraph_ScatterUpdate_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ScatterUpdate(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">ScatterUpdate(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Applies sparse updates to a variable reference.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ScatterUpdate (TensorFlow.TFOutput reference, TensorFlow.TFOutput indices, TensorFlow.TFOutput updates, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>Should be from a <code>Variable</code> node.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">updates</span></td>
        <td><p>A tensor of updated values to store in <code>ref</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the assignment will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ScatterUpdate&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>= Same as <code>ref</code>.  Returned as a convenience for operations that want
              to use the updated values after the update is done.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ScatterUpdate_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation computes</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          # Scalar indices
          ref[indices, ...] = updates[...]

          # Vector indices (for each i)
          ref[indices[i], ...] = updates[i, ...]

          # High rank indices (for each i, ..., j)
          ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]
           &lt;/code&gt;&lt;/pre&gt;

          This operation outputs &lt;code&gt;ref&lt;/code&gt; after the update is done.
          This makes it easier to chain operations that need to use the reset value.

          If values in &lt;code&gt;ref&lt;/code&gt; is to be updated more than once, because there are
          duplicate entries in &lt;code&gt;indices&lt;/code&gt;, the order at which the updates happen
          for each value is undefined.

          Requires &lt;code&gt;updates.shape = indices.shape + ref.shape[1:]&lt;/code&gt; or &lt;code&gt;updates.shape = []&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/ScatterUpdate.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;

          See also &lt;code&gt;tf.batch_scatter_update&lt;/code&gt; and &lt;code&gt;tf.scatter_nd_update&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SdcaFprint_" data-uid="TensorFlow.TFGraph.SdcaFprint*"></a>
  <h4 id="TensorFlow_TFGraph_SdcaFprint_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SdcaFprint(TensorFlow.TFOutput,System.String)">SdcaFprint(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes fingerprints of the input strings.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SdcaFprint (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>vector of strings to compute fingerprints on.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SdcaFprint&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>a (N,2) shaped matrix where N is the number of elements in the input
              vector. Each row contains the low and high parts of the fingerprint.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_SdcaOptimizer_" data-uid="TensorFlow.TFGraph.SdcaOptimizer*"></a>
  <h4 id="TensorFlow_TFGraph_SdcaOptimizer_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput_System_String_System_Single_System_Single_System_Int64_System_Int64_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SdcaOptimizer(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput,System.String,System.Single,System.Single,System.Int64,System.Int64,System.Nullable{System.Boolean},System.String)">SdcaOptimizer(TFOutput[], TFOutput[], TFOutput[], TFOutput[], TFOutput, TFOutput, TFOutput[], TFOutput[], TFOutput[], TFOutput, String, Single, Single, Int64, Int64, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Distributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput[],TensorFlow.TFOutput[]&gt; SdcaOptimizer (TensorFlow.TFOutput[] sparse_example_indices, TensorFlow.TFOutput[] sparse_feature_indices, TensorFlow.TFOutput[] sparse_feature_values, TensorFlow.TFOutput[] dense_features, TensorFlow.TFOutput example_weights, TensorFlow.TFOutput example_labels, TensorFlow.TFOutput[] sparse_indices, TensorFlow.TFOutput[] sparse_weights, TensorFlow.TFOutput[] dense_weights, TensorFlow.TFOutput example_state_data, string loss_type, float l1, float l2, long num_loss_partitions, long num_inner_iterations, Nullable&lt;bool&gt; adaptative = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">sparse_example_indices</span></td>
        <td><p>a list of vectors which contain example indices.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">sparse_feature_indices</span></td>
        <td><p>a list of vectors which contain feature indices.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">sparse_feature_values</span></td>
        <td><p>a list of vectors which contains feature value
              associated with each feature group.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">dense_features</span></td>
        <td><p>a list of matrices which contains the dense feature values.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">example_weights</span></td>
        <td><p>a vector which contains the weight associated with each
              example.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">example_labels</span></td>
        <td><p>a vector which contains the label/target associated with each
              example.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">sparse_indices</span></td>
        <td><p>a list of vectors where each value is the indices which has
              corresponding weights in sparse_weights. This field maybe omitted for the
              dense approach.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">sparse_weights</span></td>
        <td><p>a list of vectors where each value is the weight associated with
              a sparse feature group.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">dense_weights</span></td>
        <td><p>a list of vectors where the values are the weights associated
              with a dense feature group.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">example_state_data</span></td>
        <td><p>a list of vectors containing the example state data.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">loss_type</span></td>
        <td><p>Type of the primal loss. Currently SdcaSolver supports logistic,
              squared and hinge losses.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span></td>
        <td><span class="parametername">l1</span></td>
        <td><p>Symmetric l1 regularization strength.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span></td>
        <td><span class="parametername">l2</span></td>
        <td><p>Symmetric l2 regularization strength.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_loss_partitions</span></td>
        <td><p>Number of partitions of the global loss function.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_inner_iterations</span></td>
        <td><p>Number of iterations per mini-batch.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">adaptative</span></td>
        <td><p>Optional argument
              Whether to use Adaptive SDCA for the inner loop.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SdcaOptimizer&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              out_example_state_data: a list of vectors containing the updated example state
              data.
              out_delta_sparse_weights: a list of vectors where each value is the delta
              weights associated with a sparse feature group.
              out_delta_dense_weights: a list of vectors where the values are the delta
              weights associated with a dense feature group.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SdcaOptimizer_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput_System_String_System_Single_System_Single_System_Int64_System_Int64_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>linear models with L1 + L2 regularization. As global optimization objective is
              strongly-convex, the optimizer optimizes the dual objective at each step. The
              optimizer applies each update one example at a time. Examples are sampled
              uniformly, and the optimizer is learning rate free and enjoys linear convergence
              rate.</p>
<pre><code>          [Proximal Stochastic Dual Coordinate Ascent](http://arxiv.org/pdf/1211.2717v1.pdf).&amp;lt;br&amp;gt;
          Shai Shalev-Shwartz, Tong Zhang. 2012

          $$Loss Objective = \sum f_{i} (wx_{i}) + (l2 / 2) * |w|^2 + l1 * |w|$$

          [Adding vs. Averaging in Distributed Primal-Dual Optimization](http://arxiv.org/abs/1502.03508).&amp;lt;br&amp;gt;
          Chenxin Ma, Virginia Smith, Martin Jaggi, Michael I. Jordan,
          Peter Richtarik, Martin Takac. 2015

          [Stochastic Dual Coordinate Ascent with Adaptive Probabilities](https://arxiv.org/abs/1502.08053).&amp;lt;br&amp;gt;
          Dominik Csiba, Zheng Qu, Peter Richtarik. 2015
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SdcaShrinkL1_" data-uid="TensorFlow.TFGraph.SdcaShrinkL1*"></a>
  <h4 id="TensorFlow_TFGraph_SdcaShrinkL1_TensorFlow_TFOutput___System_Single_System_Single_System_String_" data-uid="TensorFlow.TFGraph.SdcaShrinkL1(TensorFlow.TFOutput[],System.Single,System.Single,System.String)">SdcaShrinkL1(TFOutput[], Single, Single, String)</h4>
  <div class="markdown level1 summary"><p>Applies L1 regularization shrink step on the parameters.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation SdcaShrinkL1 (TensorFlow.TFOutput[] weights, float l1, float l2, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">weights</span></td>
        <td><p>a list of vectors where each value is the weight associated with a
              feature group.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span></td>
        <td><span class="parametername">l1</span></td>
        <td><p>Symmetric l1 regularization strength.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Single</span></td>
        <td><span class="parametername">l2</span></td>
        <td><p>Symmetric l2 regularization strength. Should be a positive float.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SdcaShrinkL1&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_SegmentMax_" data-uid="TensorFlow.TFGraph.SegmentMax*"></a>
  <h4 id="TensorFlow_TFGraph_SegmentMax_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SegmentMax(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SegmentMax(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the maximum along segments of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SegmentMax (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A 1-D tensor whose size is equal to the size of <code>data</code>&#39;s
              first dimension.  Values should be sorted and can be repeated.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SegmentMax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for dimension 0 which
              has size <code>k</code>, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SegmentMax_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Read
              <a href="https://tensorflow.org/api_guides/python/math_ops#Segmentation">the section on segmentation</a>
              for an explanation of segments.</p>
<pre><code>          Computes a tensor such that
          \\(output_i = \max_j(data_j)\\) where &lt;code&gt;max&lt;/code&gt; is over &lt;code&gt;j&lt;/code&gt; such
          that &lt;code&gt;segment_ids[j] == i&lt;/code&gt;.

          If the max is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/SegmentMax.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SegmentMean_" data-uid="TensorFlow.TFGraph.SegmentMean*"></a>
  <h4 id="TensorFlow_TFGraph_SegmentMean_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SegmentMean(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SegmentMean(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the mean along segments of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SegmentMean (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A 1-D tensor whose size is equal to the size of <code>data</code>&#39;s
              first dimension.  Values should be sorted and can be repeated.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SegmentMean&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for dimension 0 which
              has size <code>k</code>, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SegmentMean_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Read
              <a href="https://tensorflow.org/api_guides/python/math_ops#Segmentation">the section on segmentation</a>
              for an explanation of segments.</p>
<pre><code>          Computes a tensor such that
          \\(output_i = \frac{\sum_j data_j}{N}\\) where &lt;code&gt;mean&lt;/code&gt; is
          over &lt;code&gt;j&lt;/code&gt; such that &lt;code&gt;segment_ids[j] == i&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; is the total number of
          values summed.

          If the mean is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/SegmentMean.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SegmentMin_" data-uid="TensorFlow.TFGraph.SegmentMin*"></a>
  <h4 id="TensorFlow_TFGraph_SegmentMin_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SegmentMin(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SegmentMin(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the minimum along segments of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SegmentMin (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A 1-D tensor whose size is equal to the size of <code>data</code>&#39;s
              first dimension.  Values should be sorted and can be repeated.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SegmentMin&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for dimension 0 which
              has size <code>k</code>, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SegmentMin_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Read
              <a href="https://tensorflow.org/api_guides/python/math_ops#Segmentation">the section on segmentation</a>
              for an explanation of segments.</p>
<pre><code>          Computes a tensor such that
          \\(output_i = \min_j(data_j)\\) where &lt;code&gt;min&lt;/code&gt; is over &lt;code&gt;j&lt;/code&gt; such
          that &lt;code&gt;segment_ids[j] == i&lt;/code&gt;.

          If the min is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/SegmentMin.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SegmentProd_" data-uid="TensorFlow.TFGraph.SegmentProd*"></a>
  <h4 id="TensorFlow_TFGraph_SegmentProd_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SegmentProd(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SegmentProd(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the product along segments of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SegmentProd (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A 1-D tensor whose size is equal to the size of <code>data</code>&#39;s
              first dimension.  Values should be sorted and can be repeated.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SegmentProd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for dimension 0 which
              has size <code>k</code>, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SegmentProd_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Read
              <a href="https://tensorflow.org/api_guides/python/math_ops#Segmentation">the section on segmentation</a>
              for an explanation of segments.</p>
<pre><code>          Computes a tensor such that
          \\(output_i = \prod_j data_j\\) where the product is over &lt;code&gt;j&lt;/code&gt; such
          that &lt;code&gt;segment_ids[j] == i&lt;/code&gt;.

          If the product is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 1&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/SegmentProd.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SegmentSum_" data-uid="TensorFlow.TFGraph.SegmentSum*"></a>
  <h4 id="TensorFlow_TFGraph_SegmentSum_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SegmentSum(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the sum along segments of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SegmentSum (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A 1-D tensor whose size is equal to the size of <code>data</code>&#39;s
              first dimension.  Values should be sorted and can be repeated.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SegmentSum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for dimension 0 which
              has size <code>k</code>, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SegmentSum_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Read
              <a href="https://tensorflow.org/api_guides/python/math_ops#Segmentation">the section on segmentation</a>
              for an explanation of segments.</p>
<pre><code>          Computes a tensor such that
          \\(output_i = \sum_j data_j\\) where sum is over &lt;code&gt;j&lt;/code&gt; such
          that &lt;code&gt;segment_ids[j] == i&lt;/code&gt;.

          If the sum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/SegmentSum.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Select_" data-uid="TensorFlow.TFGraph.Select*"></a>
  <h4 id="TensorFlow_TFGraph_Select_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Select(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Select(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Selects elements from <code>x</code> or <code>y</code>, depending on <code>condition</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Select (TensorFlow.TFOutput condition, TensorFlow.TFOutput t, TensorFlow.TFOutput e, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">condition</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">t</span></td>
        <td><p>= A <code>Tensor</code> which may have the same shape as <code>condition</code>.
              If <code>condition</code> is rank 1, <code>x</code> may have higher rank,
              but its first dimension must match the size of <code>condition</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">e</span></td>
        <td><p>= A <code>Tensor</code> with the same type and shape as <code>x</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Select&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>= A <code>Tensor</code> with the same type and shape as <code>x</code> and <code>y</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Select_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The <code>x</code>, and <code>y</code> tensors must all have the same shape, and the
              output will also have that shape.</p>
<pre><code>          The &lt;code&gt;condition&lt;/code&gt; tensor must be a scalar if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are scalars.
          If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are vectors or higher rank, then &lt;code&gt;condition&lt;/code&gt; must be either a
          scalar, a vector with size matching the first dimension of &lt;code&gt;x&lt;/code&gt;, or must have
          the same shape as &lt;code&gt;x&lt;/code&gt;.

          The &lt;code&gt;condition&lt;/code&gt; tensor acts as a mask that chooses, based on the value at each
          element, whether the corresponding element / row in the output should be
          taken from &lt;code&gt;x&lt;/code&gt; (if true) or &lt;code&gt;y&lt;/code&gt; (if false).

          If &lt;code&gt;condition&lt;/code&gt; is a vector and &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are higher rank matrices, then
          it chooses which row (outer dimension) to copy from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.
          If &lt;code&gt;condition&lt;/code&gt; has the same shape as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, then it chooses which
          element to copy from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.

          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;condition&#39; tensor is [[True,  False]
          #                        [False, True]]
          # &#39;t&#39; is [[1, 2],
          #         [3, 4]]
          # &#39;e&#39; is [[5, 6],
          #         [7, 8]]
          select(condition, t, e)  # =&amp;gt; [[1, 6], [7, 4]]


          # &#39;condition&#39; tensor is [True, False]
          # &#39;t&#39; is [[1, 2],
          #         [3, 4]]
          # &#39;e&#39; is [[5, 6],
          #         [7, 8]]
          select(condition, t, e) ==&amp;gt; [[1, 2],
          [7, 8]]

           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SelfAdjointEig_" data-uid="TensorFlow.TFGraph.SelfAdjointEig*"></a>
  <h4 id="TensorFlow_TFGraph_SelfAdjointEig_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SelfAdjointEig(TensorFlow.TFOutput,System.String)">SelfAdjointEig(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the Eigen Decomposition of a batch of square self-adjoint matrices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SelfAdjointEig (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>Shape is <code>[..., M, M]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SelfAdjointEig&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Shape is <code>[..., M+1, M]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SelfAdjointEig_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
              form square matrices, with the same constraints as the single matrix
              SelfAdjointEig.</p>
<pre><code>          The result is a [..., M+1, M] matrix with [..., 0,:] containing the
          eigenvalues, and subsequent [...,1:, :] containing the eigenvectors. The eigenvalues
          are sorted in non-decreasing order.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SelfAdjointEigV2_" data-uid="TensorFlow.TFGraph.SelfAdjointEigV2*"></a>
  <h4 id="TensorFlow_TFGraph_SelfAdjointEigV2_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SelfAdjointEigV2(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SelfAdjointEigV2(TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the eigen decomposition of one or more square self-adjoint matrices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SelfAdjointEigV2 (TensorFlow.TFOutput input, Nullable&lt;bool&gt; compute_v = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p><code>Tensor</code> input of shape <code>[N, N]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">compute_v</span></td>
        <td><p>Optional argument
              If <code>True</code> then eigenvectors will be computed and returned in <code>v</code>.
              Otherwise, only the eigenvalues will be computed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SelfAdjointEigV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              e: Eigenvalues. Shape is <code>[N]</code>.
              v: Eigenvectors. Shape is <code>[N, N]</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SelfAdjointEigV2_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the eigenvalues and (optionally) eigenvectors of each inner matrix in
              <code>input</code> such that <code>input[..., :, :] = v[..., :, :] * diag(e[..., :])</code>. The eigenvalues
              are sorted in non-decreasing order.</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          # a is a tensor.
          # e is a tensor of eigenvalues.
          # v is a tensor of eigenvectors.
          e, v = self_adjoint_eig(a)
          e = self_adjoint_eig(a, compute_v=False)
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Selu_" data-uid="TensorFlow.TFGraph.Selu*"></a>
  <h4 id="TensorFlow_TFGraph_Selu_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Selu(TensorFlow.TFOutput,System.String)">Selu(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes scaled exponential linear: <code>scale * alpha * (exp(features) - 1)</code></p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Selu (TensorFlow.TFOutput features, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Selu&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Selu_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>if &lt; 0, <code>scale * features</code> otherwise.</p>
<pre><code>          To be used together with
          &lt;code&gt;initializer = tf.variance_scaling_initializer(factor=1.0, mode=&#39;FAN_IN&#39;)&lt;/code&gt;.
          For correct dropout, use &lt;code&gt;tf.contrib.nn.alpha_dropout&lt;/code&gt;.

          See [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SeluGrad_" data-uid="TensorFlow.TFGraph.SeluGrad*"></a>
  <h4 id="TensorFlow_TFGraph_SeluGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SeluGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SeluGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes gradients for the scaled exponential linear (Selu) operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SeluGrad (TensorFlow.TFOutput gradients, TensorFlow.TFOutput outputs, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradients</span></td>
        <td><p>The backpropagated gradients to the corresponding Selu operation.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">outputs</span></td>
        <td><p>The outputs of the corresponding Selu operation.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SeluGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The gradients: <code>gradients * (outputs + scale * alpha)</code>
              if outputs &lt; 0, <code>scale * gradients</code> otherwise.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_SendTPUEmbeddingGradients_" data-uid="TensorFlow.TFGraph.SendTPUEmbeddingGradients*"></a>
  <h4 id="TensorFlow_TFGraph_SendTPUEmbeddingGradients_TensorFlow_TFOutput___TensorFlow_TFOutput___System_String_System_String_" data-uid="TensorFlow.TFGraph.SendTPUEmbeddingGradients(TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String,System.String)">SendTPUEmbeddingGradients(TFOutput[], TFOutput[], String, String)</h4>
  <div class="markdown level1 summary"><p>An op that performs gradient updates of embedding tables.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation SendTPUEmbeddingGradients (TensorFlow.TFOutput[] inputs, TensorFlow.TFOutput[] learning_rates, string config, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>A TensorList of gradients with which to update embedding tables.
              It contains one tensor per embedding table in the model.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">learning_rates</span></td>
        <td><p>A list of float32 scalars, one for each embedding table,
              containing the learning rates for each table when dynamic learning rate is
              enabled through the OptimizationParameters in TPUEmbeddingConfiguration.
              When the learning rate is constant, the list should be empty.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">config</span></td>
        <td><p>Serialized TPUEmbeddingConfiguration proto.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SendTPUEmbeddingGradients&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SendTPUEmbeddingGradients_TensorFlow_TFOutput___TensorFlow_TFOutput___System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The TensorList argument has the same length and shapes as the return value of
              TPUEmbeddingReceiveActivations, but contains gradients of the model&#39;s loss
              with respect to the embedding activations. The embedding tables are updated
              from these gradients via the optimizer specified in the configuration given
              to tpu.initialize_system.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SerializeIterator_" data-uid="TensorFlow.TFGraph.SerializeIterator*"></a>
  <h4 id="TensorFlow_TFGraph_SerializeIterator_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SerializeIterator(TensorFlow.TFOutput,System.String)">SerializeIterator(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Converts the given <code>resource_handle</code> representing an iterator to a variant tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SerializeIterator (TensorFlow.TFOutput resource_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource_handle</span></td>
        <td><p>A handle to an iterator resource.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SerializeIterator&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A variant tensor storing the state of the iterator contained in the
              resource.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_SerializeManySparse_" data-uid="TensorFlow.TFGraph.SerializeManySparse*"></a>
  <h4 id="TensorFlow_TFGraph_SerializeManySparse_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.SerializeManySparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">SerializeManySparse(TFOutput, TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Serialize an <code>N</code>-minibatch <code>SparseTensor</code> into an <code>[N, 3]</code><code>Tensor</code> object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SerializeManySparse (TensorFlow.TFOutput sparse_indices, TensorFlow.TFOutput sparse_values, TensorFlow.TFOutput sparse_shape, Nullable&lt;TensorFlow.TFDataType&gt; out_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_indices</span></td>
        <td><p>2-D.  The <code>indices</code> of the minibatch <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_values</span></td>
        <td><p>1-D.  The <code>values</code> of the minibatch <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_shape</span></td>
        <td><p>1-D.  The <code>shape</code> of the minibatch <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_type</span></td>
        <td><p>Optional argument
              The <code>dtype</code> to use for serialization; the supported types are <code>string</code>
              (default) and <code>variant</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SerializeManySparse&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SerializeManySparse_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The <code>SparseTensor</code> must have rank <code>R</code> greater than 1, and the first dimension
              is treated as the minibatch dimension.  Elements of the <code>SparseTensor</code>
              must be sorted in increasing order of this first dimension.  The serialized
              <code>SparseTensor</code> objects going into each row of <code>serialized_sparse</code> will have
              rank <code>R-1</code>.</p>
<pre><code>          The minibatch size &lt;code&gt;N&lt;/code&gt; is extracted from &lt;code&gt;sparse_shape[0]&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SerializeSparse_" data-uid="TensorFlow.TFGraph.SerializeSparse*"></a>
  <h4 id="TensorFlow_TFGraph_SerializeSparse_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.SerializeSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">SerializeSparse(TFOutput, TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Serialize a <code>SparseTensor</code> into a <code>[3]</code><code>Tensor</code> object.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SerializeSparse (TensorFlow.TFOutput sparse_indices, TensorFlow.TFOutput sparse_values, TensorFlow.TFOutput sparse_shape, Nullable&lt;TensorFlow.TFDataType&gt; out_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_indices</span></td>
        <td><p>2-D.  The <code>indices</code> of the <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_values</span></td>
        <td><p>1-D.  The <code>values</code> of the <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_shape</span></td>
        <td><p>1-D.  The <code>shape</code> of the <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_type</span></td>
        <td><p>Optional argument
              The <code>dtype</code> to use for serialization; the supported types are <code>string</code>
              (default) and <code>variant</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SerializeSparse&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_SerializeTensor_" data-uid="TensorFlow.TFGraph.SerializeTensor*"></a>
  <h4 id="TensorFlow_TFGraph_SerializeTensor_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SerializeTensor(TensorFlow.TFOutput,System.String)">SerializeTensor(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Transforms a Tensor into a serialized TensorProto proto.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SerializeTensor (TensorFlow.TFOutput tensor, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>A Tensor of type <code>T</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SerializeTensor&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A serialized TensorProto proto of the input tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_SetSize_" data-uid="TensorFlow.TFGraph.SetSize*"></a>
  <h4 id="TensorFlow_TFGraph_SetSize_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SetSize(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SetSize(TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Number of unique elements along last dimension of input <code>set</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SetSize (TensorFlow.TFOutput set_indices, TensorFlow.TFOutput set_values, TensorFlow.TFOutput set_shape, Nullable&lt;bool&gt; validate_indices = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set_indices</span></td>
        <td><p>2D <code>Tensor</code>, indices of a <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set_values</span></td>
        <td><p>1D <code>Tensor</code>, values of a <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set_shape</span></td>
        <td><p>1D <code>Tensor</code>, shape of a <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">validate_indices</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SetSize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>For <code>set</code> ranked <code>n</code>, this is a <code>Tensor</code> with rank <code>n-1</code>, and the same 1st
              <code>n-1</code> dimensions as <code>set</code>. Each value is the number of unique elements in
              the corresponding <code>[0...n-1]</code> dimension of <code>set</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SetSize_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Input <code>set</code> is a <code>SparseTensor</code> represented by <code>set_indices</code>, <code>set_values</code>,
              and <code>set_shape</code>. The last dimension contains values in a set, duplicates are
              allowed but ignored.</p>
<pre><code>          If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this op validates the order and range of &lt;code&gt;set&lt;/code&gt;
          indices.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SetTensorShape_" data-uid="TensorFlow.TFGraph.SetTensorShape*"></a>
  <h4 id="TensorFlow_TFGraph_SetTensorShape_TensorFlow_TFOutput_System_Int64___TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.SetTensorShape(TensorFlow.TFOutput,System.Int64[],TensorFlow.TFStatus)">SetTensorShape(TFOutput, Int64[], TFStatus)</h4>
  <div class="markdown level1 summary"><p>Sets the tensor shape of the tensor referenced by <code>output</code> to the shape described by <code>dims</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void SetTensorShape (TensorFlow.TFOutput output, long[] dims, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output</span></td>
        <td><p>The tensor on which this method will operate in the graph.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">dims</span></td>
        <td><p>The tensor shape, specified as an array of dimensions.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Shape_" data-uid="TensorFlow.TFGraph.Shape*"></a>
  <h4 id="TensorFlow_TFGraph_Shape_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.Shape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">Shape(TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns the shape of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Shape (TensorFlow.TFOutput input, Nullable&lt;TensorFlow.TFDataType&gt; out_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Shape&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Shape_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation returns a 1-D integer tensor representing the shape of <code>input</code>.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;t&#39; is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
          shape(t) ==&amp;gt; [2, 2, 3]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ShapeN_" data-uid="TensorFlow.TFGraph.ShapeN*"></a>
  <h4 id="TensorFlow_TFGraph_ShapeN_TensorFlow_TFOutput___System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.ShapeN(TensorFlow.TFOutput[],System.Nullable{TensorFlow.TFDataType},System.String)">ShapeN(TFOutput[], Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns shape of tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] ShapeN (TensorFlow.TFOutput[] input, Nullable&lt;TensorFlow.TFDataType&gt; out_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ShapeN&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ShapeN_TensorFlow_TFOutput___System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation returns N 1-D integer tensors representing shape of <code>input[i]s</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ShardedFilename_" data-uid="TensorFlow.TFGraph.ShardedFilename*"></a>
  <h4 id="TensorFlow_TFGraph_ShardedFilename_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ShardedFilename(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ShardedFilename(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Generate a sharded filename. The filename is printf formatted as</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ShardedFilename (TensorFlow.TFOutput basename, TensorFlow.TFOutput shard, TensorFlow.TFOutput num_shards, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">basename</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shard</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ShardedFilename&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ShardedFilename_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>%s-%05d-of-%05d, basename, shard, num_shards.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ShardedFilespec_" data-uid="TensorFlow.TFGraph.ShardedFilespec*"></a>
  <h4 id="TensorFlow_TFGraph_ShardedFilespec_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ShardedFilespec(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">ShardedFilespec(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Generate a glob pattern matching all sharded file names.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ShardedFilespec (TensorFlow.TFOutput basename, TensorFlow.TFOutput num_shards, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">basename</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_shards</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ShardedFilespec&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ShuffleAndRepeatDataset_" data-uid="TensorFlow.TFGraph.ShuffleAndRepeatDataset*"></a>
  <h4 id="TensorFlow_TFGraph_ShuffleAndRepeatDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.ShuffleAndRepeatDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">ShuffleAndRepeatDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that shuffles and repeats elements from <code>input_dataset</code></p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ShuffleAndRepeatDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput buffer_size, TensorFlow.TFOutput seed, TensorFlow.TFOutput seed2, TensorFlow.TFOutput count, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">buffer_size</span></td>
        <td><p>The number of output elements to buffer in an iterator over
              this dataset. Compare with the <code>min_after_dequeue</code> attr when creating a
              <code>RandomShuffleQueue</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">seed</span></td>
        <td><p>A scalar seed for the random number generator. If either <code>seed</code> or
              <code>seed2</code> is set to be non-zero, the random number generator is seeded
              by the given seed.  Otherwise, a random seed is used.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">seed2</span></td>
        <td><p>A second scalar seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">count</span></td>
        <td><p>A scalar representing the number of times the underlying dataset
              should be repeated. The default is <code>-1</code>, which results in infinite repetition.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ShuffleAndRepeatDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ShuffleAndRepeatDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>pseudorandomly.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_ShuffleDataset_" data-uid="TensorFlow.TFGraph.ShuffleDataset*"></a>
  <h4 id="TensorFlow_TFGraph_ShuffleDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.ShuffleDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.Nullable{System.Boolean},System.String)">ShuffleDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that shuffles elements from <code>input_dataset</code> pseudorandomly.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ShuffleDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput buffer_size, TensorFlow.TFOutput seed, TensorFlow.TFOutput seed2, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, Nullable&lt;bool&gt; reshuffle_each_iteration = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">buffer_size</span></td>
        <td><p>The number of output elements to buffer in an iterator over
              this dataset. Compare with the <code>min_after_dequeue</code> attr when creating a
              <code>RandomShuffleQueue</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">seed</span></td>
        <td><p>A scalar seed for the random number generator. If either <code>seed</code> or
              <code>seed2</code> is set to be non-zero, the random number generator is seeded
              by the given seed.  Otherwise, a random seed is used.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">seed2</span></td>
        <td><p>A second scalar seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">reshuffle_each_iteration</span></td>
        <td><p>Optional argument
              If true, each iterator over this dataset will be given
              a different pseudorandomly generated seed, based on a sequence seeded by the
              <code>seed</code> and <code>seed2</code> inputs. If false, each iterator will be given the same
              seed, and repeated iteration over this dataset will yield the exact same
              sequence of results.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ShuffleDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ShutdownDistributedTPU_" data-uid="TensorFlow.TFGraph.ShutdownDistributedTPU*"></a>
  <h4 id="TensorFlow_TFGraph_ShutdownDistributedTPU_System_String_" data-uid="TensorFlow.TFGraph.ShutdownDistributedTPU(System.String)">ShutdownDistributedTPU(String)</h4>
  <div class="markdown level1 summary"><p>An op that shuts down a running distributed TPU system. The Op returns</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation ShutdownDistributedTPU (string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ShutdownDistributedTPU&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ShutdownDistributedTPU_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>an error if no system is running.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Sigmoid_" data-uid="TensorFlow.TFGraph.Sigmoid*"></a>
  <h4 id="TensorFlow_TFGraph_Sigmoid_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Sigmoid(TensorFlow.TFOutput,System.String)">Sigmoid(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes sigmoid of <code>x</code> element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Sigmoid (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Sigmoid&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Sigmoid_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Specifically, <code>y = 1 / (1 + exp(-x))</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SigmoidCrossEntropyWithLogits_" data-uid="TensorFlow.TFGraph.SigmoidCrossEntropyWithLogits*"></a>
  <h4 id="TensorFlow_TFGraph_SigmoidCrossEntropyWithLogits_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SigmoidCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SigmoidCrossEntropyWithLogits(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes sigmoid cross entropy given <code>logits</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SigmoidCrossEntropyWithLogits (TensorFlow.TFOutput labels, TensorFlow.TFOutput logits, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">labels</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">logits</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SigmoidCrossEntropyWithLogits_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Measures the probability error in discrete classification tasks in which each
               class is independent and not mutually exclusive.For instance, one could
               perform multilabel classification where a picture can contain both an elephant
               and a dog at the same time.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SigmoidGrad_" data-uid="TensorFlow.TFGraph.SigmoidGrad*"></a>
  <h4 id="TensorFlow_TFGraph_SigmoidGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SigmoidGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SigmoidGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradient of the sigmoid of <code>x</code> wrt its input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SigmoidGrad (TensorFlow.TFOutput y, TensorFlow.TFOutput dy, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dy</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SigmoidGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SigmoidGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Specifically, <code>grad = dy * y * (1 - y)</code>, where <code>y = sigmoid(x)</code>, and
              <code>dy</code> is the corresponding input gradient.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Sign_" data-uid="TensorFlow.TFGraph.Sign*"></a>
  <h4 id="TensorFlow_TFGraph_Sign_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Sign(TensorFlow.TFOutput,System.String)">Sign(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns an element-wise indication of the sign of a number.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Sign (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Sign&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Sign_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>y = sign(x) = -1</code> if <code>x &lt; 0</code>; 0 if <code>x == 0</code>; 1 if <code>x &gt; 0</code>.</p>
<pre><code>          For complex numbers, &lt;code&gt;y = sign(x) = x / |x|&lt;/code&gt; if &lt;code&gt;x != 0&lt;/code&gt;, otherwise &lt;code&gt;y = 0&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Sin_" data-uid="TensorFlow.TFGraph.Sin*"></a>
  <h4 id="TensorFlow_TFGraph_Sin_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Sin(TensorFlow.TFOutput,System.String)">Sin(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes sin of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Sin (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Sin&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Sinh_" data-uid="TensorFlow.TFGraph.Sinh*"></a>
  <h4 id="TensorFlow_TFGraph_Sinh_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Sinh(TensorFlow.TFOutput,System.String)">Sinh(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes hyperbolic sine of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Sinh (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Sinh&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Size_" data-uid="TensorFlow.TFGraph.Size*"></a>
  <h4 id="TensorFlow_TFGraph_Size_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.Size(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">Size(TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns the size of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Size (TensorFlow.TFOutput input, Nullable&lt;TensorFlow.TFDataType&gt; out_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Size&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Size_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation returns an integer representing the number of elements in
              <code>input</code>.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;t&#39; is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]
          size(t) ==&amp;gt; 12
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SkipDataset_" data-uid="TensorFlow.TFGraph.SkipDataset*"></a>
  <h4 id="TensorFlow_TFGraph_SkipDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.SkipDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">SkipDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that skips <code>count</code> elements from the <code>input_dataset</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SkipDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput count, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">count</span></td>
        <td><p>A scalar representing the number of elements from the <code>input_dataset</code>
              that should be skipped.  If count is -1, skips everything.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SkipDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Skipgram_" data-uid="TensorFlow.TFGraph.Skipgram*"></a>
  <h4 id="TensorFlow_TFGraph_Skipgram_System_String_System_Int64_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Single__System_String_" data-uid="TensorFlow.TFGraph.Skipgram(System.String,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Single},System.String)">Skipgram(String, Int64, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Single&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Parses a text file and creates a batch of examples.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; Skipgram (string filename, long batch_size, Nullable&lt;long&gt; window_size = null, Nullable&lt;long&gt; min_count = null, Nullable&lt;float&gt; subsample = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">filename</span></td>
        <td><p>The corpus&#39;s text file name.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">batch_size</span></td>
        <td><p>The size of produced batch.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">window_size</span></td>
        <td><p>Optional argument
              The number of words to predict to the left and right of the target.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">min_count</span></td>
        <td><p>Optional argument
              The minimum number of word occurrences for it to be included in the
              vocabulary.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Single</span>&gt;</td>
        <td><span class="parametername">subsample</span></td>
        <td><p>Optional argument
              Threshold for word occurrence. Words that appear with higher
              frequency will be randomly down-sampled. Set to 0 to disable.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Skipgram&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              vocab_word: A vector of words in the corpus.
              vocab_freq: Frequencies of words. Sorted in the non-ascending order.
              words_per_epoch: Number of words per epoch in the data file.
              current_epoch: The current epoch number.
              total_words_processed: The total number of words processed so far.
              examples: A vector of word ids.
              labels: A vector of word ids.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Slice_" data-uid="TensorFlow.TFGraph.Slice*"></a>
  <h4 id="TensorFlow_TFGraph_Slice_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Slice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Slice(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Return a slice from &#39;input&#39;.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Slice (TensorFlow.TFOutput input, TensorFlow.TFOutput begin, TensorFlow.TFOutput size, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">begin</span></td>
        <td><p>begin[i] specifies the offset into the &#39;i&#39;th dimension of
              &#39;input&#39; to slice from.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>size[i] specifies the number of elements of the &#39;i&#39;th dimension
              of &#39;input&#39; to slice. If size[i] is -1, all remaining elements in dimension
              i are included in the slice (i.e. this is equivalent to setting
              size[i] = input.dim_size(i) - begin[i]).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Slice&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Slice_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The output tensor is a tensor with dimensions described by &#39;size&#39;
              whose values are extracted from &#39;input&#39; starting at the offsets in
              &#39;begin&#39;.</p>
<pre><code>          *Requirements*:
          0 &amp;lt;= begin[i] &amp;lt;= begin[i] + size[i] &amp;lt;= Di  for i in [0, n)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Snapshot_" data-uid="TensorFlow.TFGraph.Snapshot*"></a>
  <h4 id="TensorFlow_TFGraph_Snapshot_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Snapshot(TensorFlow.TFOutput,System.String)">Snapshot(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns a copy of the input tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Snapshot (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Snapshot&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Softmax_" data-uid="TensorFlow.TFGraph.Softmax*"></a>
  <h4 id="TensorFlow_TFGraph_Softmax_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Softmax(TensorFlow.TFOutput,System.String)">Softmax(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes softmax activations.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Softmax (TensorFlow.TFOutput logits, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">logits</span></td>
        <td><p>2-D with shape <code>[batch_size, num_classes]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Softmax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same shape as <code>logits</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Softmax_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>For each batch <code>i</code> and class <code>j</code> we have</p>
<pre><code>          $$softmax[i, j] = exp(logits[i, j]) / sum_j(exp(logits[i, j]))$$
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SoftmaxCrossEntropyWithLogits_" data-uid="TensorFlow.TFGraph.SoftmaxCrossEntropyWithLogits*"></a>
  <h4 id="TensorFlow_TFGraph_SoftmaxCrossEntropyWithLogits_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SoftmaxCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes softmax cross entropy cost and gradients to backpropagate.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SoftmaxCrossEntropyWithLogits (TensorFlow.TFOutput features, TensorFlow.TFOutput labels, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>batch_size x num_classes matrix</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">labels</span></td>
        <td><p>batch_size x num_classes matrix
              The caller must ensure that each batch of labels represents a valid
              probability distribution.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SoftmaxCrossEntropyWithLogits&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              loss: Per example loss (batch_size vector).
              backprop: backpropagated gradients (batch_size x num_classes matrix).
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SoftmaxCrossEntropyWithLogits_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Inputs are the logits, not probabilities.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Softplus_" data-uid="TensorFlow.TFGraph.Softplus*"></a>
  <h4 id="TensorFlow_TFGraph_Softplus_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Softplus(TensorFlow.TFOutput,System.String)">Softplus(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes softplus: <code>log(exp(features) + 1)</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Softplus (TensorFlow.TFOutput features, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Softplus&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_SoftplusGrad_" data-uid="TensorFlow.TFGraph.SoftplusGrad*"></a>
  <h4 id="TensorFlow_TFGraph_SoftplusGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SoftplusGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SoftplusGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes softplus gradients for a softplus operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SoftplusGrad (TensorFlow.TFOutput gradients, TensorFlow.TFOutput features, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradients</span></td>
        <td><p>The backpropagated gradients to the corresponding softplus operation.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>The features passed as input to the corresponding softplus operation.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SoftplusGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The gradients: <code>gradients / (1 + exp(-features))</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Softsign_" data-uid="TensorFlow.TFGraph.Softsign*"></a>
  <h4 id="TensorFlow_TFGraph_Softsign_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Softsign(TensorFlow.TFOutput,System.String)">Softsign(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes softsign: <code>features / (abs(features) + 1)</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Softsign (TensorFlow.TFOutput features, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Softsign&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_SoftsignGrad_" data-uid="TensorFlow.TFGraph.SoftsignGrad*"></a>
  <h4 id="TensorFlow_TFGraph_SoftsignGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SoftsignGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SoftsignGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes softsign gradients for a softsign operation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SoftsignGrad (TensorFlow.TFOutput gradients, TensorFlow.TFOutput features, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradients</span></td>
        <td><p>The backpropagated gradients to the corresponding softsign operation.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>The features passed as input to the corresponding softsign operation.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SoftsignGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The gradients: <code>gradients / (1 + abs(features)) ** 2</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_SpaceToBatch_" data-uid="TensorFlow.TFGraph.SpaceToBatch*"></a>
  <h4 id="TensorFlow_TFGraph_SpaceToBatch_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.SpaceToBatch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">SpaceToBatch(TFOutput, TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>SpaceToBatch for 4-D tensors of type T.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SpaceToBatch (TensorFlow.TFOutput input, TensorFlow.TFOutput paddings, long block_size, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>4-D with shape <code>[batch, height, width, depth]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">paddings</span></td>
        <td><p>2-D tensor of non-negative integers with shape <code>[2, 2]</code>. It specifies
              the padding of the input with zeros across the spatial dimensions as follows:</p>
<pre><code>          paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]

          The effective spatial dimensions of the zero-padded input tensor will be:

          height_pad = pad_top + height + pad_bottom
          width_pad = pad_left + width + pad_right

          The attr &lt;code&gt;block_size&lt;/code&gt; must be greater than one. It indicates the block size.

          * Non-overlapping blocks of size &lt;code&gt;block_size x block size&lt;/code&gt; in the height and
          width dimensions are rearranged into the batch dimension at each location.
          * The batch of the output tensor is &lt;code&gt;batch * block_size * block_size&lt;/code&gt;.
          * Both height_pad and width_pad must be divisible by block_size.

          The shape of the output will be:

          [batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
          depth]

          Some examples:

          (1) For the following input of shape &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt; and block_size of 2:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1], [2]], [[3], [4]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[4, 1, 1, 1]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
           &lt;/code&gt;&lt;/pre&gt;

          (2) For the following input of shape &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt; and block_size of 2:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1, 2, 3], [4, 5, 6]],
          [[7, 8, 9], [10, 11, 12]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[4, 1, 1, 3]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
           &lt;/code&gt;&lt;/pre&gt;

          (3) For the following input of shape &lt;code&gt;[1, 4, 4, 1]&lt;/code&gt; and block_size of 2:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1],   [2],  [3],  [4]],
          [[5],   [6],  [7],  [8]],
          [[9],  [10], [11],  [12]],
          [[13], [14], [15],  [16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[4, 2, 2, 1]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1], [3]], [[9], [11]]],
          [[[2], [4]], [[10], [12]]],
          [[[5], [7]], [[13], [15]]],
          [[[6], [8]], [[14], [16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          (4) For the following input of shape &lt;code&gt;[2, 2, 4, 1]&lt;/code&gt; and block_size of 2:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1],   [2],  [3],  [4]],
          [[5],   [6],  [7],  [8]]],
          [[[9],  [10], [11],  [12]],
          [[13], [14], [15],  [16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[8, 1, 2, 1]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],
          [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          Among others, this operation is useful for reducing atrous convolution into
          regular convolution.
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">block_size</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SpaceToBatch&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SpaceToBatch_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This is a legacy version of the more general SpaceToBatchND.</p>
<pre><code>          Zero-pads and then rearranges (permutes) blocks of spatial data into batch.
          More specifically, this op outputs a copy of the input tensor where values from
          the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; dimensions are moved to the &lt;code&gt;batch&lt;/code&gt; dimension. After
          the zero-padding, both &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; of the input must be divisible by the
          block size.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SpaceToBatchND_" data-uid="TensorFlow.TFGraph.SpaceToBatchND*"></a>
  <h4 id="TensorFlow_TFGraph_SpaceToBatchND_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SpaceToBatchND(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SpaceToBatchND(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>SpaceToBatch for N-D tensors of type T.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SpaceToBatchND (TensorFlow.TFOutput input, TensorFlow.TFOutput block_shape, TensorFlow.TFOutput paddings, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>N-D with shape <code>input_shape = [batch] + spatial_shape + remaining_shape</code>,
              where spatial_shape has <code>M</code> dimensions.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">block_shape</span></td>
        <td><p>1-D with shape <code>[M]</code>, all values must be &gt;= 1.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">paddings</span></td>
        <td><p>2-D with shape <code>[M, 2]</code>, all values must be &gt;= 0.
              <code>paddings[i] = [pad_start, pad_end]</code> specifies the padding for input dimension
              <code>i + 1</code>, which corresponds to spatial dimension <code>i</code>.  It is required that
              <code>block_shape[i]</code> divides <code>input_shape[i + 1] + pad_start + pad_end</code>.</p>
<pre><code>          This operation is equivalent to the following steps:

          1. Zero-pad the start and end of dimensions &lt;code&gt;[1, ..., M]&lt;/code&gt; of the
          input according to &lt;code&gt;paddings&lt;/code&gt; to produce &lt;code&gt;padded&lt;/code&gt; of shape &lt;code&gt;padded_shape&lt;/code&gt;.

          2. Reshape &lt;code&gt;padded&lt;/code&gt; to &lt;code&gt;reshaped_padded&lt;/code&gt; of shape:

          [batch] +
          [padded_shape[1] / block_shape[0],
          block_shape[0],
          ...,
          padded_shape[M] / block_shape[M-1],
          block_shape[M-1]] +
          remaining_shape

          3. Permute dimensions of &lt;code&gt;reshaped_padded&lt;/code&gt; to produce
          &lt;code&gt;permuted_reshaped_padded&lt;/code&gt; of shape:

          block_shape +
          [batch] +
          [padded_shape[1] / block_shape[0],
          ...,
          padded_shape[M] / block_shape[M-1]] +
          remaining_shape

          4. Reshape &lt;code&gt;permuted_reshaped_padded&lt;/code&gt; to flatten &lt;code&gt;block_shape&lt;/code&gt; into the batch
          dimension, producing an output tensor of shape:

          [batch * prod(block_shape)] +
          [padded_shape[1] / block_shape[0],
          ...,
          padded_shape[M] / block_shape[M-1]] +
          remaining_shape

          Some examples:

          (1) For the following input of shape &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt;, &lt;code&gt;block_shape = [2, 2]&lt;/code&gt;, and
          &lt;code&gt;paddings = [[0, 0], [0, 0]]&lt;/code&gt;:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1], [2]], [[3], [4]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[4, 1, 1, 1]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          [[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
           &lt;/code&gt;&lt;/pre&gt;

          (2) For the following input of shape &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt;, &lt;code&gt;block_shape = [2, 2]&lt;/code&gt;, and
          &lt;code&gt;paddings = [[0, 0], [0, 0]]&lt;/code&gt;:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1, 2, 3], [4, 5, 6]],
          [[7, 8, 9], [10, 11, 12]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[4, 1, 1, 3]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
           &lt;/code&gt;&lt;/pre&gt;

          (3) For the following input of shape &lt;code&gt;[1, 4, 4, 1]&lt;/code&gt;, &lt;code&gt;block_shape = [2, 2]&lt;/code&gt;, and
          &lt;code&gt;paddings = [[0, 0], [0, 0]]&lt;/code&gt;:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1],   [2],  [3],  [4]],
          [[5],   [6],  [7],  [8]],
          [[9],  [10], [11],  [12]],
          [[13], [14], [15],  [16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[4, 2, 2, 1]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1], [3]], [[9], [11]]],
          [[[2], [4]], [[10], [12]]],
          [[[5], [7]], [[13], [15]]],
          [[[6], [8]], [[14], [16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          (4) For the following input of shape &lt;code&gt;[2, 2, 4, 1]&lt;/code&gt;, block_shape = &lt;code&gt;[2, 2]&lt;/code&gt;, and
          paddings = &lt;code&gt;[[0, 0], [2, 0]]&lt;/code&gt;:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1],   [2],  [3],  [4]],
          [[5],   [6],  [7],  [8]]],
          [[[9],  [10], [11],  [12]],
          [[13], [14], [15],  [16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          The output tensor has shape &lt;code&gt;[8, 1, 3, 1]&lt;/code&gt; and value:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[0], [1], [3]]], [[[0], [9], [11]]],
          [[[0], [2], [4]]], [[[0], [10], [12]]],
          [[[0], [5], [7]]], [[[0], [13], [15]]],
          [[[0], [6], [8]]], [[[0], [14], [16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          Among others, this operation is useful for reducing atrous convolution into
          regular convolution.
</code></pre></td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SpaceToBatchND&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SpaceToBatchND_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation divides &quot;spatial&quot; dimensions <code>[1, ..., M]</code> of the input into a
              grid of blocks of shape <code>block_shape</code>, and interleaves these blocks with the
              &quot;batch&quot; dimension (0) such that in the output, the spatial dimensions
              <code>[1, ..., M]</code> correspond to the position within the grid, and the batch
              dimension combines both the position within a spatial block and the original
              batch position.  Prior to division into blocks, the spatial dimensions of the
              input are optionally zero padded according to <code>paddings</code>.  See below for a
              precise description.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SpaceToDepth_" data-uid="TensorFlow.TFGraph.SpaceToDepth*"></a>
  <h4 id="TensorFlow_TFGraph_SpaceToDepth_TensorFlow_TFOutput_System_Int64_System_String_System_String_" data-uid="TensorFlow.TFGraph.SpaceToDepth(TensorFlow.TFOutput,System.Int64,System.String,System.String)">SpaceToDepth(TFOutput, Int64, String, String)</h4>
  <div class="markdown level1 summary"><p>SpaceToDepth for tensors of type T.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SpaceToDepth (TensorFlow.TFOutput input, long block_size, string data_format = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">block_size</span></td>
        <td><p>The size of the spatial block.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">data_format</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SpaceToDepth&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SpaceToDepth_TensorFlow_TFOutput_System_Int64_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Rearranges blocks of spatial data, into depth. More specifically,
              this op outputs a copy of the input tensor where values from the <code>height</code>
              and <code>width</code> dimensions are moved to the <code>depth</code> dimension.
              The attr <code>block_size</code> indicates the input block size.</p>
<pre><code>          * Non-overlapping blocks of size &lt;code&gt;block_size x block size&lt;/code&gt; are rearranged
          into depth at each location.
          * The depth of the output tensor is &lt;code&gt;block_size * block_size * input_depth&lt;/code&gt;.
          * The Y, X coordinates within each block of the input become the high order
          component of the output channel index.
          * The input tensor&#39;s height and width must be divisible by block_size.

          The &lt;code&gt;data_format&lt;/code&gt; attr specifies the layout of the input and output tensors
          with the following options:
          &quot;NHWC&quot;: &lt;code&gt;[ batch, height, width, channels ]&lt;/code&gt;
          &quot;NCHW&quot;: &lt;code&gt;[ batch, channels, height, width ]&lt;/code&gt;
          &quot;NCHW_VECT_C&quot;:
          &lt;code&gt;qint8 [ batch, channels / 4, height, width, 4 ]&lt;/code&gt;

          It is useful to consider the operation as transforming a 6-D Tensor.
          e.g. for data_format = NHWC,
          Each element in the input tensor can be specified via 6 coordinates,
          ordered by decreasing memory layout significance as:
          n,oY,bY,oX,bX,iC  (where n=batch index, oX, oY means X or Y coordinates
          within the output image, bX, bY means coordinates
          within the input block, iC means input channels).
          The output would be a transpose to the following layout:
          n,oY,oX,bY,bX,iC

          This operation is useful for resizing the activations between convolutions
          (but keeping all data), e.g. instead of pooling. It is also useful for training
          purely convolutional models.

          For example, given an input of shape &lt;code&gt;[1, 2, 2, 1]&lt;/code&gt;, data_format = &quot;NHWC&quot; and
          block_size = 2:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1], [2]],
          [[3], [4]]]]
           &lt;/code&gt;&lt;/pre&gt;

          This operation will output a tensor of shape &lt;code&gt;[1, 1, 1, 4]&lt;/code&gt;:

           &lt;pre&gt;&lt;code&gt;
          [[[[1, 2, 3, 4]]]]
           &lt;/code&gt;&lt;/pre&gt;

          Here, the input has a batch of 1 and each batch element has shape &lt;code&gt;[2, 2, 1]&lt;/code&gt;,
          the corresponding output will have a single element (i.e. width and height are
          both 1) and will have a depth of 4 channels (1 * block_size * block_size).
          The output element shape is &lt;code&gt;[1, 1, 4]&lt;/code&gt;.

          For an input tensor with larger depth, here of shape &lt;code&gt;[1, 2, 2, 3]&lt;/code&gt;, e.g.

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1, 2, 3], [4, 5, 6]],
          [[7, 8, 9], [10, 11, 12]]]]
           &lt;/code&gt;&lt;/pre&gt;

          This operation, for block_size of 2, will return the following tensor of shape
          &lt;code&gt;[1, 1, 1, 12]&lt;/code&gt;&lt;pre&gt;&lt;code&gt;
          [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]
           &lt;/code&gt;&lt;/pre&gt;

          Similarly, for the following input of shape &lt;code&gt;[1 4 4 1]&lt;/code&gt;, and a block size of 2:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1],   [2],  [5],  [6]],
          [[3],   [4],  [7],  [8]],
          [[9],  [10], [13],  [14]],
          [[11], [12], [15],  [16]]]]
           &lt;/code&gt;&lt;/pre&gt;

          the operator will return the following tensor of shape &lt;code&gt;[1 2 2 4]&lt;/code&gt;:

           &lt;pre&gt;&lt;code&gt;
          x = [[[[1, 2, 3, 4],
          [5, 6, 7, 8]],
          [[9, 10, 11, 12],
          [13, 14, 15, 16]]]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseAccumulatorApplyGradient_" data-uid="TensorFlow.TFGraph.SparseAccumulatorApplyGradient*"></a>
  <h4 id="TensorFlow_TFGraph_SparseAccumulatorApplyGradient_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Boolean_System_String_" data-uid="TensorFlow.TFGraph.SparseAccumulatorApplyGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Boolean,System.String)">SparseAccumulatorApplyGradient(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Boolean, String)</h4>
  <div class="markdown level1 summary"><p>Applies a sparse gradient to a given accumulator.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation SparseAccumulatorApplyGradient (TensorFlow.TFOutput handle, TensorFlow.TFOutput local_step, TensorFlow.TFOutput gradient_indices, TensorFlow.TFOutput gradient_values, TensorFlow.TFOutput gradient_shape, bool has_known_shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a accumulator.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">local_step</span></td>
        <td><p>The local_step value at which the sparse gradient was computed.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_indices</span></td>
        <td><p>Indices of the sparse gradient to be accumulated. Must be a
              vector.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_values</span></td>
        <td><p>Values are the non-zero slices of the gradient, and must have
              the same first dimension as indices, i.e., the nnz represented by indices and
              values must be consistent.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_shape</span></td>
        <td><p>Shape of the sparse gradient to be accumulated.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">has_known_shape</span></td>
        <td><p>Boolean indicating whether gradient_shape is unknown, in which
              case the input is ignored during validation.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseAccumulatorApplyGradient&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseAccumulatorApplyGradient_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Boolean_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Does not add if local_step is smaller than the accumulator&#39;s
              global_step.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseAccumulatorTakeGradient_" data-uid="TensorFlow.TFGraph.SparseAccumulatorTakeGradient*"></a>
  <h4 id="TensorFlow_TFGraph_SparseAccumulatorTakeGradient_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.SparseAccumulatorTakeGradient(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">SparseAccumulatorTakeGradient(TFOutput, TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Extracts the average sparse gradient in a SparseConditionalAccumulator.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseAccumulatorTakeGradient (TensorFlow.TFOutput handle, TensorFlow.TFOutput num_required, TensorFlow.TFDataType dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a SparseConditionalAccumulator.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_required</span></td>
        <td><p>Number of gradients required before we return an aggregate.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The data type of accumulated gradients. Needs to correspond to the type
              of the accumulator.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseAccumulatorTakeGradient&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              indices: Indices of the average of the accumulated sparse gradients.
              values: Values of the average of the accumulated sparse gradients.
              shape: Shape of the average of the accumulated sparse gradients.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseAccumulatorTakeGradient_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The op will blocks until sufficient (i.e., more than num_required)
              gradients have been accumulated. If the accumulator has already
              aggregated more than num_required gradients, it will return its
              average of the accumulated gradients.  Also automatically increments
              the recorded global_step in the accumulator by 1, and resets the
              aggregate to 0.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseAdd_" data-uid="TensorFlow.TFGraph.SparseAdd*"></a>
  <h4 id="TensorFlow_TFGraph_SparseAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseAdd(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Adds two <code>SparseTensor</code> objects to produce another <code>SparseTensor</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseAdd (TensorFlow.TFOutput a_indices, TensorFlow.TFOutput a_values, TensorFlow.TFOutput a_shape, TensorFlow.TFOutput b_indices, TensorFlow.TFOutput b_values, TensorFlow.TFOutput b_shape, TensorFlow.TFOutput thresh, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_indices</span></td>
        <td><p>2-D.  The <code>indices</code> of the first <code>SparseTensor</code>, size <code>[nnz, ndims]</code> Matrix.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_values</span></td>
        <td><p>1-D.  The <code>values</code> of the first <code>SparseTensor</code>, size <code>[nnz]</code> Vector.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_shape</span></td>
        <td><p>1-D.  The <code>shape</code> of the first <code>SparseTensor</code>, size <code>[ndims]</code> Vector.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b_indices</span></td>
        <td><p>2-D.  The <code>indices</code> of the second <code>SparseTensor</code>, size <code>[nnz, ndims]</code> Matrix.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b_values</span></td>
        <td><p>1-D.  The <code>values</code> of the second <code>SparseTensor</code>, size <code>[nnz]</code> Vector.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b_shape</span></td>
        <td><p>1-D.  The <code>shape</code> of the second <code>SparseTensor</code>, size <code>[ndims]</code> Vector.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">thresh</span></td>
        <td><p>0-D.  The magnitude threshold that determines if an output value/index
              pair takes space.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseAdd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sum_indices:
              sum_values:
              sum_shape:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The input <code>SparseTensor</code> objects&#39; indices are assumed ordered in standard
              lexicographic order.  If this is not the case, before this step run
              <code>SparseReorder</code> to restore index ordering.</p>
<pre><code>          By default, if two values sum to zero at some index, the output &lt;code&gt;SparseTensor&lt;/code&gt;
          would still include that particular location in its index, storing a zero in the
          corresponding value slot.  To override this, callers can specify &lt;code&gt;thresh&lt;/code&gt;,
          indicating that if the sum has a magnitude strictly smaller than &lt;code&gt;thresh&lt;/code&gt;, its
          corresponding value and index would then not be included.  In particular,
          &lt;code&gt;thresh == 0&lt;/code&gt; (default) means everything is kept and actual thresholding happens
          only for a positive value.

          In the following shapes, &lt;code&gt;nnz&lt;/code&gt; is the count after taking &lt;code&gt;thresh&lt;/code&gt; into account.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseAddGrad_" data-uid="TensorFlow.TFGraph.SparseAddGrad*"></a>
  <h4 id="TensorFlow_TFGraph_SparseAddGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseAddGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseAddGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>The gradient operator for the SparseAdd op.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseAddGrad (TensorFlow.TFOutput backprop_val_grad, TensorFlow.TFOutput a_indices, TensorFlow.TFOutput b_indices, TensorFlow.TFOutput sum_indices, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">backprop_val_grad</span></td>
        <td><p>1-D with shape <code>[nnz(sum)]</code>.  The gradient with respect to
              the non-empty values of the sum.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_indices</span></td>
        <td><p>2-D.  The <code>indices</code> of the <code>SparseTensor</code> A, size <code>[nnz(A), ndims]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b_indices</span></td>
        <td><p>2-D.  The <code>indices</code> of the <code>SparseTensor</code> B, size <code>[nnz(B), ndims]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sum_indices</span></td>
        <td><p>2-D.  The <code>indices</code> of the sum <code>SparseTensor</code>, size
              <code>[nnz(sum), ndims]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseAddGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              a_val_grad: 1-D with shape <code>[nnz(A)]</code>. The gradient with respect to the
              non-empty values of A.
              b_val_grad: 1-D with shape <code>[nnz(B)]</code>. The gradient with respect to the
              non-empty values of B.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseAddGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The SparseAdd op calculates A + B, where A, B, and the sum are all represented
              as <code>SparseTensor</code> objects.  This op takes in the upstream gradient w.r.t.
              non-empty values of the sum, and outputs the gradients w.r.t. the non-empty
              values of A and B.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseApplyAdadelta_" data-uid="TensorFlow.TFGraph.SparseApplyAdadelta*"></a>
  <h4 id="TensorFlow_TFGraph_SparseApplyAdadelta_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseApplyAdadelta(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SparseApplyAdadelta(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>var: Should be from a Variable().</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseApplyAdadelta (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput accum_update, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum_update</span></td>
        <td><p>: Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Learning rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rho</span></td>
        <td><p>Decay factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Constant factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseApplyAdadelta&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_SparseApplyAdagrad_" data-uid="TensorFlow.TFGraph.SparseApplyAdagrad*"></a>
  <h4 id="TensorFlow_TFGraph_SparseApplyAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseApplyAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">SparseApplyAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update relevant entries in &#39;<em>var&#39; and &#39;</em>accum&#39; according to the adagrad scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseApplyAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable&lt;bool&gt; use_locking = null, Nullable&lt;bool&gt; update_slots = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Learning rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">update_slots</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseApplyAdagrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseApplyAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>That is for rows we have grad for, we update var and accum as follows:
              $$accum += grad * grad$$
              $$var -= lr * grad * (1 / sqrt(accum))$$</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseApplyAdagradDA_" data-uid="TensorFlow.TFGraph.SparseApplyAdagradDA*"></a>
  <h4 id="TensorFlow_TFGraph_SparseApplyAdagradDA_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseApplyAdagradDA(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SparseApplyAdagradDA(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update entries in &#39;<em>var&#39; and &#39;</em>accum&#39; according to the proximal adagrad scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseApplyAdagradDA (TensorFlow.TFOutput var, TensorFlow.TFOutput gradient_accumulator, TensorFlow.TFOutput gradient_squared_accumulator, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput global_step, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_accumulator</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">gradient_squared_accumulator</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Learning rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">global_step</span></td>
        <td><p>Training step number. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseApplyAdagradDA&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_SparseApplyCenteredRMSProp_" data-uid="TensorFlow.TFGraph.SparseApplyCenteredRMSProp*"></a>
  <h4 id="TensorFlow_TFGraph_SparseApplyCenteredRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseApplyCenteredRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SparseApplyCenteredRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the centered RMSProp algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseApplyCenteredRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput mg, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mg</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ms</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mom</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rho</span></td>
        <td><p>Decay rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momentum</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Ridge term. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var, ms and mom.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var, mg, ms, and mom tensors is
              protected by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseApplyCenteredRMSProp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseApplyCenteredRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The centered RMSProp algorithm uses an estimate of the centered second moment
              (i.e., the variance) for normalization, as opposed to regular RMSProp, which
              uses the (uncentered) second moment. This often helps with training, but is
              slightly more expensive in terms of computation and memory.</p>
<pre><code>          Note that in dense implementation of this algorithm, mg, ms, and mom will
          update even if the grad is zero, but in this sparse implementation, mg, ms,
          and mom will not update in iterations during which the grad is zero.

          mean_square = decay * mean_square + (1-decay) * gradient ** 2
          mean_grad = decay * mean_grad + (1-decay) * gradient
          Delta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)

          $$ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad$$
          $$mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)$$
          $$var &amp;lt;- var - mom$$
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseApplyFtrl_" data-uid="TensorFlow.TFGraph.SparseApplyFtrl*"></a>
  <h4 id="TensorFlow_TFGraph_SparseApplyFtrl_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseApplyFtrl(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SparseApplyFtrl(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update relevant entries in &#39;*var&#39; according to the Ftrl-proximal scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseApplyFtrl (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput lr_power, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">linear</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr_power</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseApplyFtrl&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseApplyFtrl_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>That is for rows we have grad for, we update var, accum and linear as follows:
              $$accum_new = accum + grad * grad$$
              $$linear += grad + (accum_{new}^{-lr_{power}} - accum^{-lr_{power}} / lr * var$$
              $$quadratic = 1.0 / (accum_{new}^{lr_{power}} * lr) + 2 * l2$$
              $$var = (sign(linear) * l1 - linear) / quadratic\ if\ |linear| &gt; l1\ else\ 0.0$$
              $$accum = accum_{new}$$</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseApplyFtrlV2_" data-uid="TensorFlow.TFGraph.SparseApplyFtrlV2*"></a>
  <h4 id="TensorFlow_TFGraph_SparseApplyFtrlV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseApplyFtrlV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SparseApplyFtrlV2(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update relevant entries in &#39;*var&#39; according to the Ftrl-proximal scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseApplyFtrlV2 (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput linear, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput l2_shrinkage, TensorFlow.TFOutput lr_power, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">linear</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 shrinkage regulariation. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2_shrinkage</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr_power</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseApplyFtrlV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseApplyFtrlV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>That is for rows we have grad for, we update var, accum and linear as follows:
              grad_with_shrinkage = grad + 2 * l2_shrinkage * var
              accum_new = accum + grad_with_shrinkage * grad_with_shrinkage
              linear += grad_with_shrinkage +
              (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var
              quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2
              var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
              accum = accum_new</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseApplyMomentum_" data-uid="TensorFlow.TFGraph.SparseApplyMomentum*"></a>
  <h4 id="TensorFlow_TFGraph_SparseApplyMomentum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseApplyMomentum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">SparseApplyMomentum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update relevant entries in &#39;<em>var&#39; and &#39;</em>accum&#39; according to the momentum scheme.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseApplyMomentum (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput momentum, Nullable&lt;bool&gt; use_locking = null, Nullable&lt;bool&gt; use_nesterov = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Learning rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momentum</span></td>
        <td><p>Momentum. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var and accum tensors will be protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_nesterov</span></td>
        <td><p>Optional argument
              If <code>True</code>, the tensor passed to compute grad will be
              var - lr * momentum * accum, so in the end, the var you get is actually
              var - lr * momentum * accum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseApplyMomentum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseApplyMomentum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Set use_nesterov = True if you want to use Nesterov momentum.</p>
<pre><code>          That is for rows we have grad for, we update var and accum as follows:

          $$accum = accum * momentum + grad$$
          $$var -= lr * accum$$
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseApplyProximalAdagrad_" data-uid="TensorFlow.TFGraph.SparseApplyProximalAdagrad*"></a>
  <h4 id="TensorFlow_TFGraph_SparseApplyProximalAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseApplyProximalAdagrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SparseApplyProximalAdagrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Sparse update entries in &#39;<em>var&#39; and &#39;</em>accum&#39; according to FOBOS algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseApplyProximalAdagrad (TensorFlow.TFOutput var, TensorFlow.TFOutput accum, TensorFlow.TFOutput lr, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">accum</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Learning rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, updating of the var and accum tensors will be protected by
              a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseApplyProximalAdagrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseApplyProximalAdagrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>That is for rows we have grad for, we update var and accum as follows:
              $$accum += grad * grad$$
              $$prox_v = var$$
              $$prox_v -= lr * grad * (1 / sqrt(accum))$$
              $$var = sign(prox_v)/(1+lr<em>l2) * max{|prox_v|-lr</em>l1,0}$$</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseApplyProximalGradientDescent_" data-uid="TensorFlow.TFGraph.SparseApplyProximalGradientDescent*"></a>
  <h4 id="TensorFlow_TFGraph_SparseApplyProximalGradientDescent_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseApplyProximalGradientDescent(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SparseApplyProximalGradientDescent(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Sparse update &#39;*var&#39; as FOBOS algorithm with fixed learning rate.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseApplyProximalGradientDescent (TensorFlow.TFOutput var, TensorFlow.TFOutput alpha, TensorFlow.TFOutput l1, TensorFlow.TFOutput l2, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">alpha</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l1</span></td>
        <td><p>L1 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">l2</span></td>
        <td><p>L2 regularization. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var and accum.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If True, the subtraction will be protected by a lock;
              otherwise the behavior is undefined, but may exhibit less contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseApplyProximalGradientDescent&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseApplyProximalGradientDescent_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>That is for rows we have grad for, we update var as follows:
              $$prox_v = var - alpha * grad$$
              $$var = sign(prox_v)/(1+alpha<em>l2) * max{|prox_v|-alpha</em>l1,0}$$</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseApplyRMSProp_" data-uid="TensorFlow.TFGraph.SparseApplyRMSProp*"></a>
  <h4 id="TensorFlow_TFGraph_SparseApplyRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseApplyRMSProp(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SparseApplyRMSProp(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Update &#39;*var&#39; according to the RMSProp algorithm.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseApplyRMSProp (TensorFlow.TFOutput var, TensorFlow.TFOutput ms, TensorFlow.TFOutput mom, TensorFlow.TFOutput lr, TensorFlow.TFOutput rho, TensorFlow.TFOutput momentum, TensorFlow.TFOutput epsilon, TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, Nullable&lt;bool&gt; use_locking = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">var</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">ms</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">mom</span></td>
        <td><p>Should be from a Variable().</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lr</span></td>
        <td><p>Scaling factor. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">rho</span></td>
        <td><p>Decay rate. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">momentum</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">epsilon</span></td>
        <td><p>Ridge term. Must be a scalar.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>The gradient.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A vector of indices into the first dimension of var, ms and mom.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">use_locking</span></td>
        <td><p>Optional argument
              If <code>True</code>, updating of the var, ms, and mom tensors is protected
              by a lock; otherwise the behavior is undefined, but may exhibit less
              contention.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseApplyRMSProp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Same as &quot;var&quot;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseApplyRMSProp_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that in dense implementation of this algorithm, ms and mom will
              update even if the grad is zero, but in this sparse implementation, ms
              and mom will not update in iterations during which the grad is zero.</p>
<pre><code>          mean_square = decay * mean_square + (1-decay) * gradient ** 2
          Delta = learning_rate * gradient / sqrt(mean_square + epsilon)

          $$ms &amp;lt;- rho * ms_{t-1} + (1-rho) * grad * grad$$
          $$mom &amp;lt;- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)$$
          $$var &amp;lt;- var - mom$$
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseConcat_" data-uid="TensorFlow.TFGraph.SparseConcat*"></a>
  <h4 id="TensorFlow_TFGraph_SparseConcat_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___System_Int64_System_String_" data-uid="TensorFlow.TFGraph.SparseConcat(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.Int64,System.String)">SparseConcat(TFOutput[], TFOutput[], TFOutput[], Int64, String)</h4>
  <div class="markdown level1 summary"><p>Concatenates a list of <code>SparseTensor</code> along the specified dimension.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseConcat (TensorFlow.TFOutput[] indices, TensorFlow.TFOutput[] values, TensorFlow.TFOutput[] shapes, long concat_dim, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">indices</span></td>
        <td><p>2-D.  Indices of each input <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">values</span></td>
        <td><p>1-D.  Non-empty values of each <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>1-D.  Shapes of each <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">concat_dim</span></td>
        <td><p>Dimension to concatenate along. Must be in range [-rank, rank),
              where rank is the number of dimensions in each input <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseConcat&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_indices: 2-D.  Indices of the concatenated <code>SparseTensor</code>.
              output_values: 1-D.  Non-empty values of the concatenated <code>SparseTensor</code>.
              output_shape: 1-D.  Shape of the concatenated <code>SparseTensor</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseConcat_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Concatenation is with respect to the dense versions of these sparse tensors.
              It is assumed that each input is a <code>SparseTensor</code> whose elements are ordered
              along increasing dimension number.</p>
<pre><code>          All inputs&#39; shapes must match, except for the concat dimension.  The
          &lt;code&gt;indices&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, and &lt;code&gt;shapes&lt;/code&gt; lists must have the same length.

          The output shape is identical to the inputs&#39;, except along the concat
          dimension, where it is the sum of the inputs&#39; sizes along that dimension.

          The output elements will be resorted to preserve the sort order along
          increasing dimension number.

          This op runs in &lt;code&gt;O(M log M)&lt;/code&gt; time, where &lt;code&gt;M&lt;/code&gt; is the total number of non-empty
          values across all inputs. This is due to the need for an internal sort in
          order to concatenate efficiently across an arbitrary dimension.

          For example, if &lt;code&gt;concat_dim = 1&lt;/code&gt; and the inputs are

          sp_inputs[0]: shape = [2, 3]
          [0, 2]: &quot;a&quot;
          [1, 0]: &quot;b&quot;
          [1, 1]: &quot;c&quot;

          sp_inputs[1]: shape = [2, 4]
          [0, 1]: &quot;d&quot;
          [0, 2]: &quot;e&quot;

          then the output will be

          shape = [2, 7]
          [0, 2]: &quot;a&quot;
          [0, 4]: &quot;d&quot;
          [0, 5]: &quot;e&quot;
          [1, 0]: &quot;b&quot;
          [1, 1]: &quot;c&quot;

          Graphically this is equivalent to doing

          [    a] concat [  d e  ] = [    a   d e  ]
          [b c  ]        [       ]   [b c          ]
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseConditionalAccumulator_" data-uid="TensorFlow.TFGraph.SparseConditionalAccumulator*"></a>
  <h4 id="TensorFlow_TFGraph_SparseConditionalAccumulator_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.SparseConditionalAccumulator(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String,System.String)">SparseConditionalAccumulator(TFDataType, TFShape, String, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A conditional accumulator for aggregating sparse gradients.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseConditionalAccumulator (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string container = null, string shared_name = null, string reduction_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of the value being accumulated.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the values.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this accumulator is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this accumulator will be shared under the given name
              across multiple sessions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">reduction_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseConditionalAccumulator&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to the accumulator.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseConditionalAccumulator_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The accumulator accepts gradients marked with local_step greater or
              equal to the most recent global_step known to the accumulator. The
              average can be extracted from the accumulator, provided sufficient
              gradients have been accumulated. Extracting the average automatically
              resets the aggregate to 0, and increments the global_step recorded by
              the accumulator.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseCross_" data-uid="TensorFlow.TFGraph.SparseCross*"></a>
  <h4 id="TensorFlow_TFGraph_SparseCross_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___System_Boolean_System_Int64_System_Int64_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.SparseCross(TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.Boolean,System.Int64,System.Int64,TensorFlow.TFDataType,TensorFlow.TFDataType,System.String)">SparseCross(TFOutput[], TFOutput[], TFOutput[], TFOutput[], Boolean, Int64, Int64, TFDataType, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Generates sparse cross from a list of sparse and dense tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseCross (TensorFlow.TFOutput[] indices, TensorFlow.TFOutput[] values, TensorFlow.TFOutput[] shapes, TensorFlow.TFOutput[] dense_inputs, bool hashed_output, long num_buckets, long hash_key, TensorFlow.TFDataType out_type, TensorFlow.TFDataType internal_type, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">indices</span></td>
        <td><p>2-D.  Indices of each input <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">values</span></td>
        <td><p>1-D.   values of each <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">shapes</span></td>
        <td><p>1-D.   Shapes of each <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">dense_inputs</span></td>
        <td><p>2-D.    Columns represented by dense <code>Tensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">hashed_output</span></td>
        <td><p>If true, returns the hash of the cross instead of the string.
              This will allow us avoiding string manipulations.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_buckets</span></td>
        <td><p>It is used if hashed_output is true.
              output = hashed_value%num_buckets if num_buckets &gt; 0 else hashed_value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">hash_key</span></td>
        <td><p>Specify the hash_key that will be used by the <code>FingerprintCat64</code>
              function to combine the crosses fingerprints.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">out_type</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">internal_type</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseCross&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_indices: 2-D.  Indices of the concatenated <code>SparseTensor</code>.
              output_values: 1-D.  Non-empty values of the concatenated or hashed
              <code>SparseTensor</code>.
              output_shape: 1-D.  Shape of the concatenated <code>SparseTensor</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseCross_TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___TensorFlow_TFOutput___System_Boolean_System_Int64_System_Int64_TensorFlow_TFDataType_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The op takes two lists, one of 2D <code>SparseTensor</code> and one of 2D <code>Tensor</code>, each
              representing features of one feature column. It outputs a 2D <code>SparseTensor</code> with
              the batchwise crosses of these features.</p>
<pre><code>          For example, if the inputs are

          inputs[0]: SparseTensor with shape = [2, 2]
          [0, 0]: &quot;a&quot;
          [1, 0]: &quot;b&quot;
          [1, 1]: &quot;c&quot;

          inputs[1]: SparseTensor with shape = [2, 1]
          [0, 0]: &quot;d&quot;
          [1, 0]: &quot;e&quot;

          inputs[2]: Tensor [[&quot;f&quot;], [&quot;g&quot;]]

          then the output will be

          shape = [2, 2]
          [0, 0]: &quot;a_X_d_X_f&quot;
          [1, 0]: &quot;b_X_e_X_g&quot;
          [1, 1]: &quot;c_X_e_X_g&quot;

          if hashed_output=true then the output will be

          shape = [2, 2]
          [0, 0]: FingerprintCat64(
          Fingerprint64(&quot;f&quot;), FingerprintCat64(
          Fingerprint64(&quot;d&quot;), Fingerprint64(&quot;a&quot;)))
          [1, 0]: FingerprintCat64(
          Fingerprint64(&quot;g&quot;), FingerprintCat64(
          Fingerprint64(&quot;e&quot;), Fingerprint64(&quot;b&quot;)))
          [1, 1]: FingerprintCat64(
          Fingerprint64(&quot;g&quot;), FingerprintCat64(
          Fingerprint64(&quot;e&quot;), Fingerprint64(&quot;c&quot;)))
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseDenseCwiseAdd_" data-uid="TensorFlow.TFGraph.SparseDenseCwiseAdd*"></a>
  <h4 id="TensorFlow_TFGraph_SparseDenseCwiseAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseDenseCwiseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseDenseCwiseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Adds up a SparseTensor and a dense Tensor, using these special rules:</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseDenseCwiseAdd (TensorFlow.TFOutput sp_indices, TensorFlow.TFOutput sp_values, TensorFlow.TFOutput sp_shape, TensorFlow.TFOutput dense, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sp_indices</span></td>
        <td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sp_values</span></td>
        <td><p>1-D.  <code>N</code> non-empty values corresponding to <code>sp_indices</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sp_shape</span></td>
        <td><p>1-D.  Shape of the input SparseTensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dense</span></td>
        <td><p><code>R</code>-D.  The dense Tensor operand.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseDenseCwiseAdd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>1-D.  The <code>N</code> values that are operated on.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseDenseCwiseAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>(1) Broadcasts the dense side to have the same shape as the sparse side, if
              eligible;
              (2) Then, only the dense values pointed to by the indices of the SparseTensor
              participate in the cwise addition.</p>
<pre><code>          By these rules, the result is a logical SparseTensor with exactly the same
          indices and shape, but possibly with different non-zero values.  The output of
          this Op is the resultant non-zero values.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseDenseCwiseDiv_" data-uid="TensorFlow.TFGraph.SparseDenseCwiseDiv*"></a>
  <h4 id="TensorFlow_TFGraph_SparseDenseCwiseDiv_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseDenseCwiseDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseDenseCwiseDiv(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Component-wise divides a SparseTensor by a dense Tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseDenseCwiseDiv (TensorFlow.TFOutput sp_indices, TensorFlow.TFOutput sp_values, TensorFlow.TFOutput sp_shape, TensorFlow.TFOutput dense, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sp_indices</span></td>
        <td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sp_values</span></td>
        <td><p>1-D.  <code>N</code> non-empty values corresponding to <code>sp_indices</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sp_shape</span></td>
        <td><p>1-D.  Shape of the input SparseTensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dense</span></td>
        <td><p><code>R</code>-D.  The dense Tensor operand.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseDenseCwiseDiv&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>1-D.  The <code>N</code> values that are operated on.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseDenseCwiseDiv_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>Limitation</em>: this Op only broadcasts the dense side to the sparse side, but not
              the other direction.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseDenseCwiseMul_" data-uid="TensorFlow.TFGraph.SparseDenseCwiseMul*"></a>
  <h4 id="TensorFlow_TFGraph_SparseDenseCwiseMul_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseDenseCwiseMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseDenseCwiseMul(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Component-wise multiplies a SparseTensor by a dense Tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseDenseCwiseMul (TensorFlow.TFOutput sp_indices, TensorFlow.TFOutput sp_values, TensorFlow.TFOutput sp_shape, TensorFlow.TFOutput dense, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sp_indices</span></td>
        <td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sp_values</span></td>
        <td><p>1-D.  <code>N</code> non-empty values corresponding to <code>sp_indices</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sp_shape</span></td>
        <td><p>1-D.  Shape of the input SparseTensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dense</span></td>
        <td><p><code>R</code>-D.  The dense Tensor operand.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseDenseCwiseMul&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>1-D.  The <code>N</code> values that are operated on.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseDenseCwiseMul_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The output locations corresponding to the implicitly zero elements in the sparse
              tensor will be zero (i.e., will not take up storage space), regardless of the
              contents of the dense tensor (even if it&#39;s +/-INF and that INF*0 == NaN).</p>
<pre><code>          *Limitation*: this Op only broadcasts the dense side to the sparse side, but not
          the other direction.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseFillEmptyRows_" data-uid="TensorFlow.TFGraph.SparseFillEmptyRows*"></a>
  <h4 id="TensorFlow_TFGraph_SparseFillEmptyRows_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseFillEmptyRows(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseFillEmptyRows(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Fills empty rows in the input 2-D <code>SparseTensor</code> with a default value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseFillEmptyRows (TensorFlow.TFOutput indices, TensorFlow.TFOutput values, TensorFlow.TFOutput dense_shape, TensorFlow.TFOutput default_value, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>2-D. the indices of the sparse tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>1-D. the values of the sparse tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dense_shape</span></td>
        <td><p>1-D. the shape of the sparse tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">default_value</span></td>
        <td><p>0-D. default value to insert into location <code>[row, 0, ..., 0]</code>
              for rows missing from the input sparse tensor.
              output indices: 2-D. the indices of the filled sparse tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseFillEmptyRows&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_indices:
              output_values: 1-D. the values of the filled sparse tensor.
              empty_row_indicator: 1-D. whether the dense row was missing in the
              input sparse tensor.
              reverse_index_map: 1-D. a map from the input indices to the output indices.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseFillEmptyRows_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The input <code>SparseTensor</code> is represented via the tuple of inputs
              (<code>indices</code>, <code>values</code>, <code>dense_shape</code>).  The output <code>SparseTensor</code> has the
              same <code>dense_shape</code> but with indices <code>output_indices</code> and values
              <code>output_values</code>.</p>
<pre><code>          This op inserts a single entry for every row that doesn&#39;t have any values.
          The index is created as &lt;code&gt;[row, 0, ..., 0]&lt;/code&gt; and the inserted value
          is &lt;code&gt;default_value&lt;/code&gt;.

          For example, suppose &lt;code&gt;sp_input&lt;/code&gt; has shape &lt;code&gt;[5, 6]&lt;/code&gt; and non-empty values:

          [0, 1]: a
          [0, 3]: b
          [2, 0]: c
          [3, 1]: d

          Rows 1 and 4 are empty, so the output will be of shape &lt;code&gt;[5, 6]&lt;/code&gt; with values:

          [0, 1]: a
          [0, 3]: b
          [1, 0]: default_value
          [2, 0]: c
          [3, 1]: d
          [4, 0]: default_value

          The output &lt;code&gt;SparseTensor&lt;/code&gt; will be in row-major order and will have the
          same shape as the input.

          This op also returns an indicator vector shaped &lt;code&gt;[dense_shape[0]]&lt;/code&gt; such that

          empty_row_indicator[i] = True iff row i was an empty row.

          And a reverse index map vector shaped &lt;code&gt;[indices.shape[0]]&lt;/code&gt; that is used during
          backpropagation,

          reverse_index_map[j] = out_j s.t. indices[j, :] == output_indices[out_j, :]
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseFillEmptyRowsGrad_" data-uid="TensorFlow.TFGraph.SparseFillEmptyRowsGrad*"></a>
  <h4 id="TensorFlow_TFGraph_SparseFillEmptyRowsGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseFillEmptyRowsGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseFillEmptyRowsGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>The gradient of SparseFillEmptyRows.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseFillEmptyRowsGrad (TensorFlow.TFOutput reverse_index_map, TensorFlow.TFOutput grad_values, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reverse_index_map</span></td>
        <td><p>1-D.  The reverse index map from SparseFillEmptyRows.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad_values</span></td>
        <td><p>1-D.  The gradients from backprop.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseFillEmptyRowsGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              d_values: 1-D.  The backprop into values.
              d_default_value: 0-D.  The backprop into default_value.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseFillEmptyRowsGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Takes vectors reverse_index_map, shaped <code>[N]</code>, and grad_values,
              shaped <code>[N_full]</code>, where <code>N_full &gt;= N</code> and copies data into either
              <code>d_values</code> or <code>d_default_value</code>.  Here <code>d_values</code> is shaped <code>[N]</code> and
              <code>d_default_value</code> is a scalar.</p>
<pre><code>          d_values[j] = grad_values[reverse_index_map[j]]
          d_default_value = sum_{k : 0 .. N_full - 1} (
          grad_values[k] * 1{k not in reverse_index_map})
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseMatMul_" data-uid="TensorFlow.TFGraph.SparseMatMul*"></a>
  <h4 id="TensorFlow_TFGraph_SparseMatMul_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">SparseMatMul(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Multiply matrix &quot;a&quot; by matrix &quot;b&quot;.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseMatMul (TensorFlow.TFOutput a, TensorFlow.TFOutput b, Nullable&lt;bool&gt; transpose_a = null, Nullable&lt;bool&gt; transpose_b = null, Nullable&lt;bool&gt; a_is_sparse = null, Nullable&lt;bool&gt; b_is_sparse = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">transpose_a</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">transpose_b</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">a_is_sparse</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">b_is_sparse</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseMatMul&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseMatMul_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The inputs must be two-dimensional matrices and the inner dimension of &quot;a&quot; must
              match the outer dimension of &quot;b&quot;. Both &quot;a&quot; and &quot;b&quot; must be <code>Tensor</code>s not
              <code>SparseTensor</code>s.  This op is optimized for the case where at least one of &quot;a&quot; or
              &quot;b&quot; is sparse, in the sense that they have a large proportion of zero values.
              The breakeven for using this versus a dense matrix multiply on one platform was
              30% zero values in the sparse matrix.</p>
<pre><code>          The gradient computation of this operation will only take advantage of sparsity
          in the input gradient when that gradient comes from a Relu.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseReduceMax_" data-uid="TensorFlow.TFGraph.SparseReduceMax*"></a>
  <h4 id="TensorFlow_TFGraph_SparseReduceMax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseReduceMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SparseReduceMax(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the max of elements across dimensions of a SparseTensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseReduceMax (TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_values, TensorFlow.TFOutput input_shape, TensorFlow.TFOutput reduction_axes, Nullable&lt;bool&gt; keep_dims = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_indices</span></td>
        <td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_values</span></td>
        <td><p>1-D.  <code>N</code> non-empty values corresponding to <code>input_indices</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_shape</span></td>
        <td><p>1-D.  Shape of the input SparseTensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reduction_axes</span></td>
        <td><p>1-D.  Length-<code>K</code> vector containing the reduction axes.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>Optional argument
              If true, retain reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseReduceMax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p><code>R-K</code>-D.  The reduced Tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseReduceMax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This Op takes a SparseTensor and is the sparse counterpart to
              <code>tf.reduce_max()</code>.  In particular, this Op also returns a dense <code>Tensor</code>
              instead of a sparse one.</p>
<pre><code>          Reduces &lt;code&gt;sp_input&lt;/code&gt; along the dimensions given in &lt;code&gt;reduction_axes&lt;/code&gt;.  Unless
          &lt;code&gt;keep_dims&lt;/code&gt; is true, the rank of the tensor is reduced by 1 for each entry in
          &lt;code&gt;reduction_axes&lt;/code&gt;. If &lt;code&gt;keep_dims&lt;/code&gt; is true, the reduced dimensions are retained
          with length 1.

          If &lt;code&gt;reduction_axes&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor
          with a single element is returned.  Additionally, the axes can be negative,
          which are interpreted according to the indexing rules in Python.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseReduceMaxSparse_" data-uid="TensorFlow.TFGraph.SparseReduceMaxSparse*"></a>
  <h4 id="TensorFlow_TFGraph_SparseReduceMaxSparse_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseReduceMaxSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SparseReduceMaxSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the max of elements across dimensions of a SparseTensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseReduceMaxSparse (TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_values, TensorFlow.TFOutput input_shape, TensorFlow.TFOutput reduction_axes, Nullable&lt;bool&gt; keep_dims = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_indices</span></td>
        <td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_values</span></td>
        <td><p>1-D.  <code>N</code> non-empty values corresponding to <code>input_indices</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_shape</span></td>
        <td><p>1-D.  Shape of the input SparseTensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reduction_axes</span></td>
        <td><p>1-D.  Length-<code>K</code> vector containing the reduction axes.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>Optional argument
              If true, retain reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseReduceMaxSparse&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_indices:
              output_values:
              output_shape:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseReduceMaxSparse_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This Op takes a SparseTensor and is the sparse counterpart to
              <code>tf.reduce_max()</code>.  In contrast to SparseReduceMax, this Op returns a
              SparseTensor.</p>
<pre><code>          Reduces &lt;code&gt;sp_input&lt;/code&gt; along the dimensions given in &lt;code&gt;reduction_axes&lt;/code&gt;.  Unless
          &lt;code&gt;keep_dims&lt;/code&gt; is true, the rank of the tensor is reduced by 1 for each entry in
          &lt;code&gt;reduction_axes&lt;/code&gt;. If &lt;code&gt;keep_dims&lt;/code&gt; is true, the reduced dimensions are retained
          with length 1.

          If &lt;code&gt;reduction_axes&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor
          with a single element is returned.  Additionally, the axes can be negative,
          which are interpreted according to the indexing rules in Python.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseReduceSum_" data-uid="TensorFlow.TFGraph.SparseReduceSum*"></a>
  <h4 id="TensorFlow_TFGraph_SparseReduceSum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseReduceSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SparseReduceSum(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the sum of elements across dimensions of a SparseTensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseReduceSum (TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_values, TensorFlow.TFOutput input_shape, TensorFlow.TFOutput reduction_axes, Nullable&lt;bool&gt; keep_dims = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_indices</span></td>
        <td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_values</span></td>
        <td><p>1-D.  <code>N</code> non-empty values corresponding to <code>input_indices</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_shape</span></td>
        <td><p>1-D.  Shape of the input SparseTensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reduction_axes</span></td>
        <td><p>1-D.  Length-<code>K</code> vector containing the reduction axes.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>Optional argument
              If true, retain reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseReduceSum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p><code>R-K</code>-D.  The reduced Tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseReduceSum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This Op takes a SparseTensor and is the sparse counterpart to
              <code>tf.reduce_sum()</code>.  In particular, this Op also returns a dense <code>Tensor</code>
              instead of a sparse one.</p>
<pre><code>          Reduces &lt;code&gt;sp_input&lt;/code&gt; along the dimensions given in &lt;code&gt;reduction_axes&lt;/code&gt;.  Unless
          &lt;code&gt;keep_dims&lt;/code&gt; is true, the rank of the tensor is reduced by 1 for each entry in
          &lt;code&gt;reduction_axes&lt;/code&gt;. If &lt;code&gt;keep_dims&lt;/code&gt; is true, the reduced dimensions are retained
          with length 1.

          If &lt;code&gt;reduction_axes&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor
          with a single element is returned.  Additionally, the axes can be negative,
          which are interpreted according to the indexing rules in Python.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseReduceSumSparse_" data-uid="TensorFlow.TFGraph.SparseReduceSumSparse*"></a>
  <h4 id="TensorFlow_TFGraph_SparseReduceSumSparse_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseReduceSumSparse(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SparseReduceSumSparse(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the sum of elements across dimensions of a SparseTensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseReduceSumSparse (TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_values, TensorFlow.TFOutput input_shape, TensorFlow.TFOutput reduction_axes, Nullable&lt;bool&gt; keep_dims = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_indices</span></td>
        <td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_values</span></td>
        <td><p>1-D.  <code>N</code> non-empty values corresponding to <code>input_indices</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_shape</span></td>
        <td><p>1-D.  Shape of the input SparseTensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reduction_axes</span></td>
        <td><p>1-D.  Length-<code>K</code> vector containing the reduction axes.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>Optional argument
              If true, retain reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseReduceSumSparse&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_indices:
              output_values:
              output_shape:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseReduceSumSparse_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This Op takes a SparseTensor and is the sparse counterpart to
              <code>tf.reduce_sum()</code>.  In contrast to SparseReduceSum, this Op returns a
              SparseTensor.</p>
<pre><code>          Reduces &lt;code&gt;sp_input&lt;/code&gt; along the dimensions given in &lt;code&gt;reduction_axes&lt;/code&gt;.  Unless
          &lt;code&gt;keep_dims&lt;/code&gt; is true, the rank of the tensor is reduced by 1 for each entry in
          &lt;code&gt;reduction_axes&lt;/code&gt;. If &lt;code&gt;keep_dims&lt;/code&gt; is true, the reduced dimensions are retained
          with length 1.

          If &lt;code&gt;reduction_axes&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor
          with a single element is returned.  Additionally, the axes can be negative,
          which are interpreted according to the indexing rules in Python.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseReorder_" data-uid="TensorFlow.TFGraph.SparseReorder*"></a>
  <h4 id="TensorFlow_TFGraph_SparseReorder_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseReorder(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseReorder(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Reorders a SparseTensor into the canonical, row-major ordering.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseReorder (TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_values, TensorFlow.TFOutput input_shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_indices</span></td>
        <td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
              SparseTensor, possibly not in canonical ordering.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_values</span></td>
        <td><p>1-D.  <code>N</code> non-empty values corresponding to <code>input_indices</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_shape</span></td>
        <td><p>1-D.  Shape of the input SparseTensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseReorder&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_indices: 2-D.  <code>N x R</code> matrix with the same indices as input_indices, but
              in canonical row-major ordering.
              output_values: 1-D.  <code>N</code> non-empty values corresponding to <code>output_indices</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseReorder_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note that by convention, all sparse ops preserve the canonical ordering along
              increasing dimension number. The only time ordering can be violated is during
              manual manipulation of the indices and values vectors to add entries.</p>
<pre><code>          Reordering does not affect the shape of the SparseTensor.

          If the tensor has rank &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; non-empty values, &lt;code&gt;input_indices&lt;/code&gt; has
          shape &lt;code&gt;[N, R]&lt;/code&gt;, input_values has length &lt;code&gt;N&lt;/code&gt;, and input_shape has length &lt;code&gt;R&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseReshape_" data-uid="TensorFlow.TFGraph.SparseReshape*"></a>
  <h4 id="TensorFlow_TFGraph_SparseReshape_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseReshape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseReshape(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Reshapes a SparseTensor to represent values in a new dense shape.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseReshape (TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_shape, TensorFlow.TFOutput new_shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_indices</span></td>
        <td><p>2-D.  <code>N x R_in</code> matrix with the indices of non-empty values in a
              SparseTensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_shape</span></td>
        <td><p>1-D.  <code>R_in</code> vector with the input SparseTensor&#39;s dense shape.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">new_shape</span></td>
        <td><p>1-D.  <code>R_out</code> vector with the requested new dense shape.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseReshape&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_indices: 2-D.  <code>N x R_out</code> matrix with the updated indices of non-empty
              values in the output SparseTensor.
              output_shape: 1-D.  <code>R_out</code> vector with the full dense shape of the output
              SparseTensor.  This is the same as <code>new_shape</code> but with any -1 dimensions
              filled in.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseReshape_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation has the same semantics as reshape on the represented dense
              tensor.  The <code>input_indices</code> are recomputed based on the requested <code>new_shape</code>.</p>
<pre><code>          If one component of &lt;code&gt;new_shape&lt;/code&gt; is the special value -1, the size of that
          dimension is computed so that the total dense size remains constant.  At
          most one component of &lt;code&gt;new_shape&lt;/code&gt; can be -1.  The number of dense elements
          implied by &lt;code&gt;new_shape&lt;/code&gt; must be the same as the number of dense elements
          originally implied by &lt;code&gt;input_shape&lt;/code&gt;.

          Reshaping does not affect the order of values in the SparseTensor.

          If the input tensor has rank &lt;code&gt;R_in&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; non-empty values, and &lt;code&gt;new_shape&lt;/code&gt;
          has length &lt;code&gt;R_out&lt;/code&gt;, then &lt;code&gt;input_indices&lt;/code&gt; has shape &lt;code&gt;[N, R_in]&lt;/code&gt;,
          &lt;code&gt;input_shape&lt;/code&gt; has length &lt;code&gt;R_in&lt;/code&gt;, &lt;code&gt;output_indices&lt;/code&gt; has shape &lt;code&gt;[N, R_out]&lt;/code&gt;, and
          &lt;code&gt;output_shape&lt;/code&gt; has length &lt;code&gt;R_out&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseSegmentMean_" data-uid="TensorFlow.TFGraph.SparseSegmentMean*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSegmentMean_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSegmentMean(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSegmentMean(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the mean along sparse segments of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseSegmentMean (TensorFlow.TFOutput data, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A 1-D tensor. Has same rank as <code>segment_ids</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A 1-D tensor. Values should be sorted and can be repeated.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSegmentMean&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for dimension 0 which
              has size <code>k</code>, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSegmentMean_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Read
              <a href="https://tensorflow.org/api_guides/python/math_ops#Segmentation">the section on segmentation</a>
              for an explanation of segments.</p>
<pre><code>          Like &lt;code&gt;SegmentMean&lt;/code&gt;, but &lt;code&gt;segment_ids&lt;/code&gt; can have rank less than &lt;code&gt;data&lt;/code&gt;&#39;s first
          dimension, selecting a subset of dimension 0, specified by &lt;code&gt;indices&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseSegmentMeanGrad_" data-uid="TensorFlow.TFGraph.SparseSegmentMeanGrad*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSegmentMeanGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSegmentMeanGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSegmentMeanGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes gradients for SparseSegmentMean.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseSegmentMeanGrad (TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput output_dim0, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>gradient propagated to the SparseSegmentMean op.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>indices passed to the corresponding SparseSegmentMean op.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>segment_ids passed to the corresponding SparseSegmentMean op.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_dim0</span></td>
        <td><p>dimension 0 of &quot;data&quot; passed to SparseSegmentMean op.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSegmentMeanGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSegmentMeanGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Returns tensor &quot;output&quot; with same shape as grad, except for dimension 0 whose
              value is output_dim0.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseSegmentMeanWithNumSegments_" data-uid="TensorFlow.TFGraph.SparseSegmentMeanWithNumSegments*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSegmentMeanWithNumSegments_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSegmentMeanWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSegmentMeanWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the mean along sparse segments of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseSegmentMeanWithNumSegments (TensorFlow.TFOutput data, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A 1-D tensor. Has same rank as <code>segment_ids</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A 1-D tensor. Values should be sorted and can be repeated.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_segments</span></td>
        <td><p>Should equal the number of distinct segment IDs.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSegmentMeanWithNumSegments&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for dimension 0 which has size
              <code>num_segments</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSegmentMeanWithNumSegments_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Like <code>SparseSegmentMean</code>, but allows missing ids in <code>segment_ids</code>. If an id is
              misisng, the <code>output</code> tensor at that position will be zeroed.</p>
<pre><code>          Read
          [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)
          for an explanation of segments.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseSegmentSqrtN_" data-uid="TensorFlow.TFGraph.SparseSegmentSqrtN*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSegmentSqrtN_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSegmentSqrtN(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSegmentSqrtN(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the sum along sparse segments of a tensor divided by the sqrt of N.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseSegmentSqrtN (TensorFlow.TFOutput data, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A 1-D tensor. Has same rank as <code>segment_ids</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A 1-D tensor. Values should be sorted and can be repeated.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSegmentSqrtN&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for dimension 0 which
              has size <code>k</code>, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSegmentSqrtN_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>N is the size of the segment being reduced.</p>
<pre><code>          Read
          [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)
          for an explanation of segments.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseSegmentSqrtNGrad_" data-uid="TensorFlow.TFGraph.SparseSegmentSqrtNGrad*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSegmentSqrtNGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSegmentSqrtNGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSegmentSqrtNGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes gradients for SparseSegmentSqrtN.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseSegmentSqrtNGrad (TensorFlow.TFOutput grad, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput output_dim0, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>gradient propagated to the SparseSegmentSqrtN op.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>indices passed to the corresponding SparseSegmentSqrtN op.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>segment_ids passed to the corresponding SparseSegmentSqrtN op.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_dim0</span></td>
        <td><p>dimension 0 of &quot;data&quot; passed to SparseSegmentSqrtN op.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSegmentSqrtNGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSegmentSqrtNGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Returns tensor &quot;output&quot; with same shape as grad, except for dimension 0 whose
              value is output_dim0.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseSegmentSqrtNWithNumSegments_" data-uid="TensorFlow.TFGraph.SparseSegmentSqrtNWithNumSegments*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSegmentSqrtNWithNumSegments_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSegmentSqrtNWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSegmentSqrtNWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the sum along sparse segments of a tensor divided by the sqrt of N.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseSegmentSqrtNWithNumSegments (TensorFlow.TFOutput data, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A 1-D tensor. Has same rank as <code>segment_ids</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A 1-D tensor. Values should be sorted and can be repeated.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_segments</span></td>
        <td><p>Should equal the number of distinct segment IDs.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSegmentSqrtNWithNumSegments&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for dimension 0 which
              has size <code>k</code>, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSegmentSqrtNWithNumSegments_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>N is the size of the segment being reduced.</p>
<pre><code>          Like &lt;code&gt;SparseSegmentSqrtN&lt;/code&gt;, but allows missing ids in &lt;code&gt;segment_ids&lt;/code&gt;. If an id is
          misisng, the &lt;code&gt;output&lt;/code&gt; tensor at that position will be zeroed.

          Read
          [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)
          for an explanation of segments.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseSegmentSum_" data-uid="TensorFlow.TFGraph.SparseSegmentSum*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSegmentSum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSegmentSum(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the sum along sparse segments of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseSegmentSum (TensorFlow.TFOutput data, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A 1-D tensor. Has same rank as <code>segment_ids</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A 1-D tensor. Values should be sorted and can be repeated.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSegmentSum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for dimension 0 which
              has size <code>k</code>, the number of segments.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSegmentSum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Read
              <a href="https://tensorflow.org/api_guides/python/math_ops#Segmentation">the section on segmentation</a>
              for an explanation of segments.</p>
<pre><code>          Like &lt;code&gt;SegmentSum&lt;/code&gt;, but &lt;code&gt;segment_ids&lt;/code&gt; can have rank less than &lt;code&gt;data&lt;/code&gt;&#39;s first
          dimension, selecting a subset of dimension 0, specified by &lt;code&gt;indices&lt;/code&gt;.

          For example:

           &lt;pre&gt;&lt;code&gt;
          c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])

          # Select two rows, one segment.
          tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))
          # =&amp;gt; [[0 0 0 0]]

          # Select two rows, two segment.
          tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))
          # =&amp;gt; [[ 1  2  3  4]
          #     [-1 -2 -3 -4]]

          # Select all rows, two segments.
          tf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))
          # =&amp;gt; [[0 0 0 0]
          #     [5 6 7 8]]

          # Which is equivalent to:
          tf.segment_sum(c, tf.constant([0, 0, 1]))
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseSegmentSumWithNumSegments_" data-uid="TensorFlow.TFGraph.SparseSegmentSumWithNumSegments*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSegmentSumWithNumSegments_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSegmentSumWithNumSegments(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSegmentSumWithNumSegments(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the sum along sparse segments of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseSegmentSumWithNumSegments (TensorFlow.TFOutput data, TensorFlow.TFOutput indices, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>A 1-D tensor. Has same rank as <code>segment_ids</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A 1-D tensor. Values should be sorted and can be repeated.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_segments</span></td>
        <td><p>Should equal the number of distinct segment IDs.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSegmentSumWithNumSegments&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for dimension 0 which
              has size <code>num_segments</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSegmentSumWithNumSegments_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Like <code>SparseSegmentSum</code>, but allows missing ids in <code>segment_ids</code>. If an id is
              misisng, the <code>output</code> tensor at that position will be zeroed.</p>
<pre><code>          Read
          [the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)
          for an explanation of segments.

          For example:

           &lt;pre&gt;&lt;code&gt;
          c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])

          tf.sparse_segment_sum_with_num_segments(
          c, tf.constant([0, 1]), tf.constant([0, 0]), num_segments=3)
          # =&amp;gt; [[0 0 0 0]
          #     [0 0 0 0]
          #     [0 0 0 0]]

          tf.sparse_segment_sum_with_num_segments(c,
          tf.constant([0, 1]),
          tf.constant([0, 2],
          num_segments=4))
          # =&amp;gt; [[ 1  2  3  4]
          #     [ 0  0  0  0]
          #     [-1 -2 -3 -4]
          #     [ 0  0  0  0]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseSlice_" data-uid="TensorFlow.TFGraph.SparseSlice*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSlice_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSlice(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Slice a <code>SparseTensor</code> based on the <code>start</code> and <code>size</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseSlice (TensorFlow.TFOutput indices, TensorFlow.TFOutput values, TensorFlow.TFOutput shape, TensorFlow.TFOutput start, TensorFlow.TFOutput size, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>2-D tensor represents the indices of the sparse tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>1-D tensor represents the values of the sparse tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>1-D. tensor represents the shape of the sparse tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">start</span></td>
        <td><p>1-D. tensor represents the start of the slice.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>1-D. tensor represents the size of the slice.
              output indices: A list of 1-D tensors represents the indices of the output
              sparse tensors.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSlice&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_indices:
              output_values: A list of 1-D tensors represents the values of the output sparse
              tensors.
              output_shape: A list of 1-D tensors represents the shape of the output sparse
              tensors.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSlice_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>For example, if the input is</p>
<pre><code>          input_tensor = shape = [2, 7]
          [    a   d e  ]
          [b c          ]

          Graphically the output tensors are:

          sparse_slice([0, 0], [2, 4]) = shape = [2, 4]
          [    a  ]
          [b c    ]

          sparse_slice([0, 4], [2, 3]) = shape = [2, 3]
          [ d e  ]
          [      ]
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseSliceGrad_" data-uid="TensorFlow.TFGraph.SparseSliceGrad*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSliceGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSliceGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>The gradient operator for the SparseSlice op.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseSliceGrad (TensorFlow.TFOutput backprop_val_grad, TensorFlow.TFOutput input_indices, TensorFlow.TFOutput input_start, TensorFlow.TFOutput output_indices, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">backprop_val_grad</span></td>
        <td><p>1-D. The gradient with respect to
              the non-empty values of the sliced <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_indices</span></td>
        <td><p>2-D.  The <code>indices</code> of the input <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_start</span></td>
        <td><p>1-D. tensor represents the start of the slice.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_indices</span></td>
        <td><p>2-D.  The <code>indices</code> of the sliced <code>SparseTensor</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSliceGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>1-D. The gradient with respect to the non-empty values of input <code>SparseTensor</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSliceGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op takes in the upstream gradient w.r.t. non-empty values of
              the sliced <code>SparseTensor</code>, and outputs the gradients w.r.t.
              the non-empty values of input <code>SparseTensor</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseSoftmax_" data-uid="TensorFlow.TFGraph.SparseSoftmax*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSoftmax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSoftmax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSoftmax(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Applies softmax to a batched N-D <code>SparseTensor</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseSoftmax (TensorFlow.TFOutput sp_indices, TensorFlow.TFOutput sp_values, TensorFlow.TFOutput sp_shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sp_indices</span></td>
        <td><p>2-D.  <code>NNZ x R</code> matrix with the indices of non-empty values in a
              SparseTensor, in canonical ordering.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sp_values</span></td>
        <td><p>1-D.  <code>NNZ</code> non-empty values corresponding to <code>sp_indices</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sp_shape</span></td>
        <td><p>1-D.  Shape of the input SparseTensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSoftmax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>1-D.  The <code>NNZ</code> values for the result <code>SparseTensor</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSoftmax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The inputs represent an N-D SparseTensor  with logical shape <code>[..., B, C]</code>
              (where <code>N &gt;= 2</code>), and with indices sorted in the canonical lexicographic order.</p>
<pre><code>          This op is equivalent to applying the normal &lt;code&gt;tf.nn.softmax()&lt;/code&gt; to each innermost
          logical submatrix with shape &lt;code&gt;[B, C]&lt;/code&gt;, but with the catch that *the implicitly
          zero elements do not participate*.  Specifically, the algorithm is equivalent
          to the following:

          (1) Applies &lt;code&gt;tf.nn.softmax()&lt;/code&gt; to a densified view of each innermost submatrix
          with shape &lt;code&gt;[B, C]&lt;/code&gt;, along the size-C dimension;
          (2) Masks out the original implicitly-zero locations;
          (3) Renormalizes the remaining elements.

          Hence, the &lt;code&gt;SparseTensor&lt;/code&gt; result has exactly the same non-zero indices and
          shape.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseSoftmaxCrossEntropyWithLogits_" data-uid="TensorFlow.TFGraph.SparseSoftmaxCrossEntropyWithLogits*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSoftmaxCrossEntropyWithLogits_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSoftmaxCrossEntropyWithLogits(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSoftmaxCrossEntropyWithLogits(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes softmax cross entropy cost and gradients to backpropagate.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseSoftmaxCrossEntropyWithLogits (TensorFlow.TFOutput features, TensorFlow.TFOutput labels, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">features</span></td>
        <td><p>batch_size x num_classes matrix</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">labels</span></td>
        <td><p>batch_size vector with values in [0, num_classes).
              This is the label for the given minibatch entry.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSoftmaxCrossEntropyWithLogits&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              loss: Per example loss (batch_size vector).
              backprop: backpropagated gradients (batch_size x num_classes matrix).
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSoftmaxCrossEntropyWithLogits_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Unlike <code>SoftmaxCrossEntropyWithLogits</code>, this operation does not accept
              a matrix of label probabilities, but rather a single label per row
              of features.  This label is considered to have probability 1.0 for the
              given row.</p>
<pre><code>          Inputs are the logits, not probabilities.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseSparseMaximum_" data-uid="TensorFlow.TFGraph.SparseSparseMaximum*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSparseMaximum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSparseMaximum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSparseMaximum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the element-wise max of two SparseTensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseSparseMaximum (TensorFlow.TFOutput a_indices, TensorFlow.TFOutput a_values, TensorFlow.TFOutput a_shape, TensorFlow.TFOutput b_indices, TensorFlow.TFOutput b_values, TensorFlow.TFOutput b_shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_indices</span></td>
        <td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
              SparseTensor, in the canonical lexicographic ordering.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_values</span></td>
        <td><p>1-D.  <code>N</code> non-empty values corresponding to <code>a_indices</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_shape</span></td>
        <td><p>1-D.  Shape of the input SparseTensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b_indices</span></td>
        <td><p>counterpart to <code>a_indices</code> for the other operand.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b_values</span></td>
        <td><p>counterpart to <code>a_values</code> for the other operand; must be of the same dtype.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b_shape</span></td>
        <td><p>counterpart to <code>a_shape</code> for the other operand; the two shapes must be equal.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSparseMaximum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_indices: 2-D.  The indices of the output SparseTensor.
              output_values: 1-D.  The values of the output SparseTensor.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSparseMaximum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Assumes the two SparseTensors have the same shape, i.e., no broadcasting.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseSparseMinimum_" data-uid="TensorFlow.TFGraph.SparseSparseMinimum*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSparseMinimum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseSparseMinimum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseSparseMinimum(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the element-wise min of two SparseTensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseSparseMinimum (TensorFlow.TFOutput a_indices, TensorFlow.TFOutput a_values, TensorFlow.TFOutput a_shape, TensorFlow.TFOutput b_indices, TensorFlow.TFOutput b_values, TensorFlow.TFOutput b_shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_indices</span></td>
        <td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
              SparseTensor, in the canonical lexicographic ordering.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_values</span></td>
        <td><p>1-D.  <code>N</code> non-empty values corresponding to <code>a_indices</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_shape</span></td>
        <td><p>1-D.  Shape of the input SparseTensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b_indices</span></td>
        <td><p>counterpart to <code>a_indices</code> for the other operand.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b_values</span></td>
        <td><p>counterpart to <code>a_values</code> for the other operand; must be of the same dtype.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b_shape</span></td>
        <td><p>counterpart to <code>a_shape</code> for the other operand; the two shapes must be equal.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSparseMinimum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_indices: 2-D.  The indices of the output SparseTensor.
              output_values: 1-D.  The values of the output SparseTensor.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSparseMinimum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Assumes the two SparseTensors have the same shape, i.e., no broadcasting.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseSplit_" data-uid="TensorFlow.TFGraph.SparseSplit*"></a>
  <h4 id="TensorFlow_TFGraph_SparseSplit_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.SparseSplit(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">SparseSplit(TFOutput, TFOutput, TFOutput, TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>Split a <code>SparseTensor</code> into <code>num_split</code> tensors along one dimension.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput[],TensorFlow.TFOutput[],TensorFlow.TFOutput[]&gt; SparseSplit (TensorFlow.TFOutput split_dim, TensorFlow.TFOutput indices, TensorFlow.TFOutput values, TensorFlow.TFOutput shape, long num_split, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">split_dim</span></td>
        <td><p>0-D.  The dimension along which to split.  Must be in the range
              <code>[0, rank(shape))</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>2-D tensor represents the indices of the sparse tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>1-D tensor represents the values of the sparse tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>1-D. tensor represents the shape of the sparse tensor.
              output indices: A list of 1-D tensors represents the indices of the output
              sparse tensors.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_split</span></td>
        <td><p>The number of ways to split.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseSplit&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[],<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_indices:
              output_values: A list of 1-D tensors represents the values of the output sparse
              tensors.
              output_shape: A list of 1-D tensors represents the shape of the output sparse
              tensors.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseSplit_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If the <code>shape[split_dim]</code> is not an integer multiple of <code>num_split</code>. Slices
              <code>[0 : shape[split_dim] % num_split]</code> gets one extra dimension.
              For example, if <code>split_dim = 1</code> and <code>num_split = 2</code> and the input is</p>
<pre><code>          input_tensor = shape = [2, 7]
          [    a   d e  ]
          [b c          ]

          Graphically the output tensors are:

          output_tensor[0] = shape = [2, 4]
          [    a  ]
          [b c    ]

          output_tensor[1] = shape = [2, 3]
          [ d e  ]
          [      ]
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseTensorDenseAdd_" data-uid="TensorFlow.TFGraph.SparseTensorDenseAdd*"></a>
  <h4 id="TensorFlow_TFGraph_SparseTensorDenseAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseTensorDenseAdd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseTensorDenseAdd(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Adds up a <code>SparseTensor</code> and a dense <code>Tensor</code>, producing a dense <code>Tensor</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseTensorDenseAdd (TensorFlow.TFOutput a_indices, TensorFlow.TFOutput a_values, TensorFlow.TFOutput a_shape, TensorFlow.TFOutput b, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_indices</span></td>
        <td><p>2-D.  The <code>indices</code> of the <code>SparseTensor</code>, with shape <code>[nnz, ndims]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_values</span></td>
        <td><p>1-D.  The <code>values</code> of the <code>SparseTensor</code>, with shape <code>[nnz]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_shape</span></td>
        <td><p>1-D.  The <code>shape</code> of the <code>SparseTensor</code>, with shape <code>[ndims]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b</span></td>
        <td><p><code>ndims</code>-D Tensor.  With shape <code>a_shape</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseTensorDenseAdd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseTensorDenseAdd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This Op does not require <code>a_indices</code> be sorted in standard lexicographic order.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SparseTensorDenseMatMul_" data-uid="TensorFlow.TFGraph.SparseTensorDenseMatMul*"></a>
  <h4 id="TensorFlow_TFGraph_SparseTensorDenseMatMul_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseTensorDenseMatMul(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">SparseTensorDenseMatMul(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Multiply SparseTensor (of rank 2) &quot;A&quot; by dense matrix &quot;B&quot;.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseTensorDenseMatMul (TensorFlow.TFOutput a_indices, TensorFlow.TFOutput a_values, TensorFlow.TFOutput a_shape, TensorFlow.TFOutput b, Nullable&lt;bool&gt; adjoint_a = null, Nullable&lt;bool&gt; adjoint_b = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_indices</span></td>
        <td><p>2-D.  The <code>indices</code> of the <code>SparseTensor</code>, size <code>[nnz, 2]</code> Matrix.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_values</span></td>
        <td><p>1-D.  The <code>values</code> of the <code>SparseTensor</code>, size <code>[nnz]</code> Vector.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">a_shape</span></td>
        <td><p>1-D.  The <code>shape</code> of the <code>SparseTensor</code>, size <code>[2]</code> Vector.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">b</span></td>
        <td><p>2-D.  A dense Matrix.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">adjoint_a</span></td>
        <td><p>Optional argument
              Use the adjoint of A in the matrix multiply.  If A is complex, this
              is transpose(conj(A)).  Otherwise it&#39;s transpose(A).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">adjoint_b</span></td>
        <td><p>Optional argument
              Use the adjoint of B in the matrix multiply.  If B is complex, this
              is transpose(conj(B)).  Otherwise it&#39;s transpose(B).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseTensorDenseMatMul&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseTensorDenseMatMul_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>No validity checking is performed on the indices of A.  However, the following
              input format is recommended for optimal behavior:</p>
<pre><code>          if adjoint_a == false:
          A should be sorted in lexicographically increasing order.  Use SparseReorder
          if you&#39;re not sure.
          if adjoint_a == true:
          A should be sorted in order of increasing dimension 1 (i.e., &quot;column major&quot;
          order instead of &quot;row major&quot; order).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseTensorSliceDataset_" data-uid="TensorFlow.TFGraph.SparseTensorSliceDataset*"></a>
  <h4 id="TensorFlow_TFGraph_SparseTensorSliceDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SparseTensorSliceDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SparseTensorSliceDataset(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that splits a SparseTensor into elements row-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseTensorSliceDataset (TensorFlow.TFOutput indices, TensorFlow.TFOutput values, TensorFlow.TFOutput dense_shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dense_shape</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseTensorSliceDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_SparseToDense_" data-uid="TensorFlow.TFGraph.SparseToDense*"></a>
  <h4 id="TensorFlow_TFGraph_SparseToDense_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseToDense(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">SparseToDense(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Converts a sparse representation into a dense tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SparseToDense (TensorFlow.TFOutput sparse_indices, TensorFlow.TFOutput output_shape, TensorFlow.TFOutput sparse_values, TensorFlow.TFOutput default_value, Nullable&lt;bool&gt; validate_indices = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_indices</span></td>
        <td><p>0-D, 1-D, or 2-D.  <code>sparse_indices[i]</code> contains the complete
              index where <code>sparse_values[i]</code> will be placed.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output_shape</span></td>
        <td><p>1-D.  Shape of the dense output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_values</span></td>
        <td><p>1-D.  Values corresponding to each row of <code>sparse_indices</code>,
              or a scalar value to be used for all sparse indices.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">default_value</span></td>
        <td><p>Scalar value to set for indices not specified in
              <code>sparse_indices</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">validate_indices</span></td>
        <td><p>Optional argument
              If true, indices are checked to make sure they are sorted in
              lexicographic order and that there are no repeats.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseToDense&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Dense output tensor of shape <code>output_shape</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseToDense_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Builds an array <code>dense</code> with shape <code>output_shape</code> such that</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          # If sparse_indices is scalar
          dense[i] = (i == sparse_indices ? sparse_values : default_value)

          # If sparse_indices is a vector, then for each i
          dense[sparse_indices[i]] = sparse_values[i]

          # If sparse_indices is an n by d matrix, then for each i in [0, n)
          dense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]
           &lt;/code&gt;&lt;/pre&gt;

          All other values in &lt;code&gt;dense&lt;/code&gt; are set to &lt;code&gt;default_value&lt;/code&gt;.  If &lt;code&gt;sparse_values&lt;/code&gt; is a
          scalar, all sparse indices are set to this single value.

          Indices should be sorted in lexicographic order, and indices must not
          contain any repeats. If &lt;code&gt;validate_indices&lt;/code&gt; is true, these properties
          are checked during execution.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_SparseToSparseSetOperation_" data-uid="TensorFlow.TFGraph.SparseToSparseSetOperation*"></a>
  <h4 id="TensorFlow_TFGraph_SparseToSparseSetOperation_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.SparseToSparseSetOperation(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.String)">SparseToSparseSetOperation(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Applies set operation along last dimension of 2 <code>SparseTensor</code> inputs.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; SparseToSparseSetOperation (TensorFlow.TFOutput set1_indices, TensorFlow.TFOutput set1_values, TensorFlow.TFOutput set1_shape, TensorFlow.TFOutput set2_indices, TensorFlow.TFOutput set2_values, TensorFlow.TFOutput set2_shape, string set_operation, Nullable&lt;bool&gt; validate_indices = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set1_indices</span></td>
        <td><p>2D <code>Tensor</code>, indices of a <code>SparseTensor</code>. Must be in row-major
              order.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set1_values</span></td>
        <td><p>1D <code>Tensor</code>, values of a <code>SparseTensor</code>. Must be in row-major
              order.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set1_shape</span></td>
        <td><p>1D <code>Tensor</code>, shape of a <code>SparseTensor</code>. <code>set1_shape[0...n-1]</code> must
              be the same as <code>set2_shape[0...n-1]</code>, <code>set1_shape[n]</code> is the
              max set size across <code>0...n-1</code> dimensions.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set2_indices</span></td>
        <td><p>2D <code>Tensor</code>, indices of a <code>SparseTensor</code>. Must be in row-major
              order.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set2_values</span></td>
        <td><p>1D <code>Tensor</code>, values of a <code>SparseTensor</code>. Must be in row-major
              order.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">set2_shape</span></td>
        <td><p>1D <code>Tensor</code>, shape of a <code>SparseTensor</code>. <code>set2_shape[0...n-1]</code> must
              be the same as <code>set1_shape[0...n-1]</code>, <code>set2_shape[n]</code> is the
              max set size across <code>0...n-1</code> dimensions.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">set_operation</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">validate_indices</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SparseToSparseSetOperation&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              result_indices: 2D indices of a <code>SparseTensor</code>.
              result_values: 1D values of a <code>SparseTensor</code>.
              result_shape: 1D <code>Tensor</code> shape of a <code>SparseTensor</code>. <code>result_shape[0...n-1]</code> is
              the same as the 1st <code>n-1</code> dimensions of <code>set1</code> and <code>set2</code>, <code>result_shape[n]</code>
              is the max result set size across all <code>0...n-1</code> dimensions.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SparseToSparseSetOperation_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>See SetOperationOp::SetOperationFromContext for values of <code>set_operation</code>.</p>
<pre><code>          If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;SparseToSparseSetOperation&lt;/code&gt; validates the
          order and range of &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; indices.

          Input &lt;code&gt;set1&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; represented by &lt;code&gt;set1_indices&lt;/code&gt;, &lt;code&gt;set1_values&lt;/code&gt;,
          and &lt;code&gt;set1_shape&lt;/code&gt;. For &lt;code&gt;set1&lt;/code&gt; ranked &lt;code&gt;n&lt;/code&gt;, 1st &lt;code&gt;n-1&lt;/code&gt; dimensions must be the same
          as &lt;code&gt;set2&lt;/code&gt;. Dimension &lt;code&gt;n&lt;/code&gt; contains values in a set, duplicates are allowed but
          ignored.

          Input &lt;code&gt;set2&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; represented by &lt;code&gt;set2_indices&lt;/code&gt;, &lt;code&gt;set2_values&lt;/code&gt;,
          and &lt;code&gt;set2_shape&lt;/code&gt;. For &lt;code&gt;set2&lt;/code&gt; ranked &lt;code&gt;n&lt;/code&gt;, 1st &lt;code&gt;n-1&lt;/code&gt; dimensions must be the same
          as &lt;code&gt;set1&lt;/code&gt;. Dimension &lt;code&gt;n&lt;/code&gt; contains values in a set, duplicates are allowed but
          ignored.

          If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this op validates the order and range of &lt;code&gt;set1&lt;/code&gt;
          and &lt;code&gt;set2&lt;/code&gt; indices.

          Output &lt;code&gt;result&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; represented by &lt;code&gt;result_indices&lt;/code&gt;,
          &lt;code&gt;result_values&lt;/code&gt;, and &lt;code&gt;result_shape&lt;/code&gt;. For &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; ranked &lt;code&gt;n&lt;/code&gt;, this
          has rank &lt;code&gt;n&lt;/code&gt; and the same 1st &lt;code&gt;n-1&lt;/code&gt; dimensions as &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt;. The &lt;code&gt;nth&lt;/code&gt;
          dimension contains the result of &lt;code&gt;set_operation&lt;/code&gt; applied to the corresponding
          &lt;code&gt;[0...n-1]&lt;/code&gt; dimension of &lt;code&gt;set&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Split_" data-uid="TensorFlow.TFGraph.Split*"></a>
  <h4 id="TensorFlow_TFGraph_Split_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.Split(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">Split(TFOutput, TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>Splits a tensor into <code>num_split</code> tensors along one dimension.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] Split (TensorFlow.TFOutput split_dim, TensorFlow.TFOutput value, long num_split, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">split_dim</span></td>
        <td><p>0-D.  The dimension along which to split.  Must be in the range
              <code>[-rank(value), rank(value))</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>The tensor to split.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_split</span></td>
        <td><p>The number of ways to split.  Must evenly divide
              <code>value.shape[split_dim]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Split&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>They are identically shaped tensors, whose shape matches that of <code>value</code>
              except along <code>axis</code>, where their sizes are
              <code>values.shape[split_dim] / num_split</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_SplitV_" data-uid="TensorFlow.TFGraph.SplitV*"></a>
  <h4 id="TensorFlow_TFGraph_SplitV_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.SplitV(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String)">SplitV(TFOutput, TFOutput, TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>Splits a tensor into <code>num_split</code> tensors along one dimension.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] SplitV (TensorFlow.TFOutput value, TensorFlow.TFOutput size_splits, TensorFlow.TFOutput split_dim, long num_split, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>The tensor to split.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size_splits</span></td>
        <td><p>list containing the sizes of each output tensor along the split
              dimension. Must sum to the dimension of value along split_dim.
              Can contain one -1 indicating that dimension is to be inferred.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">split_dim</span></td>
        <td><p>0-D.  The dimension along which to split.  Must be in the range
              <code>[-rank(value), rank(value))</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_split</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SplitV&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>Tensors whose shape matches that of <code>value</code>
              except along <code>axis</code>, where their sizes are
              <code>size_splits[i]</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Sqrt_" data-uid="TensorFlow.TFGraph.Sqrt*"></a>
  <h4 id="TensorFlow_TFGraph_Sqrt_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Sqrt(TensorFlow.TFOutput,System.String)">Sqrt(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes square root of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Sqrt (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Sqrt&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Sqrt_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>I.e., \(y = \sqrt{x} = x^{1/2}\).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SqrtGrad_" data-uid="TensorFlow.TFGraph.SqrtGrad*"></a>
  <h4 id="TensorFlow_TFGraph_SqrtGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SqrtGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SqrtGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradient for the sqrt of <code>x</code> wrt its input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SqrtGrad (TensorFlow.TFOutput y, TensorFlow.TFOutput dy, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dy</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SqrtGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SqrtGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Specifically, <code>grad = dy * 0.5 / y</code>, where <code>y = sqrt(x)</code>, and <code>dy</code>
              is the corresponding input gradient.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Square_" data-uid="TensorFlow.TFGraph.Square*"></a>
  <h4 id="TensorFlow_TFGraph_Square_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Square(TensorFlow.TFOutput,System.String)">Square(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes square of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Square (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Square&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Square_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>I.e., \(y = x * x = x^2\).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_SquaredDifference_" data-uid="TensorFlow.TFGraph.SquaredDifference*"></a>
  <h4 id="TensorFlow_TFGraph_SquaredDifference_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.SquaredDifference(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">SquaredDifference(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns (x - y)(x - y) element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput SquaredDifference (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;SquaredDifference&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_SquaredDifference_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>SquaredDifference</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Squeeze_" data-uid="TensorFlow.TFGraph.Squeeze*"></a>
  <h4 id="TensorFlow_TFGraph_Squeeze_TensorFlow_TFOutput_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.Squeeze(TensorFlow.TFOutput,System.Int64[],System.String)">Squeeze(TFOutput, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Removes dimensions of size 1 from the shape of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Squeeze (TensorFlow.TFOutput input, long[] squeeze_dims = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The <code>input</code> to squeeze.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">squeeze_dims</span></td>
        <td><p>Optional argument
              If specified, only squeezes the dimensions listed. The dimension
              index starts at 0. It is an error to squeeze a dimension that is not 1. Must
              be in the range <code>[-rank(input), rank(input))</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Squeeze&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Contains the same data as <code>input</code>, but has one or more dimensions of
              size 1 removed.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Squeeze_TensorFlow_TFOutput_System_Int64___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Given a tensor <code>input</code>, this operation returns a tensor of the same type with
              all dimensions of size 1 removed. If you don&#39;t want to remove all size 1
              dimensions, you can remove specific size 1 dimensions by specifying
              <code>axis</code>.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;t&#39; is a tensor of shape [1, 2, 1, 3, 1, 1]
          shape(squeeze(t)) ==&amp;gt; [2, 3]
           &lt;/code&gt;&lt;/pre&gt;

          Or, to remove specific size 1 dimensions:

           &lt;pre&gt;&lt;code&gt;
          # &#39;t&#39; is a tensor of shape [1, 2, 1, 3, 1, 1]
          shape(squeeze(t, [2, 4])) ==&amp;gt; [1, 2, 3, 1]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Stack_" data-uid="TensorFlow.TFGraph.Stack*"></a>
  <h4 id="TensorFlow_TFGraph_Stack_TensorFlow_TFDataType_System_String_System_String_" data-uid="TensorFlow.TFGraph.Stack(TensorFlow.TFDataType,System.String,System.String)">Stack(TFDataType, String, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated, use StackV2.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Stack (TensorFlow.TFDataType elem_type, string stack_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">elem_type</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">stack_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Stack&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Stack_" data-uid="TensorFlow.TFGraph.Stack*"></a>
  <h4 id="TensorFlow_TFGraph_Stack_TensorFlow_TFOutput___System_Nullable_System_Int32__System_String_" data-uid="TensorFlow.TFGraph.Stack(TensorFlow.TFOutput[],System.Nullable{System.Int32},System.String)">Stack(TFOutput[], Nullable&lt;Int32&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Stacks a list of rank-<code>R</code> tensors into one rank-<code>(R+1)</code> tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Stack (TensorFlow.TFOutput[] values, Nullable&lt;int&gt; axis = 0, string operName = &quot;stack&quot;);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">values</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int32</span>&gt;</td>
        <td><span class="parametername">axis</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Stack_TensorFlow_TFOutput___System_Nullable_System_Int32__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Packs the list of tensors in <code>values</code> into a tensor with rank one higher than
             each tensor in <code>values</code>, by packing them along the <code>axis</code> dimension.
             Given a list of length <code>N</code> of tensors of shape <code>(A, B, C)</code>: if <code>axis == 0</code> then the 
             <code>output</code> tensor will have the shape <code>(N, A, B, C)</code>; if <code>axis == 1</code> then the <code>output</code>
             tensor will have the shape <code>(A, N, B, C)</code>; etc.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_StackClose_" data-uid="TensorFlow.TFGraph.StackClose*"></a>
  <h4 id="TensorFlow_TFGraph_StackClose_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.StackClose(TensorFlow.TFOutput,System.String)">StackClose(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated, use StackCloseV2.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation StackClose (TensorFlow.TFOutput handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StackClose&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_StackCloseV2_" data-uid="TensorFlow.TFGraph.StackCloseV2*"></a>
  <h4 id="TensorFlow_TFGraph_StackCloseV2_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.StackCloseV2(TensorFlow.TFOutput,System.String)">StackCloseV2(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Delete the stack from its resource container.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation StackCloseV2 (TensorFlow.TFOutput handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a stack.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StackCloseV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_StackPop_" data-uid="TensorFlow.TFGraph.StackPop*"></a>
  <h4 id="TensorFlow_TFGraph_StackPop_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.StackPop(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">StackPop(TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated, use StackPopV2.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StackPop (TensorFlow.TFOutput handle, TensorFlow.TFDataType elem_type, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">elem_type</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StackPop&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_StackPopV2_" data-uid="TensorFlow.TFGraph.StackPopV2*"></a>
  <h4 id="TensorFlow_TFGraph_StackPopV2_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.StackPopV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">StackPopV2(TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Pop the element at the top of the stack.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StackPopV2 (TensorFlow.TFOutput handle, TensorFlow.TFDataType elem_type, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a stack.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">elem_type</span></td>
        <td><p>The type of the elem that is popped.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StackPopV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The tensor that is popped from the top of the stack.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_StackPush_" data-uid="TensorFlow.TFGraph.StackPush*"></a>
  <h4 id="TensorFlow_TFGraph_StackPush_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.StackPush(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">StackPush(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated, use StackPushV2.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StackPush (TensorFlow.TFOutput handle, TensorFlow.TFOutput elem, Nullable&lt;bool&gt; swap_memory = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">elem</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">swap_memory</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StackPush&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_StackPushV2_" data-uid="TensorFlow.TFGraph.StackPushV2*"></a>
  <h4 id="TensorFlow_TFGraph_StackPushV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.StackPushV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">StackPushV2(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Push an element onto the stack.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StackPushV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput elem, Nullable&lt;bool&gt; swap_memory = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a stack.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">elem</span></td>
        <td><p>The tensor to be pushed onto the stack.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">swap_memory</span></td>
        <td><p>Optional argument
              Swap <code>elem</code> to CPU. Default to false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StackPushV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The same tensor as the input &#39;elem&#39;.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_StackV2_" data-uid="TensorFlow.TFGraph.StackV2*"></a>
  <h4 id="TensorFlow_TFGraph_StackV2_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_System_String_" data-uid="TensorFlow.TFGraph.StackV2(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String)">StackV2(TFOutput, TFDataType, String, String)</h4>
  <div class="markdown level1 summary"><p>A stack that produces elements in first-in last-out order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StackV2 (TensorFlow.TFOutput max_size, TensorFlow.TFDataType elem_type, string stack_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">max_size</span></td>
        <td><p>The maximum size of the stack if non-negative. If negative, the stack
              size is unlimited.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">elem_type</span></td>
        <td><p>The type of the elements on the stack.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">stack_name</span></td>
        <td><p>Optional argument
              Overrides the name used for the temporary stack resource. Default
              value is the name of the &#39;Stack&#39; op (which is guaranteed unique).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StackV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to the stack.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Stage_" data-uid="TensorFlow.TFGraph.Stage*"></a>
  <h4 id="TensorFlow_TFGraph_Stage_TensorFlow_TFOutput___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.Stage(TensorFlow.TFOutput[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">Stage(TFOutput[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Stage values similar to a lightweight Enqueue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation Stage (TensorFlow.TFOutput[] values, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">values</span></td>
        <td><p>a list of tensors
              dtypes A list of data types that inserted values should adhere to.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument
              Maximum number of elements in the Staging Area. If &gt; 0, inserts
              on the container will block when the capacity is reached.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument
              The maximum number of bytes allowed for Tensors in the Staging Area.
              If &gt; 0, inserts will block until sufficient space is available.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this queue is placed in the given container. Otherwise,
              a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              It is necessary to match this name to the matching Unstage Op.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Stage&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Stage_TensorFlow_TFOutput___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The basic functionality of this Op is similar to a queue with many
              fewer capabilities and options.  This Op is optimized for performance.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_StageClear_" data-uid="TensorFlow.TFGraph.StageClear*"></a>
  <h4 id="TensorFlow_TFGraph_StageClear_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.StageClear(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">StageClear(TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op removes all elements in the underlying container.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation StageClear (TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StageClear&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_StagePeek_" data-uid="TensorFlow.TFGraph.StagePeek*"></a>
  <h4 id="TensorFlow_TFGraph_StagePeek_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.StagePeek(TensorFlow.TFOutput,TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">StagePeek(TFOutput, TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op peeks at the values at the specified index.  If the</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] StagePeek (TensorFlow.TFOutput index, TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">index</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StagePeek&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StagePeek_TensorFlow_TFOutput_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>underlying container does not contain sufficient elements
              this op will block until it does.   This Op is optimized for
              performance.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_StageSize_" data-uid="TensorFlow.TFGraph.StageSize*"></a>
  <h4 id="TensorFlow_TFGraph_StageSize_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.StageSize(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">StageSize(TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op returns the number of elements in the underlying container.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StageSize (TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StageSize&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_StatelessMultinomial_" data-uid="TensorFlow.TFGraph.StatelessMultinomial*"></a>
  <h4 id="TensorFlow_TFGraph_StatelessMultinomial_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.StatelessMultinomial(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">StatelessMultinomial(TFOutput, TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Draws samples from a multinomial distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StatelessMultinomial (TensorFlow.TFOutput logits, TensorFlow.TFOutput num_samples, TensorFlow.TFOutput seed, Nullable&lt;TensorFlow.TFDataType&gt; output_dtype = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">logits</span></td>
        <td><p>2-D Tensor with shape <code>[batch_size, num_classes]</code>.  Each slice <code>[i, :]</code>
              represents the unnormalized log probabilities for all classes.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_samples</span></td>
        <td><p>0-D.  Number of independent samples to draw for each row slice.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">seed</span></td>
        <td><p>2 seeds (shape [2]).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">output_dtype</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StatelessMultinomial&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>2-D Tensor with shape <code>[batch_size, num_samples]</code>.  Each slice <code>[i, :]</code>
              contains the drawn class labels with range <code>[0, num_classes)</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_StatelessRandomNormal_" data-uid="TensorFlow.TFGraph.StatelessRandomNormal*"></a>
  <h4 id="TensorFlow_TFGraph_StatelessRandomNormal_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.StatelessRandomNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">StatelessRandomNormal(TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Outputs deterministic pseudorandom values from a normal distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StatelessRandomNormal (TensorFlow.TFOutput shape, TensorFlow.TFOutput seed, Nullable&lt;TensorFlow.TFDataType&gt; dtype = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">seed</span></td>
        <td><p>2 seeds (shape [2]).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">dtype</span></td>
        <td><p>Optional argument
              The type of the output.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StatelessRandomNormal&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Random values with specified shape.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StatelessRandomNormal_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The generated values will have mean 0 and standard deviation 1.</p>
<pre><code>          The outputs are a deterministic function of &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_StatelessRandomUniform_" data-uid="TensorFlow.TFGraph.StatelessRandomUniform*"></a>
  <h4 id="TensorFlow_TFGraph_StatelessRandomUniform_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.StatelessRandomUniform(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">StatelessRandomUniform(TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Outputs deterministic pseudorandom random values from a uniform distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StatelessRandomUniform (TensorFlow.TFOutput shape, TensorFlow.TFOutput seed, Nullable&lt;TensorFlow.TFDataType&gt; dtype = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">seed</span></td>
        <td><p>2 seeds (shape [2]).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">dtype</span></td>
        <td><p>Optional argument
              The type of the output.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StatelessRandomUniform&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Random values with specified shape.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StatelessRandomUniform_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The generated values follow a uniform distribution in the range <code>[0, 1)</code>. The
              lower bound 0 is included in the range, while the upper bound 1 is excluded.</p>
<pre><code>          The outputs are a deterministic function of &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_StatelessTruncatedNormal_" data-uid="TensorFlow.TFGraph.StatelessTruncatedNormal*"></a>
  <h4 id="TensorFlow_TFGraph_StatelessTruncatedNormal_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.StatelessTruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">StatelessTruncatedNormal(TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Outputs deterministic pseudorandom values from a truncated normal distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StatelessTruncatedNormal (TensorFlow.TFOutput shape, TensorFlow.TFOutput seed, Nullable&lt;TensorFlow.TFDataType&gt; dtype = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">seed</span></td>
        <td><p>2 seeds (shape [2]).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">dtype</span></td>
        <td><p>Optional argument
              The type of the output.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StatelessTruncatedNormal&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Random values with specified shape.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StatelessTruncatedNormal_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The generated values follow a normal distribution with mean 0 and standard
              deviation 1, except that values whose magnitude is more than 2 standard
              deviations from the mean are dropped and re-picked.</p>
<pre><code>          The outputs are a deterministic function of &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_StaticRegexFullMatch_" data-uid="TensorFlow.TFGraph.StaticRegexFullMatch*"></a>
  <h4 id="TensorFlow_TFGraph_StaticRegexFullMatch_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.StaticRegexFullMatch(TensorFlow.TFOutput,System.String,System.String)">StaticRegexFullMatch(TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>Check if the input matches the regex pattern.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StaticRegexFullMatch (TensorFlow.TFOutput input, string pattern, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A string tensor of the text to be processed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">pattern</span></td>
        <td><p>The regular expression to match the input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StaticRegexFullMatch&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A bool tensor with the same shape as <code>input</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StaticRegexFullMatch_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The input is a string tensor of any shape. The pattern is the
              regular expression to be matched with every element of the input tensor.
              The boolean values (True or False) of the output tensor indicate
              if the input matches the regex pattern provided.</p>
<pre><code>          The pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_StaticRegexReplace_" data-uid="TensorFlow.TFGraph.StaticRegexReplace*"></a>
  <h4 id="TensorFlow_TFGraph_StaticRegexReplace_TensorFlow_TFOutput_System_String_System_String_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.StaticRegexReplace(TensorFlow.TFOutput,System.String,System.String,System.Nullable{System.Boolean},System.String)">StaticRegexReplace(TFOutput, String, String, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Replaces the match of pattern in input with rewrite.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StaticRegexReplace (TensorFlow.TFOutput input, string pattern, string rewrite, Nullable&lt;bool&gt; replace_global = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The text to be processed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">pattern</span></td>
        <td><p>The regular expression to match the input.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">rewrite</span></td>
        <td><p>The rewrite to be applied to the matched expresion.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">replace_global</span></td>
        <td><p>Optional argument
              If True, the replacement is global, otherwise the replacement
              is done only on the first match.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StaticRegexReplace&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The text after applying pattern and rewrite.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StaticRegexReplace_TensorFlow_TFOutput_System_String_System_String_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>It follows the re2 syntax (<a href="https://github.com/google/re2/wiki/Syntax">https://github.com/google/re2/wiki/Syntax</a>)</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_StopGradient_" data-uid="TensorFlow.TFGraph.StopGradient*"></a>
  <h4 id="TensorFlow_TFGraph_StopGradient_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.StopGradient(TensorFlow.TFOutput,System.String)">StopGradient(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Stops gradient computation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StopGradient (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StopGradient&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StopGradient_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>When executed in a graph, this op outputs its input tensor as-is.</p>
<pre><code>          When building ops to compute gradients, this op prevents the contribution of
          its inputs to be taken into account.  Normally, the gradient generator adds ops
          to a graph to compute the derivatives of a specified &#39;loss&#39; by recursively
          finding out inputs that contributed to its computation.  If you insert this op
          in the graph it inputs are masked from the gradient generator.  They are not
          taken into account for computing gradients.

          This is useful any time you want to compute a value with TensorFlow but need
          to pretend that the value was a constant. Some examples include:

          *  The *EM* algorithm where the *M-step* should not involve backpropagation
          through the output of the *E-step*.
          *  Contrastive divergence training of Boltzmann machines where, when
          differentiating the energy function, the training must not backpropagate
          through the graph that generated the samples from the model.
          *  Adversarial training, where no backprop should happen through the adversarial
          example generation process.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_StridedSlice_" data-uid="TensorFlow.TFGraph.StridedSlice*"></a>
  <h4 id="TensorFlow_TFGraph_StridedSlice_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.StridedSlice(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">StridedSlice(TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Return a strided slice from <code>input</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StridedSlice (TensorFlow.TFOutput input, TensorFlow.TFOutput begin, TensorFlow.TFOutput end, TensorFlow.TFOutput strides, Nullable&lt;long&gt; begin_mask = null, Nullable&lt;long&gt; end_mask = null, Nullable&lt;long&gt; ellipsis_mask = null, Nullable&lt;long&gt; new_axis_mask = null, Nullable&lt;long&gt; shrink_axis_mask = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">begin</span></td>
        <td><p><code>begin[k]</code> specifies the offset into the <code>k</code>th range specification.
              The exact dimension this corresponds to will be determined by context.
              Out-of-bounds values will be silently clamped. If the <code>k</code>th bit of
              <code>begin_mask</code> then <code>begin[k]</code> is ignored and the full range of the
              appropriate dimension is used instead. Negative values causes indexing
              to start from the highest element e.g. If <code>foo==[1,2,3]</code> then <code>foo[-1]==3</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">end</span></td>
        <td><p><code>end[i]</code> is like <code>begin</code> with the exception that <code>end_mask</code> is
              used to determine full ranges.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">strides</span></td>
        <td><p><code>strides[i]</code> specifies the increment in the <code>i</code>th specification
              after extracting a given element. Negative indices will reverse
              the original order. Out or range values are
              clamped to <code>[0,dim[i]) if slice[i]&gt;0</code> or <code>[-1,dim[i]-1] if slice[i] &lt; 0</code></p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">begin_mask</span></td>
        <td><p>Optional argument
              a bitmask where a bit i being 1 means to ignore the begin
              value and instead use the largest interval possible. At runtime
              begin[i] will be replaced with <code>[0, n-1)</code> if <code>stride[i] &gt; 0</code> or
              <code>[-1, n-1]</code> if <code>stride[i] &lt; 0</code></p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">end_mask</span></td>
        <td><p>Optional argument
              analogous to <code>begin_mask</code></p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">ellipsis_mask</span></td>
        <td><p>Optional argument
              a bitmask where bit <code>i</code> being 1 means the <code>i</code>th
              position is actually an ellipsis. One bit at most can be 1.
              If <code>ellipsis_mask == 0</code>, then an implicit ellipsis mask of <code>1 &lt;&lt; (m+1)</code>
              is provided. This means that <code>foo[3:5] == foo[3:5, ...]</code>. An ellipsis
              implicitly creates as many range specifications as necessary to fully
              specify the sliced range for every dimension. For example for a 4-dimensional
              tensor <code>foo</code> the slice <code>foo[2, ..., 5:8]</code> implies <code>foo[2, :, :, 5:8]</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">new_axis_mask</span></td>
        <td><p>Optional argument
              a bitmask where bit <code>i</code> being 1 means the <code>i</code>th
              specification creates a new shape 1 dimension. For example
              <code>foo[:4, tf.newaxis, :2]</code> would produce a shape <code>(4, 1, 2)</code> tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">shrink_axis_mask</span></td>
        <td><p>Optional argument
              a bitmask where bit <code>i</code> implies that the <code>i</code>th
              specification should shrink the dimensionality. begin and end
              must imply a slice of size 1 in the dimension. For example in
              python one might do <code>foo[:, 3, :]</code> which would result in
              <code>shrink_axis_mask</code> being 2.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StridedSlice&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StridedSlice_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Note, most python users will want to use the Python <code>Tensor.<strong>getitem</strong></code>
              or <code>Variable.<strong>getitem</strong></code> rather than this op directly.</p>
<pre><code>          The goal of this op is to produce a new tensor with a subset of
          the elements from the &lt;code&gt;n&lt;/code&gt; dimensional &lt;code&gt;input&lt;/code&gt; tensor. The subset is chosen using
          a sequence of &lt;code&gt;m&lt;/code&gt; sparse range specifications encoded into the arguments
          of this function. Note, in some cases
          &lt;code&gt;m&lt;/code&gt; could be equal to &lt;code&gt;n&lt;/code&gt;, but this need not be the case. Each
          range specification entry can be one of the following:

          - An ellipsis (...). Ellipses are used to imply zero or more
          dimensions of full-dimension selection and are produced using
          &lt;code&gt;ellipsis_mask&lt;/code&gt;. For example, &lt;code&gt;foo[...]&lt;/code&gt; is the identity slice.

          - A new axis. This is used to insert a new shape=1 dimension and is
          produced using &lt;code&gt;new_axis_mask&lt;/code&gt;. For example, &lt;code&gt;foo[:, ...]&lt;/code&gt; where
          &lt;code&gt;foo&lt;/code&gt; is shape &lt;code&gt;(3, 4)&lt;/code&gt; produces a &lt;code&gt;(1, 3, 4)&lt;/code&gt; tensor.


          - A range &lt;code&gt;begin:end:stride&lt;/code&gt;. This is used to specify how much to choose from
          a given dimension. &lt;code&gt;stride&lt;/code&gt; can be any integer but 0.  &lt;code&gt;begin&lt;/code&gt; is an integer
          which represents the index of the first value to select while &lt;code&gt;end&lt;/code&gt; represents
          the index of the last value to select. The number of values selected in each
          dimension is &lt;code&gt;end - begin&lt;/code&gt; if &lt;code&gt;stride &amp;gt; 0&lt;/code&gt; and &lt;code&gt;begin - end&lt;/code&gt; if &lt;code&gt;stride &amp;lt; 0&lt;/code&gt;.
          &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; can be negative where &lt;code&gt;-1&lt;/code&gt; is the last element, &lt;code&gt;-2&lt;/code&gt; is
          the second to last. &lt;code&gt;begin_mask&lt;/code&gt; controls whether to replace the explicitly
          given &lt;code&gt;begin&lt;/code&gt; with an implicit effective value of &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;stride &amp;gt; 0&lt;/code&gt; and
          &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;stride &amp;lt; 0&lt;/code&gt;. &lt;code&gt;end_mask&lt;/code&gt; is analogous but produces the number
          required to create the largest open interval. For example, given a shape
          &lt;code&gt;(3,)&lt;/code&gt; tensor &lt;code&gt;foo[:]&lt;/code&gt;, the effective &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt;. Do
          not assume this is equivalent to &lt;code&gt;foo[0:-1]&lt;/code&gt; which has an effective &lt;code&gt;begin&lt;/code&gt;
          and &lt;code&gt;end&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;. Another example is &lt;code&gt;foo[-2::-1]&lt;/code&gt; which reverses the
          first dimension of a tensor while dropping the last two (in the original
          order elements). For example &lt;code&gt;foo = [1,2,3,4]; foo[-2::-1]&lt;/code&gt; is &lt;code&gt;[4,3]&lt;/code&gt;.

          - A single index. This is used to keep only elements that have a given
          index. For example (&lt;code&gt;foo[2, :]&lt;/code&gt; on a shape &lt;code&gt;(5,6)&lt;/code&gt; tensor produces a
          shape &lt;code&gt;(6,)&lt;/code&gt; tensor. This is encoded in &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; and
          &lt;code&gt;shrink_axis_mask&lt;/code&gt;.

          Each conceptual range specification is encoded in the op&#39;s argument. This
          encoding is best understand by considering a non-trivial example. In
          particular,
          &lt;code&gt;foo[1, 2:4, None, ..., :-3:-1, :]&lt;/code&gt; will be encoded as

           &lt;pre&gt;&lt;code&gt;
          begin = [1, 2, x, x, 0, x] # x denotes don&#39;t care (usually 0)
          end = [2, 4, x, x, -3, x]
          strides = [1, 1, x, x, -1, 1]
          begin_mask = 1&amp;lt;&amp;lt;4 | 1 &amp;lt;&amp;lt; 5 = 48
          end_mask = 1&amp;lt;&amp;lt;5 = 32
          ellipsis_mask = 1&amp;lt;&amp;lt;3 = 8
          new_axis_mask = 1&amp;lt;&amp;lt;2 4
          shrink_axis_mask = 1&amp;lt;&amp;lt;0
           &lt;/code&gt;&lt;/pre&gt;

          In this case if &lt;code&gt;foo.shape&lt;/code&gt; is (5, 5, 5, 5, 5, 5) the final shape of
          the slice becomes (2, 1, 5, 5, 2, 5).
          Let us walk step by step through each argument specification.

          1.  The first argument in the example slice is turned into &lt;code&gt;begin = 1&lt;/code&gt; and
          &lt;code&gt;end = begin + 1 = 2&lt;/code&gt;. To disambiguate from the original spec &lt;code&gt;2:4&lt;/code&gt; we
          also set the appropriate bit in &lt;code&gt;shrink_axis_mask&lt;/code&gt;.

          2. &lt;code&gt;2:4&lt;/code&gt; is contributes 2, 4, 1 to begin, end, and stride. All masks have
          zero bits contributed.

          3. None is a synonym for &lt;code&gt;tf.newaxis&lt;/code&gt;. This means insert a dimension of size 1
          dimension in the final shape. Dummy values are contributed to begin,
          end and stride, while the new_axis_mask bit is set.

          4. &lt;code&gt;...&lt;/code&gt; grab the full ranges from as many dimensions as needed to
          fully specify a slice for every dimension of the input shape.

          5. &lt;code&gt;:-3:-1&lt;/code&gt; shows the use of negative indices. A negative index &lt;code&gt;i&lt;/code&gt; associated
          with a dimension that has shape &lt;code&gt;s&lt;/code&gt; is converted to a positive index
          &lt;code&gt;s + i&lt;/code&gt;. So &lt;code&gt;-1&lt;/code&gt; becomes &lt;code&gt;s-1&lt;/code&gt; (i.e. the last element). This conversion
          is done internally so begin, end and strides receive x, -3, and -1.
          The appropriate begin_mask bit is set to indicate the start range is the
          full range (ignoring the x).

          6. &lt;code&gt;:&lt;/code&gt; indicates that the entire contents of the corresponding dimension
          is selected. This is equivalent to &lt;code&gt;::&lt;/code&gt; or &lt;code&gt;0::1&lt;/code&gt;. begin, end, and strides
          receive 0, 0, and 1, respectively. The appropriate bits in &lt;code&gt;begin_mask&lt;/code&gt; and
          &lt;code&gt;end_mask&lt;/code&gt; are also set.

          *Requirements*:
          &lt;code&gt;0 != strides[i] for i in [0, m)&lt;/code&gt;&lt;code&gt;ellipsis_mask must be a power of two (only one ellipsis)&lt;/code&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_StridedSliceAssign_" data-uid="TensorFlow.TFGraph.StridedSliceAssign*"></a>
  <h4 id="TensorFlow_TFGraph_StridedSliceAssign_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.StridedSliceAssign(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">StridedSliceAssign(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StridedSliceAssign (TensorFlow.TFOutput reference, TensorFlow.TFOutput begin, TensorFlow.TFOutput end, TensorFlow.TFOutput strides, TensorFlow.TFOutput value, Nullable&lt;long&gt; begin_mask = null, Nullable&lt;long&gt; end_mask = null, Nullable&lt;long&gt; ellipsis_mask = null, Nullable&lt;long&gt; new_axis_mask = null, Nullable&lt;long&gt; shrink_axis_mask = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reference</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">begin</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">end</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">strides</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">begin_mask</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">end_mask</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">ellipsis_mask</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">new_axis_mask</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">shrink_axis_mask</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_StridedSliceGrad_" data-uid="TensorFlow.TFGraph.StridedSliceGrad*"></a>
  <h4 id="TensorFlow_TFGraph_StridedSliceGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.StridedSliceGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">StridedSliceGrad(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns the gradient of <code>StridedSlice</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StridedSliceGrad (TensorFlow.TFOutput shape, TensorFlow.TFOutput begin, TensorFlow.TFOutput end, TensorFlow.TFOutput strides, TensorFlow.TFOutput dy, Nullable&lt;long&gt; begin_mask = null, Nullable&lt;long&gt; end_mask = null, Nullable&lt;long&gt; ellipsis_mask = null, Nullable&lt;long&gt; new_axis_mask = null, Nullable&lt;long&gt; shrink_axis_mask = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">begin</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">end</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">strides</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dy</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">begin_mask</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">end_mask</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">ellipsis_mask</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">new_axis_mask</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">shrink_axis_mask</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StridedSliceGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StridedSliceGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Since <code>StridedSlice</code> cuts out pieces of its <code>input</code> which is size
              <code>shape</code>, its gradient will have the same shape (which is passed here
              as <code>shape</code>). The gradient will be zero in any element that the slice
              does not select.</p>
<pre><code>          Arguments are the same as StridedSliceGrad with the exception that
          &lt;code&gt;dy&lt;/code&gt; is the input gradient to be propagated and &lt;code&gt;shape&lt;/code&gt; is the
          shape of &lt;code&gt;StridedSlice&lt;/code&gt;&#39;s &lt;code&gt;input&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_StringFormat_" data-uid="TensorFlow.TFGraph.StringFormat*"></a>
  <h4 id="TensorFlow_TFGraph_StringFormat_TensorFlow_TFOutput___System_String_System_String_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.StringFormat(TensorFlow.TFOutput[],System.String,System.String,System.Nullable{System.Int64},System.String)">StringFormat(TFOutput[], String, String, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Formats a string template using a list of tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StringFormat (TensorFlow.TFOutput[] inputs, string template = null, string placeholder = null, Nullable&lt;long&gt; summarize = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>The list of tensors to format into the placeholder string.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">template</span></td>
        <td><p>Optional argument
              A string, the template to format tensor summaries into.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">placeholder</span></td>
        <td><p>Optional argument
              A string, at each placeholder in the template a subsequent tensor summary will be inserted.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">summarize</span></td>
        <td><p>Optional argument
              When formatting the tensor summaries print the first and last summarize entries of each tensor dimension.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StringFormat&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>= The resulting string scalar.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StringFormat_TensorFlow_TFOutput___System_String_System_String_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Formats a string template using a list of tensors, pretty-printing tensor summaries.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_StringJoin_" data-uid="TensorFlow.TFGraph.StringJoin*"></a>
  <h4 id="TensorFlow_TFGraph_StringJoin_TensorFlow_TFOutput___System_String_System_String_" data-uid="TensorFlow.TFGraph.StringJoin(TensorFlow.TFOutput[],System.String,System.String)">StringJoin(TFOutput[], String, String)</h4>
  <div class="markdown level1 summary"><p>Joins the strings in the given list of string tensors into one tensor;</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StringJoin (TensorFlow.TFOutput[] inputs, string separator = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>A list of string tensors.  The tensors must all have the same shape,
              or be scalars.  Scalars may be mixed in; these will be broadcast to the shape
              of non-scalar inputs.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">separator</span></td>
        <td><p>Optional argument
              string, an optional join separator.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StringJoin&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StringJoin_TensorFlow_TFOutput___System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>with the given separator (default is an empty separator).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_StringLength_" data-uid="TensorFlow.TFGraph.StringLength*"></a>
  <h4 id="TensorFlow_TFGraph_StringLength_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.StringLength(TensorFlow.TFOutput,System.String,System.String)">StringLength(TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>String lengths of <code>input</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StringLength (TensorFlow.TFOutput input, string unit = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The string for which to compute the length.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">unit</span></td>
        <td><p>Optional argument
              The unit that is counted to compute string length.  One of: <code>&quot;BYTE&quot;</code> (for
              the number of bytes in each string) or <code>&quot;UTF8_CHAR&quot;</code> (for the number of UTF-8
              encoded Unicode code points in each string).  Results are undefined
              if <code>unit=UTF8_CHAR</code> and the <code>input</code> strings do not contain structurally
              valid UTF-8.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StringLength&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Integer tensor that has the same shape as <code>input</code>. The output contains the
              element-wise string lengths of <code>input</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StringLength_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the length of each string given in the input tensor.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_StringSplit_" data-uid="TensorFlow.TFGraph.StringSplit*"></a>
  <h4 id="TensorFlow_TFGraph_StringSplit_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.StringSplit(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">StringSplit(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Split elements of <code>input</code> based on <code>delimiter</code> into a <code>SparseTensor</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; StringSplit (TensorFlow.TFOutput input, TensorFlow.TFOutput delimiter, Nullable&lt;bool&gt; skip_empty = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>1-D. Strings to split.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">delimiter</span></td>
        <td><p>0-D. Delimiter characters (bytes), or empty string.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">skip_empty</span></td>
        <td><p>Optional argument
              A <code>bool</code>. If <code>True</code>, skip the empty strings from the result.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StringSplit&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              indices: A dense matrix of int64 representing the indices of the sparse tensor.
              values: A vector of strings corresponding to the splited values.
              shape: a length-2 vector of int64 representing the shape of the sparse
              tensor, where the first value is N and the second value is the maximum number
              of tokens in a single input entry.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StringSplit_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Let N be the size of source (typically N will be the batch size). Split each
              element of <code>input</code> based on <code>delimiter</code> and return a <code>SparseTensor</code>
              containing the splitted tokens. Empty tokens are ignored.</p>
<pre><code>          &lt;code&gt;delimiter&lt;/code&gt; can be empty, or a string of split characters. If &lt;code&gt;delimiter&lt;/code&gt; is an
          empty string, each element of &lt;code&gt;input&lt;/code&gt; is split into individual single-byte
          character strings, including splitting of UTF-8 multibyte sequences. Otherwise
          every character of &lt;code&gt;delimiter&lt;/code&gt; is a potential split point.

          For example:
          N = 2, input[0] is &#39;hello world&#39; and input[1] is &#39;a b c&#39;, then the output
          will be

          indices = [0, 0;
          0, 1;
          1, 0;
          1, 1;
          1, 2]
          shape = [2, 3]
          values = [&#39;hello&#39;, &#39;world&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_StringSplitV2_" data-uid="TensorFlow.TFGraph.StringSplitV2*"></a>
  <h4 id="TensorFlow_TFGraph_StringSplitV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.StringSplitV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Int64},System.String)">StringSplitV2(TFOutput, TFOutput, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Split elements of <code>source</code> based on <code>sep</code> into a <code>SparseTensor</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; StringSplitV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput sep, Nullable&lt;long&gt; maxsplit = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p><code>1-D</code> string <code>Tensor</code>, the strings to split.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sep</span></td>
        <td><p><code>0-D</code> string <code>Tensor</code>, the delimiter character.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">maxsplit</span></td>
        <td><p>Optional argument
              An <code>int</code>. If <code>maxsplit &gt; 0</code>, limit of the split of the result.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StringSplitV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              indices:
              values:
              shape:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StringSplitV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Let N be the size of source (typically N will be the batch size). Split each
              element of <code>source</code> based on <code>sep</code> and return a <code>SparseTensor</code>
              containing the split tokens. Empty tokens are ignored.</p>
<pre><code>          For example, N = 2, source[0] is &#39;hello world&#39; and source[1] is &#39;a b c&#39;,
          then the output will be
           &lt;pre&gt;&lt;code&gt;
          st.indices = [0, 0;
          0, 1;
          1, 0;
          1, 1;
          1, 2]
          st.shape = [2, 3]
          st.values = [&#39;hello&#39;, &#39;world&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
           &lt;/code&gt;&lt;/pre&gt;

          If &lt;code&gt;sep&lt;/code&gt; is given, consecutive delimiters are not grouped together and are
          deemed to delimit empty strings. For example, source of &lt;code&gt;&quot;1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;&amp;lt;&amp;gt;3&quot;&lt;/code&gt; and
          sep of &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; returns &lt;code&gt;[&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;]&lt;/code&gt;. If &lt;code&gt;sep&lt;/code&gt; is None or an empty
          string, consecutive whitespace are regarded as a single separator, and the
          result will contain no empty strings at the startor end if the string has
          leading or trailing whitespace.

          Note that the above mentioned behavior matches python&#39;s str.split.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_StringStrip_" data-uid="TensorFlow.TFGraph.StringStrip*"></a>
  <h4 id="TensorFlow_TFGraph_StringStrip_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.StringStrip(TensorFlow.TFOutput,System.String)">StringStrip(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Strip leading and trailing whitespaces from the Tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StringStrip (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A string <code>Tensor</code> of any shape.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StringStrip&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A string <code>Tensor</code> of the same shape as the input.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_StringToHashBucket_" data-uid="TensorFlow.TFGraph.StringToHashBucket*"></a>
  <h4 id="TensorFlow_TFGraph_StringToHashBucket_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.StringToHashBucket(TensorFlow.TFOutput,System.Int64,System.String)">StringToHashBucket(TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>Converts each string in the input Tensor to its hash mod by a number of buckets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StringToHashBucket (TensorFlow.TFOutput string_tensor, long num_buckets, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">string_tensor</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_buckets</span></td>
        <td><p>The number of buckets.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StringToHashBucket&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A Tensor of the same shape as the input <code>string_tensor</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StringToHashBucket_TensorFlow_TFOutput_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The hash function is deterministic on the content of the string within the
              process.</p>
<pre><code>          Note that the hash function may change from time to time.
          This functionality will be deprecated and it&#39;s recommended to use
          &lt;code&gt;tf.string_to_hash_bucket_fast()&lt;/code&gt; or &lt;code&gt;tf.string_to_hash_bucket_strong()&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_StringToHashBucketFast_" data-uid="TensorFlow.TFGraph.StringToHashBucketFast*"></a>
  <h4 id="TensorFlow_TFGraph_StringToHashBucketFast_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.StringToHashBucketFast(TensorFlow.TFOutput,System.Int64,System.String)">StringToHashBucketFast(TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>Converts each string in the input Tensor to its hash mod by a number of buckets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StringToHashBucketFast (TensorFlow.TFOutput input, long num_buckets, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The strings to assign a hash bucket.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_buckets</span></td>
        <td><p>The number of buckets.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StringToHashBucketFast&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A Tensor of the same shape as the input <code>string_tensor</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StringToHashBucketFast_TensorFlow_TFOutput_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The hash function is deterministic on the content of the string within the
              process and will never change. However, it is not suitable for cryptography.
              This function may be used when CPU time is scarce and inputs are trusted or
              unimportant. There is a risk of adversaries constructing inputs that all hash
              to the same bucket. To prevent this problem, use a strong hash function with
              <code>tf.string_to_hash_bucket_strong</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_StringToHashBucketStrong_" data-uid="TensorFlow.TFGraph.StringToHashBucketStrong*"></a>
  <h4 id="TensorFlow_TFGraph_StringToHashBucketStrong_TensorFlow_TFOutput_System_Int64_System_Int64___System_String_" data-uid="TensorFlow.TFGraph.StringToHashBucketStrong(TensorFlow.TFOutput,System.Int64,System.Int64[],System.String)">StringToHashBucketStrong(TFOutput, Int64, Int64[], String)</h4>
  <div class="markdown level1 summary"><p>Converts each string in the input Tensor to its hash mod by a number of buckets.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StringToHashBucketStrong (TensorFlow.TFOutput input, long num_buckets, long[] key, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The strings to assign a hash bucket.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_buckets</span></td>
        <td><p>The number of buckets.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span>[]</td>
        <td><span class="parametername">key</span></td>
        <td><p>The key for the keyed hash function passed as a list of two uint64
              elements.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StringToHashBucketStrong&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A Tensor of the same shape as the input <code>string_tensor</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StringToHashBucketStrong_TensorFlow_TFOutput_System_Int64_System_Int64___System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The hash function is deterministic on the content of the string within the
              process. The hash function is a keyed hash function, where attribute <code>key</code>
              defines the key of the hash function. <code>key</code> is an array of 2 elements.</p>
<pre><code>          A strong hash is important when inputs may be malicious, e.g. URLs with
          additional components. Adversaries could try to make their inputs hash to the
          same bucket for a denial-of-service attack or to skew the results. A strong
          hash prevents this by making it difficult, if not infeasible, to compute inputs
          that hash to the same bucket. This comes at a cost of roughly 4x higher compute
          time than &lt;code&gt;tf.string_to_hash_bucket_fast&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_StringToNumber_" data-uid="TensorFlow.TFGraph.StringToNumber*"></a>
  <h4 id="TensorFlow_TFGraph_StringToNumber_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.StringToNumber(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">StringToNumber(TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Converts each string in the input Tensor to the specified numeric type.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput StringToNumber (TensorFlow.TFOutput string_tensor, Nullable&lt;TensorFlow.TFDataType&gt; out_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">string_tensor</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_type</span></td>
        <td><p>Optional argument
              The numeric type to interpret each string in <code>string_tensor</code> as.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;StringToNumber&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A Tensor of the same shape as the input <code>string_tensor</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_StringToNumber_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>(Note that int32 overflow results in an error while float overflow
              results in a rounded value.)</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Sub_" data-uid="TensorFlow.TFGraph.Sub*"></a>
  <h4 id="TensorFlow_TFGraph_Sub_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Sub(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Sub(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns x - y element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Sub (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Sub&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Sub_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><em>NOTE</em>: <code>Subtract</code> supports broadcasting. More about broadcasting
              <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">here</a></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Sum_" data-uid="TensorFlow.TFGraph.Sum*"></a>
  <h4 id="TensorFlow_TFGraph_Sum_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Sum(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">Sum(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the sum of elements across dimensions of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Sum (TensorFlow.TFOutput input, TensorFlow.TFOutput reduction_indices, Nullable&lt;bool&gt; keep_dims = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>The tensor to reduce.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">reduction_indices</span></td>
        <td><p>The dimensions to reduce. Must be in the range
              <code>[-rank(input), rank(input))</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">keep_dims</span></td>
        <td><p>Optional argument
              If true, retain reduced dimensions with length 1.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Sum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The reduced tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Sum_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Reduces <code>input</code> along the dimensions given in <code>axis</code>. Unless
              <code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
              <code>axis</code>. If <code>keep_dims</code> is true, the reduced dimensions are
              retained with length 1.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Svd_" data-uid="TensorFlow.TFGraph.Svd*"></a>
  <h4 id="TensorFlow_TFGraph_Svd_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.Svd(TensorFlow.TFOutput,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String)">Svd(TFOutput, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Computes the singular value decompositions of one or more matrices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; Svd (TensorFlow.TFOutput input, Nullable&lt;bool&gt; compute_uv = null, Nullable&lt;bool&gt; full_matrices = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A tensor of shape <code>[..., M, N]</code> whose inner-most 2 dimensions
              form matrices of size <code>[M, N]</code>. Let <code>P</code> be the minimum of <code>M</code> and <code>N</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">compute_uv</span></td>
        <td><p>Optional argument
              If true, left and right singular vectors will be
              computed and returned in <code>u</code> and <code>v</code>, respectively.
              If false, <code>u</code> and <code>v</code> are not set and should never referenced.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">full_matrices</span></td>
        <td><p>Optional argument
              If true, compute full-sized <code>u</code> and <code>v</code>. If false
              (the default), compute only the leading <code>P</code> singular vectors.
              Ignored if <code>compute_uv</code> is <code>False</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Svd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              s: Singular values. Shape is <code>[..., P]</code>.
              u: Left singular vectors. If <code>full_matrices</code> is <code>False</code> then shape is
              <code>[..., M, P]</code>; if <code>full_matrices</code> is <code>True</code> then shape is
              <code>[..., M, M]</code>. Undefined if <code>compute_uv</code> is <code>False</code>.
              v: Left singular vectors. If <code>full_matrices</code> is <code>False</code> then shape is
              <code>[..., N, P]</code>. If <code>full_matrices</code> is <code>True</code> then shape is <code>[..., N, N]</code>.
              Undefined if <code>compute_uv</code> is false.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Svd_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Computes the SVD of each inner matrix in <code>input</code> such that
              <code>input[..., :, :] = u[..., :, :] * diag(s[..., :, :]) * transpose(v[..., :, :])</code><pre><code><p>
<h1 id="a-is-a-tensor-containing-a-batch-of-matrices">a is a tensor containing a batch of matrices.</h1>
<pre><code>          # s is a tensor of singular values for each matrix.
          # u is the tensor containing of left singular vectors for each matrix.
          # v is the tensor containing of right singular vectors for each matrix.
          s, u, v = svd(a)
          s, _, _ = svd(a, compute_uv=False)
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Switch_" data-uid="TensorFlow.TFGraph.Switch*"></a>
  <h4 id="TensorFlow_TFGraph_Switch_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Switch(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Switch(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Forwards <code>data</code> to the output port determined by <code>pred</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; Switch (TensorFlow.TFOutput data, TensorFlow.TFOutput pred, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>The tensor to be forwarded to the appropriate output.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">pred</span></td>
        <td><p>A scalar that specifies which output port will receive data.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Switch&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_false: If <code>pred</code> is false, data will be forwarded to this output.
              output_true: If <code>pred</code> is true, data will be forwarded to this output.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Switch_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If <code>pred</code> is true, the <code>data</code> input is forwarded to <code>output_true</code>. Otherwise,
              the data goes to <code>output_false</code>.</p>
<pre><code>          See also &lt;code&gt;RefSwitch&lt;/code&gt; and &lt;code&gt;Merge&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_TakeDataset_" data-uid="TensorFlow.TFGraph.TakeDataset*"></a>
  <h4 id="TensorFlow_TFGraph_TakeDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.TakeDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">TakeDataset(TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that contains <code>count</code> elements from the <code>input_dataset</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TakeDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput count, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">count</span></td>
        <td><p>A scalar representing the number of elements from the <code>input_dataset</code>
              that should be taken. A value of <code>-1</code> indicates that all of <code>input_dataset</code>
              is taken.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TakeDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TakeManySparseFromTensorsMap_" data-uid="TensorFlow.TFGraph.TakeManySparseFromTensorsMap*"></a>
  <h4 id="TensorFlow_TFGraph_TakeManySparseFromTensorsMap_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.TakeManySparseFromTensorsMap(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String,System.String,System.String)">TakeManySparseFromTensorsMap(TFOutput, TFDataType, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Read <code>SparseTensors</code> from a <code>SparseTensorsMap</code> and concatenate them.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; TakeManySparseFromTensorsMap (TensorFlow.TFOutput sparse_handles, TensorFlow.TFDataType dtype, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sparse_handles</span></td>
        <td><p>1-D, The <code>N</code> serialized <code>SparseTensor</code> objects.
              Shape: <code>[N]</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The <code>dtype</code> of the <code>SparseTensor</code> objects stored in the
              <code>SparseTensorsMap</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              The container name for the <code>SparseTensorsMap</code> read by this op.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              The shared name for the <code>SparseTensorsMap</code> read by this op.
              It should not be blank; rather the <code>shared_name</code> or unique Operation name
              of the Op that created the original <code>SparseTensorsMap</code> should be used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TakeManySparseFromTensorsMap&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sparse_indices: 2-D.  The <code>indices</code> of the minibatch <code>SparseTensor</code>.
              sparse_values: 1-D.  The <code>values</code> of the minibatch <code>SparseTensor</code>.
              sparse_shape: 1-D.  The <code>shape</code> of the minibatch <code>SparseTensor</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TakeManySparseFromTensorsMap_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The input <code>sparse_handles</code> must be an <code>int64</code> matrix of shape <code>[N, 1]</code> where
              <code>N</code> is the minibatch size and the rows correspond to the output handles of
              <code>AddSparseToTensorsMap</code> or <code>AddManySparseToTensorsMap</code>.  The ranks of the
              original <code>SparseTensor</code> objects that went into the given input ops must all
              match.  When the final <code>SparseTensor</code> is created, it has rank one
              higher than the ranks of the incoming <code>SparseTensor</code> objects
              (they have been concatenated along a new row dimension on the left).</p>
<pre><code>          The output &lt;code&gt;SparseTensor&lt;/code&gt; object&#39;s shape values for all dimensions but the
          first are the max across the input &lt;code&gt;SparseTensor&lt;/code&gt; objects&#39; shape values
          for the corresponding dimensions.  Its first shape value is &lt;code&gt;N&lt;/code&gt;, the minibatch
          size.

          The input &lt;code&gt;SparseTensor&lt;/code&gt; objects&#39; indices are assumed ordered in
          standard lexicographic order.  If this is not the case, after this
          step run &lt;code&gt;SparseReorder&lt;/code&gt; to restore index ordering.

          For example, if the handles represent an input, which is a &lt;code&gt;[2, 3]&lt;/code&gt; matrix
          representing two original &lt;code&gt;SparseTensor&lt;/code&gt; objects:

           &lt;pre&gt;&lt;code&gt;
          index = [ 0]
          [10]
          [20]
          values = [1, 2, 3]
          shape = [50]
           &lt;/code&gt;&lt;/pre&gt;

          and

           &lt;pre&gt;&lt;code&gt;
          index = [ 2]
          [10]
          values = [4, 5]
          shape = [30]
           &lt;/code&gt;&lt;/pre&gt;

          then the final &lt;code&gt;SparseTensor&lt;/code&gt; will be:

           &lt;pre&gt;&lt;code&gt;
          index = [0  0]
          [0 10]
          [0 20]
          [1  2]
          [1 10]
          values = [1, 2, 3, 4, 5]
          shape = [2 50]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Tan_" data-uid="TensorFlow.TFGraph.Tan*"></a>
  <h4 id="TensorFlow_TFGraph_Tan_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Tan(TensorFlow.TFOutput,System.String)">Tan(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes tan of x element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Tan (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Tan&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Tanh_" data-uid="TensorFlow.TFGraph.Tanh*"></a>
  <h4 id="TensorFlow_TFGraph_Tanh_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Tanh(TensorFlow.TFOutput,System.String)">Tanh(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes hyperbolic tangent of <code>x</code> element-wise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Tanh (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Tanh&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TanhGrad_" data-uid="TensorFlow.TFGraph.TanhGrad*"></a>
  <h4 id="TensorFlow_TFGraph_TanhGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TanhGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TanhGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the gradient for the tanh of <code>x</code> wrt its input.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TanhGrad (TensorFlow.TFOutput y, TensorFlow.TFOutput dy, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dy</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TanhGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TanhGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Specifically, <code>grad = dy * (1 - y*y)</code>, where <code>y = tanh(x)</code>, and <code>dy</code>
              is the corresponding input gradient.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TemporaryVariable_" data-uid="TensorFlow.TFGraph.TemporaryVariable*"></a>
  <h4 id="TensorFlow_TFGraph_TemporaryVariable_TensorFlow_TFShape_TensorFlow_TFDataType_System_String_System_String_" data-uid="TensorFlow.TFGraph.TemporaryVariable(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String)">TemporaryVariable(TFShape, TFDataType, String, String)</h4>
  <div class="markdown level1 summary"><p>Returns a tensor that may be mutated, but only persists within a single step.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TemporaryVariable (TensorFlow.TFShape shape, TensorFlow.TFDataType dtype, string var_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the variable tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of elements in the variable tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">var_name</span></td>
        <td><p>Optional argument
              Overrides the name used for the temporary variable resource. Default
              value is the name of the &#39;TemporaryVariable&#39; op (which is guaranteed unique).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TemporaryVariable&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A reference to the variable tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TemporaryVariable_TensorFlow_TFShape_TensorFlow_TFDataType_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This is an experimental op for internal use only and it is possible to use this
              op in unsafe ways.  DO NOT USE unless you fully understand the risks.</p>
<pre><code>          It is the caller&#39;s responsibility to ensure that &#39;ref&#39; is eventually passed to a
          matching &#39;DestroyTemporaryVariable&#39; op after all other uses have completed.

          Outputs a ref to the tensor state so it may be read or modified.

          E.g.
          var = state_ops._temporary_variable([1, 2], types.float_)
          var_name = var.op.name
          var = state_ops.assign(var, [[4.0, 5.0]])
          var = state_ops.assign_add(var, [[6.0, 7.0]])
          final = state_ops._destroy_temporary_variable(var, var_name=var_name)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayCloseV2_" data-uid="TensorFlow.TFGraph.TensorArrayCloseV2*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayCloseV2_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayCloseV2(TensorFlow.TFOutput,System.String)">TensorArrayCloseV2(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated. Use TensorArrayCloseV3</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation TensorArrayCloseV2 (TensorFlow.TFOutput handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayCloseV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayCloseV3_" data-uid="TensorFlow.TFGraph.TensorArrayCloseV3*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayCloseV3_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayCloseV3(TensorFlow.TFOutput,System.String)">TensorArrayCloseV3(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Delete the TensorArray from its resource container.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation TensorArrayCloseV3 (TensorFlow.TFOutput handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a TensorArray (output of TensorArray or TensorArrayGrad).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayCloseV3&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorArrayCloseV3_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This enables the user to close and release the resource in the middle
              of a step/run.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayConcatV2_" data-uid="TensorFlow.TFGraph.TensorArrayConcatV2*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayConcatV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayConcatV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">TensorArrayConcatV2(TFOutput, TFOutput, TFDataType, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated. Use TensorArrayConcatV3</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; TensorArrayConcatV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, TensorFlow.TFDataType dtype, TensorFlow.TFShape element_shape_except0 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">element_shape_except0</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayConcatV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              value:
              lengths:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayConcatV3_" data-uid="TensorFlow.TFGraph.TensorArrayConcatV3*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayConcatV3_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayConcatV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">TensorArrayConcatV3(TFOutput, TFOutput, TFDataType, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>Concat the elements from the TensorArray into value <code>value</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; TensorArrayConcatV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, TensorFlow.TFDataType dtype, TensorFlow.TFShape element_shape_except0 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a TensorArray.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>A float scalar that enforces proper chaining of operations.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of the elem that is returned.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">element_shape_except0</span></td>
        <td><p>Optional argument
              The expected shape of an element, if known,
              excluding the first dimension. Used to validate the shapes of
              TensorArray elements. If this shape is not fully specified, concatenating
              zero-size TensorArrays is an error.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayConcatV3&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              value: All of the elements in the TensorArray, concatenated along the first
              axis.
              lengths: A vector of the row sizes of the original T elements in the
              value output.  In the example above, this would be the values:
              <code>(n1, n2, ..., n(T-1))</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorArrayConcatV3_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_TensorFlow_TFShape_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Takes <code>T</code> elements of shapes</p>
<pre><code>           &lt;pre&gt;&lt;code&gt;
          (n0 x d0 x d1 x ...), (n1 x d0 x d1 x ...), ..., (n(T-1) x d0 x d1 x ...)
           &lt;/code&gt;&lt;/pre&gt;

          and concatenates them into a Tensor of shape:

           &lt;pre&gt;&lt;code&gt;
           (n0 + n1 + ... + n(T-1) x d0 x d1 x ...)
           &lt;/code&gt;&lt;/pre&gt;

          All elements must have the same shape (excepting the first dimension).
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayGatherV2_" data-uid="TensorFlow.TFGraph.TensorArrayGatherV2*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayGatherV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayGatherV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">TensorArrayGatherV2(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated. Use TensorArrayGatherV3</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArrayGatherV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput indices, TensorFlow.TFOutput flow_in, TensorFlow.TFDataType dtype, TensorFlow.TFShape element_shape = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">element_shape</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayGatherV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayGatherV3_" data-uid="TensorFlow.TFGraph.TensorArrayGatherV3*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayGatherV3_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayGatherV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.String)">TensorArrayGatherV3(TFOutput, TFOutput, TFOutput, TFDataType, TFShape, String)</h4>
  <div class="markdown level1 summary"><p>Gather specific elements from the TensorArray into output <code>value</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArrayGatherV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput indices, TensorFlow.TFOutput flow_in, TensorFlow.TFDataType dtype, TensorFlow.TFShape element_shape = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a TensorArray.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>The locations in the TensorArray from which to read tensor elements.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>A float scalar that enforces proper chaining of operations.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of the elem that is returned.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">element_shape</span></td>
        <td><p>Optional argument
              The expected shape of an element, if known. Used to
              validate the shapes of TensorArray elements. If this shape is not
              fully specified, gathering zero-size TensorArrays is an error.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayGatherV3&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>All of the elements in the TensorArray, concatenated along a new
              axis (the new dimension 0).
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorArrayGatherV3_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_TensorFlow_TFShape_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>All elements selected by <code>indices</code> must have the same shape.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayGradV2_" data-uid="TensorFlow.TFGraph.TensorArrayGradV2*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayGradV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayGradV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">TensorArrayGradV2(TFOutput, TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated. Use TensorArrayGradV3</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArrayGradV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, string source, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">source</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayGradV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayGradV3_" data-uid="TensorFlow.TFGraph.TensorArrayGradV3*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayGradV3_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayGradV3(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">TensorArrayGradV3(TFOutput, TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>Creates a TensorArray for storing the gradients of values in the given handle.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; TensorArrayGradV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, string source, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to the forward TensorArray.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>A float scalar that enforces proper chaining of operations.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">source</span></td>
        <td><p>The gradient source string, used to decide which gradient TensorArray
              to return.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayGradV3&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              grad_handle:
              flow_out:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorArrayGradV3_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If the given TensorArray gradient already exists, returns a reference to it.</p>
<pre><code>          Locks the size of the original TensorArray by disabling its dynamic size flag.

          **A note about the input flow_in:**

          The handle flow_in forces the execution of the gradient lookup to occur
          only after certain other operations have occurred.  For example, when
          the forward TensorArray is dynamically sized, writes to this TensorArray
          may resize the object.  The gradient TensorArray is statically sized based
          on the size of the forward TensorArray when this operation executes.
          Furthermore, the size of the forward TensorArray is frozen by this call.
          As a result, the flow is used to ensure that the call to generate the gradient
          TensorArray only happens after all writes are executed.

          In the case of dynamically sized TensorArrays, gradient computation should
          only be performed on read operations that have themselves been chained via
          flow to occur only after all writes have executed. That way the final size
          of the forward TensorArray is known when this operation is called.

          **A note about the source attribute:**

          TensorArray gradient calls use an accumulator TensorArray object.  If
          multiple gradients are calculated and run in the same session, the multiple
          gradient nodes may accidentally flow through the same accumulator TensorArray.
          This double counts and generally breaks the TensorArray gradient flow.

          The solution is to identify which gradient call this particular
          TensorArray gradient is being called in.  This is performed by identifying
          a unique string (e.g. &quot;gradients&quot;, &quot;gradients_1&quot;, ...) from the input
          gradient Tensor&#39;s name.  This string is used as a suffix when creating
          the TensorArray gradient object here (the attribute &lt;code&gt;source&lt;/code&gt;).

          The attribute &lt;code&gt;source&lt;/code&gt; is added as a suffix to the forward TensorArray&#39;s
          name when performing the creation / lookup, so that each separate gradient
          calculation gets its own TensorArray accumulator.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayGradWithShape_" data-uid="TensorFlow.TFGraph.TensorArrayGradWithShape*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayGradWithShape_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayGradWithShape(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String)">TensorArrayGradWithShape(TFOutput, TFOutput, TFOutput, String, String)</h4>
  <div class="markdown level1 summary"><p>Creates a TensorArray for storing multiple gradients of values in the given handle.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; TensorArrayGradWithShape (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, TensorFlow.TFOutput shape_to_prepend, string source, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to the forward TensorArray.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>A float scalar that enforces proper chaining of operations.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape_to_prepend</span></td>
        <td><p>An int32 vector representing a shape. Elements in the gradient accumulator will
              have shape which is this shape_to_prepend value concatenated with shape of the
              elements in the TensorArray corresponding to the input handle.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">source</span></td>
        <td><p>The gradient source string, used to decide which gradient TensorArray
              to return.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayGradWithShape&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              grad_handle:
              flow_out:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorArrayGradWithShape_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Similar to TensorArrayGradV3. However it creates an accumulator with an
              expanded shape compared to the input TensorArray whose gradient is being
              computed. This enables multiple gradients for the same TensorArray to be
              calculated using the same accumulator.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayReadV2_" data-uid="TensorFlow.TFGraph.TensorArrayReadV2*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayReadV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayReadV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">TensorArrayReadV2(TFOutput, TFOutput, TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated. Use TensorArrayReadV3</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArrayReadV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput index, TensorFlow.TFOutput flow_in, TensorFlow.TFDataType dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">index</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayReadV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayReadV3_" data-uid="TensorFlow.TFGraph.TensorArrayReadV3*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayReadV3_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayReadV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">TensorArrayReadV3(TFOutput, TFOutput, TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Read an element from the TensorArray into output <code>value</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArrayReadV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput index, TensorFlow.TFOutput flow_in, TensorFlow.TFDataType dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a TensorArray.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">index</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>A float scalar that enforces proper chaining of operations.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of the elem that is returned.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayReadV3&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The tensor that is read from the TensorArray.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayScatterV2_" data-uid="TensorFlow.TFGraph.TensorArrayScatterV2*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayScatterV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayScatterV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TensorArrayScatterV2(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated. Use TensorArrayScatterV3</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArrayScatterV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput indices, TensorFlow.TFOutput value, TensorFlow.TFOutput flow_in, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayScatterV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayScatterV3_" data-uid="TensorFlow.TFGraph.TensorArrayScatterV3*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayScatterV3_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayScatterV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TensorArrayScatterV3(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Scatter the data from the input value into specific TensorArray elements.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArrayScatterV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput indices, TensorFlow.TFOutput value, TensorFlow.TFOutput flow_in, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a TensorArray.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>The locations at which to write the tensor elements.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>The concatenated tensor to write to the TensorArray.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>A float scalar that enforces proper chaining of operations.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayScatterV3&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A float scalar that enforces proper chaining of operations.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorArrayScatterV3_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><code>indices</code> must be a vector, its length must match the first dim of <code>value</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TensorArraySizeV2_" data-uid="TensorFlow.TFGraph.TensorArraySizeV2*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArraySizeV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorArraySizeV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TensorArraySizeV2(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated. Use TensorArraySizeV3</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArraySizeV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArraySizeV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorArraySizeV3_" data-uid="TensorFlow.TFGraph.TensorArraySizeV3*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArraySizeV3_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorArraySizeV3(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TensorArraySizeV3(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Get the current size of the TensorArray.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArraySizeV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput flow_in, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a TensorArray (output of TensorArray or TensorArrayGrad).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>A float scalar that enforces proper chaining of operations.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArraySizeV3&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The current size of the TensorArray.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorArraySplitV2_" data-uid="TensorFlow.TFGraph.TensorArraySplitV2*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArraySplitV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorArraySplitV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TensorArraySplitV2(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated. Use TensorArraySplitV3</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArraySplitV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput value, TensorFlow.TFOutput lengths, TensorFlow.TFOutput flow_in, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lengths</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArraySplitV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorArraySplitV3_" data-uid="TensorFlow.TFGraph.TensorArraySplitV3*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArraySplitV3_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorArraySplitV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TensorArraySplitV3(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArraySplitV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput value, TensorFlow.TFOutput lengths, TensorFlow.TFOutput flow_in, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">lengths</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayV2_" data-uid="TensorFlow.TFGraph.TensorArrayV2*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayV2_TensorFlow_TFOutput_TensorFlow_TFDataType_TensorFlow_TFShape_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayV2(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)">TensorArrayV2(TFOutput, TFDataType, TFShape, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated. Use TensorArrayV3</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArrayV2 (TensorFlow.TFOutput size, TensorFlow.TFDataType dtype, TensorFlow.TFShape element_shape = null, Nullable&lt;bool&gt; dynamic_size = null, Nullable&lt;bool&gt; clear_after_read = null, string tensor_array_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">element_shape</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">dynamic_size</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">clear_after_read</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">tensor_array_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayV3_" data-uid="TensorFlow.TFGraph.TensorArrayV3*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayV3_TensorFlow_TFOutput_TensorFlow_TFDataType_TensorFlow_TFShape_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayV3(TensorFlow.TFOutput,TensorFlow.TFDataType,TensorFlow.TFShape,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)">TensorArrayV3(TFOutput, TFDataType, TFShape, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, Nullable&lt;Boolean&gt;, String, String)</h4>
  <div class="markdown level1 summary"><p>An array of Tensors of given size.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; TensorArrayV3 (TensorFlow.TFOutput size, TensorFlow.TFDataType dtype, TensorFlow.TFShape element_shape = null, Nullable&lt;bool&gt; dynamic_size = null, Nullable&lt;bool&gt; clear_after_read = null, Nullable&lt;bool&gt; identical_element_shapes = null, string tensor_array_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>The size of the array.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of the elements on the tensor_array.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">element_shape</span></td>
        <td><p>Optional argument
              The expected shape of an element, if known. Used to
              validate the shapes of TensorArray elements. If this shape is not
              fully specified, gathering zero-size TensorArrays is an error.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">dynamic_size</span></td>
        <td><p>Optional argument
              A boolean that determines whether writes to the TensorArray
              are allowed to grow the size.  By default, this is not allowed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">clear_after_read</span></td>
        <td><p>Optional argument
              If true (default), Tensors in the TensorArray are cleared
              after being read.  This disables multiple read semantics but allows early
              release of memory.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">identical_element_shapes</span></td>
        <td><p>Optional argument
              If true (default is false), then all
              elements in the TensorArray will be expected to have have identical shapes.
              This allows certain behaviors, like dynamically checking for
              consistent shapes on write, and being able to fill in properly
              shaped zero tensors on stack -- even if the element_shape attribute
              is not fully defined.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">tensor_array_name</span></td>
        <td><p>Optional argument
              Overrides the name used for the temporary tensor_array
              resource. Default value is the name of the &#39;TensorArray&#39; op (which
              is guaranteed unique).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayV3&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              handle: The handle to the TensorArray.
              flow: A scalar used to control gradient flow.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorArrayV3_TensorFlow_TFOutput_TensorFlow_TFDataType_TensorFlow_TFShape_System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_Nullable_System_Boolean__System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Write data via Write and read via Read or Pack.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayWriteV2_" data-uid="TensorFlow.TFGraph.TensorArrayWriteV2*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayWriteV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayWriteV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TensorArrayWriteV2(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Deprecated. Use TensorArrayGradV3</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArrayWriteV2 (TensorFlow.TFOutput handle, TensorFlow.TFOutput index, TensorFlow.TFOutput value, TensorFlow.TFOutput flow_in, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">index</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayWriteV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorArrayWriteV3_" data-uid="TensorFlow.TFGraph.TensorArrayWriteV3*"></a>
  <h4 id="TensorFlow_TFGraph_TensorArrayWriteV3_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorArrayWriteV3(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TensorArrayWriteV3(TFOutput, TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Push an element onto the tensor_array.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorArrayWriteV3 (TensorFlow.TFOutput handle, TensorFlow.TFOutput index, TensorFlow.TFOutput value, TensorFlow.TFOutput flow_in, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">handle</span></td>
        <td><p>The handle to a TensorArray.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">index</span></td>
        <td><p>The position to write to inside the TensorArray.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>The tensor to write to the TensorArray.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">flow_in</span></td>
        <td><p>A float scalar that enforces proper chaining of operations.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorArrayWriteV3&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A float scalar that enforces proper chaining of operations.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorDataset_" data-uid="TensorFlow.TFGraph.TensorDataset*"></a>
  <h4 id="TensorFlow_TFGraph_TensorDataset_TensorFlow_TFOutput___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.TensorDataset(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)">TensorDataset(TFOutput[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that emits <code>components</code> as a tuple of tensors once.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorDataset (TensorFlow.TFOutput[] components, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">components</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorListElementShape_" data-uid="TensorFlow.TFGraph.TensorListElementShape*"></a>
  <h4 id="TensorFlow_TFGraph_TensorListElementShape_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.TensorListElementShape(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">TensorListElementShape(TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>The shape of the elements of the given list, as a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorListElementShape (TensorFlow.TFOutput input_handle, TensorFlow.TFDataType shape_type, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">shape_type</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorListElementShape&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorListElementShape_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>input_handle: the list
              element_shape: the shape of elements of the list</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TensorListFromTensor_" data-uid="TensorFlow.TFGraph.TensorListFromTensor*"></a>
  <h4 id="TensorFlow_TFGraph_TensorListFromTensor_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorListFromTensor(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TensorListFromTensor(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Creates a TensorList which, when stacked, has the value of <code>tensor</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorListFromTensor (TensorFlow.TFOutput tensor, TensorFlow.TFOutput element_shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">element_shape</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorListFromTensor&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorListFromTensor_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Each tensor in the result list corresponds to one row of the input tensor.</p>
<pre><code>          tensor: The input tensor.
          output_handle: The list.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_TensorListGather_" data-uid="TensorFlow.TFGraph.TensorListGather*"></a>
  <h4 id="TensorFlow_TFGraph_TensorListGather_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.TensorListGather(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">TensorListGather(TFOutput, TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Creates a Tensor by indexing into the TensorList.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorListGather (TensorFlow.TFOutput input_handle, TensorFlow.TFOutput indices, TensorFlow.TFDataType element_dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">element_dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorListGather&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorListGather_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Each row in the produced Tensor corresponds to the element in the TensorList
              specified by the given index (see <code>tf.gather</code>).</p>
<pre><code>          input_handle: The input tensor list.
          indices: The indices used to index into the list.
          values: The tensor.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_TensorListGetItem_" data-uid="TensorFlow.TFGraph.TensorListGetItem*"></a>
  <h4 id="TensorFlow_TFGraph_TensorListGetItem_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.TensorListGetItem(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">TensorListGetItem(TFOutput, TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Returns the item in the list with the given index.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorListGetItem (TensorFlow.TFOutput input_handle, TensorFlow.TFOutput index, TensorFlow.TFDataType element_dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">index</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">element_dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorListGetItem&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorListGetItem_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>input_handle: the list
              index: the position in the list from which an element will be retrieved
              item: the element at that position</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TensorListLength_" data-uid="TensorFlow.TFGraph.TensorListLength*"></a>
  <h4 id="TensorFlow_TFGraph_TensorListLength_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorListLength(TensorFlow.TFOutput,System.String)">TensorListLength(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the number of tensors in the input tensor list.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorListLength (TensorFlow.TFOutput input_handle, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorListLength&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorListLength_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>input_handle: the input list
              length: the number of tensors in the list</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TensorListPopBack_" data-uid="TensorFlow.TFGraph.TensorListPopBack*"></a>
  <h4 id="TensorFlow_TFGraph_TensorListPopBack_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.TensorListPopBack(TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">TensorListPopBack(TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Returns the last element of the input list as well as a list with all but that element.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; TensorListPopBack (TensorFlow.TFOutput input_handle, TensorFlow.TFDataType element_dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">element_dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorListPopBack&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              output_handle:
              tensor:
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorListPopBack_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Fails if the list is empty.</p>
<pre><code>          input_handle: the input list
          tensor: the withdrawn last element of the list
          element_dtype: the type of elements in the list
          element_shape: the shape of the output tensor
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_TensorListPushBack_" data-uid="TensorFlow.TFGraph.TensorListPushBack*"></a>
  <h4 id="TensorFlow_TFGraph_TensorListPushBack_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorListPushBack(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TensorListPushBack(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns a list list which has the passed-in <code>Tensor</code> as last element and the other elements of the given list in <code>input_handle</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorListPushBack (TensorFlow.TFOutput input_handle, TensorFlow.TFOutput tensor, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorListPushBack&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorListPushBack_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>tensor: The tensor to put on the list.
              input_handle: The old list.
              output_handle: A list with the elements of the old list followed by tensor.
              element_dtype: the type of elements in the list.
              element_shape: a shape compatible with that of elements in the list.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TensorListReserve_" data-uid="TensorFlow.TFGraph.TensorListReserve*"></a>
  <h4 id="TensorFlow_TFGraph_TensorListReserve_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.TensorListReserve(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType,System.String)">TensorListReserve(TFOutput, TFOutput, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>List of the given size with empty elements.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorListReserve (TensorFlow.TFOutput element_shape, TensorFlow.TFOutput num_elements, TensorFlow.TFDataType element_dtype, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">element_shape</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_elements</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">element_dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorListReserve&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorListReserve_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>element_shape: the shape of the future elements of the list
              num_elements: the number of elements to reserve
              handle: the output list
              element_dtype: the desired type of elements in the list.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TensorListScatter_" data-uid="TensorFlow.TFGraph.TensorListScatter*"></a>
  <h4 id="TensorFlow_TFGraph_TensorListScatter_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorListScatter(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TensorListScatter(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Creates a TensorList by indexing into a Tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorListScatter (TensorFlow.TFOutput tensor, TensorFlow.TFOutput indices, TensorFlow.TFOutput element_shape, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">element_shape</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorListScatter&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorListScatter_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Each member of the TensorList corresponds to one row of the input tensor,
              specified by the given index (see <code>tf.gather</code>).</p>
<pre><code>          tensor: The input tensor.
          indices: The indices used to index into the list.
          element_shape: The shape of the elements in the list (can be less specified than
          the shape of the tensor).
          output_handle: The TensorList.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_TensorListSetItem_" data-uid="TensorFlow.TFGraph.TensorListSetItem*"></a>
  <h4 id="TensorFlow_TFGraph_TensorListSetItem_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorListSetItem(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TensorListSetItem(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Sets the index-th position of the list to contain the given tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorListSetItem (TensorFlow.TFOutput input_handle, TensorFlow.TFOutput index, TensorFlow.TFOutput item, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">index</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">item</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorListSetItem&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorListSetItem_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>input_handle: the list
              index: the position in the list to which the tensor will be assigned
              item: the element to be assigned to that position
              output_handle: the new list, with the element in the proper position</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TensorListStack_" data-uid="TensorFlow.TFGraph.TensorListStack*"></a>
  <h4 id="TensorFlow_TFGraph_TensorListStack_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.TensorListStack(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.String)">TensorListStack(TFOutput, TFDataType, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Stacks all tensors in the list.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorListStack (TensorFlow.TFOutput input_handle, TensorFlow.TFDataType element_dtype, Nullable&lt;long&gt; num_elements = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_handle</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">element_dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">num_elements</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorListStack&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorListStack_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Requires that all tensors have the same shape.</p>
<pre><code>          input_handle: the input list
          tensor: the gathered result
          num_elements: optional. If not -1, the number of elements in the list.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_TensorSliceDataset_" data-uid="TensorFlow.TFGraph.TensorSliceDataset*"></a>
  <h4 id="TensorFlow_TFGraph_TensorSliceDataset_TensorFlow_TFOutput___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.TensorSliceDataset(TensorFlow.TFOutput[],TensorFlow.TFShape[],System.String)">TensorSliceDataset(TFOutput[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that emits each dim-0 slice of <code>components</code> once.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorSliceDataset (TensorFlow.TFOutput[] components, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">components</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorSliceDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TensorSummary_" data-uid="TensorFlow.TFGraph.TensorSummary*"></a>
  <h4 id="TensorFlow_TFGraph_TensorSummary_TensorFlow_TFOutput_System_String_System_String___System_String_System_String_" data-uid="TensorFlow.TFGraph.TensorSummary(TensorFlow.TFOutput,System.String,System.String[],System.String,System.String)">TensorSummary(TFOutput, String, String[], String, String)</h4>
  <div class="markdown level1 summary"><p>Outputs a <code>Summary</code> protocol buffer with a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorSummary (TensorFlow.TFOutput tensor, string description = null, string[] labels = null, string display_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>A tensor to serialize.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">description</span></td>
        <td><p>Optional argument
              A json-encoded SummaryDescription proto.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">labels</span></td>
        <td><p>Optional argument
              An unused list of strings.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">display_name</span></td>
        <td><p>Optional argument
              An unused string.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorSummary&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TensorSummary_TensorFlow_TFOutput_System_String_System_String___System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op is being phased out in favor of TensorSummaryV2, which lets callers pass
              a tag as well as a serialized SummaryMetadata proto string that contains
              plugin-specific data. We will keep this op to maintain backwards compatibility.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TensorSummaryV2_" data-uid="TensorFlow.TFGraph.TensorSummaryV2*"></a>
  <h4 id="TensorFlow_TFGraph_TensorSummaryV2_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TensorSummaryV2(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TensorSummaryV2(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Outputs a <code>Summary</code> protocol buffer with a tensor and per-plugin data.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TensorSummaryV2 (TensorFlow.TFOutput tag, TensorFlow.TFOutput tensor, TensorFlow.TFOutput serialized_summary_metadata, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tag</span></td>
        <td><p>A string attached to this summary. Used for organization in TensorBoard.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>A tensor to serialize.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">serialized_summary_metadata</span></td>
        <td><p>A serialized SummaryMetadata proto. Contains plugin
              data.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TensorSummaryV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TextLineDataset_" data-uid="TensorFlow.TFGraph.TextLineDataset*"></a>
  <h4 id="TensorFlow_TFGraph_TextLineDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TextLineDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TextLineDataset(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that emits the lines of one or more text files.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TextLineDataset (TensorFlow.TFOutput filenames, TensorFlow.TFOutput compression_type, TensorFlow.TFOutput buffer_size, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filenames</span></td>
        <td><p>A scalar or a vector containing the name(s) of the file(s) to be
              read.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">compression_type</span></td>
        <td><p>A scalar containing either (i) the empty string (no
              compression), (ii) &quot;ZLIB&quot;, or (iii) &quot;GZIP&quot;.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">buffer_size</span></td>
        <td><p>A scalar containing the number of bytes to buffer.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TextLineDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TextLineReader_" data-uid="TensorFlow.TFGraph.TextLineReader*"></a>
  <h4 id="TensorFlow_TFGraph_TextLineReader_System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.TextLineReader(System.Nullable{System.Int64},System.String,System.String,System.String)">TextLineReader(Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A Reader that outputs the lines of a file delimited by &#39;\n&#39;.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TextLineReader (Nullable&lt;long&gt; skip_header_lines = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">skip_header_lines</span></td>
        <td><p>Optional argument
              Number of lines to skip from the beginning of every file.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TextLineReader&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TextLineReaderV2_" data-uid="TensorFlow.TFGraph.TextLineReaderV2*"></a>
  <h4 id="TensorFlow_TFGraph_TextLineReaderV2_System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.TextLineReaderV2(System.Nullable{System.Int64},System.String,System.String,System.String)">TextLineReaderV2(Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A Reader that outputs the lines of a file delimited by &#39;\n&#39;.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TextLineReaderV2 (Nullable&lt;long&gt; skip_header_lines = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">skip_header_lines</span></td>
        <td><p>Optional argument
              Number of lines to skip from the beginning of every file.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TextLineReaderV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TFRecordDataset_" data-uid="TensorFlow.TFGraph.TFRecordDataset*"></a>
  <h4 id="TensorFlow_TFGraph_TFRecordDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TFRecordDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TFRecordDataset(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that emits the records from one or more TFRecord files.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TFRecordDataset (TensorFlow.TFOutput filenames, TensorFlow.TFOutput compression_type, TensorFlow.TFOutput buffer_size, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filenames</span></td>
        <td><p>A scalar or vector containing the name(s) of the file(s) to be
              read.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">compression_type</span></td>
        <td><p>A scalar containing either (i) the empty string (no
              compression), (ii) &quot;ZLIB&quot;, or (iii) &quot;GZIP&quot;.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">buffer_size</span></td>
        <td><p>A scalar representing the number of bytes to buffer. A value of
              0 means no buffering will be performed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TFRecordDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TFRecordReader_" data-uid="TensorFlow.TFGraph.TFRecordReader*"></a>
  <h4 id="TensorFlow_TFGraph_TFRecordReader_System_String_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.TFRecordReader(System.String,System.String,System.String,System.String)">TFRecordReader(String, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A Reader that outputs the records from a TensorFlow Records file.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TFRecordReader (string container = null, string shared_name = null, string compression_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">compression_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TFRecordReader&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TFRecordReaderV2_" data-uid="TensorFlow.TFGraph.TFRecordReaderV2*"></a>
  <h4 id="TensorFlow_TFGraph_TFRecordReaderV2_System_String_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.TFRecordReaderV2(System.String,System.String,System.String,System.String)">TFRecordReaderV2(String, String, String, String)</h4>
  <div class="markdown level1 summary"><p>A Reader that outputs the records from a TensorFlow Records file.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TFRecordReaderV2 (string container = null, string shared_name = null, string compression_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">compression_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TFRecordReaderV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ThreadUnsafeUnigramCandidateSampler_" data-uid="TensorFlow.TFGraph.ThreadUnsafeUnigramCandidateSampler*"></a>
  <h4 id="TensorFlow_TFGraph_ThreadUnsafeUnigramCandidateSampler_TensorFlow_TFOutput_System_Int64_System_Int64_System_Boolean_System_Int64_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.ThreadUnsafeUnigramCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">ThreadUnsafeUnigramCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Generates labels for candidate sampling with a learned unigram distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; ThreadUnsafeUnigramCandidateSampler (TensorFlow.TFOutput true_classes, long num_true, long num_sampled, bool unique, long range_max, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">true_classes</span></td>
        <td><p>A batch_size * num_true matrix, in which each row contains the
              IDs of the num_true target_classes in the corresponding original label.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_true</span></td>
        <td><p>Number of true labels per context.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_sampled</span></td>
        <td><p>Number of candidates to randomly sample.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">unique</span></td>
        <td><p>If unique is true, we sample with rejection, so that all sampled
              candidates in a batch are unique. This requires some approximation to
              estimate the post-rejection sampling probabilities.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">range_max</span></td>
        <td><p>The sampler will sample integers from the interval [0, range_max).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              An second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ThreadUnsafeUnigramCandidateSampler&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sampled_candidates: A vector of length num_sampled, in which each element is
              the ID of a sampled candidate.
              true_expected_count: A batch_size * num_true matrix, representing
              the number of times each candidate is expected to occur in a batch
              of sampled candidates. If unique=true, then this is a probability.
              sampled_expected_count: A vector of length num_sampled, for each sampled
              candidate representing the number of times the candidate is expected
              to occur in a batch of sampled candidates.  If unique=true, then this is a
              probability.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ThreadUnsafeUnigramCandidateSampler_TensorFlow_TFOutput_System_Int64_System_Int64_System_Boolean_System_Int64_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>See explanations of candidate sampling and the data formats at
              go/candidate-sampling.</p>
<pre><code>          For each batch, this op picks a single set of sampled candidate labels.

          The advantages of sampling candidates per-batch are simplicity and the
          possibility of efficient dense matrix multiplication. The disadvantage is that
          the sampled candidates must be chosen independently of the context and of the
          true labels.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Tile_" data-uid="TensorFlow.TFGraph.Tile*"></a>
  <h4 id="TensorFlow_TFGraph_Tile_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Tile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Tile(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Constructs a tensor by tiling a given tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Tile (TensorFlow.TFOutput input, TensorFlow.TFOutput multiples, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>1-D or higher.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">multiples</span></td>
        <td><p>1-D. Length must be the same as the number of dimensions in <code>input</code></p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Tile&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Tile_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation creates a new tensor by replicating <code>input</code><code>multiples</code> times.
              The output tensor&#39;s i&#39;th dimension has <code>input.dims(i) * multiples[i]</code> elements,
              and the values of <code>input</code> are replicated <code>multiples[i]</code> times along the &#39;i&#39;th
              dimension. For example, tiling <code>[a b c d]</code> by <code>[2]</code> produces
              <code>[a b c d a b c d]</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TileGrad_" data-uid="TensorFlow.TFGraph.TileGrad*"></a>
  <h4 id="TensorFlow_TFGraph_TileGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TileGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TileGrad(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns the gradient of <code>Tile</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TileGrad (TensorFlow.TFOutput input, TensorFlow.TFOutput multiples, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">multiples</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TileGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TileGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Since <code>Tile</code> takes an input and repeats the input <code>multiples</code> times
              along each dimension, <code>TileGrad</code> takes in <code>multiples</code> and aggregates
              each repeated tile of <code>input</code> into <code>output</code>.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Timestamp_" data-uid="TensorFlow.TFGraph.Timestamp*"></a>
  <h4 id="TensorFlow_TFGraph_Timestamp_System_String_" data-uid="TensorFlow.TFGraph.Timestamp(System.String)">Timestamp(String)</h4>
  <div class="markdown level1 summary"><p>Provides the time since epoch in seconds.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Timestamp (string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Timestamp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Timestamp_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Returns the timestamp as a <code>float64</code> for seconds since the Unix epoch.</p>
<pre><code>          Note: the timestamp is computed when the op is executed, not when it is added
          to the graph.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ToFunction_" data-uid="TensorFlow.TFGraph.ToFunction*"></a>
  <h4 id="TensorFlow_TFGraph_ToFunction_System_String_System_String_TensorFlow_TFOperation___TensorFlow_TFOutput___TensorFlow_TFOutput___System_String___System_Boolean_TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.ToFunction(System.String,System.String,TensorFlow.TFOperation[],TensorFlow.TFOutput[],TensorFlow.TFOutput[],System.String[],System.Boolean,TensorFlow.TFStatus)">ToFunction(String, String, TFOperation[], TFOutput[], TFOutput[], String[], Boolean, TFStatus)</h4>
  <div class="markdown level1 summary"><p>Creates a TFFunction from a TFGraph</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFFunction ToFunction (string functionName, string description, TensorFlow.TFOperation[] operations, TensorFlow.TFOutput[] inputs, TensorFlow.TFOutput[] outputs, string[] outputNames, bool appendHashToFunctionName = false, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">functionName</span></td>
        <td><p>Name of the new function.  Should match the operation name (OpDef.name) regexp [A-Z][A-Za-z0-9_.\-/]*.  If appendHashToFunctioName is false, the name must be unique (at least those registered in graphs where this function will be used).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">description</span></td>
        <td><p>Optional, human readable description of this function.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a>[]</td>
        <td><span class="parametername">operations</span></td>
        <td><p>Array of operations to become the body of the function or null.<br>                If no array is given , all the
                operations in function body will become part of the function
                except operations referenced in inputs. These operations
                must have a single output (these operations are typically
                placeholders created for the sole purpose of representing
                an input).</p>
<pre><code>            If an array is given, all operations
            in it will become part of the function. In particular, no
            automatic skipping of dummy input operations is performed.
</code></pre></td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>Array that specify the inputs to the function, or null.  The names used for function inputs are normalized
                names of the operations (usually placeholders) pointed to by
                inputs.  These operation names should start with a letter.
                Normalization will convert all letters to lowercase and
                non-alphanumeric characters to &#39;<em>&#39; to make resulting names match
                the &quot;[a-z][a-z0-9</em>]*&quot; pattern for operation argument names.
                <code>inputs</code> cannot contain the same tensor twice.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">outputs</span></td>
        <td><p>rray that specify the inputs to the function, or null.   This can contain the same tensor twice.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span>[]</td>
        <td><span class="parametername">outputNames</span></td>
        <td><p>The names of the function&#39;s outputs.   The array either has the same elements of outputs, or be null.   Names must match &quot;[a-z][a-z0-9_]*&quot; regexp, if null is passed, the names are generated automatically.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">appendHashToFunctionName</span></td>
        <td><p>If set to <code>true</code> appends hash to functionName, otherwise it will use the specified name in functionName.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFFunction.html">TFFunction</a></td>
        <td><p>The function.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_ToFunction_System_String_System_String_TensorFlow_TFOperation___TensorFlow_TFOutput___TensorFlow_TFOutput___System_String___System_Boolean_TensorFlow_TFStatus__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>
              This method converts the graph whose operations (or a subset of its operations) will be converted
              into a TFFunction.
            </p>
    <p>
              Note that when the same TF_Output is listed as both an input and an output,
              the corresponding function&#39;s output will equal to this input,
              instead of the original node&#39;s output.
            </p>
    <p>
            Callers must also satisfy the following constraints:
            </p>
    <p>
      <code>inputs</code> cannot refer to TFOutputs within a control flow context. For
              example, one cannot use the output of &quot;switch&quot; node as input.
            </p>
    <p>
      <code>inputs</code> and <code>outputs</code> cannot have reference types. Reference types are
              not exposed through C API and are being replaced with Resources. We support
              reference types inside function&#39;s body to support legacy code. Do not
              use them in new code.
            </p>
    <p>
              Every node in the function&#39;s body must have all of its inputs (including
              control inputs). In other words, for every node in the body, each input
              must be either listed in <code>inputs</code> or must come from another node in
              the body. In particular, it is an error to have a control edge going from
              a node outside of the body into a node in the body. This applies to control
              edges going from nodes referenced in <code>inputs</code> to nodes in the body when
              the former nodes are not in the body (automatically skipped or not
              included in explicitly specified body).
            </p></div>
  
  
  <a id="TensorFlow_TFGraph_ToGraphDef_" data-uid="TensorFlow.TFGraph.ToGraphDef*"></a>
  <h4 id="TensorFlow_TFGraph_ToGraphDef_TensorFlow_TFBuffer_TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.ToGraphDef(TensorFlow.TFBuffer,TensorFlow.TFStatus)">ToGraphDef(TFBuffer, TFStatus)</h4>
  <div class="markdown level1 summary"><p>Write out a serialized representation of the graph (as a GraphDef protocol buffer message) into <code>outputGraphDef</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void ToGraphDef (TensorFlow.TFBuffer outputGraphDef, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFBuffer.html">TFBuffer</a></td>
        <td><span class="parametername">outputGraphDef</span></td>
        <td><p>Target buffer where the graphs is serialized into.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TopK_" data-uid="TensorFlow.TFGraph.TopK*"></a>
  <h4 id="TensorFlow_TFGraph_TopK_TensorFlow_TFOutput_System_Int64_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.TopK(TensorFlow.TFOutput,System.Int64,System.Nullable{System.Boolean},System.String)">TopK(TFOutput, Int64, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Finds values and indices of the <code>k</code> largest elements for the last dimension.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; TopK (TensorFlow.TFOutput input, long k, Nullable&lt;bool&gt; sorted = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>1-D or higher with last dimension at least <code>k</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">k</span></td>
        <td><p>Number of top elements to look for along the last dimension (along each
              row for matrices).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">sorted</span></td>
        <td><p>Optional argument
              If true the resulting <code>k</code> elements will be sorted by the values in
              descending order.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TopK&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              values: The <code>k</code> largest elements along each last dimensional slice.
              indices: The indices of <code>values</code> within the last dimension of <code>input</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TopK_TensorFlow_TFOutput_System_Int64_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If the input is a vector (rank-1), finds the <code>k</code> largest entries in the vector
              and outputs their values and indices as vectors.  Thus <code>values[j]</code> is the
              <code>j</code>-th largest entry in <code>input</code>, and its index is <code>indices[j]</code>.</p>
<pre><code>          For matrices (resp. higher rank input), computes the top &lt;code&gt;k&lt;/code&gt; entries in each
          row (resp. vector along the last dimension).  Thus,

          values.shape = indices.shape = input.shape[:-1] + [k]

          If two elements are equal, the lower-index element appears first.

          If &lt;code&gt;k&lt;/code&gt; varies dynamically, use &lt;code&gt;TopKV2&lt;/code&gt; below.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_TopKV2_" data-uid="TensorFlow.TFGraph.TopKV2*"></a>
  <h4 id="TensorFlow_TFGraph_TopKV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String_" data-uid="TensorFlow.TFGraph.TopKV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{System.Boolean},System.String)">TopKV2(TFOutput, TFOutput, Nullable&lt;Boolean&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Finds values and indices of the <code>k</code> largest elements for the last dimension.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; TopKV2 (TensorFlow.TFOutput input, TensorFlow.TFOutput k, Nullable&lt;bool&gt; sorted = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>1-D or higher with last dimension at least <code>k</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">k</span></td>
        <td><p>0-D.  Number of top elements to look for along the last dimension (along each
              row for matrices).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">sorted</span></td>
        <td><p>Optional argument
              If true the resulting <code>k</code> elements will be sorted by the values in
              descending order.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TopKV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              values: The <code>k</code> largest elements along each last dimensional slice.
              indices: The indices of <code>values</code> within the last dimension of <code>input</code>.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TopKV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_System_Boolean__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If the input is a vector (rank-1), finds the <code>k</code> largest entries in the vector
              and outputs their values and indices as vectors.  Thus <code>values[j]</code> is the
              <code>j</code>-th largest entry in <code>input</code>, and its index is <code>indices[j]</code>.</p>
<pre><code>          For matrices (resp. higher rank input), computes the top &lt;code&gt;k&lt;/code&gt; entries in each
          row (resp. vector along the last dimension).  Thus,

          values.shape = indices.shape = input.shape[:-1] + [k]

          If two elements are equal, the lower-index element appears first.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ToString_" data-uid="TensorFlow.TFGraph.ToString*"></a>
  <h4 id="TensorFlow_TFGraph_ToString" data-uid="TensorFlow.TFGraph.ToString">ToString()</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public override string ToString ();</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TPUEmbeddingActivations_" data-uid="TensorFlow.TFGraph.TPUEmbeddingActivations*"></a>
  <h4 id="TensorFlow_TFGraph_TPUEmbeddingActivations_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.TPUEmbeddingActivations(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.Int64,System.String)">TPUEmbeddingActivations(TFOutput, TFOutput, Int64, Int64, String)</h4>
  <div class="markdown level1 summary"><p>An op enabling differentiation of TPU Embeddings.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TPUEmbeddingActivations (TensorFlow.TFOutput embedding_variable, TensorFlow.TFOutput sliced_activations, long table_id, long lookup_id, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">embedding_variable</span></td>
        <td><p>A trainable variable, enabling optimizers to find this op.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sliced_activations</span></td>
        <td><p>The embedding activations Tensor to return.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">table_id</span></td>
        <td><p>The id of the table in the embedding layer configuration from which
              these activations were computed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">lookup_id</span></td>
        <td><p>Identifier of the set of embedding indices which produced these
              activations.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TPUEmbeddingActivations&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TPUEmbeddingActivations_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_Int64_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op simply returns its first input, which is assumed to have been sliced
              from the Tensors returned by TPUEmbeddingDequeueActivations. The presence of this
              op, and its first argument being a trainable Variable, enables automatic
              differentiation of graphs containing embeddings via the TPU Embedding Python
              libraries.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TPUReplicatedInput_" data-uid="TensorFlow.TFGraph.TPUReplicatedInput*"></a>
  <h4 id="TensorFlow_TFGraph_TPUReplicatedInput_TensorFlow_TFOutput___System_String_" data-uid="TensorFlow.TFGraph.TPUReplicatedInput(TensorFlow.TFOutput[],System.String)">TPUReplicatedInput(TFOutput[], String)</h4>
  <div class="markdown level1 summary"><p>Operator that connects N unreplicated inputs to an N-way replicated TPU computation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TPUReplicatedInput (TensorFlow.TFOutput[] inputs, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TPUReplicatedInput&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TPUReplicatedOutput_" data-uid="TensorFlow.TFGraph.TPUReplicatedOutput*"></a>
  <h4 id="TensorFlow_TFGraph_TPUReplicatedOutput_TensorFlow_TFOutput_System_Int64_System_String_" data-uid="TensorFlow.TFGraph.TPUReplicatedOutput(TensorFlow.TFOutput,System.Int64,System.String)">TPUReplicatedOutput(TFOutput, Int64, String)</h4>
  <div class="markdown level1 summary"><p>Operator that connects the output of an N-way replicated TPU computation to N separate outputs.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] TPUReplicatedOutput (TensorFlow.TFOutput input, long num_replicas, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_replicas</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TPUReplicatedOutput&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Transpose_" data-uid="TensorFlow.TFGraph.Transpose*"></a>
  <h4 id="TensorFlow_TFGraph_Transpose_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Transpose(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Transpose(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Shuffle dimensions of x according to a permutation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Transpose (TensorFlow.TFOutput x, TensorFlow.TFOutput perm, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">perm</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Transpose&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Transpose_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The output <code>y</code> has the same rank as <code>x</code>. The shapes of <code>x</code> and <code>y</code> satisfy:
              <code>y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]</code></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Transpose_" data-uid="TensorFlow.TFGraph.Transpose*"></a>
  <h4 id="TensorFlow_TFGraph_Transpose_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Transpose(TensorFlow.TFOutput,System.String)">Transpose(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Shuffle dimensions of x according to a permutation.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Transpose (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Transpose&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Transpose_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The output <code>y</code> has the same rank as <code>x</code>. The shapes of <code>x</code> and <code>y</code> satisfy:
                <code>y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]</code></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TruncateDiv_" data-uid="TensorFlow.TFGraph.TruncateDiv*"></a>
  <h4 id="TensorFlow_TFGraph_TruncateDiv_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TruncateDiv(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TruncateDiv(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns x / y element-wise for integer types.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TruncateDiv (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TruncateDiv&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TruncateDiv_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Truncation designates that negative numbers will round fractional quantities
              toward zero. I.e. -7 / 5 = -1. This matches C semantics but it is different
              than Python semantics. See <code>FloorDiv</code> for a division function that matches
              Python Semantics.</p>
<pre><code>          *NOTE*: &lt;code&gt;TruncateDiv&lt;/code&gt; supports broadcasting. More about broadcasting
          [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_TruncatedNormal_" data-uid="TensorFlow.TFGraph.TruncatedNormal*"></a>
  <h4 id="TensorFlow_TFGraph_TruncatedNormal_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.TruncatedNormal(TensorFlow.TFOutput,TensorFlow.TFDataType,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">TruncatedNormal(TFOutput, TFDataType, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Outputs random values from a truncated normal distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TruncatedNormal (TensorFlow.TFOutput shape, TensorFlow.TFDataType dtype, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the output tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of the output.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              A second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TruncatedNormal&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A tensor of the specified shape filled with random truncated normal
              values.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TruncatedNormal_TensorFlow_TFOutput_TensorFlow_TFDataType_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The generated values follow a normal distribution with mean 0 and standard
              deviation 1, except that values whose magnitude is more than 2 standard
              deviations from the mean are dropped and re-picked.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_TruncateMod_" data-uid="TensorFlow.TFGraph.TruncateMod*"></a>
  <h4 id="TensorFlow_TFGraph_TruncateMod_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.TruncateMod(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">TruncateMod(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns element-wise remainder of division. This emulates C semantics in that</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput TruncateMod (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TruncateMod&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TruncateMod_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>the result here is consistent with a truncating divide. E.g. <code>truncate(x / y) *
              y + truncate_mod(x, y) = x</code>.</p>
<pre><code>          *NOTE*: &lt;code&gt;TruncateMod&lt;/code&gt; supports broadcasting. More about broadcasting
          [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_TryEvaluateConstant_" data-uid="TensorFlow.TFGraph.TryEvaluateConstant*"></a>
  <h4 id="TensorFlow_TFGraph_TryEvaluateConstant_TensorFlow_TFOutput_TensorFlow_TFTensor__" data-uid="TensorFlow.TFGraph.TryEvaluateConstant(TensorFlow.TFOutput,TensorFlow.TFTensor@)">TryEvaluateConstant(TFOutput, TFTensor)</h4>
  <div class="markdown level1 summary"><p>Attempts to evaluate the <code>output</code>.   This is only possible if <code>output</code> does not
            depend on any graph inputs - the function is safe to call if this is not the case though.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool TryEvaluateConstant (TensorFlow.TFOutput output, ref TensorFlow.TFTensor tensor);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">output</span></td>
        <td><p>Output.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFTensor.html">TFTensor</a></td>
        <td><span class="parametername">tensor</span></td>
        <td><p>Tensor.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p><code>true</code>, if the evaluation is successful, in which case the result is returned in <code>tensor</code>, <code>false</code> otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_TryRpc_" data-uid="TensorFlow.TFGraph.TryRpc*"></a>
  <h4 id="TensorFlow_TFGraph_TryRpc_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.TryRpc(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.Nullable{System.Boolean},System.Nullable{System.Int64},System.String)">TryRpc(TFOutput, TFOutput, TFOutput, String, Nullable&lt;Boolean&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Perform batches of RPC requests.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; TryRpc (TensorFlow.TFOutput address, TensorFlow.TFOutput method, TensorFlow.TFOutput request, string protocol = null, Nullable&lt;bool&gt; fail_fast = null, Nullable&lt;long&gt; timeout_in_ms = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">address</span></td>
        <td><p><code>0-D</code> or <code>1-D</code>.  The address (i.e. host_name:port) of the RPC server.
              If this tensor has more than 1 element, then multiple parallel rpc requests
              are sent.  This argument broadcasts with <code>method</code> and <code>request</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">method</span></td>
        <td><p><code>0-D</code> or <code>1-D</code>.  The method address on the RPC server.
              If this tensor has more than 1 element, then multiple parallel rpc requests
              are sent.  This argument broadcasts with <code>address</code> and <code>request</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">request</span></td>
        <td><p><code>0-D</code> or <code>1-D</code>.  Serialized proto strings: the rpc request argument.
              If this tensor has more than 1 element, then multiple parallel rpc requests
              are sent.  This argument broadcasts with <code>address</code> and <code>method</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">protocol</span></td>
        <td><p>Optional argument
              RPC protocol to use.  Empty string means use the default protocol.
              Options include &#39;grpc&#39;.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Boolean</span>&gt;</td>
        <td><span class="parametername">fail_fast</span></td>
        <td><p>Optional argument
              <code>boolean</code>. If <code>true</code> (default), then failures to connect
              (i.e., the server does not immediately respond) cause an RPC failure.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">timeout_in_ms</span></td>
        <td><p>Optional argument
              <code>int</code>. If <code>0</code> (default), then the kernel will run the RPC
              request and only time out if the RPC deadline passes or the session times out.
              If this value is greater than <code>0</code>, then the op will raise an exception if
              the RPC takes longer than <code>timeout_in_ms</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;TryRpc&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              response: Same shape as <code>request</code>. Serialized proto strings: the rpc responses.
              status_code: Same shape as <code>request</code>.  Values correspond to tensorflow Status enum codes.
              status_message: Same shape as <code>request</code>.  Values correspond to Status messages
              returned from the RPC calls.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_TryRpc_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_Nullable_System_Boolean__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This op asynchronously performs either a single RPC request, or a batch
              of requests.  RPC requests are defined by three main parameters:</p>
<pre><code>          - &lt;code&gt;address&lt;/code&gt; (the host+port or BNS address of the request)
          - &lt;code&gt;method&lt;/code&gt; (the method name for the request)
          - &lt;code&gt;request&lt;/code&gt; (the serialized proto string, or vector of strings,
          of the RPC request argument).

          For example, if you have an RPC service running on port localhost:2345,
          and its interface is configured with the following proto declaration:

           &lt;pre&gt;&lt;code&gt;
          service MyService {
          rpc MyMethod(MyRequestProto) returns (MyResponseProto) {
          }
          };
           &lt;/code&gt;&lt;/pre&gt;

          then call this op with arguments:

           &lt;pre&gt;&lt;code&gt;
          address = &quot;localhost:2345&quot;
          method = &quot;MyService/MyMethod&quot;
           &lt;/code&gt;&lt;/pre&gt;

          The &lt;code&gt;request&lt;/code&gt; tensor is a string tensor representing serialized &lt;code&gt;MyRequestProto&lt;/code&gt;
          strings; and the output string tensor &lt;code&gt;response&lt;/code&gt; will have the same shape
          and contain (upon successful completion) corresponding serialized
          &lt;code&gt;MyResponseProto&lt;/code&gt; strings.

          For example, to send a single, empty, &lt;code&gt;MyRequestProto&lt;/code&gt;, call
          this op with &lt;code&gt;request = &quot;&quot;&lt;/code&gt;.  To send 5 **parallel** empty requests,
          call this op with &lt;code&gt;request = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]&lt;/code&gt;.

          More generally, one can create a batch of &lt;code&gt;MyRequestProto&lt;/code&gt; serialized protos
          from regular batched tensors using the &lt;code&gt;encode_proto&lt;/code&gt; op, and convert
          the response &lt;code&gt;MyResponseProto&lt;/code&gt; serialized protos to batched tensors
          using the &lt;code&gt;decode_proto&lt;/code&gt; op.

          **NOTE** Working with serialized proto strings is faster than instantiating
          actual proto objects in memory, so no performance degradation is expected
          compared to writing custom kernels for this workflow.

          Unlike the standard &lt;code&gt;Rpc&lt;/code&gt; op, if the connection fails or the remote worker
          returns an error status, this op does **not** reraise the exception.
          Instead, the &lt;code&gt;status_code&lt;/code&gt; and &lt;code&gt;status_message&lt;/code&gt; entry for the corresponding RPC
          call is set with the error returned from the RPC call.  The &lt;code&gt;response&lt;/code&gt; tensor
          will contain valid response values for those minibatch entries whose RPCs did
          not fail; the rest of the entries will have empty strings.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Unbatch_" data-uid="TensorFlow.TFGraph.Unbatch*"></a>
  <h4 id="TensorFlow_TFGraph_Unbatch_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.Unbatch(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.Int64,System.String,System.String,System.String)">Unbatch(TFOutput, TFOutput, TFOutput, Int64, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Reverses the operation of Batch for a single output Tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Unbatch (TensorFlow.TFOutput batched_tensor, TensorFlow.TFOutput batch_index, TensorFlow.TFOutput id, long timeout_micros, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">batched_tensor</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">batch_index</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">timeout_micros</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Unbatch&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Unbatch_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Int64_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>An instance of Unbatch either receives an empty batched_tensor, in which case it
              asynchronously waits until the values become available from a concurrently
              running instance of Unbatch with the same container and shared_name, or receives
              a non-empty batched_tensor in which case it finalizes all other concurrently
              running instances and outputs its own element from the batch.</p>
<pre><code>          batched_tensor: The possibly transformed output of Batch. The size of the first
          dimension should remain unchanged by the transformations for the operation to
          work.
          batch_index: The matching batch_index obtained from Batch.
          id: The id scalar emitted by Batch.
          unbatched_tensor: The Tensor corresponding to this execution.
          timeout_micros: Maximum amount of time (in microseconds) to wait to receive the
          batched input tensor associated with a given invocation of the op.
          container: Container to control resource sharing.
          shared_name: Instances of Unbatch with the same container and shared_name are
          assumed to possibly belong to the same batch. If left empty, the op name will
          be used as the shared name.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_UnbatchGrad_" data-uid="TensorFlow.TFGraph.UnbatchGrad*"></a>
  <h4 id="TensorFlow_TFGraph_UnbatchGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.UnbatchGrad(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String,System.String,System.String)">UnbatchGrad(TFOutput, TFOutput, TFOutput, TFOutput, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Gradient of Unbatch.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput UnbatchGrad (TensorFlow.TFOutput original_input, TensorFlow.TFOutput batch_index, TensorFlow.TFOutput grad, TensorFlow.TFOutput id, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">original_input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">batch_index</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">grad</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">id</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;UnbatchGrad&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_UnbatchGrad_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Acts like Batch but using the given batch_index index of batching things as they
              become available. This ensures that the gradients are propagated back in the
              same session which did the forward pass.</p>
<pre><code>          original_input: The input to the Unbatch operation this is the gradient of.
          batch_index: The batch_index given to the Unbatch operation this is the gradient
          of.
          grad: The downstream gradient.
          id: The id scalar emitted by Batch.
          batched_grad: The return value, either an empty tensor or the batched gradient.
          container: Container to control resource sharing.
          shared_name: Instances of UnbatchGrad with the same container and shared_name
          are assumed to possibly belong to the same batch. If left empty, the op name
          will be used as the shared name.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_UnicodeScript_" data-uid="TensorFlow.TFGraph.UnicodeScript*"></a>
  <h4 id="TensorFlow_TFGraph_UnicodeScript_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.UnicodeScript(TensorFlow.TFOutput,System.String)">UnicodeScript(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Determine the script codes of a given tensor of Unicode integer code points.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput UnicodeScript (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>A Tensor of int32 Unicode code points.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;UnicodeScript&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A Tensor of int32 script codes corresponding to each input code point.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_UnicodeScript_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation converts Unicode code points to script codes corresponding to
              each code point. Script codes correspond to International Components for
              Unicode (ICU) UScriptCode values. See <a href="http://icu-project.org/apiref/icu4c/uscript_8h.html">http://icu-project.org/apiref/icu4c/uscript_8h.html</a>.
              Returns -1 (USCRIPT_INVALID_CODE) for invalid codepoints. Output shape will
              match input shape.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_UniformCandidateSampler_" data-uid="TensorFlow.TFGraph.UniformCandidateSampler*"></a>
  <h4 id="TensorFlow_TFGraph_UniformCandidateSampler_TensorFlow_TFOutput_System_Int64_System_Int64_System_Boolean_System_Int64_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.UniformCandidateSampler(TensorFlow.TFOutput,System.Int64,System.Int64,System.Boolean,System.Int64,System.Nullable{System.Int64},System.Nullable{System.Int64},System.String)">UniformCandidateSampler(TFOutput, Int64, Int64, Boolean, Int64, Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Generates labels for candidate sampling with a uniform distribution.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; UniformCandidateSampler (TensorFlow.TFOutput true_classes, long num_true, long num_sampled, bool unique, long range_max, Nullable&lt;long&gt; seed = null, Nullable&lt;long&gt; seed2 = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">true_classes</span></td>
        <td><p>A batch_size * num_true matrix, in which each row contains the
              IDs of the num_true target_classes in the corresponding original label.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_true</span></td>
        <td><p>Number of true labels per context.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num_sampled</span></td>
        <td><p>Number of candidates to randomly sample.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">unique</span></td>
        <td><p>If unique is true, we sample with rejection, so that all sampled
              candidates in a batch are unique. This requires some approximation to
              estimate the post-rejection sampling probabilities.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">range_max</span></td>
        <td><p>The sampler will sample integers from the interval [0, range_max).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed</span></td>
        <td><p>Optional argument
              If either seed or seed2 are set to be non-zero, the random number
              generator is seeded by the given seed.  Otherwise, it is seeded by a
              random seed.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">seed2</span></td>
        <td><p>Optional argument
              An second seed to avoid seed collision.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;UniformCandidateSampler&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              sampled_candidates: A vector of length num_sampled, in which each element is
              the ID of a sampled candidate.
              true_expected_count: A batch_size * num_true matrix, representing
              the number of times each candidate is expected to occur in a batch
              of sampled candidates. If unique=true, then this is a probability.
              sampled_expected_count: A vector of length num_sampled, for each sampled
              candidate representing the number of times the candidate is expected
              to occur in a batch of sampled candidates.  If unique=true, then this is a
              probability.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_UniformCandidateSampler_TensorFlow_TFOutput_System_Int64_System_Int64_System_Boolean_System_Int64_System_Nullable_System_Int64__System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>See explanations of candidate sampling and the data formats at
              go/candidate-sampling.</p>
<pre><code>          For each batch, this op picks a single set of sampled candidate labels.

          The advantages of sampling candidates per-batch are simplicity and the
          possibility of efficient dense matrix multiplication. The disadvantage is that
          the sampled candidates must be chosen independently of the context and of the
          true labels.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Unique_" data-uid="TensorFlow.TFGraph.Unique*"></a>
  <h4 id="TensorFlow_TFGraph_Unique_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.Unique(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">Unique(TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Finds unique elements in a 1-D tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; Unique (TensorFlow.TFOutput x, Nullable&lt;TensorFlow.TFDataType&gt; out_idx = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>1-D.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_idx</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Unique&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              y: 1-D.
              idx: 1-D.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Unique_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation returns a tensor <code>y</code> containing all of the unique elements of <code>x</code>
              sorted in the same order that they occur in <code>x</code>. This operation also returns a
              tensor <code>idx</code> the same size as <code>x</code> that contains the index of each value of <code>x</code>
              in the unique output <code>y</code>. In other words:</p>
<pre><code>          &lt;code&gt;y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]&lt;/code&gt;

          For example:

           &lt;pre&gt;&lt;code&gt;
          # tensor &#39;x&#39; is [1, 1, 2, 4, 4, 4, 7, 8, 8]
          y, idx = unique(x)
          y ==&amp;gt; [1, 2, 4, 7, 8]
          idx ==&amp;gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_UniqueV2_" data-uid="TensorFlow.TFGraph.UniqueV2*"></a>
  <h4 id="TensorFlow_TFGraph_UniqueV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.UniqueV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">UniqueV2(TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput&gt; UniqueV2 (TensorFlow.TFOutput x, TensorFlow.TFOutput axis, Nullable&lt;TensorFlow.TFDataType&gt; out_idx = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">axis</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_idx</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_UniqueWithCounts_" data-uid="TensorFlow.TFGraph.UniqueWithCounts*"></a>
  <h4 id="TensorFlow_TFGraph_UniqueWithCounts_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.UniqueWithCounts(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">UniqueWithCounts(TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Finds unique elements in a 1-D tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; UniqueWithCounts (TensorFlow.TFOutput x, Nullable&lt;TensorFlow.TFDataType&gt; out_idx = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>1-D.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_idx</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;UniqueWithCounts&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>Returns a tuple with multiple values, as follows:
              y: 1-D.
              idx: 1-D.
              count: 1-D.
              The TFOperation can be fetched from any of the TFOutputs returned in the tuple values, by fethching the Operation property.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_UniqueWithCounts_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation returns a tensor <code>y</code> containing all of the unique elements of <code>x</code>
              sorted in the same order that they occur in <code>x</code>. This operation also returns a
              tensor <code>idx</code> the same size as <code>x</code> that contains the index of each value of <code>x</code>
              in the unique output <code>y</code>. Finally, it returns a third tensor <code>count</code> that
              contains the count of each element of <code>y</code> in <code>x</code>. In other words:</p>
<pre><code>          &lt;code&gt;y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]&lt;/code&gt;

          For example:

           &lt;pre&gt;&lt;code&gt;
          # tensor &#39;x&#39; is [1, 1, 2, 4, 4, 4, 7, 8, 8]
          y, idx, count = unique_with_counts(x)
          y ==&amp;gt; [1, 2, 4, 7, 8]
          idx ==&amp;gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
          count ==&amp;gt; [2, 1, 3, 1, 2]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_UniqueWithCountsV2_" data-uid="TensorFlow.TFGraph.UniqueWithCountsV2*"></a>
  <h4 id="TensorFlow_TFGraph_UniqueWithCountsV2_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.UniqueWithCountsV2(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">UniqueWithCountsV2(TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public ValueTuple&lt;TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput&gt; UniqueWithCountsV2 (TensorFlow.TFOutput x, TensorFlow.TFOutput axis, Nullable&lt;TensorFlow.TFDataType&gt; out_idx = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">axis</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_idx</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ValueTuple</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>,<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Unpack_" data-uid="TensorFlow.TFGraph.Unpack*"></a>
  <h4 id="TensorFlow_TFGraph_Unpack_TensorFlow_TFOutput_System_Int64_System_Nullable_System_Int64__System_String_" data-uid="TensorFlow.TFGraph.Unpack(TensorFlow.TFOutput,System.Int64,System.Nullable{System.Int64},System.String)">Unpack(TFOutput, Int64, Nullable&lt;Int64&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Unpacks a given dimension of a rank-<code>R</code> tensor into <code>num</code> rank-<code>(R-1)</code> tensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] Unpack (TensorFlow.TFOutput value, long num, Nullable&lt;long&gt; axis = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>1-D or higher, with <code>axis</code> dimension size equal to <code>num</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int64</span></td>
        <td><span class="parametername">num</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">axis</span></td>
        <td><p>Optional argument
              Dimension along which to unpack.  Negative values wrap around, so the
              valid range is <code>[-R, R)</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Unpack&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The list of tensors unpacked from <code>value</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Unpack_TensorFlow_TFOutput_System_Int64_System_Nullable_System_Int64__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Unpacks <code>num</code> tensors from <code>value</code> by chipping it along the <code>axis</code> dimension.
              For example, given a tensor of shape <code>(A, B, C, D)</code>;</p>
<pre><code>          If &lt;code&gt;axis == 0&lt;/code&gt; then the i&#39;th tensor in &lt;code&gt;output&lt;/code&gt; is the slice &lt;code&gt;value[i, :, :, :]&lt;/code&gt;
          and each tensor in &lt;code&gt;output&lt;/code&gt; will have shape &lt;code&gt;(B, C, D)&lt;/code&gt;. (Note that the
          dimension unpacked along is gone, unlike &lt;code&gt;split&lt;/code&gt;).

          If &lt;code&gt;axis == 1&lt;/code&gt; then the i&#39;th tensor in &lt;code&gt;output&lt;/code&gt; is the slice &lt;code&gt;value[:, i, :, :]&lt;/code&gt;
          and each tensor in &lt;code&gt;output&lt;/code&gt; will have shape &lt;code&gt;(A, C, D)&lt;/code&gt;.
          Etc.

          This is the opposite of &lt;code&gt;pack&lt;/code&gt;.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_UnravelIndex_" data-uid="TensorFlow.TFGraph.UnravelIndex*"></a>
  <h4 id="TensorFlow_TFGraph_UnravelIndex_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.UnravelIndex(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">UnravelIndex(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Converts a flat index or array of flat indices into a tuple of</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput UnravelIndex (TensorFlow.TFOutput indices, TensorFlow.TFOutput dims, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">indices</span></td>
        <td><p>An 0-D or 1-D <code>int</code> Tensor whose elements are indices into the
              flattened version of an array of dimensions dims.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">dims</span></td>
        <td><p>An 1-D <code>int</code> Tensor. The shape of the array to use for unraveling
              indices.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;UnravelIndex&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>An 2-D (or 1-D if indices is 0-D) tensor where each row has the
              same shape as the indices array.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_UnravelIndex_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>coordinate arrays.</p>
<pre><code>          @compatibility(numpy)
          Equivalent to np.unravel_index
          @end_compatibility
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_UnsortedSegmentMax_" data-uid="TensorFlow.TFGraph.UnsortedSegmentMax*"></a>
  <h4 id="TensorFlow_TFGraph_UnsortedSegmentMax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.UnsortedSegmentMax(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">UnsortedSegmentMax(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the maximum along segments of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput UnsortedSegmentMax (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A tensor whose shape is a prefix of <code>data.shape</code>.END
              }
              out_arg {
              name: &quot;output&quot;
              description: &lt;&lt;END
              Has same shape as data, except for the first <code>segment_ids.rank</code>
              dimensions, which are replaced with a single dimension which has size
              <code>num_segments</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_segments</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;UnsortedSegmentMax&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_UnsortedSegmentMax_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Read
              <a href="https://tensorflow.org/api_guides/python/math_ops#Segmentation">the section on segmentation</a>
              for an explanation of segments.</p>
<pre><code>          This operator is similar to the unsorted segment sum operator found
          [(here)](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).
          Instead of computing the sum over segments, it computes the maximum such that:

          \\(output_i = \max_{j...} data[j...]\\) where max is over tuples &lt;code&gt;j...&lt;/code&gt; such
          that &lt;code&gt;segment_ids[j...] == i&lt;/code&gt;.

          If the maximum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs the smallest
          possible value for the specific numeric type,
          &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::lowest()&lt;/code&gt;.

          If the given segment ID &lt;code&gt;i&lt;/code&gt; is negative, then the corresponding value is
          dropped, and will not be included in the result.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/UnsortedSegmentMax.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_UnsortedSegmentMin_" data-uid="TensorFlow.TFGraph.UnsortedSegmentMin*"></a>
  <h4 id="TensorFlow_TFGraph_UnsortedSegmentMin_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.UnsortedSegmentMin(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">UnsortedSegmentMin(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the minimum along segments of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput UnsortedSegmentMin (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A tensor whose shape is a prefix of <code>data.shape</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_segments</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;UnsortedSegmentMin&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for the first <code>segment_ids.rank</code>
              dimensions, which are replaced with a single dimension which has size
              <code>num_segments</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_UnsortedSegmentMin_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Read
              <a href="https://tensorflow.org/api_guides/python/math_ops#segmentation">the section on segmentation</a>
              for an explanation of segments.</p>
<pre><code>          This operator is similar to the unsorted segment sum operator found
          [(here)](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).
          Instead of computing the sum over segments, it computes the minimum such that:

          \\(output_i = \min_{j...} data_[j...]\\) where min is over tuples &lt;code&gt;j...&lt;/code&gt; such
          that &lt;code&gt;segment_ids[j...] == i&lt;/code&gt;.

          If the minimum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs the largest
          possible value for the specific numeric type,
          &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::max()&lt;/code&gt;.

          If the given segment ID &lt;code&gt;i&lt;/code&gt; is negative, then the corresponding value is
          dropped, and will not be included in the result.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_UnsortedSegmentProd_" data-uid="TensorFlow.TFGraph.UnsortedSegmentProd*"></a>
  <h4 id="TensorFlow_TFGraph_UnsortedSegmentProd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.UnsortedSegmentProd(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">UnsortedSegmentProd(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the product along segments of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput UnsortedSegmentProd (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A tensor whose shape is a prefix of <code>data.shape</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_segments</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;UnsortedSegmentProd&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for the first <code>segment_ids.rank</code>
              dimensions, which are replaced with a single dimension which has size
              <code>num_segments</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_UnsortedSegmentProd_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Read
              <a href="https://tensorflow.org/api_guides/python/math_ops#segmentation">the section on segmentation</a>
              for an explanation of segments.</p>
<pre><code>          This operator is similar to the unsorted segment sum operator found
          [(here)](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).
          Instead of computing the sum over segments, it computes the product of all
          entries belonging to a segment such that:

          \\(output_i = \prod_{j...} data[j...]\\) where the product is over tuples
          &lt;code&gt;j...&lt;/code&gt; such that &lt;code&gt;segment_ids[j...] == i&lt;/code&gt;.

          If there is no entry for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs 1.

          If the given segment ID &lt;code&gt;i&lt;/code&gt; is negative, then the corresponding value is
          dropped, and will not be included in the result.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_UnsortedSegmentSum_" data-uid="TensorFlow.TFGraph.UnsortedSegmentSum*"></a>
  <h4 id="TensorFlow_TFGraph_UnsortedSegmentSum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.UnsortedSegmentSum(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">UnsortedSegmentSum(TFOutput, TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Computes the sum along segments of a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput UnsortedSegmentSum (TensorFlow.TFOutput data, TensorFlow.TFOutput segment_ids, TensorFlow.TFOutput num_segments, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">segment_ids</span></td>
        <td><p>A tensor whose shape is a prefix of <code>data.shape</code>.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">num_segments</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;UnsortedSegmentSum&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>Has same shape as data, except for the first <code>segment_ids.rank</code>
              dimensions, which are replaced with a single dimension which has size
              <code>num_segments</code>.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_UnsortedSegmentSum_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Read
              <a href="https://tensorflow.org/api_guides/python/math_ops#Segmentation">the section on segmentation</a>
              for an explanation of segments.</p>
<pre><code>          Computes a tensor such that
          \\(output[i] = \sum_{j...} data[j...]\\) where the sum is over tuples &lt;code&gt;j...&lt;/code&gt; such
          that &lt;code&gt;segment_ids[j...] == i&lt;/code&gt;.  Unlike &lt;code&gt;SegmentSum&lt;/code&gt;, &lt;code&gt;segment_ids&lt;/code&gt;
          need not be sorted and need not cover all values in the full
          range of valid values.

          If the sum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.
          If the given segment ID &lt;code&gt;i&lt;/code&gt; is negative, the value is dropped and will not be
          added to the sum of the segment.

          &lt;code&gt;num_segments&lt;/code&gt; should equal the number of distinct segment IDs.

          &amp;lt;div style=&quot;width:70%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&amp;gt;
          &amp;lt;img style=&quot;width:100%&quot; src=&quot;https://www.tensorflow.org/images/UnsortedSegmentSum.png&quot; alt&amp;gt;
          &amp;lt;/div&amp;gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Unstage_" data-uid="TensorFlow.TFGraph.Unstage*"></a>
  <h4 id="TensorFlow_TFGraph_Unstage_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.Unstage(TensorFlow.TFDataType[],System.Nullable{System.Int64},System.Nullable{System.Int64},System.String,System.String,System.String)">Unstage(TFDataType[], Nullable&lt;Int64&gt;, Nullable&lt;Int64&gt;, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Op is similar to a lightweight Dequeue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] Unstage (TensorFlow.TFDataType[] dtypes, Nullable&lt;long&gt; capacity = null, Nullable&lt;long&gt; memory_limit = null, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">dtypes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">capacity</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<span class="xref">System.Int64</span>&gt;</td>
        <td><span class="parametername">memory_limit</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Unstage&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Unstage_TensorFlow_TFDataType___System_Nullable_System_Int64__System_Nullable_System_Int64__System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The basic functionality is similar to dequeue with many fewer
              capabilities and options.  This Op is optimized for performance.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_UpperBound_" data-uid="TensorFlow.TFGraph.UpperBound*"></a>
  <h4 id="TensorFlow_TFGraph_UpperBound_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.UpperBound(TensorFlow.TFOutput,TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">UpperBound(TFOutput, TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Applies upper_bound(sorted_search_values, values) along each row.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput UpperBound (TensorFlow.TFOutput sorted_inputs, TensorFlow.TFOutput values, Nullable&lt;TensorFlow.TFDataType&gt; out_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">sorted_inputs</span></td>
        <td><p>2-D Tensor where each row is ordered.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">values</span></td>
        <td><p>2-D Tensor with the same numbers of rows as <code>sorted_search_values</code>. Contains
              the values that will be searched for in <code>sorted_search_values</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;UpperBound&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A <code>Tensor</code> with the same shape as <code>values</code>.  It contains the last scalar index
              into the last dimension where values can be inserted without changing the
              ordered property.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_UpperBound_TensorFlow_TFOutput_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Each set of rows with the same index in (sorted_inputs, values) is treated
              independently.  The resulting row is the equivalent of calling
              <code>np.searchsorted(sorted_inputs, values, side=&#39;right&#39;)</code>.</p>
<pre><code>          The result is not a global index to the entire
          &lt;code&gt;Tensor&lt;/code&gt;, but rather just the index in the last dimension.

          A 2-D example:
          sorted_sequence = [[0, 3, 9, 9, 10],
          [1, 2, 3, 4, 5]]
          values = [[2, 4, 9],
          [0, 2, 6]]

          result = UpperBound(sorted_sequence, values)

          result == [[1, 2, 4],
          [0, 2, 5]]
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_VarHandleOp_" data-uid="TensorFlow.TFGraph.VarHandleOp*"></a>
  <h4 id="TensorFlow_TFGraph_VarHandleOp_TensorFlow_TFDataType_TensorFlow_TFShape_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.VarHandleOp(TensorFlow.TFDataType,TensorFlow.TFShape,System.String,System.String,System.String)">VarHandleOp(TFDataType, TFShape, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Creates a handle to a Variable resource.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput VarHandleOp (TensorFlow.TFDataType dtype, TensorFlow.TFShape shape, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>the type of this variable. Must agree with the dtypes
              of all ops using this variable.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The (possibly partially specified) shape of this variable.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              the container this variable is placed in.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              the name by which this variable is referred to.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;VarHandleOp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Variable_" data-uid="TensorFlow.TFGraph.Variable*"></a>
  <h4 id="TensorFlow_TFGraph_Variable_TensorFlow_TFOutput_System_Boolean_System_String_" data-uid="TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,System.Boolean,System.String)">Variable(TFOutput, Boolean, String)</h4>
  <div class="markdown level1 summary"><p>Variable node, with a starting initial value.  Convenience that registers the init variable to a global queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.Variable Variable (TensorFlow.TFOutput initialValue, bool trainable = true, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">initialValue</span></td>
        <td><p>Initial value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">trainable</span></td>
        <td><p>If true, this add the variable to the graph&#39;s TrainableVariables, this collection is intended to be used by the Optimizer classes.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Operation name, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.Variable.html">Variable</a></td>
        <td><p>The returning Variable contains the variable, with three nodes with the operations making up the variable assignment.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Variable_TensorFlow_TFOutput_System_Boolean_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Variables need to be initialized before the main execution so you will typically want to
            run the session on the variable.</p>
<pre><code>        The init sequence for the variable is stored in the graph, you must manually initialize 
        those by running the session on the global variables.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Variable_" data-uid="TensorFlow.TFGraph.Variable*"></a>
  <h4 id="TensorFlow_TFGraph_Variable_TensorFlow_TFOutput_TensorFlow_TFOutput__System_Boolean_System_String_" data-uid="TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,TensorFlow.TFOutput@,System.Boolean,System.String)">Variable(TFOutput, TFOutput, Boolean, String)</h4>
  <div class="markdown level1 summary"><p>Variable node, with a starting initial value.  Convenience that registers the init variable to a global queue.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.Variable Variable (TensorFlow.TFOutput initialValue, out TensorFlow.TFOutput value, bool trainable = true, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">initialValue</span></td>
        <td><p>Initial value.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>Returns the value of the variable.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">trainable</span></td>
        <td><p>If true, this add the variable to the graph&#39;s TrainableVariables, this collection is intended to be used by the Optimizer classes.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Operation name, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.Variable.html">Variable</a></td>
        <td><p>The returning Variable contains the variable, with three nodes with the operations making up the variable assignment.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Variable_TensorFlow_TFOutput_TensorFlow_TFOutput__System_Boolean_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Variables need to be initialized before the main execution so you will typically want to
            run the session on the variable.</p>
<pre><code>        The init sequence for the variable is stored in the graph, you must manually initialize 
        those by running the session on the global variables.
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_Variable_" data-uid="TensorFlow.TFGraph.Variable*"></a>
  <h4 id="TensorFlow_TFGraph_Variable_TensorFlow_TFOutput_TensorFlow_TFOperation__TensorFlow_TFOutput__System_Boolean_System_String_" data-uid="TensorFlow.TFGraph.Variable(TensorFlow.TFOutput,TensorFlow.TFOperation@,TensorFlow.TFOutput@,System.Boolean,System.String)">Variable(TFOutput, TFOperation, TFOutput, Boolean, String)</h4>
  <div class="markdown level1 summary"><p>Variable node, with a starting initial value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.Variable Variable (TensorFlow.TFOutput initialValue, out TensorFlow.TFOperation init, out TensorFlow.TFOutput value, bool trainable = true, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">initialValue</span></td>
        <td><p>Initial value.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><span class="parametername">init</span></td>
        <td><p>Returns the operation that initializes the value of the variable.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">value</span></td>
        <td><p>Returns the value of the variable.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">trainable</span></td>
        <td><p>If true, this add the variable to the graph&#39;s TrainableVariables, this collection is intended to be used by the Optimizer classes.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Operation name, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.Variable.html">Variable</a></td>
        <td><p>The returning Variable contains the variable, with three nodes with the operations making up the variable assignment.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Variable_TensorFlow_TFOutput_TensorFlow_TFOperation__TensorFlow_TFOutput__System_Boolean_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Variables need to be initialized before the main execution so you will typically want to
            run the session on the variable</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Variable_" data-uid="TensorFlow.TFGraph.Variable*"></a>
  <h4 id="TensorFlow_TFGraph_Variable_TensorFlow_TFShape_TensorFlow_TFDataType_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.Variable(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String,System.String)">Variable(TFShape, TFDataType, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Use VariableV2 instead.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Variable (TensorFlow.TFShape shape, TensorFlow.TFDataType dtype, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Variable&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_VariableShape_" data-uid="TensorFlow.TFGraph.VariableShape*"></a>
  <h4 id="TensorFlow_TFGraph_VariableShape_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String_" data-uid="TensorFlow.TFGraph.VariableShape(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFDataType},System.String)">VariableShape(TFOutput, Nullable&lt;TFDataType&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Returns the shape of the variable pointed to by <code>resource</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput VariableShape (TensorFlow.TFOutput input, Nullable&lt;TensorFlow.TFDataType&gt; out_type = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>&gt;</td>
        <td><span class="parametername">out_type</span></td>
        <td><p>Optional argument</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;VariableShape&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_VariableShape_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFDataType__System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation returns a 1-D integer tensor representing the shape of <code>input</code>.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;t&#39; is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
          shape(t) ==&amp;gt; [2, 2, 3]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_VariableV2_" data-uid="TensorFlow.TFGraph.VariableV2*"></a>
  <h4 id="TensorFlow_TFGraph_VariableV2_TensorFlow_TFShape_TensorFlow_TFDataType_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.VariableV2(TensorFlow.TFShape,TensorFlow.TFDataType,System.String,System.String,System.String)">VariableV2(TFShape, TFDataType, String, String, String)</h4>
  <div class="markdown level1 summary"><p>Holds state in the form of a tensor that persists across steps.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput VariableV2 (TensorFlow.TFShape shape, TensorFlow.TFDataType dtype, string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>The shape of the variable tensor.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>The type of elements in the variable tensor.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this variable is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this variable is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;VariableV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A reference to the variable tensor.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_VariableV2_TensorFlow_TFShape_TensorFlow_TFDataType_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Outputs a ref to the tensor state so it may be read or modified.
              TODO(zhifengc/mrry): Adds a pointer to a more detail document
              about sharing states in tensorflow.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_VarIsInitializedOp_" data-uid="TensorFlow.TFGraph.VarIsInitializedOp*"></a>
  <h4 id="TensorFlow_TFGraph_VarIsInitializedOp_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.VarIsInitializedOp(TensorFlow.TFOutput,System.String)">VarIsInitializedOp(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Checks whether a resource handle-based variable has been initialized.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput VarIsInitializedOp (TensorFlow.TFOutput resource, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">resource</span></td>
        <td><p>the input resource handle.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;VarIsInitializedOp&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>a scalar boolean which is true if the variable has been
              initialized.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Versions_" data-uid="TensorFlow.TFGraph.Versions*"></a>
  <h4 id="TensorFlow_TFGraph_Versions_TensorFlow_TFBuffer_TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.Versions(TensorFlow.TFBuffer,TensorFlow.TFStatus)">Versions(TFBuffer, TFStatus)</h4>
  <div class="markdown level1 summary"><p>Returns the serialized VersionDef proto for this graph.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Versions (TensorFlow.TFBuffer outputVersionDef, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFBuffer.html">TFBuffer</a></td>
        <td><span class="parametername">outputVersionDef</span></td>
        <td><p>The buffer where the serialized protocol buffer will be stored.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Where_" data-uid="TensorFlow.TFGraph.Where*"></a>
  <h4 id="TensorFlow_TFGraph_Where_TensorFlow_TFOutput_System_Nullable_TensorFlow_TFOutput__System_Nullable_TensorFlow_TFOutput__System_String_" data-uid="TensorFlow.TFGraph.Where(TensorFlow.TFOutput,System.Nullable{TensorFlow.TFOutput},System.Nullable{TensorFlow.TFOutput},System.String)">Where(TFOutput, Nullable&lt;TFOutput&gt;, Nullable&lt;TFOutput&gt;, String)</h4>
  <div class="markdown level1 summary"><p>Return elements from x or y depending on condition.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Where (TensorFlow.TFOutput condition, Nullable&lt;TensorFlow.TFOutput&gt; x, Nullable&lt;TensorFlow.TFOutput&gt; y, string name = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">condition</span></td>
        <td><p>LabeledTensor of type <code>bool</code>.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><span class="parametername">x</span></td>
        <td><p>LabeledTensor for values where condition is true.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Nullable</span>&lt;<a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>&gt;</td>
        <td><span class="parametername">y</span></td>
        <td><p>LabeledTensor for values where condition is false.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">name</span></td>
        <td><p>Optional op name.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The labeled tensor with values according to condition.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Where_" data-uid="TensorFlow.TFGraph.Where*"></a>
  <h4 id="TensorFlow_TFGraph_Where_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Where(TensorFlow.TFOutput,System.String)">Where(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns locations of nonzero / true values in a tensor.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Where (TensorFlow.TFOutput input, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Where&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Where_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This operation returns the coordinates of true elements in <code>condition</code>. The
              coordinates are returned in a 2-D tensor where the first dimension (rows)
              represents the number of true elements, and the second dimension (columns)
              represents the coordinates of the true elements. Keep in mind, the shape of
              the output tensor can vary depending on how many true values there are in
              <code>condition</code>. Indices are output in row-major order.</p>
<pre><code>          For example:

           &lt;pre&gt;&lt;code&gt;
          # &#39;input&#39; tensor is [[True, False]
          #                    [True, False]]
          # &#39;input&#39; has two true values, so output has two coordinates.
          # &#39;input&#39; has rank of 2, so coordinates have two indices.
          where(input) ==&amp;gt; [[0, 0],
          [1, 0]]

          # &lt;code&gt;condition&lt;/code&gt; tensor is [[[True, False]
          #                     [True, False]]
          #                    [[False, True]
          #                     [False, True]]
          #                    [[False, False]
          #                     [False, True]]]
          # &#39;input&#39; has 5 true values, so output has 5 coordinates.
          # &#39;input&#39; has rank of 3, so coordinates have three indices.
          where(input) ==&amp;gt; [[0, 0, 0],
          [0, 1, 0],
          [1, 0, 1],
          [1, 1, 1],
          [2, 1, 1]]

          # &lt;code&gt;condition&lt;/code&gt; tensor is [[[1.5,  0.0]
          #                     [-0.5, 0.0]]
          #                    [[0.0,  0.25]
          #                     [0.0,  0.75]]
          #                    [[0.0,  0.0]
          #                     [0.0,  0.01]]]
          # &#39;input&#39; has 5 nonzero values, so output has 5 coordinates.
          # &#39;input&#39; has rank of 3, so coordinates have three indices.
          where(input) ==&amp;gt; [[0, 0, 0],
          [0, 1, 0],
          [1, 0, 1],
          [1, 1, 1],
          [2, 1, 1]]

          # &lt;code&gt;condition&lt;/code&gt; tensor is [[[1.5 + 0.0j, 0.0  + 0.0j]
          #                     [0.0 + 0.5j, 0.0  + 0.0j]]
          #                    [[0.0 + 0.0j, 0.25 + 1.5j]
          #                     [0.0 + 0.0j, 0.75 + 0.0j]]
          #                    [[0.0 + 0.0j, 0.0  + 0.0j]
          #                     [0.0 + 0.0j, 0.01 + 0.0j]]]
          # &#39;input&#39; has 5 nonzero magnitude values, so output has 5 coordinates.
          # &#39;input&#39; has rank of 3, so coordinates have three indices.
          where(input) ==&amp;gt; [[0, 0, 0],
          [0, 1, 0],
          [1, 0, 1],
          [1, 1, 1],
          [2, 1, 1]]
           &lt;/code&gt;&lt;/pre&gt;
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_While_" data-uid="TensorFlow.TFGraph.While*"></a>
  <h4 id="TensorFlow_TFGraph_While_TensorFlow_TFOutput___TensorFlow_TFGraph_WhileConstructor_TensorFlow_TFStatus_" data-uid="TensorFlow.TFGraph.While(TensorFlow.TFOutput[],TensorFlow.TFGraph.WhileConstructor,TensorFlow.TFStatus)">While(TFOutput[], TFGraph+WhileConstructor, TFStatus)</h4>
  <div class="markdown level1 summary"><p>Constructs a while loop with the specified inputs and a callback that composes the while loop</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput[] While (TensorFlow.TFOutput[] inputs, TensorFlow.TFGraph.WhileConstructor constructor, TensorFlow.TFStatus status = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">inputs</span></td>
        <td><p>Inputs.</p>
</td>
      </tr>
      <tr>
        <td></td>
        <td><span class="parametername">constructor</span></td>
        <td><p>Callback method that fills out the various while loop parameters.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFStatus.html">TFStatus</a></td>
        <td><span class="parametername">status</span></td>
        <td><p>Status buffer, if specified a status code will be left here, if not specified, a <a class="xref" href="TensorFlow.TFException.html">TFException</a> exception is raised if there is an error.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><p>An array of TFOutputs from creating the While loop, or null if there is an error creating the 
            while loop, or if the constructor raised an exception when it was invoked.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_WholeFileReader_" data-uid="TensorFlow.TFGraph.WholeFileReader*"></a>
  <h4 id="TensorFlow_TFGraph_WholeFileReader_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.WholeFileReader(System.String,System.String,System.String)">WholeFileReader(String, String, String)</h4>
  <div class="markdown level1 summary"><p>A Reader that outputs the entire contents of a file as a value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput WholeFileReader (string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;WholeFileReader&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_WholeFileReader_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>To use, enqueue filenames in a Queue.  The output of ReaderRead will
              be a filename (key) and the contents of that file (value).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_WholeFileReaderV2_" data-uid="TensorFlow.TFGraph.WholeFileReaderV2*"></a>
  <h4 id="TensorFlow_TFGraph_WholeFileReaderV2_System_String_System_String_System_String_" data-uid="TensorFlow.TFGraph.WholeFileReaderV2(System.String,System.String,System.String)">WholeFileReaderV2(String, String, String)</h4>
  <div class="markdown level1 summary"><p>A Reader that outputs the entire contents of a file as a value.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput WholeFileReaderV2 (string container = null, string shared_name = null, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">container</span></td>
        <td><p>Optional argument
              If non-empty, this reader is placed in the given container.
              Otherwise, a default container is used.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">shared_name</span></td>
        <td><p>Optional argument
              If non-empty, this reader is named in the given bucket
              with this shared_name. Otherwise, the node name is used instead.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;WholeFileReaderV2&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The handle to reference the Reader.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_WholeFileReaderV2_System_String_System_String_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>To use, enqueue filenames in a Queue.  The output of ReaderRead will
              be a filename (key) and the contents of that file (value).</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_WindowDataset_" data-uid="TensorFlow.TFGraph.WindowDataset*"></a>
  <h4 id="TensorFlow_TFGraph_WindowDataset_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFOutput_TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.WindowDataset(TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFOutput,TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">WindowDataset(TFOutput, TFOutput, TFOutput, TFOutput, TFOutput, TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>A dataset that creates window datasets from the input dataset.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput WindowDataset (TensorFlow.TFOutput input_dataset, TensorFlow.TFOutput size, TensorFlow.TFOutput shift, TensorFlow.TFOutput stride, TensorFlow.TFOutput drop_remainder, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">input_dataset</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">size</span></td>
        <td><p>A scalar representing the number of elements to accumulate in a window.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">shift</span></td>
        <td><p>A scalar representing the steps moving the sliding window forward in one
              iteration. It must be positive.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">stride</span></td>
        <td><p>A scalar representing the stride of the input elements of the sliding window.
              It must be positive.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">drop_remainder</span></td>
        <td><p>A scalar representing whether a window should be dropped in case its size is
              smaller than desired.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;WindowDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_WithDependencies_" data-uid="TensorFlow.TFGraph.WithDependencies*"></a>
  <h4 id="TensorFlow_TFGraph_WithDependencies_TensorFlow_TFOperation___" data-uid="TensorFlow.TFGraph.WithDependencies(TensorFlow.TFOperation[])">WithDependencies(TFOperation[])</h4>
  <div class="markdown level1 summary"><p>Adds new dependencies for new tensors and operations created while the context is active.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFDependencies WithDependencies (TensorFlow.TFOperation[] dependencies);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a>[]</td>
        <td><span class="parametername">dependencies</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDependencies.html">TFDependencies</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_WithScope_" data-uid="TensorFlow.TFGraph.WithScope*"></a>
  <h4 id="TensorFlow_TFGraph_WithScope_System_String_" data-uid="TensorFlow.TFGraph.WithScope(System.String)">WithScope(String)</h4>
  <div class="markdown level1 summary"><p>Creates a new namescope by setting the scope to the description provided.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFScope WithScope (string nameScopeDesc);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">nameScopeDesc</span></td>
        <td><p>The namescope description, if the value is null, this
            will reset the toplevel namescope to be the empty value.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFScope.html">TFScope</a></td>
        <td><p>A new scope that will remain in use until the return TFScope is disposed.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_WithScope_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p><p>
            To more easily name your operations and group then, you can use the
            WithScope method to set a current name scope that alter the complete name
            of an operation added to the graph.
            </p>
    <p>
            The graph starts with a scope set to the empty string, you can introduce new
            scopes by calling WithScope, and can be conveniently used with the C# using
            statement, like this:
            </p>
    <pre><code>
            Assert (graph.CurrentNamescope, "");
            using (var nested = graph.WithScope ("nested")){
               Assert (graph.CurrentNameScope, "nested");
               using (var inner = graph.WithScope ("inner")){
                   Assert (graph.CurrentNameScope, "nested/inner");
               }
            }
            </code></pre></p>
</div>
  
  
  <a id="TensorFlow_TFGraph_WorkerHeartbeat_" data-uid="TensorFlow.TFGraph.WorkerHeartbeat*"></a>
  <h4 id="TensorFlow_TFGraph_WorkerHeartbeat_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.WorkerHeartbeat(TensorFlow.TFOutput,System.String)">WorkerHeartbeat(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Worker heartbeat op.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput WorkerHeartbeat (TensorFlow.TFOutput request, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">request</span></td>
        <td><p>A string tensor containing a serialized WorkerHeartbeatRequest</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;WorkerHeartbeat&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>A string tensor containing a serialized WorkerHeartbeatResponse
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_WorkerHeartbeat_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Heartbeats may be sent periodically to indicate the coordinator is still active,
              to retrieve the current worker status and to expedite shutdown when necessary.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_WriteFile_" data-uid="TensorFlow.TFGraph.WriteFile*"></a>
  <h4 id="TensorFlow_TFGraph_WriteFile_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.WriteFile(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">WriteFile(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Writes contents to the file at input filename. Creates file and recursively</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOperation WriteFile (TensorFlow.TFOutput filename, TensorFlow.TFOutput contents, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">filename</span></td>
        <td><p>scalar. The name of the file to which we write the contents.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">contents</span></td>
        <td><p>scalar. The content to be written to the output file.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;WriteFile&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOperation.html">TFOperation</a></td>
        <td><p>Returns the description of the operation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_WriteFile_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>creates directory if not existing.</p>
</div>
  
  
  <a id="TensorFlow_TFGraph_Xdivy_" data-uid="TensorFlow.TFGraph.Xdivy*"></a>
  <h4 id="TensorFlow_TFGraph_Xdivy_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Xdivy(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Xdivy(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns 0 if x == 0, and x / y otherwise, elementwise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Xdivy (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Xdivy&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Xlogy_" data-uid="TensorFlow.TFGraph.Xlogy*"></a>
  <h4 id="TensorFlow_TFGraph_Xlogy_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Xlogy(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Xlogy(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns 0 if x == 0, and x * log(y) otherwise, elementwise.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Xlogy (TensorFlow.TFOutput x, TensorFlow.TFOutput y, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">y</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Xlogy&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Zeros_" data-uid="TensorFlow.TFGraph.Zeros*"></a>
  <h4 id="TensorFlow_TFGraph_Zeros_TensorFlow_TFShape_TensorFlow_TFDataType_System_String_" data-uid="TensorFlow.TFGraph.Zeros(TensorFlow.TFShape,TensorFlow.TFDataType,System.String)">Zeros(TFShape, TFDataType, String)</h4>
  <div class="markdown level1 summary"><p>Outputs Zero values based on shape of tensor</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Zeros (TensorFlow.TFShape shape, TensorFlow.TFDataType dtype = TensorFlow.TFDataType.Double, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a></td>
        <td><span class="parametername">shape</span></td>
        <td><p>Shape of the output tensor</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a></td>
        <td><span class="parametername">dtype</span></td>
        <td><p>Optional Type of the Zero value. Default: Double</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>Operation name, optional.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>To be added.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_ZerosLike_" data-uid="TensorFlow.TFGraph.ZerosLike*"></a>
  <h4 id="TensorFlow_TFGraph_ZerosLike_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.ZerosLike(TensorFlow.TFOutput,System.String)">ZerosLike(TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Returns a tensor of zeros with the same shape and type as x.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ZerosLike (TensorFlow.TFOutput x, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>a tensor of type T.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ZerosLike&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>a tensor of the same shape and type as x but filled with zeros.
              The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="TensorFlow_TFGraph_Zeta_" data-uid="TensorFlow.TFGraph.Zeta*"></a>
  <h4 id="TensorFlow_TFGraph_Zeta_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String_" data-uid="TensorFlow.TFGraph.Zeta(TensorFlow.TFOutput,TensorFlow.TFOutput,System.String)">Zeta(TFOutput, TFOutput, String)</h4>
  <div class="markdown level1 summary"><p>Compute the Hurwitz zeta function \(\zeta(x, q)\).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput Zeta (TensorFlow.TFOutput x, TensorFlow.TFOutput q, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">x</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><span class="parametername">q</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;Zeta&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="TensorFlow_TFGraph_Zeta_TensorFlow_TFOutput_TensorFlow_TFOutput_System_String__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The Hurwitz zeta function is defined as:</p>
<pre><code>          \\(\zeta(x, q) = \sum_{n=0}^{\infty} (q + n)^{-x}\\)
</code></pre></div>
  
  
  <a id="TensorFlow_TFGraph_ZipDataset_" data-uid="TensorFlow.TFGraph.ZipDataset*"></a>
  <h4 id="TensorFlow_TFGraph_ZipDataset_TensorFlow_TFOutput___TensorFlow_TFDataType___TensorFlow_TFShape___System_String_" data-uid="TensorFlow.TFGraph.ZipDataset(TensorFlow.TFOutput[],TensorFlow.TFDataType[],TensorFlow.TFShape[],System.String)">ZipDataset(TFOutput[], TFDataType[], TFShape[], String)</h4>
  <div class="markdown level1 summary"><p>Creates a dataset that zips together <code>input_datasets</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public TensorFlow.TFOutput ZipDataset (TensorFlow.TFOutput[] input_datasets, TensorFlow.TFDataType[] output_types, TensorFlow.TFShape[] output_shapes, string operName = null);</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a>[]</td>
        <td><span class="parametername">input_datasets</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFDataType.html">TFDataType</a>[]</td>
        <td><span class="parametername">output_types</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="TensorFlow.TFShape.html">TFShape</a>[]</td>
        <td><span class="parametername">output_shapes</span></td>
        <td><p>To be added.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">operName</span></td>
        <td><p>If specified, the created operation in the graph will be this one, otherwise it will be named &#39;ZipDataset&#39;.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="TensorFlow.TFOutput.html">TFOutput</a></td>
        <td><p>The TFOperation can be fetched from the resulting TFOutput, by fethching the Operation property from the result.</p>
</td>
      </tr>
    </tbody>
  </table>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2017 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
